// Auto-generated by writeBuilders.js. Modification is unwise.

import {StartStop, StartStopContinue, StartStopSingle, SymbolSize, AboveBelow, OverUnder, UpDown, TopBottom, LeftRight, EnclosureShape, NormalItalic, NormalBold, LeftCenterRight, TopMiddleBottomBaseline, DirectionMode, StraightCurved, SolidDashedDottedWavy, NormalAngledSquare, UprightInverted, UpperMainBelow, WholeHalfUnison, WholeHalfNone, OddEvenBoth, CueGraceLarge, SeparatorType, TimeSymbolType, CancelLocation, PartSymbolType, ShowFretsType, Count, MxmlAccidental, StemType, NoteheadType, BeamType, AccelRitNone, ActualBothNone, HoleLocation, HoleClosedType, BreathMarkType, SyllabicType, BarlineLocation, BarStyleType, StartStopDiscontinue, WingedType, DirectionTypeBg, TipDirection, WedgeType, LineEndType, PedalType, OctaveShiftType, VoiceSymbol, ExplicitImpliedAlternate, ChordType, TextSegment, EncodingDate, CalendarDate, Position, Placement, Orientation, DirectiveEntity, Bezier, Font, Color, TextDecoration, Justify, Halign, Valign, ValignImage, LetterSpacing, LineHeight, TextDirection, TextRotation, Enclosure, PrintStyle, PrintStyleAlign, LineShape, LineType, DashedFormatting, PrintObject, PrintSpacing, Printout, TextFormatting, LevelDisplay, TrillSound, BendSound, TimeOnly, DocumentAttributes, Editorial, EditorialVoice, Footnote, Level, Fermata, WavyLine, Segno, Coda, NormalDot, Dynamics, Fingering, Fret, String, DisplayText, AccidentalText, PartNameDisplay, PartAbbreviationDisplay, MidiDevice, MidiInstrument, Play, OtherPlay, Scaling, PageMargins, PageLayout, SystemLayout, SystemMargins, SystemDividers, LeftDivider, RightDivider, StaffLayout, MeasureLayout, LineWidth, NoteSize, Distance, Appearance, Creator, Rights, Encoder, Relation, MiscellaneousField, Miscellaneous, Identification, Supports, Encoding, TimeSeparator, TimeSymbol, Cancel, KeyOctave, Key, Time, Interchangeable, PartSymbol, Clef, StaffTuning, StaffDetails, Double, Transpose, Directive, SlashDot, MultipleRest, MeasureRepeat, BeatRepeat, Slash, MeasureStyle, Attributes, Cue, Grace, Chord, Unpitched, Pitch, FullNote, Rest, Tie, Instrument, Note, Type, Dot, Accidental, TimeModification, Stem, Notehead, NoteheadText, Beam, Notations, Tied, Slur, Tuplet, TupletActual, TupletNormal, TupletNumber, TupletType, TupletDot, Glissando, Slide, OtherNotation, OtherDirection, Ornaments, TrillMark, Turn, DelayedTurn, InvertedTurn, DelayedInvertedTurn, VerticalTurn, Shake, Mordent, InvertedMordent, Schleifer, Tremolo, OtherOrnament, AccidentalMark, Technical, UpBow, DownBow, Harmonic, OpenString, ThumbPosition, Pluck, DoubleTongue, TripleTongue, Stopped, SnapPizzicato, HammerOn, PullOff, Bend, WithBar, Tap, Heel, Toe, Fingernails, Hole, HoleClosed, Arrow, Handbell, OtherTechnical, Articulations, Accent, StrongAccent, Staccato, Tenuto, DetachedLegato, Staccatissimo, Spiccato, Scoop, Plop, Doit, Falloff, BreathMark, Caesura, Stress, Unstress, OtherArticulation, Arpeggiate, NonArpeggiate, Laughing, Humming, EndLine, EndParagraph, LyricParts, Lyric, Text, Syllabic, Elision, Extend, FiguredBass, Figure, Prefix, FigureNumber, Suffix, Backup, Forward, Barline, BarStyle, Ending, Repeat, Direction, DirectionType, Rehearsal, Words, Wedge, Dashes, Bracket, Pedal, Metronome, BeatUnitDot, PerMinute, MetronomeNote, MetronomeDot, MetronomeBeam, MetronomeTuplet, OctaveShift, HarpPedals, PedalTuning, Damp, DampAll, Eyeglasses, StringMute, Scordatura, Accord, Image, PrincipalVoice, AccordionRegistration, Percussion, Timpani, Beater, Stick, Offset, HarmonyChord, Harmony, Root, RootStep, RootAlter, Function, Kind, Inversion, Bass, BassStep, BassAlter, Degree, DegreeValue, DegreeAlter, DegreeType, Frame, FirstFret, FrameNote, Barre, Grouping, Feature, Print, MeasureNumbering, Sound, Work, Opus, Defaults, MusicFont, WordFont, LyricFont, LyricLanguage, Credit, CreditWords, CreditImage, ScorePart, PartName, PartAbbreviation, PartGroup, GroupName, GroupNameDisplay, GroupAbbreviation, GroupAbbreviationDisplay, GroupSymbol, GroupBarline, GroupTime, ScoreInstrument, Solo, VirtualInstrument, ScoreHeader, ScoreTimewise, Measure, PartList} from "./index";
import {IAny} from "./operations";


function makePatch<T, U>(original: T, updates: any, childBuilders: U, explicitPatches: any[], modifiedKeys: {[key: string]: boolean}) {
  if (!original) return [{p: [], oi: updates}].concat(explicitPatches);

  let patches: any = Object.keys(modifiedKeys).map(key => {
    if (childBuilders[key] !== undefined) return;
    if (updates[key] === original[key] || updates[key] !== updates[key] && original[key] !== original[key]) return;
    if (updates[key] === undefined) return {p: [key], od: original[key]};
    if (original[key] === undefined) return {p: [key], oi: updates[key]};
    return {p: [key], od: original[key], oi: updates[key]};
  }).filter(p => Boolean(p));

  Object.keys(childBuilders).map(key => {
    if (original[key] === undefined) {
      patches.push({p: [key], oi: childBuilders[key].build()});
    } else {
      let subpatches = childBuilders[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    }
  });
  return patches.concat(explicitPatches);
}
export interface ITextSegmentBuilder {
  build?: () => TextSegment;
  patch: () => IAny[];
  acc: (build: AccidentalText | ((builder: IAccidentalTextBuilder) => IAccidentalTextBuilder)) => ITextSegmentBuilder;
  text: (build: DisplayText | ((builder: IDisplayTextBuilder) => IDisplayTextBuilder)) => ITextSegmentBuilder;
}

class TextSegmentBuilder implements ITextSegmentBuilder {
  build: () => TextSegment;
  patch: () => IAny[];
  acc: (build: AccidentalText | ((builder: IAccidentalTextBuilder) => IAccidentalTextBuilder)) => ITextSegmentBuilder;
  text: (build: DisplayText | ((builder: IDisplayTextBuilder) => IDisplayTextBuilder)) => ITextSegmentBuilder;
  constructor(original?: TextSegment) {
    let updates: TextSegment = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): TextSegment => {
        checkInvariants();
        (updates as any)._class = "TextSegment";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.acc = (build: AccidentalText | ((builder: IAccidentalTextBuilder) => IAccidentalTextBuilder)): ITextSegmentBuilder => {
      if (typeof build === 'function') {
        delete updates["acc"]
        const builder = (build as any)(new AccidentalTextBuilder(original && original["acc"]));
        if (!original) updates["acc"] = builder.build();
        else childBuilders["acc"] = builder;
      } else {
        updates.acc = build as any;
        delete childBuilders["acc;"];
      }
      modifiedKeys["acc"] = true;
      return this;
    }

    this.text = (build: DisplayText | ((builder: IDisplayTextBuilder) => IDisplayTextBuilder)): ITextSegmentBuilder => {
      if (typeof build === 'function') {
        delete updates["text"]
        const builder = (build as any)(new DisplayTextBuilder(original && original["text"]));
        if (!original) updates["text"] = builder.build();
        else childBuilders["text"] = builder;
      } else {
        updates.text = build as any;
        delete childBuilders["text;"];
      }
      modifiedKeys["text"] = true;
      return this;
    }
  }
}
export function patchTextSegment(base: TextSegment, builder: (build: ITextSegmentBuilder) => ITextSegmentBuilder): IAny[] { return builder(new TextSegmentBuilder(base)).patch(); }
export function buildTextSegment(builder: (build: ITextSegmentBuilder) => ITextSegmentBuilder): TextSegment { return builder(new TextSegmentBuilder()).build(); }

export interface IEncodingDateBuilder {
  build?: () => EncodingDate;
  patch: () => IAny[];
  month: (month: number) => IEncodingDateBuilder;
  day: (day: number) => IEncodingDateBuilder;
  year: (year: number) => IEncodingDateBuilder;
}

class EncodingDateBuilder implements IEncodingDateBuilder {
  build: () => EncodingDate;
  patch: () => IAny[];
  month: (month: number) => IEncodingDateBuilder;
  day: (day: number) => IEncodingDateBuilder;
  year: (year: number) => IEncodingDateBuilder;
  constructor(original?: EncodingDate) {
    let updates: EncodingDate = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["month"]) ||
          childBuilders["month"] !== undefined ||
          updates.month !== undefined,
        "month is a required field");
      console.assert(
          (original && !modifiedKeys["day"]) ||
          childBuilders["day"] !== undefined ||
          updates.day !== undefined,
        "day is a required field");
      console.assert(
          (original && !modifiedKeys["year"]) ||
          childBuilders["year"] !== undefined ||
          updates.year !== undefined,
        "year is a required field");
    }

    if (!original) {
      this.build = (): EncodingDate => {
        checkInvariants();
        (updates as any)._class = "EncodingDate";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.month = (spec: number): IEncodingDateBuilder => {
        updates["month"] = spec;
        delete childBuilders["month;"];
        modifiedKeys["month"] = true;
        return this;
    }

    this.day = (spec: number): IEncodingDateBuilder => {
        updates["day"] = spec;
        delete childBuilders["day;"];
        modifiedKeys["day"] = true;
        return this;
    }

    this.year = (spec: number): IEncodingDateBuilder => {
        updates["year"] = spec;
        delete childBuilders["year;"];
        modifiedKeys["year"] = true;
        return this;
    }
  }
}
export function patchEncodingDate(base: EncodingDate, builder: (build: IEncodingDateBuilder) => IEncodingDateBuilder): IAny[] { return builder(new EncodingDateBuilder(base)).patch(); }
export function buildEncodingDate(builder: (build: IEncodingDateBuilder) => IEncodingDateBuilder): EncodingDate { return builder(new EncodingDateBuilder()).build(); }

export interface ICalendarDateBuilder {
  build?: () => CalendarDate;
  patch: () => IAny[];
  month: (month: number) => ICalendarDateBuilder;
  day: (day: number) => ICalendarDateBuilder;
  year: (year: number) => ICalendarDateBuilder;
}

class CalendarDateBuilder implements ICalendarDateBuilder {
  build: () => CalendarDate;
  patch: () => IAny[];
  month: (month: number) => ICalendarDateBuilder;
  day: (day: number) => ICalendarDateBuilder;
  year: (year: number) => ICalendarDateBuilder;
  constructor(original?: CalendarDate) {
    let updates: CalendarDate = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["month"]) ||
          childBuilders["month"] !== undefined ||
          updates.month !== undefined,
        "month is a required field");
      console.assert(
          (original && !modifiedKeys["day"]) ||
          childBuilders["day"] !== undefined ||
          updates.day !== undefined,
        "day is a required field");
      console.assert(
          (original && !modifiedKeys["year"]) ||
          childBuilders["year"] !== undefined ||
          updates.year !== undefined,
        "year is a required field");
    }

    if (!original) {
      this.build = (): CalendarDate => {
        checkInvariants();
        (updates as any)._class = "CalendarDate";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.month = (spec: number): ICalendarDateBuilder => {
        updates["month"] = spec;
        delete childBuilders["month;"];
        modifiedKeys["month"] = true;
        return this;
    }

    this.day = (spec: number): ICalendarDateBuilder => {
        updates["day"] = spec;
        delete childBuilders["day;"];
        modifiedKeys["day"] = true;
        return this;
    }

    this.year = (spec: number): ICalendarDateBuilder => {
        updates["year"] = spec;
        delete childBuilders["year;"];
        modifiedKeys["year"] = true;
        return this;
    }
  }
}
export function patchCalendarDate(base: CalendarDate, builder: (build: ICalendarDateBuilder) => ICalendarDateBuilder): IAny[] { return builder(new CalendarDateBuilder(base)).patch(); }
export function buildCalendarDate(builder: (build: ICalendarDateBuilder) => ICalendarDateBuilder): CalendarDate { return builder(new CalendarDateBuilder()).build(); }

export interface IPositionBuilder {
  build?: () => Position;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IPositionBuilder;
  relativeY: (relativeY: number) => IPositionBuilder;
  defaultY: (defaultY: number) => IPositionBuilder;
  relativeX: (relativeX: number) => IPositionBuilder;
}

class PositionBuilder implements IPositionBuilder {
  build: () => Position;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IPositionBuilder;
  relativeY: (relativeY: number) => IPositionBuilder;
  defaultY: (defaultY: number) => IPositionBuilder;
  relativeX: (relativeX: number) => IPositionBuilder;
  constructor(original?: Position) {
    let updates: Position = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Position => {
        checkInvariants();
        (updates as any)._class = "Position";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IPositionBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IPositionBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IPositionBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IPositionBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }
  }
}
export function patchPosition(base: Position, builder: (build: IPositionBuilder) => IPositionBuilder): IAny[] { return builder(new PositionBuilder(base)).patch(); }
export function buildPosition(builder: (build: IPositionBuilder) => IPositionBuilder): Position { return builder(new PositionBuilder()).build(); }

export interface IPlacementBuilder {
  build?: () => Placement;
  patch: () => IAny[];
  placement: (placement: AboveBelow) => IPlacementBuilder;
}

class PlacementBuilder implements IPlacementBuilder {
  build: () => Placement;
  patch: () => IAny[];
  placement: (placement: AboveBelow) => IPlacementBuilder;
  constructor(original?: Placement) {
    let updates: Placement = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Placement => {
        checkInvariants();
        (updates as any)._class = "Placement";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.placement = (spec: AboveBelow): IPlacementBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchPlacement(base: Placement, builder: (build: IPlacementBuilder) => IPlacementBuilder): IAny[] { return builder(new PlacementBuilder(base)).patch(); }
export function buildPlacement(builder: (build: IPlacementBuilder) => IPlacementBuilder): Placement { return builder(new PlacementBuilder()).build(); }

export interface IOrientationBuilder {
  build?: () => Orientation;
  patch: () => IAny[];
  orientation: (orientation: OverUnder) => IOrientationBuilder;
}

class OrientationBuilder implements IOrientationBuilder {
  build: () => Orientation;
  patch: () => IAny[];
  orientation: (orientation: OverUnder) => IOrientationBuilder;
  constructor(original?: Orientation) {
    let updates: Orientation = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Orientation => {
        checkInvariants();
        (updates as any)._class = "Orientation";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.orientation = (spec: OverUnder): IOrientationBuilder => {
        updates["orientation"] = spec;
        delete childBuilders["orientation;"];
        modifiedKeys["orientation"] = true;
        return this;
    }
  }
}
export function patchOrientation(base: Orientation, builder: (build: IOrientationBuilder) => IOrientationBuilder): IAny[] { return builder(new OrientationBuilder(base)).patch(); }
export function buildOrientation(builder: (build: IOrientationBuilder) => IOrientationBuilder): Orientation { return builder(new OrientationBuilder()).build(); }

export interface IDirectiveEntityBuilder {
  build?: () => DirectiveEntity;
  patch: () => IAny[];
  directive: (directive: boolean) => IDirectiveEntityBuilder;
}

class DirectiveEntityBuilder implements IDirectiveEntityBuilder {
  build: () => DirectiveEntity;
  patch: () => IAny[];
  directive: (directive: boolean) => IDirectiveEntityBuilder;
  constructor(original?: DirectiveEntity) {
    let updates: DirectiveEntity = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): DirectiveEntity => {
        checkInvariants();
        (updates as any)._class = "DirectiveEntity";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.directive = (spec: boolean): IDirectiveEntityBuilder => {
        updates["directive"] = spec;
        delete childBuilders["directive;"];
        modifiedKeys["directive"] = true;
        return this;
    }
  }
}
export function patchDirectiveEntity(base: DirectiveEntity, builder: (build: IDirectiveEntityBuilder) => IDirectiveEntityBuilder): IAny[] { return builder(new DirectiveEntityBuilder(base)).patch(); }
export function buildDirectiveEntity(builder: (build: IDirectiveEntityBuilder) => IDirectiveEntityBuilder): DirectiveEntity { return builder(new DirectiveEntityBuilder()).build(); }

export interface IBezierBuilder {
  build?: () => Bezier;
  patch: () => IAny[];
  bezierX2: (bezierX2: number) => IBezierBuilder;
  bezierOffset: (bezierOffset: number) => IBezierBuilder;
  bezierOffset2: (bezierOffset2: number) => IBezierBuilder;
  bezierX: (bezierX: number) => IBezierBuilder;
  bezierY: (bezierY: number) => IBezierBuilder;
  bezierY2: (bezierY2: number) => IBezierBuilder;
}

class BezierBuilder implements IBezierBuilder {
  build: () => Bezier;
  patch: () => IAny[];
  bezierX2: (bezierX2: number) => IBezierBuilder;
  bezierOffset: (bezierOffset: number) => IBezierBuilder;
  bezierOffset2: (bezierOffset2: number) => IBezierBuilder;
  bezierX: (bezierX: number) => IBezierBuilder;
  bezierY: (bezierY: number) => IBezierBuilder;
  bezierY2: (bezierY2: number) => IBezierBuilder;
  constructor(original?: Bezier) {
    let updates: Bezier = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Bezier => {
        checkInvariants();
        (updates as any)._class = "Bezier";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.bezierX2 = (spec: number): IBezierBuilder => {
        updates["bezierX2"] = spec;
        delete childBuilders["bezierX2;"];
        modifiedKeys["bezierX2"] = true;
        return this;
    }

    this.bezierOffset = (spec: number): IBezierBuilder => {
        updates["bezierOffset"] = spec;
        delete childBuilders["bezierOffset;"];
        modifiedKeys["bezierOffset"] = true;
        return this;
    }

    this.bezierOffset2 = (spec: number): IBezierBuilder => {
        updates["bezierOffset2"] = spec;
        delete childBuilders["bezierOffset2;"];
        modifiedKeys["bezierOffset2"] = true;
        return this;
    }

    this.bezierX = (spec: number): IBezierBuilder => {
        updates["bezierX"] = spec;
        delete childBuilders["bezierX;"];
        modifiedKeys["bezierX"] = true;
        return this;
    }

    this.bezierY = (spec: number): IBezierBuilder => {
        updates["bezierY"] = spec;
        delete childBuilders["bezierY;"];
        modifiedKeys["bezierY"] = true;
        return this;
    }

    this.bezierY2 = (spec: number): IBezierBuilder => {
        updates["bezierY2"] = spec;
        delete childBuilders["bezierY2;"];
        modifiedKeys["bezierY2"] = true;
        return this;
    }
  }
}
export function patchBezier(base: Bezier, builder: (build: IBezierBuilder) => IBezierBuilder): IAny[] { return builder(new BezierBuilder(base)).patch(); }
export function buildBezier(builder: (build: IBezierBuilder) => IBezierBuilder): Bezier { return builder(new BezierBuilder()).build(); }

export interface IFontBuilder {
  build?: () => Font;
  patch: () => IAny[];
  fontFamily: (fontFamily: string) => IFontBuilder;
  fontWeight: (fontWeight: NormalBold) => IFontBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFontBuilder;
  fontSize: (fontSize: string) => IFontBuilder;
}

class FontBuilder implements IFontBuilder {
  build: () => Font;
  patch: () => IAny[];
  fontFamily: (fontFamily: string) => IFontBuilder;
  fontWeight: (fontWeight: NormalBold) => IFontBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFontBuilder;
  fontSize: (fontSize: string) => IFontBuilder;
  constructor(original?: Font) {
    let updates: Font = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Font => {
        checkInvariants();
        (updates as any)._class = "Font";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.fontFamily = (spec: string): IFontBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IFontBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IFontBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IFontBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }
  }
}
export function patchFont(base: Font, builder: (build: IFontBuilder) => IFontBuilder): IAny[] { return builder(new FontBuilder(base)).patch(); }
export function buildFont(builder: (build: IFontBuilder) => IFontBuilder): Font { return builder(new FontBuilder()).build(); }

export interface IColorBuilder {
  build?: () => Color;
  patch: () => IAny[];
  color: (color: string) => IColorBuilder;
}

class ColorBuilder implements IColorBuilder {
  build: () => Color;
  patch: () => IAny[];
  color: (color: string) => IColorBuilder;
  constructor(original?: Color) {
    let updates: Color = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Color => {
        checkInvariants();
        (updates as any)._class = "Color";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.color = (spec: string): IColorBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchColor(base: Color, builder: (build: IColorBuilder) => IColorBuilder): IAny[] { return builder(new ColorBuilder(base)).patch(); }
export function buildColor(builder: (build: IColorBuilder) => IColorBuilder): Color { return builder(new ColorBuilder()).build(); }

export interface ITextDecorationBuilder {
  build?: () => TextDecoration;
  patch: () => IAny[];
  underline: (underline: number) => ITextDecorationBuilder;
  overline: (overline: number) => ITextDecorationBuilder;
  lineThrough: (lineThrough: number) => ITextDecorationBuilder;
}

class TextDecorationBuilder implements ITextDecorationBuilder {
  build: () => TextDecoration;
  patch: () => IAny[];
  underline: (underline: number) => ITextDecorationBuilder;
  overline: (overline: number) => ITextDecorationBuilder;
  lineThrough: (lineThrough: number) => ITextDecorationBuilder;
  constructor(original?: TextDecoration) {
    let updates: TextDecoration = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): TextDecoration => {
        checkInvariants();
        (updates as any)._class = "TextDecoration";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.underline = (spec: number): ITextDecorationBuilder => {
        updates["underline"] = spec;
        delete childBuilders["underline;"];
        modifiedKeys["underline"] = true;
        return this;
    }

    this.overline = (spec: number): ITextDecorationBuilder => {
        updates["overline"] = spec;
        delete childBuilders["overline;"];
        modifiedKeys["overline"] = true;
        return this;
    }

    this.lineThrough = (spec: number): ITextDecorationBuilder => {
        updates["lineThrough"] = spec;
        delete childBuilders["lineThrough;"];
        modifiedKeys["lineThrough"] = true;
        return this;
    }
  }
}
export function patchTextDecoration(base: TextDecoration, builder: (build: ITextDecorationBuilder) => ITextDecorationBuilder): IAny[] { return builder(new TextDecorationBuilder(base)).patch(); }
export function buildTextDecoration(builder: (build: ITextDecorationBuilder) => ITextDecorationBuilder): TextDecoration { return builder(new TextDecorationBuilder()).build(); }

export interface IJustifyBuilder {
  build?: () => Justify;
  patch: () => IAny[];
  justify: (justify: LeftCenterRight) => IJustifyBuilder;
}

class JustifyBuilder implements IJustifyBuilder {
  build: () => Justify;
  patch: () => IAny[];
  justify: (justify: LeftCenterRight) => IJustifyBuilder;
  constructor(original?: Justify) {
    let updates: Justify = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Justify => {
        checkInvariants();
        (updates as any)._class = "Justify";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.justify = (spec: LeftCenterRight): IJustifyBuilder => {
        updates["justify"] = spec;
        delete childBuilders["justify;"];
        modifiedKeys["justify"] = true;
        return this;
    }
  }
}
export function patchJustify(base: Justify, builder: (build: IJustifyBuilder) => IJustifyBuilder): IAny[] { return builder(new JustifyBuilder(base)).patch(); }
export function buildJustify(builder: (build: IJustifyBuilder) => IJustifyBuilder): Justify { return builder(new JustifyBuilder()).build(); }

export interface IHalignBuilder {
  build?: () => Halign;
  patch: () => IAny[];
  halign: (halign: LeftCenterRight) => IHalignBuilder;
}

class HalignBuilder implements IHalignBuilder {
  build: () => Halign;
  patch: () => IAny[];
  halign: (halign: LeftCenterRight) => IHalignBuilder;
  constructor(original?: Halign) {
    let updates: Halign = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Halign => {
        checkInvariants();
        (updates as any)._class = "Halign";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.halign = (spec: LeftCenterRight): IHalignBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }
  }
}
export function patchHalign(base: Halign, builder: (build: IHalignBuilder) => IHalignBuilder): IAny[] { return builder(new HalignBuilder(base)).patch(); }
export function buildHalign(builder: (build: IHalignBuilder) => IHalignBuilder): Halign { return builder(new HalignBuilder()).build(); }

export interface IValignBuilder {
  build?: () => Valign;
  patch: () => IAny[];
  valign: (valign: TopMiddleBottomBaseline) => IValignBuilder;
}

class ValignBuilder implements IValignBuilder {
  build: () => Valign;
  patch: () => IAny[];
  valign: (valign: TopMiddleBottomBaseline) => IValignBuilder;
  constructor(original?: Valign) {
    let updates: Valign = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Valign => {
        checkInvariants();
        (updates as any)._class = "Valign";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.valign = (spec: TopMiddleBottomBaseline): IValignBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchValign(base: Valign, builder: (build: IValignBuilder) => IValignBuilder): IAny[] { return builder(new ValignBuilder(base)).patch(); }
export function buildValign(builder: (build: IValignBuilder) => IValignBuilder): Valign { return builder(new ValignBuilder()).build(); }

export interface IValignImageBuilder {
  build?: () => ValignImage;
  patch: () => IAny[];
  valignImage: (valignImage: TopMiddleBottomBaseline) => IValignImageBuilder;
}

class ValignImageBuilder implements IValignImageBuilder {
  build: () => ValignImage;
  patch: () => IAny[];
  valignImage: (valignImage: TopMiddleBottomBaseline) => IValignImageBuilder;
  constructor(original?: ValignImage) {
    let updates: ValignImage = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): ValignImage => {
        checkInvariants();
        (updates as any)._class = "ValignImage";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.valignImage = (spec: TopMiddleBottomBaseline): IValignImageBuilder => {
        updates["valignImage"] = spec;
        delete childBuilders["valignImage;"];
        modifiedKeys["valignImage"] = true;
        return this;
    }
  }
}
export function patchValignImage(base: ValignImage, builder: (build: IValignImageBuilder) => IValignImageBuilder): IAny[] { return builder(new ValignImageBuilder(base)).patch(); }
export function buildValignImage(builder: (build: IValignImageBuilder) => IValignImageBuilder): ValignImage { return builder(new ValignImageBuilder()).build(); }

export interface ILetterSpacingBuilder {
  build?: () => LetterSpacing;
  patch: () => IAny[];
  letterSpacing: (letterSpacing: string) => ILetterSpacingBuilder;
}

class LetterSpacingBuilder implements ILetterSpacingBuilder {
  build: () => LetterSpacing;
  patch: () => IAny[];
  letterSpacing: (letterSpacing: string) => ILetterSpacingBuilder;
  constructor(original?: LetterSpacing) {
    let updates: LetterSpacing = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): LetterSpacing => {
        checkInvariants();
        (updates as any)._class = "LetterSpacing";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.letterSpacing = (spec: string): ILetterSpacingBuilder => {
        updates["letterSpacing"] = spec;
        delete childBuilders["letterSpacing;"];
        modifiedKeys["letterSpacing"] = true;
        return this;
    }
  }
}
export function patchLetterSpacing(base: LetterSpacing, builder: (build: ILetterSpacingBuilder) => ILetterSpacingBuilder): IAny[] { return builder(new LetterSpacingBuilder(base)).patch(); }
export function buildLetterSpacing(builder: (build: ILetterSpacingBuilder) => ILetterSpacingBuilder): LetterSpacing { return builder(new LetterSpacingBuilder()).build(); }

export interface ILineHeightBuilder {
  build?: () => LineHeight;
  patch: () => IAny[];
  lineHeight: (lineHeight: string) => ILineHeightBuilder;
}

class LineHeightBuilder implements ILineHeightBuilder {
  build: () => LineHeight;
  patch: () => IAny[];
  lineHeight: (lineHeight: string) => ILineHeightBuilder;
  constructor(original?: LineHeight) {
    let updates: LineHeight = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): LineHeight => {
        checkInvariants();
        (updates as any)._class = "LineHeight";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.lineHeight = (spec: string): ILineHeightBuilder => {
        updates["lineHeight"] = spec;
        delete childBuilders["lineHeight;"];
        modifiedKeys["lineHeight"] = true;
        return this;
    }
  }
}
export function patchLineHeight(base: LineHeight, builder: (build: ILineHeightBuilder) => ILineHeightBuilder): IAny[] { return builder(new LineHeightBuilder(base)).patch(); }
export function buildLineHeight(builder: (build: ILineHeightBuilder) => ILineHeightBuilder): LineHeight { return builder(new LineHeightBuilder()).build(); }

export interface ITextDirectionBuilder {
  build?: () => TextDirection;
  patch: () => IAny[];
  dir: (dir: DirectionMode) => ITextDirectionBuilder;
}

class TextDirectionBuilder implements ITextDirectionBuilder {
  build: () => TextDirection;
  patch: () => IAny[];
  dir: (dir: DirectionMode) => ITextDirectionBuilder;
  constructor(original?: TextDirection) {
    let updates: TextDirection = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): TextDirection => {
        checkInvariants();
        (updates as any)._class = "TextDirection";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.dir = (spec: DirectionMode): ITextDirectionBuilder => {
        updates["dir"] = spec;
        delete childBuilders["dir;"];
        modifiedKeys["dir"] = true;
        return this;
    }
  }
}
export function patchTextDirection(base: TextDirection, builder: (build: ITextDirectionBuilder) => ITextDirectionBuilder): IAny[] { return builder(new TextDirectionBuilder(base)).patch(); }
export function buildTextDirection(builder: (build: ITextDirectionBuilder) => ITextDirectionBuilder): TextDirection { return builder(new TextDirectionBuilder()).build(); }

export interface ITextRotationBuilder {
  build?: () => TextRotation;
  patch: () => IAny[];
  rotation: (rotation: number) => ITextRotationBuilder;
}

class TextRotationBuilder implements ITextRotationBuilder {
  build: () => TextRotation;
  patch: () => IAny[];
  rotation: (rotation: number) => ITextRotationBuilder;
  constructor(original?: TextRotation) {
    let updates: TextRotation = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): TextRotation => {
        checkInvariants();
        (updates as any)._class = "TextRotation";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.rotation = (spec: number): ITextRotationBuilder => {
        updates["rotation"] = spec;
        delete childBuilders["rotation;"];
        modifiedKeys["rotation"] = true;
        return this;
    }
  }
}
export function patchTextRotation(base: TextRotation, builder: (build: ITextRotationBuilder) => ITextRotationBuilder): IAny[] { return builder(new TextRotationBuilder(base)).patch(); }
export function buildTextRotation(builder: (build: ITextRotationBuilder) => ITextRotationBuilder): TextRotation { return builder(new TextRotationBuilder()).build(); }

export interface IEnclosureBuilder {
  build?: () => Enclosure;
  patch: () => IAny[];
  enclosure: (enclosure: EnclosureShape) => IEnclosureBuilder;
}

class EnclosureBuilder implements IEnclosureBuilder {
  build: () => Enclosure;
  patch: () => IAny[];
  enclosure: (enclosure: EnclosureShape) => IEnclosureBuilder;
  constructor(original?: Enclosure) {
    let updates: Enclosure = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Enclosure => {
        checkInvariants();
        (updates as any)._class = "Enclosure";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.enclosure = (spec: EnclosureShape): IEnclosureBuilder => {
        updates["enclosure"] = spec;
        delete childBuilders["enclosure;"];
        modifiedKeys["enclosure"] = true;
        return this;
    }
  }
}
export function patchEnclosure(base: Enclosure, builder: (build: IEnclosureBuilder) => IEnclosureBuilder): IAny[] { return builder(new EnclosureBuilder(base)).patch(); }
export function buildEnclosure(builder: (build: IEnclosureBuilder) => IEnclosureBuilder): Enclosure { return builder(new EnclosureBuilder()).build(); }

export interface IPrintStyleBuilder {
  build?: () => PrintStyle;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IPrintStyleBuilder;
  relativeY: (relativeY: number) => IPrintStyleBuilder;
  defaultY: (defaultY: number) => IPrintStyleBuilder;
  relativeX: (relativeX: number) => IPrintStyleBuilder;
  fontFamily: (fontFamily: string) => IPrintStyleBuilder;
  fontWeight: (fontWeight: NormalBold) => IPrintStyleBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPrintStyleBuilder;
  fontSize: (fontSize: string) => IPrintStyleBuilder;
  color: (color: string) => IPrintStyleBuilder;
}

class PrintStyleBuilder implements IPrintStyleBuilder {
  build: () => PrintStyle;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IPrintStyleBuilder;
  relativeY: (relativeY: number) => IPrintStyleBuilder;
  defaultY: (defaultY: number) => IPrintStyleBuilder;
  relativeX: (relativeX: number) => IPrintStyleBuilder;
  fontFamily: (fontFamily: string) => IPrintStyleBuilder;
  fontWeight: (fontWeight: NormalBold) => IPrintStyleBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPrintStyleBuilder;
  fontSize: (fontSize: string) => IPrintStyleBuilder;
  color: (color: string) => IPrintStyleBuilder;
  constructor(original?: PrintStyle) {
    let updates: PrintStyle = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): PrintStyle => {
        checkInvariants();
        (updates as any)._class = "PrintStyle";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IPrintStyleBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IPrintStyleBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IPrintStyleBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IPrintStyleBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IPrintStyleBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IPrintStyleBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IPrintStyleBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IPrintStyleBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IPrintStyleBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchPrintStyle(base: PrintStyle, builder: (build: IPrintStyleBuilder) => IPrintStyleBuilder): IAny[] { return builder(new PrintStyleBuilder(base)).patch(); }
export function buildPrintStyle(builder: (build: IPrintStyleBuilder) => IPrintStyleBuilder): PrintStyle { return builder(new PrintStyleBuilder()).build(); }

export interface IPrintStyleAlignBuilder {
  build?: () => PrintStyleAlign;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IPrintStyleAlignBuilder;
  relativeY: (relativeY: number) => IPrintStyleAlignBuilder;
  defaultY: (defaultY: number) => IPrintStyleAlignBuilder;
  relativeX: (relativeX: number) => IPrintStyleAlignBuilder;
  fontFamily: (fontFamily: string) => IPrintStyleAlignBuilder;
  fontWeight: (fontWeight: NormalBold) => IPrintStyleAlignBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPrintStyleAlignBuilder;
  fontSize: (fontSize: string) => IPrintStyleAlignBuilder;
  color: (color: string) => IPrintStyleAlignBuilder;
  halign: (halign: LeftCenterRight) => IPrintStyleAlignBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IPrintStyleAlignBuilder;
}

class PrintStyleAlignBuilder implements IPrintStyleAlignBuilder {
  build: () => PrintStyleAlign;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IPrintStyleAlignBuilder;
  relativeY: (relativeY: number) => IPrintStyleAlignBuilder;
  defaultY: (defaultY: number) => IPrintStyleAlignBuilder;
  relativeX: (relativeX: number) => IPrintStyleAlignBuilder;
  fontFamily: (fontFamily: string) => IPrintStyleAlignBuilder;
  fontWeight: (fontWeight: NormalBold) => IPrintStyleAlignBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPrintStyleAlignBuilder;
  fontSize: (fontSize: string) => IPrintStyleAlignBuilder;
  color: (color: string) => IPrintStyleAlignBuilder;
  halign: (halign: LeftCenterRight) => IPrintStyleAlignBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IPrintStyleAlignBuilder;
  constructor(original?: PrintStyleAlign) {
    let updates: PrintStyleAlign = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): PrintStyleAlign => {
        checkInvariants();
        (updates as any)._class = "PrintStyleAlign";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IPrintStyleAlignBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IPrintStyleAlignBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IPrintStyleAlignBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IPrintStyleAlignBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IPrintStyleAlignBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IPrintStyleAlignBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IPrintStyleAlignBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IPrintStyleAlignBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IPrintStyleAlignBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IPrintStyleAlignBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IPrintStyleAlignBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchPrintStyleAlign(base: PrintStyleAlign, builder: (build: IPrintStyleAlignBuilder) => IPrintStyleAlignBuilder): IAny[] { return builder(new PrintStyleAlignBuilder(base)).patch(); }
export function buildPrintStyleAlign(builder: (build: IPrintStyleAlignBuilder) => IPrintStyleAlignBuilder): PrintStyleAlign { return builder(new PrintStyleAlignBuilder()).build(); }

export interface ILineShapeBuilder {
  build?: () => LineShape;
  patch: () => IAny[];
  lineShape: (lineShape: StraightCurved) => ILineShapeBuilder;
}

class LineShapeBuilder implements ILineShapeBuilder {
  build: () => LineShape;
  patch: () => IAny[];
  lineShape: (lineShape: StraightCurved) => ILineShapeBuilder;
  constructor(original?: LineShape) {
    let updates: LineShape = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): LineShape => {
        checkInvariants();
        (updates as any)._class = "LineShape";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.lineShape = (spec: StraightCurved): ILineShapeBuilder => {
        updates["lineShape"] = spec;
        delete childBuilders["lineShape;"];
        modifiedKeys["lineShape"] = true;
        return this;
    }
  }
}
export function patchLineShape(base: LineShape, builder: (build: ILineShapeBuilder) => ILineShapeBuilder): IAny[] { return builder(new LineShapeBuilder(base)).patch(); }
export function buildLineShape(builder: (build: ILineShapeBuilder) => ILineShapeBuilder): LineShape { return builder(new LineShapeBuilder()).build(); }

export interface ILineTypeBuilder {
  build?: () => LineType;
  patch: () => IAny[];
  lineType: (lineType: SolidDashedDottedWavy) => ILineTypeBuilder;
}

class LineTypeBuilder implements ILineTypeBuilder {
  build: () => LineType;
  patch: () => IAny[];
  lineType: (lineType: SolidDashedDottedWavy) => ILineTypeBuilder;
  constructor(original?: LineType) {
    let updates: LineType = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): LineType => {
        checkInvariants();
        (updates as any)._class = "LineType";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.lineType = (spec: SolidDashedDottedWavy): ILineTypeBuilder => {
        updates["lineType"] = spec;
        delete childBuilders["lineType;"];
        modifiedKeys["lineType"] = true;
        return this;
    }
  }
}
export function patchLineType(base: LineType, builder: (build: ILineTypeBuilder) => ILineTypeBuilder): IAny[] { return builder(new LineTypeBuilder(base)).patch(); }
export function buildLineType(builder: (build: ILineTypeBuilder) => ILineTypeBuilder): LineType { return builder(new LineTypeBuilder()).build(); }

export interface IDashedFormattingBuilder {
  build?: () => DashedFormatting;
  patch: () => IAny[];
  dashLength: (dashLength: number) => IDashedFormattingBuilder;
  spaceLength: (spaceLength: number) => IDashedFormattingBuilder;
}

class DashedFormattingBuilder implements IDashedFormattingBuilder {
  build: () => DashedFormatting;
  patch: () => IAny[];
  dashLength: (dashLength: number) => IDashedFormattingBuilder;
  spaceLength: (spaceLength: number) => IDashedFormattingBuilder;
  constructor(original?: DashedFormatting) {
    let updates: DashedFormatting = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): DashedFormatting => {
        checkInvariants();
        (updates as any)._class = "DashedFormatting";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.dashLength = (spec: number): IDashedFormattingBuilder => {
        updates["dashLength"] = spec;
        delete childBuilders["dashLength;"];
        modifiedKeys["dashLength"] = true;
        return this;
    }

    this.spaceLength = (spec: number): IDashedFormattingBuilder => {
        updates["spaceLength"] = spec;
        delete childBuilders["spaceLength;"];
        modifiedKeys["spaceLength"] = true;
        return this;
    }
  }
}
export function patchDashedFormatting(base: DashedFormatting, builder: (build: IDashedFormattingBuilder) => IDashedFormattingBuilder): IAny[] { return builder(new DashedFormattingBuilder(base)).patch(); }
export function buildDashedFormatting(builder: (build: IDashedFormattingBuilder) => IDashedFormattingBuilder): DashedFormatting { return builder(new DashedFormattingBuilder()).build(); }

export interface IPrintObjectBuilder {
  build?: () => PrintObject;
  patch: () => IAny[];
  printObject: (printObject: boolean) => IPrintObjectBuilder;
}

class PrintObjectBuilder implements IPrintObjectBuilder {
  build: () => PrintObject;
  patch: () => IAny[];
  printObject: (printObject: boolean) => IPrintObjectBuilder;
  constructor(original?: PrintObject) {
    let updates: PrintObject = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): PrintObject => {
        checkInvariants();
        (updates as any)._class = "PrintObject";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.printObject = (spec: boolean): IPrintObjectBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }
  }
}
export function patchPrintObject(base: PrintObject, builder: (build: IPrintObjectBuilder) => IPrintObjectBuilder): IAny[] { return builder(new PrintObjectBuilder(base)).patch(); }
export function buildPrintObject(builder: (build: IPrintObjectBuilder) => IPrintObjectBuilder): PrintObject { return builder(new PrintObjectBuilder()).build(); }

export interface IPrintSpacingBuilder {
  build?: () => PrintSpacing;
  patch: () => IAny[];
  printSpacing: (printSpacing: boolean) => IPrintSpacingBuilder;
}

class PrintSpacingBuilder implements IPrintSpacingBuilder {
  build: () => PrintSpacing;
  patch: () => IAny[];
  printSpacing: (printSpacing: boolean) => IPrintSpacingBuilder;
  constructor(original?: PrintSpacing) {
    let updates: PrintSpacing = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): PrintSpacing => {
        checkInvariants();
        (updates as any)._class = "PrintSpacing";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.printSpacing = (spec: boolean): IPrintSpacingBuilder => {
        updates["printSpacing"] = spec;
        delete childBuilders["printSpacing;"];
        modifiedKeys["printSpacing"] = true;
        return this;
    }
  }
}
export function patchPrintSpacing(base: PrintSpacing, builder: (build: IPrintSpacingBuilder) => IPrintSpacingBuilder): IAny[] { return builder(new PrintSpacingBuilder(base)).patch(); }
export function buildPrintSpacing(builder: (build: IPrintSpacingBuilder) => IPrintSpacingBuilder): PrintSpacing { return builder(new PrintSpacingBuilder()).build(); }

export interface IPrintoutBuilder {
  build?: () => Printout;
  patch: () => IAny[];
  printDot: (printDot: boolean) => IPrintoutBuilder;
  printLyric: (printLyric: boolean) => IPrintoutBuilder;
  printObject: (printObject: boolean) => IPrintoutBuilder;
  printSpacing: (printSpacing: boolean) => IPrintoutBuilder;
}

class PrintoutBuilder implements IPrintoutBuilder {
  build: () => Printout;
  patch: () => IAny[];
  printDot: (printDot: boolean) => IPrintoutBuilder;
  printLyric: (printLyric: boolean) => IPrintoutBuilder;
  printObject: (printObject: boolean) => IPrintoutBuilder;
  printSpacing: (printSpacing: boolean) => IPrintoutBuilder;
  constructor(original?: Printout) {
    let updates: Printout = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Printout => {
        checkInvariants();
        (updates as any)._class = "Printout";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.printDot = (spec: boolean): IPrintoutBuilder => {
        updates["printDot"] = spec;
        delete childBuilders["printDot;"];
        modifiedKeys["printDot"] = true;
        return this;
    }

    this.printLyric = (spec: boolean): IPrintoutBuilder => {
        updates["printLyric"] = spec;
        delete childBuilders["printLyric;"];
        modifiedKeys["printLyric"] = true;
        return this;
    }

    this.printObject = (spec: boolean): IPrintoutBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.printSpacing = (spec: boolean): IPrintoutBuilder => {
        updates["printSpacing"] = spec;
        delete childBuilders["printSpacing;"];
        modifiedKeys["printSpacing"] = true;
        return this;
    }
  }
}
export function patchPrintout(base: Printout, builder: (build: IPrintoutBuilder) => IPrintoutBuilder): IAny[] { return builder(new PrintoutBuilder(base)).patch(); }
export function buildPrintout(builder: (build: IPrintoutBuilder) => IPrintoutBuilder): Printout { return builder(new PrintoutBuilder()).build(); }

export interface ITextFormattingBuilder {
  build?: () => TextFormatting;
  patch: () => IAny[];
  justify: (justify: LeftCenterRight) => ITextFormattingBuilder;
  defaultX: (defaultX: number) => ITextFormattingBuilder;
  relativeY: (relativeY: number) => ITextFormattingBuilder;
  defaultY: (defaultY: number) => ITextFormattingBuilder;
  relativeX: (relativeX: number) => ITextFormattingBuilder;
  fontFamily: (fontFamily: string) => ITextFormattingBuilder;
  fontWeight: (fontWeight: NormalBold) => ITextFormattingBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITextFormattingBuilder;
  fontSize: (fontSize: string) => ITextFormattingBuilder;
  color: (color: string) => ITextFormattingBuilder;
  halign: (halign: LeftCenterRight) => ITextFormattingBuilder;
  valign: (valign: TopMiddleBottomBaseline) => ITextFormattingBuilder;
  underline: (underline: number) => ITextFormattingBuilder;
  overline: (overline: number) => ITextFormattingBuilder;
  lineThrough: (lineThrough: number) => ITextFormattingBuilder;
  rotation: (rotation: number) => ITextFormattingBuilder;
  letterSpacing: (letterSpacing: string) => ITextFormattingBuilder;
  lineHeight: (lineHeight: string) => ITextFormattingBuilder;
  dir: (dir: DirectionMode) => ITextFormattingBuilder;
  enclosure: (enclosure: EnclosureShape) => ITextFormattingBuilder;
}

class TextFormattingBuilder implements ITextFormattingBuilder {
  build: () => TextFormatting;
  patch: () => IAny[];
  justify: (justify: LeftCenterRight) => ITextFormattingBuilder;
  defaultX: (defaultX: number) => ITextFormattingBuilder;
  relativeY: (relativeY: number) => ITextFormattingBuilder;
  defaultY: (defaultY: number) => ITextFormattingBuilder;
  relativeX: (relativeX: number) => ITextFormattingBuilder;
  fontFamily: (fontFamily: string) => ITextFormattingBuilder;
  fontWeight: (fontWeight: NormalBold) => ITextFormattingBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITextFormattingBuilder;
  fontSize: (fontSize: string) => ITextFormattingBuilder;
  color: (color: string) => ITextFormattingBuilder;
  halign: (halign: LeftCenterRight) => ITextFormattingBuilder;
  valign: (valign: TopMiddleBottomBaseline) => ITextFormattingBuilder;
  underline: (underline: number) => ITextFormattingBuilder;
  overline: (overline: number) => ITextFormattingBuilder;
  lineThrough: (lineThrough: number) => ITextFormattingBuilder;
  rotation: (rotation: number) => ITextFormattingBuilder;
  letterSpacing: (letterSpacing: string) => ITextFormattingBuilder;
  lineHeight: (lineHeight: string) => ITextFormattingBuilder;
  dir: (dir: DirectionMode) => ITextFormattingBuilder;
  enclosure: (enclosure: EnclosureShape) => ITextFormattingBuilder;
  constructor(original?: TextFormatting) {
    let updates: TextFormatting = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): TextFormatting => {
        checkInvariants();
        (updates as any)._class = "TextFormatting";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.justify = (spec: LeftCenterRight): ITextFormattingBuilder => {
        updates["justify"] = spec;
        delete childBuilders["justify;"];
        modifiedKeys["justify"] = true;
        return this;
    }

    this.defaultX = (spec: number): ITextFormattingBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ITextFormattingBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ITextFormattingBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ITextFormattingBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ITextFormattingBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ITextFormattingBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ITextFormattingBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ITextFormattingBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ITextFormattingBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): ITextFormattingBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): ITextFormattingBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }

    this.underline = (spec: number): ITextFormattingBuilder => {
        updates["underline"] = spec;
        delete childBuilders["underline;"];
        modifiedKeys["underline"] = true;
        return this;
    }

    this.overline = (spec: number): ITextFormattingBuilder => {
        updates["overline"] = spec;
        delete childBuilders["overline;"];
        modifiedKeys["overline"] = true;
        return this;
    }

    this.lineThrough = (spec: number): ITextFormattingBuilder => {
        updates["lineThrough"] = spec;
        delete childBuilders["lineThrough;"];
        modifiedKeys["lineThrough"] = true;
        return this;
    }

    this.rotation = (spec: number): ITextFormattingBuilder => {
        updates["rotation"] = spec;
        delete childBuilders["rotation;"];
        modifiedKeys["rotation"] = true;
        return this;
    }

    this.letterSpacing = (spec: string): ITextFormattingBuilder => {
        updates["letterSpacing"] = spec;
        delete childBuilders["letterSpacing;"];
        modifiedKeys["letterSpacing"] = true;
        return this;
    }

    this.lineHeight = (spec: string): ITextFormattingBuilder => {
        updates["lineHeight"] = spec;
        delete childBuilders["lineHeight;"];
        modifiedKeys["lineHeight"] = true;
        return this;
    }

    this.dir = (spec: DirectionMode): ITextFormattingBuilder => {
        updates["dir"] = spec;
        delete childBuilders["dir;"];
        modifiedKeys["dir"] = true;
        return this;
    }

    this.enclosure = (spec: EnclosureShape): ITextFormattingBuilder => {
        updates["enclosure"] = spec;
        delete childBuilders["enclosure;"];
        modifiedKeys["enclosure"] = true;
        return this;
    }
  }
}
export function patchTextFormatting(base: TextFormatting, builder: (build: ITextFormattingBuilder) => ITextFormattingBuilder): IAny[] { return builder(new TextFormattingBuilder(base)).patch(); }
export function buildTextFormatting(builder: (build: ITextFormattingBuilder) => ITextFormattingBuilder): TextFormatting { return builder(new TextFormattingBuilder()).build(); }

export interface ILevelDisplayBuilder {
  build?: () => LevelDisplay;
  patch: () => IAny[];
  bracket: (bracket: boolean) => ILevelDisplayBuilder;
  size: (size: SymbolSize) => ILevelDisplayBuilder;
  parentheses: (parentheses: boolean) => ILevelDisplayBuilder;
}

class LevelDisplayBuilder implements ILevelDisplayBuilder {
  build: () => LevelDisplay;
  patch: () => IAny[];
  bracket: (bracket: boolean) => ILevelDisplayBuilder;
  size: (size: SymbolSize) => ILevelDisplayBuilder;
  parentheses: (parentheses: boolean) => ILevelDisplayBuilder;
  constructor(original?: LevelDisplay) {
    let updates: LevelDisplay = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): LevelDisplay => {
        checkInvariants();
        (updates as any)._class = "LevelDisplay";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.bracket = (spec: boolean): ILevelDisplayBuilder => {
        updates["bracket"] = spec;
        delete childBuilders["bracket;"];
        modifiedKeys["bracket"] = true;
        return this;
    }

    this.size = (spec: SymbolSize): ILevelDisplayBuilder => {
        updates["size"] = spec;
        delete childBuilders["size;"];
        modifiedKeys["size"] = true;
        return this;
    }

    this.parentheses = (spec: boolean): ILevelDisplayBuilder => {
        updates["parentheses"] = spec;
        delete childBuilders["parentheses;"];
        modifiedKeys["parentheses"] = true;
        return this;
    }
  }
}
export function patchLevelDisplay(base: LevelDisplay, builder: (build: ILevelDisplayBuilder) => ILevelDisplayBuilder): IAny[] { return builder(new LevelDisplayBuilder(base)).patch(); }
export function buildLevelDisplay(builder: (build: ILevelDisplayBuilder) => ILevelDisplayBuilder): LevelDisplay { return builder(new LevelDisplayBuilder()).build(); }

export interface ITrillSoundBuilder {
  build?: () => TrillSound;
  patch: () => IAny[];
  startNote: (startNote: UpperMainBelow) => ITrillSoundBuilder;
  accelerate: (accelerate: boolean) => ITrillSoundBuilder;
  beats: (beats: number) => ITrillSoundBuilder;
  lastBeat: (lastBeat: number) => ITrillSoundBuilder;
  trillStep: (trillStep: WholeHalfUnison) => ITrillSoundBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => ITrillSoundBuilder;
  secondBeat: (secondBeat: number) => ITrillSoundBuilder;
}

class TrillSoundBuilder implements ITrillSoundBuilder {
  build: () => TrillSound;
  patch: () => IAny[];
  startNote: (startNote: UpperMainBelow) => ITrillSoundBuilder;
  accelerate: (accelerate: boolean) => ITrillSoundBuilder;
  beats: (beats: number) => ITrillSoundBuilder;
  lastBeat: (lastBeat: number) => ITrillSoundBuilder;
  trillStep: (trillStep: WholeHalfUnison) => ITrillSoundBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => ITrillSoundBuilder;
  secondBeat: (secondBeat: number) => ITrillSoundBuilder;
  constructor(original?: TrillSound) {
    let updates: TrillSound = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): TrillSound => {
        checkInvariants();
        (updates as any)._class = "TrillSound";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.startNote = (spec: UpperMainBelow): ITrillSoundBuilder => {
        updates["startNote"] = spec;
        delete childBuilders["startNote;"];
        modifiedKeys["startNote"] = true;
        return this;
    }

    this.accelerate = (spec: boolean): ITrillSoundBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): ITrillSoundBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.lastBeat = (spec: number): ITrillSoundBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }

    this.trillStep = (spec: WholeHalfUnison): ITrillSoundBuilder => {
        updates["trillStep"] = spec;
        delete childBuilders["trillStep;"];
        modifiedKeys["trillStep"] = true;
        return this;
    }

    this.twoNoteTurn = (spec: WholeHalfNone): ITrillSoundBuilder => {
        updates["twoNoteTurn"] = spec;
        delete childBuilders["twoNoteTurn;"];
        modifiedKeys["twoNoteTurn"] = true;
        return this;
    }

    this.secondBeat = (spec: number): ITrillSoundBuilder => {
        updates["secondBeat"] = spec;
        delete childBuilders["secondBeat;"];
        modifiedKeys["secondBeat"] = true;
        return this;
    }
  }
}
export function patchTrillSound(base: TrillSound, builder: (build: ITrillSoundBuilder) => ITrillSoundBuilder): IAny[] { return builder(new TrillSoundBuilder(base)).patch(); }
export function buildTrillSound(builder: (build: ITrillSoundBuilder) => ITrillSoundBuilder): TrillSound { return builder(new TrillSoundBuilder()).build(); }

export interface IBendSoundBuilder {
  build?: () => BendSound;
  patch: () => IAny[];
  accelerate: (accelerate: boolean) => IBendSoundBuilder;
  beats: (beats: number) => IBendSoundBuilder;
  firstBeat: (firstBeat: number) => IBendSoundBuilder;
  lastBeat: (lastBeat: number) => IBendSoundBuilder;
}

class BendSoundBuilder implements IBendSoundBuilder {
  build: () => BendSound;
  patch: () => IAny[];
  accelerate: (accelerate: boolean) => IBendSoundBuilder;
  beats: (beats: number) => IBendSoundBuilder;
  firstBeat: (firstBeat: number) => IBendSoundBuilder;
  lastBeat: (lastBeat: number) => IBendSoundBuilder;
  constructor(original?: BendSound) {
    let updates: BendSound = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): BendSound => {
        checkInvariants();
        (updates as any)._class = "BendSound";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.accelerate = (spec: boolean): IBendSoundBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): IBendSoundBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.firstBeat = (spec: number): IBendSoundBuilder => {
        updates["firstBeat"] = spec;
        delete childBuilders["firstBeat;"];
        modifiedKeys["firstBeat"] = true;
        return this;
    }

    this.lastBeat = (spec: number): IBendSoundBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }
  }
}
export function patchBendSound(base: BendSound, builder: (build: IBendSoundBuilder) => IBendSoundBuilder): IAny[] { return builder(new BendSoundBuilder(base)).patch(); }
export function buildBendSound(builder: (build: IBendSoundBuilder) => IBendSoundBuilder): BendSound { return builder(new BendSoundBuilder()).build(); }

export interface ITimeOnlyBuilder {
  build?: () => TimeOnly;
  patch: () => IAny[];
  timeOnly: (timeOnly: string) => ITimeOnlyBuilder;
}

class TimeOnlyBuilder implements ITimeOnlyBuilder {
  build: () => TimeOnly;
  patch: () => IAny[];
  timeOnly: (timeOnly: string) => ITimeOnlyBuilder;
  constructor(original?: TimeOnly) {
    let updates: TimeOnly = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): TimeOnly => {
        checkInvariants();
        (updates as any)._class = "TimeOnly";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.timeOnly = (spec: string): ITimeOnlyBuilder => {
        updates["timeOnly"] = spec;
        delete childBuilders["timeOnly;"];
        modifiedKeys["timeOnly"] = true;
        return this;
    }
  }
}
export function patchTimeOnly(base: TimeOnly, builder: (build: ITimeOnlyBuilder) => ITimeOnlyBuilder): IAny[] { return builder(new TimeOnlyBuilder(base)).patch(); }
export function buildTimeOnly(builder: (build: ITimeOnlyBuilder) => ITimeOnlyBuilder): TimeOnly { return builder(new TimeOnlyBuilder()).build(); }

export interface IDocumentAttributesBuilder {
  build?: () => DocumentAttributes;
  patch: () => IAny[];
  version: (version: string) => IDocumentAttributesBuilder;
}

class DocumentAttributesBuilder implements IDocumentAttributesBuilder {
  build: () => DocumentAttributes;
  patch: () => IAny[];
  version: (version: string) => IDocumentAttributesBuilder;
  constructor(original?: DocumentAttributes) {
    let updates: DocumentAttributes = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["version"]) ||
          childBuilders["version"] !== undefined ||
          updates.version !== undefined,
        "version is a required field");
    }

    if (!original) {
      this.build = (): DocumentAttributes => {
        checkInvariants();
        (updates as any)._class = "DocumentAttributes";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.version = (spec: string): IDocumentAttributesBuilder => {
        updates["version"] = spec;
        delete childBuilders["version;"];
        modifiedKeys["version"] = true;
        return this;
    }
  }
}
export function patchDocumentAttributes(base: DocumentAttributes, builder: (build: IDocumentAttributesBuilder) => IDocumentAttributesBuilder): IAny[] { return builder(new DocumentAttributesBuilder(base)).patch(); }
export function buildDocumentAttributes(builder: (build: IDocumentAttributesBuilder) => IDocumentAttributesBuilder): DocumentAttributes { return builder(new DocumentAttributesBuilder()).build(); }

export interface IEditorialBuilder {
  build?: () => Editorial;
  patch: () => IAny[];
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IEditorialBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IEditorialBuilder;
}

class EditorialBuilder implements IEditorialBuilder {
  build: () => Editorial;
  patch: () => IAny[];
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IEditorialBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IEditorialBuilder;
  constructor(original?: Editorial) {
    let updates: Editorial = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Editorial => {
        checkInvariants();
        (updates as any)._class = "Editorial";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.footnote = (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)): IEditorialBuilder => {
      if (typeof build === 'function') {
        delete updates["footnote"]
        const builder = (build as any)(new FootnoteBuilder(original && original["footnote"]));
        if (!original) updates["footnote"] = builder.build();
        else childBuilders["footnote"] = builder;
      } else {
        updates.footnote = build as any;
        delete childBuilders["footnote;"];
      }
      modifiedKeys["footnote"] = true;
      return this;
    }

    this.level = (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)): IEditorialBuilder => {
      if (typeof build === 'function') {
        delete updates["level"]
        const builder = (build as any)(new LevelBuilder(original && original["level"]));
        if (!original) updates["level"] = builder.build();
        else childBuilders["level"] = builder;
      } else {
        updates.level = build as any;
        delete childBuilders["level;"];
      }
      modifiedKeys["level"] = true;
      return this;
    }
  }
}
export function patchEditorial(base: Editorial, builder: (build: IEditorialBuilder) => IEditorialBuilder): IAny[] { return builder(new EditorialBuilder(base)).patch(); }
export function buildEditorial(builder: (build: IEditorialBuilder) => IEditorialBuilder): Editorial { return builder(new EditorialBuilder()).build(); }

export interface IEditorialVoiceBuilder {
  build?: () => EditorialVoice;
  patch: () => IAny[];
  voice: (voice: number) => IEditorialVoiceBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IEditorialVoiceBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IEditorialVoiceBuilder;
}

class EditorialVoiceBuilder implements IEditorialVoiceBuilder {
  build: () => EditorialVoice;
  patch: () => IAny[];
  voice: (voice: number) => IEditorialVoiceBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IEditorialVoiceBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IEditorialVoiceBuilder;
  constructor(original?: EditorialVoice) {
    let updates: EditorialVoice = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): EditorialVoice => {
        checkInvariants();
        (updates as any)._class = "EditorialVoice";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.voice = (spec: number): IEditorialVoiceBuilder => {
        updates["voice"] = spec;
        delete childBuilders["voice;"];
        modifiedKeys["voice"] = true;
        return this;
    }

    this.footnote = (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)): IEditorialVoiceBuilder => {
      if (typeof build === 'function') {
        delete updates["footnote"]
        const builder = (build as any)(new FootnoteBuilder(original && original["footnote"]));
        if (!original) updates["footnote"] = builder.build();
        else childBuilders["footnote"] = builder;
      } else {
        updates.footnote = build as any;
        delete childBuilders["footnote;"];
      }
      modifiedKeys["footnote"] = true;
      return this;
    }

    this.level = (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)): IEditorialVoiceBuilder => {
      if (typeof build === 'function') {
        delete updates["level"]
        const builder = (build as any)(new LevelBuilder(original && original["level"]));
        if (!original) updates["level"] = builder.build();
        else childBuilders["level"] = builder;
      } else {
        updates.level = build as any;
        delete childBuilders["level;"];
      }
      modifiedKeys["level"] = true;
      return this;
    }
  }
}
export function patchEditorialVoice(base: EditorialVoice, builder: (build: IEditorialVoiceBuilder) => IEditorialVoiceBuilder): IAny[] { return builder(new EditorialVoiceBuilder(base)).patch(); }
export function buildEditorialVoice(builder: (build: IEditorialVoiceBuilder) => IEditorialVoiceBuilder): EditorialVoice { return builder(new EditorialVoiceBuilder()).build(); }

export interface IFootnoteBuilder {
  build?: () => Footnote;
  patch: () => IAny[];
  text: (text: string) => IFootnoteBuilder;
  justify: (justify: LeftCenterRight) => IFootnoteBuilder;
  defaultX: (defaultX: number) => IFootnoteBuilder;
  relativeY: (relativeY: number) => IFootnoteBuilder;
  defaultY: (defaultY: number) => IFootnoteBuilder;
  relativeX: (relativeX: number) => IFootnoteBuilder;
  fontFamily: (fontFamily: string) => IFootnoteBuilder;
  fontWeight: (fontWeight: NormalBold) => IFootnoteBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFootnoteBuilder;
  fontSize: (fontSize: string) => IFootnoteBuilder;
  color: (color: string) => IFootnoteBuilder;
  halign: (halign: LeftCenterRight) => IFootnoteBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IFootnoteBuilder;
  underline: (underline: number) => IFootnoteBuilder;
  overline: (overline: number) => IFootnoteBuilder;
  lineThrough: (lineThrough: number) => IFootnoteBuilder;
  rotation: (rotation: number) => IFootnoteBuilder;
  letterSpacing: (letterSpacing: string) => IFootnoteBuilder;
  lineHeight: (lineHeight: string) => IFootnoteBuilder;
  dir: (dir: DirectionMode) => IFootnoteBuilder;
  enclosure: (enclosure: EnclosureShape) => IFootnoteBuilder;
}

class FootnoteBuilder implements IFootnoteBuilder {
  build: () => Footnote;
  patch: () => IAny[];
  text: (text: string) => IFootnoteBuilder;
  justify: (justify: LeftCenterRight) => IFootnoteBuilder;
  defaultX: (defaultX: number) => IFootnoteBuilder;
  relativeY: (relativeY: number) => IFootnoteBuilder;
  defaultY: (defaultY: number) => IFootnoteBuilder;
  relativeX: (relativeX: number) => IFootnoteBuilder;
  fontFamily: (fontFamily: string) => IFootnoteBuilder;
  fontWeight: (fontWeight: NormalBold) => IFootnoteBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFootnoteBuilder;
  fontSize: (fontSize: string) => IFootnoteBuilder;
  color: (color: string) => IFootnoteBuilder;
  halign: (halign: LeftCenterRight) => IFootnoteBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IFootnoteBuilder;
  underline: (underline: number) => IFootnoteBuilder;
  overline: (overline: number) => IFootnoteBuilder;
  lineThrough: (lineThrough: number) => IFootnoteBuilder;
  rotation: (rotation: number) => IFootnoteBuilder;
  letterSpacing: (letterSpacing: string) => IFootnoteBuilder;
  lineHeight: (lineHeight: string) => IFootnoteBuilder;
  dir: (dir: DirectionMode) => IFootnoteBuilder;
  enclosure: (enclosure: EnclosureShape) => IFootnoteBuilder;
  constructor(original?: Footnote) {
    let updates: Footnote = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["text"]) ||
          childBuilders["text"] !== undefined ||
          updates.text !== undefined,
        "text is a required field");
    }

    if (!original) {
      this.build = (): Footnote => {
        checkInvariants();
        (updates as any)._class = "Footnote";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.text = (spec: string): IFootnoteBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.justify = (spec: LeftCenterRight): IFootnoteBuilder => {
        updates["justify"] = spec;
        delete childBuilders["justify;"];
        modifiedKeys["justify"] = true;
        return this;
    }

    this.defaultX = (spec: number): IFootnoteBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IFootnoteBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IFootnoteBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IFootnoteBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IFootnoteBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IFootnoteBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IFootnoteBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IFootnoteBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IFootnoteBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IFootnoteBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IFootnoteBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }

    this.underline = (spec: number): IFootnoteBuilder => {
        updates["underline"] = spec;
        delete childBuilders["underline;"];
        modifiedKeys["underline"] = true;
        return this;
    }

    this.overline = (spec: number): IFootnoteBuilder => {
        updates["overline"] = spec;
        delete childBuilders["overline;"];
        modifiedKeys["overline"] = true;
        return this;
    }

    this.lineThrough = (spec: number): IFootnoteBuilder => {
        updates["lineThrough"] = spec;
        delete childBuilders["lineThrough;"];
        modifiedKeys["lineThrough"] = true;
        return this;
    }

    this.rotation = (spec: number): IFootnoteBuilder => {
        updates["rotation"] = spec;
        delete childBuilders["rotation;"];
        modifiedKeys["rotation"] = true;
        return this;
    }

    this.letterSpacing = (spec: string): IFootnoteBuilder => {
        updates["letterSpacing"] = spec;
        delete childBuilders["letterSpacing;"];
        modifiedKeys["letterSpacing"] = true;
        return this;
    }

    this.lineHeight = (spec: string): IFootnoteBuilder => {
        updates["lineHeight"] = spec;
        delete childBuilders["lineHeight;"];
        modifiedKeys["lineHeight"] = true;
        return this;
    }

    this.dir = (spec: DirectionMode): IFootnoteBuilder => {
        updates["dir"] = spec;
        delete childBuilders["dir;"];
        modifiedKeys["dir"] = true;
        return this;
    }

    this.enclosure = (spec: EnclosureShape): IFootnoteBuilder => {
        updates["enclosure"] = spec;
        delete childBuilders["enclosure;"];
        modifiedKeys["enclosure"] = true;
        return this;
    }
  }
}
export function patchFootnote(base: Footnote, builder: (build: IFootnoteBuilder) => IFootnoteBuilder): IAny[] { return builder(new FootnoteBuilder(base)).patch(); }
export function buildFootnote(builder: (build: IFootnoteBuilder) => IFootnoteBuilder): Footnote { return builder(new FootnoteBuilder()).build(); }

export interface ILevelBuilder {
  build?: () => Level;
  patch: () => IAny[];
  text: (text: string) => ILevelBuilder;
  reference: (reference: boolean) => ILevelBuilder;
  bracket: (bracket: boolean) => ILevelBuilder;
  size: (size: SymbolSize) => ILevelBuilder;
  parentheses: (parentheses: boolean) => ILevelBuilder;
}

class LevelBuilder implements ILevelBuilder {
  build: () => Level;
  patch: () => IAny[];
  text: (text: string) => ILevelBuilder;
  reference: (reference: boolean) => ILevelBuilder;
  bracket: (bracket: boolean) => ILevelBuilder;
  size: (size: SymbolSize) => ILevelBuilder;
  parentheses: (parentheses: boolean) => ILevelBuilder;
  constructor(original?: Level) {
    let updates: Level = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["text"]) ||
          childBuilders["text"] !== undefined ||
          updates.text !== undefined,
        "text is a required field");
    }

    if (!original) {
      this.build = (): Level => {
        checkInvariants();
        (updates as any)._class = "Level";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.text = (spec: string): ILevelBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.reference = (spec: boolean): ILevelBuilder => {
        updates["reference"] = spec;
        delete childBuilders["reference;"];
        modifiedKeys["reference"] = true;
        return this;
    }

    this.bracket = (spec: boolean): ILevelBuilder => {
        updates["bracket"] = spec;
        delete childBuilders["bracket;"];
        modifiedKeys["bracket"] = true;
        return this;
    }

    this.size = (spec: SymbolSize): ILevelBuilder => {
        updates["size"] = spec;
        delete childBuilders["size;"];
        modifiedKeys["size"] = true;
        return this;
    }

    this.parentheses = (spec: boolean): ILevelBuilder => {
        updates["parentheses"] = spec;
        delete childBuilders["parentheses;"];
        modifiedKeys["parentheses"] = true;
        return this;
    }
  }
}
export function patchLevel(base: Level, builder: (build: ILevelBuilder) => ILevelBuilder): IAny[] { return builder(new LevelBuilder(base)).patch(); }
export function buildLevel(builder: (build: ILevelBuilder) => ILevelBuilder): Level { return builder(new LevelBuilder()).build(); }

export interface IFermataBuilder {
  build?: () => Fermata;
  patch: () => IAny[];
  shape: (shape: NormalAngledSquare) => IFermataBuilder;
  type: (type: UprightInverted) => IFermataBuilder;
  defaultX: (defaultX: number) => IFermataBuilder;
  relativeY: (relativeY: number) => IFermataBuilder;
  defaultY: (defaultY: number) => IFermataBuilder;
  relativeX: (relativeX: number) => IFermataBuilder;
  fontFamily: (fontFamily: string) => IFermataBuilder;
  fontWeight: (fontWeight: NormalBold) => IFermataBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFermataBuilder;
  fontSize: (fontSize: string) => IFermataBuilder;
  color: (color: string) => IFermataBuilder;
}

class FermataBuilder implements IFermataBuilder {
  build: () => Fermata;
  patch: () => IAny[];
  shape: (shape: NormalAngledSquare) => IFermataBuilder;
  type: (type: UprightInverted) => IFermataBuilder;
  defaultX: (defaultX: number) => IFermataBuilder;
  relativeY: (relativeY: number) => IFermataBuilder;
  defaultY: (defaultY: number) => IFermataBuilder;
  relativeX: (relativeX: number) => IFermataBuilder;
  fontFamily: (fontFamily: string) => IFermataBuilder;
  fontWeight: (fontWeight: NormalBold) => IFermataBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFermataBuilder;
  fontSize: (fontSize: string) => IFermataBuilder;
  color: (color: string) => IFermataBuilder;
  constructor(original?: Fermata) {
    let updates: Fermata = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["shape"]) ||
          childBuilders["shape"] !== undefined ||
          updates.shape !== undefined,
        "shape is a required field");
    }

    if (!original) {
      this.build = (): Fermata => {
        checkInvariants();
        (updates as any)._class = "Fermata";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.shape = (spec: NormalAngledSquare): IFermataBuilder => {
        updates["shape"] = spec;
        delete childBuilders["shape;"];
        modifiedKeys["shape"] = true;
        return this;
    }

    this.type = (spec: UprightInverted): IFermataBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): IFermataBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IFermataBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IFermataBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IFermataBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IFermataBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IFermataBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IFermataBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IFermataBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IFermataBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchFermata(base: Fermata, builder: (build: IFermataBuilder) => IFermataBuilder): IAny[] { return builder(new FermataBuilder(base)).patch(); }
export function buildFermata(builder: (build: IFermataBuilder) => IFermataBuilder): Fermata { return builder(new FermataBuilder()).build(); }

export interface IWavyLineBuilder {
  build?: () => WavyLine;
  patch: () => IAny[];
  number: (number: number) => IWavyLineBuilder;
  type: (type: StartStopContinue) => IWavyLineBuilder;
  defaultX: (defaultX: number) => IWavyLineBuilder;
  relativeY: (relativeY: number) => IWavyLineBuilder;
  defaultY: (defaultY: number) => IWavyLineBuilder;
  relativeX: (relativeX: number) => IWavyLineBuilder;
  color: (color: string) => IWavyLineBuilder;
  placement: (placement: AboveBelow) => IWavyLineBuilder;
  startNote: (startNote: UpperMainBelow) => IWavyLineBuilder;
  accelerate: (accelerate: boolean) => IWavyLineBuilder;
  beats: (beats: number) => IWavyLineBuilder;
  lastBeat: (lastBeat: number) => IWavyLineBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IWavyLineBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IWavyLineBuilder;
  secondBeat: (secondBeat: number) => IWavyLineBuilder;
}

class WavyLineBuilder implements IWavyLineBuilder {
  build: () => WavyLine;
  patch: () => IAny[];
  number: (number: number) => IWavyLineBuilder;
  type: (type: StartStopContinue) => IWavyLineBuilder;
  defaultX: (defaultX: number) => IWavyLineBuilder;
  relativeY: (relativeY: number) => IWavyLineBuilder;
  defaultY: (defaultY: number) => IWavyLineBuilder;
  relativeX: (relativeX: number) => IWavyLineBuilder;
  color: (color: string) => IWavyLineBuilder;
  placement: (placement: AboveBelow) => IWavyLineBuilder;
  startNote: (startNote: UpperMainBelow) => IWavyLineBuilder;
  accelerate: (accelerate: boolean) => IWavyLineBuilder;
  beats: (beats: number) => IWavyLineBuilder;
  lastBeat: (lastBeat: number) => IWavyLineBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IWavyLineBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IWavyLineBuilder;
  secondBeat: (secondBeat: number) => IWavyLineBuilder;
  constructor(original?: WavyLine) {
    let updates: WavyLine = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): WavyLine => {
        checkInvariants();
        (updates as any)._class = "WavyLine";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: number): IWavyLineBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.type = (spec: StartStopContinue): IWavyLineBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): IWavyLineBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IWavyLineBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IWavyLineBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IWavyLineBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.color = (spec: string): IWavyLineBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IWavyLineBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.startNote = (spec: UpperMainBelow): IWavyLineBuilder => {
        updates["startNote"] = spec;
        delete childBuilders["startNote;"];
        modifiedKeys["startNote"] = true;
        return this;
    }

    this.accelerate = (spec: boolean): IWavyLineBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): IWavyLineBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.lastBeat = (spec: number): IWavyLineBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }

    this.trillStep = (spec: WholeHalfUnison): IWavyLineBuilder => {
        updates["trillStep"] = spec;
        delete childBuilders["trillStep;"];
        modifiedKeys["trillStep"] = true;
        return this;
    }

    this.twoNoteTurn = (spec: WholeHalfNone): IWavyLineBuilder => {
        updates["twoNoteTurn"] = spec;
        delete childBuilders["twoNoteTurn;"];
        modifiedKeys["twoNoteTurn"] = true;
        return this;
    }

    this.secondBeat = (spec: number): IWavyLineBuilder => {
        updates["secondBeat"] = spec;
        delete childBuilders["secondBeat;"];
        modifiedKeys["secondBeat"] = true;
        return this;
    }
  }
}
export function patchWavyLine(base: WavyLine, builder: (build: IWavyLineBuilder) => IWavyLineBuilder): IAny[] { return builder(new WavyLineBuilder(base)).patch(); }
export function buildWavyLine(builder: (build: IWavyLineBuilder) => IWavyLineBuilder): WavyLine { return builder(new WavyLineBuilder()).build(); }

export interface ISegnoBuilder {
  build?: () => Segno;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ISegnoBuilder;
  relativeY: (relativeY: number) => ISegnoBuilder;
  defaultY: (defaultY: number) => ISegnoBuilder;
  relativeX: (relativeX: number) => ISegnoBuilder;
  fontFamily: (fontFamily: string) => ISegnoBuilder;
  fontWeight: (fontWeight: NormalBold) => ISegnoBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISegnoBuilder;
  fontSize: (fontSize: string) => ISegnoBuilder;
  color: (color: string) => ISegnoBuilder;
  halign: (halign: LeftCenterRight) => ISegnoBuilder;
  valign: (valign: TopMiddleBottomBaseline) => ISegnoBuilder;
}

class SegnoBuilder implements ISegnoBuilder {
  build: () => Segno;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ISegnoBuilder;
  relativeY: (relativeY: number) => ISegnoBuilder;
  defaultY: (defaultY: number) => ISegnoBuilder;
  relativeX: (relativeX: number) => ISegnoBuilder;
  fontFamily: (fontFamily: string) => ISegnoBuilder;
  fontWeight: (fontWeight: NormalBold) => ISegnoBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISegnoBuilder;
  fontSize: (fontSize: string) => ISegnoBuilder;
  color: (color: string) => ISegnoBuilder;
  halign: (halign: LeftCenterRight) => ISegnoBuilder;
  valign: (valign: TopMiddleBottomBaseline) => ISegnoBuilder;
  constructor(original?: Segno) {
    let updates: Segno = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Segno => {
        checkInvariants();
        (updates as any)._class = "Segno";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): ISegnoBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ISegnoBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ISegnoBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ISegnoBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ISegnoBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ISegnoBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ISegnoBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ISegnoBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ISegnoBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): ISegnoBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): ISegnoBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchSegno(base: Segno, builder: (build: ISegnoBuilder) => ISegnoBuilder): IAny[] { return builder(new SegnoBuilder(base)).patch(); }
export function buildSegno(builder: (build: ISegnoBuilder) => ISegnoBuilder): Segno { return builder(new SegnoBuilder()).build(); }

export interface ICodaBuilder {
  build?: () => Coda;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ICodaBuilder;
  relativeY: (relativeY: number) => ICodaBuilder;
  defaultY: (defaultY: number) => ICodaBuilder;
  relativeX: (relativeX: number) => ICodaBuilder;
  fontFamily: (fontFamily: string) => ICodaBuilder;
  fontWeight: (fontWeight: NormalBold) => ICodaBuilder;
  fontStyle: (fontStyle: NormalItalic) => ICodaBuilder;
  fontSize: (fontSize: string) => ICodaBuilder;
  color: (color: string) => ICodaBuilder;
  halign: (halign: LeftCenterRight) => ICodaBuilder;
  valign: (valign: TopMiddleBottomBaseline) => ICodaBuilder;
}

class CodaBuilder implements ICodaBuilder {
  build: () => Coda;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ICodaBuilder;
  relativeY: (relativeY: number) => ICodaBuilder;
  defaultY: (defaultY: number) => ICodaBuilder;
  relativeX: (relativeX: number) => ICodaBuilder;
  fontFamily: (fontFamily: string) => ICodaBuilder;
  fontWeight: (fontWeight: NormalBold) => ICodaBuilder;
  fontStyle: (fontStyle: NormalItalic) => ICodaBuilder;
  fontSize: (fontSize: string) => ICodaBuilder;
  color: (color: string) => ICodaBuilder;
  halign: (halign: LeftCenterRight) => ICodaBuilder;
  valign: (valign: TopMiddleBottomBaseline) => ICodaBuilder;
  constructor(original?: Coda) {
    let updates: Coda = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Coda => {
        checkInvariants();
        (updates as any)._class = "Coda";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): ICodaBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ICodaBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ICodaBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ICodaBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ICodaBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ICodaBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ICodaBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ICodaBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ICodaBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): ICodaBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): ICodaBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchCoda(base: Coda, builder: (build: ICodaBuilder) => ICodaBuilder): IAny[] { return builder(new CodaBuilder(base)).patch(); }
export function buildCoda(builder: (build: ICodaBuilder) => ICodaBuilder): Coda { return builder(new CodaBuilder()).build(); }

export interface INormalDotBuilder {
  build?: () => NormalDot;
  patch: () => IAny[];
}

class NormalDotBuilder implements INormalDotBuilder {
  build: () => NormalDot;
  patch: () => IAny[];
  constructor(original?: NormalDot) {
    let updates: NormalDot = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): NormalDot => {
        checkInvariants();
        (updates as any)._class = "NormalDot";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchNormalDot(base: NormalDot, builder: (build: INormalDotBuilder) => INormalDotBuilder): IAny[] { return builder(new NormalDotBuilder(base)).patch(); }
export function buildNormalDot(builder: (build: INormalDotBuilder) => INormalDotBuilder): NormalDot { return builder(new NormalDotBuilder()).build(); }

export interface IDynamicsBuilder {
  build?: () => Dynamics;
  patch: () => IAny[];
  f: (f: boolean) => IDynamicsBuilder;
  ff: (ff: boolean) => IDynamicsBuilder;
  fff: (fff: boolean) => IDynamicsBuilder;
  ffff: (ffff: boolean) => IDynamicsBuilder;
  fffff: (fffff: boolean) => IDynamicsBuilder;
  ffffff: (ffffff: boolean) => IDynamicsBuilder;
  fp: (fp: boolean) => IDynamicsBuilder;
  fz: (fz: boolean) => IDynamicsBuilder;
  mf: (mf: boolean) => IDynamicsBuilder;
  mp: (mp: boolean) => IDynamicsBuilder;
  otherDynamics: (otherDynamics: string) => IDynamicsBuilder;
  p: (p: boolean) => IDynamicsBuilder;
  pp: (pp: boolean) => IDynamicsBuilder;
  ppp: (ppp: boolean) => IDynamicsBuilder;
  pppp: (pppp: boolean) => IDynamicsBuilder;
  ppppp: (ppppp: boolean) => IDynamicsBuilder;
  pppppp: (pppppp: boolean) => IDynamicsBuilder;
  rf: (rf: boolean) => IDynamicsBuilder;
  rfz: (rfz: boolean) => IDynamicsBuilder;
  sf: (sf: boolean) => IDynamicsBuilder;
  sffz: (sffz: boolean) => IDynamicsBuilder;
  sfp: (sfp: boolean) => IDynamicsBuilder;
  sfpp: (sfpp: boolean) => IDynamicsBuilder;
  sfz: (sfz: boolean) => IDynamicsBuilder;
  defaultX: (defaultX: number) => IDynamicsBuilder;
  relativeY: (relativeY: number) => IDynamicsBuilder;
  defaultY: (defaultY: number) => IDynamicsBuilder;
  relativeX: (relativeX: number) => IDynamicsBuilder;
  fontFamily: (fontFamily: string) => IDynamicsBuilder;
  fontWeight: (fontWeight: NormalBold) => IDynamicsBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDynamicsBuilder;
  fontSize: (fontSize: string) => IDynamicsBuilder;
  color: (color: string) => IDynamicsBuilder;
  halign: (halign: LeftCenterRight) => IDynamicsBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IDynamicsBuilder;
  underline: (underline: number) => IDynamicsBuilder;
  overline: (overline: number) => IDynamicsBuilder;
  lineThrough: (lineThrough: number) => IDynamicsBuilder;
  enclosure: (enclosure: EnclosureShape) => IDynamicsBuilder;
  placement: (placement: AboveBelow) => IDynamicsBuilder;
}

class DynamicsBuilder implements IDynamicsBuilder {
  build: () => Dynamics;
  patch: () => IAny[];
  f: (f: boolean) => IDynamicsBuilder;
  ff: (ff: boolean) => IDynamicsBuilder;
  fff: (fff: boolean) => IDynamicsBuilder;
  ffff: (ffff: boolean) => IDynamicsBuilder;
  fffff: (fffff: boolean) => IDynamicsBuilder;
  ffffff: (ffffff: boolean) => IDynamicsBuilder;
  fp: (fp: boolean) => IDynamicsBuilder;
  fz: (fz: boolean) => IDynamicsBuilder;
  mf: (mf: boolean) => IDynamicsBuilder;
  mp: (mp: boolean) => IDynamicsBuilder;
  otherDynamics: (otherDynamics: string) => IDynamicsBuilder;
  p: (p: boolean) => IDynamicsBuilder;
  pp: (pp: boolean) => IDynamicsBuilder;
  ppp: (ppp: boolean) => IDynamicsBuilder;
  pppp: (pppp: boolean) => IDynamicsBuilder;
  ppppp: (ppppp: boolean) => IDynamicsBuilder;
  pppppp: (pppppp: boolean) => IDynamicsBuilder;
  rf: (rf: boolean) => IDynamicsBuilder;
  rfz: (rfz: boolean) => IDynamicsBuilder;
  sf: (sf: boolean) => IDynamicsBuilder;
  sffz: (sffz: boolean) => IDynamicsBuilder;
  sfp: (sfp: boolean) => IDynamicsBuilder;
  sfpp: (sfpp: boolean) => IDynamicsBuilder;
  sfz: (sfz: boolean) => IDynamicsBuilder;
  defaultX: (defaultX: number) => IDynamicsBuilder;
  relativeY: (relativeY: number) => IDynamicsBuilder;
  defaultY: (defaultY: number) => IDynamicsBuilder;
  relativeX: (relativeX: number) => IDynamicsBuilder;
  fontFamily: (fontFamily: string) => IDynamicsBuilder;
  fontWeight: (fontWeight: NormalBold) => IDynamicsBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDynamicsBuilder;
  fontSize: (fontSize: string) => IDynamicsBuilder;
  color: (color: string) => IDynamicsBuilder;
  halign: (halign: LeftCenterRight) => IDynamicsBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IDynamicsBuilder;
  underline: (underline: number) => IDynamicsBuilder;
  overline: (overline: number) => IDynamicsBuilder;
  lineThrough: (lineThrough: number) => IDynamicsBuilder;
  enclosure: (enclosure: EnclosureShape) => IDynamicsBuilder;
  placement: (placement: AboveBelow) => IDynamicsBuilder;
  constructor(original?: Dynamics) {
    let updates: Dynamics = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Dynamics => {
        checkInvariants();
        (updates as any)._class = "Dynamics";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.f = (spec: boolean): IDynamicsBuilder => {
        updates["f"] = spec;
        delete childBuilders["f;"];
        modifiedKeys["f"] = true;
        return this;
    }

    this.ff = (spec: boolean): IDynamicsBuilder => {
        updates["ff"] = spec;
        delete childBuilders["ff;"];
        modifiedKeys["ff"] = true;
        return this;
    }

    this.fff = (spec: boolean): IDynamicsBuilder => {
        updates["fff"] = spec;
        delete childBuilders["fff;"];
        modifiedKeys["fff"] = true;
        return this;
    }

    this.ffff = (spec: boolean): IDynamicsBuilder => {
        updates["ffff"] = spec;
        delete childBuilders["ffff;"];
        modifiedKeys["ffff"] = true;
        return this;
    }

    this.fffff = (spec: boolean): IDynamicsBuilder => {
        updates["fffff"] = spec;
        delete childBuilders["fffff;"];
        modifiedKeys["fffff"] = true;
        return this;
    }

    this.ffffff = (spec: boolean): IDynamicsBuilder => {
        updates["ffffff"] = spec;
        delete childBuilders["ffffff;"];
        modifiedKeys["ffffff"] = true;
        return this;
    }

    this.fp = (spec: boolean): IDynamicsBuilder => {
        updates["fp"] = spec;
        delete childBuilders["fp;"];
        modifiedKeys["fp"] = true;
        return this;
    }

    this.fz = (spec: boolean): IDynamicsBuilder => {
        updates["fz"] = spec;
        delete childBuilders["fz;"];
        modifiedKeys["fz"] = true;
        return this;
    }

    this.mf = (spec: boolean): IDynamicsBuilder => {
        updates["mf"] = spec;
        delete childBuilders["mf;"];
        modifiedKeys["mf"] = true;
        return this;
    }

    this.mp = (spec: boolean): IDynamicsBuilder => {
        updates["mp"] = spec;
        delete childBuilders["mp;"];
        modifiedKeys["mp"] = true;
        return this;
    }

    this.otherDynamics = (spec: string): IDynamicsBuilder => {
        updates["otherDynamics"] = spec;
        delete childBuilders["otherDynamics;"];
        modifiedKeys["otherDynamics"] = true;
        return this;
    }

    this.p = (spec: boolean): IDynamicsBuilder => {
        updates["p"] = spec;
        delete childBuilders["p;"];
        modifiedKeys["p"] = true;
        return this;
    }

    this.pp = (spec: boolean): IDynamicsBuilder => {
        updates["pp"] = spec;
        delete childBuilders["pp;"];
        modifiedKeys["pp"] = true;
        return this;
    }

    this.ppp = (spec: boolean): IDynamicsBuilder => {
        updates["ppp"] = spec;
        delete childBuilders["ppp;"];
        modifiedKeys["ppp"] = true;
        return this;
    }

    this.pppp = (spec: boolean): IDynamicsBuilder => {
        updates["pppp"] = spec;
        delete childBuilders["pppp;"];
        modifiedKeys["pppp"] = true;
        return this;
    }

    this.ppppp = (spec: boolean): IDynamicsBuilder => {
        updates["ppppp"] = spec;
        delete childBuilders["ppppp;"];
        modifiedKeys["ppppp"] = true;
        return this;
    }

    this.pppppp = (spec: boolean): IDynamicsBuilder => {
        updates["pppppp"] = spec;
        delete childBuilders["pppppp;"];
        modifiedKeys["pppppp"] = true;
        return this;
    }

    this.rf = (spec: boolean): IDynamicsBuilder => {
        updates["rf"] = spec;
        delete childBuilders["rf;"];
        modifiedKeys["rf"] = true;
        return this;
    }

    this.rfz = (spec: boolean): IDynamicsBuilder => {
        updates["rfz"] = spec;
        delete childBuilders["rfz;"];
        modifiedKeys["rfz"] = true;
        return this;
    }

    this.sf = (spec: boolean): IDynamicsBuilder => {
        updates["sf"] = spec;
        delete childBuilders["sf;"];
        modifiedKeys["sf"] = true;
        return this;
    }

    this.sffz = (spec: boolean): IDynamicsBuilder => {
        updates["sffz"] = spec;
        delete childBuilders["sffz;"];
        modifiedKeys["sffz"] = true;
        return this;
    }

    this.sfp = (spec: boolean): IDynamicsBuilder => {
        updates["sfp"] = spec;
        delete childBuilders["sfp;"];
        modifiedKeys["sfp"] = true;
        return this;
    }

    this.sfpp = (spec: boolean): IDynamicsBuilder => {
        updates["sfpp"] = spec;
        delete childBuilders["sfpp;"];
        modifiedKeys["sfpp"] = true;
        return this;
    }

    this.sfz = (spec: boolean): IDynamicsBuilder => {
        updates["sfz"] = spec;
        delete childBuilders["sfz;"];
        modifiedKeys["sfz"] = true;
        return this;
    }

    this.defaultX = (spec: number): IDynamicsBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDynamicsBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDynamicsBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDynamicsBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDynamicsBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDynamicsBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDynamicsBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDynamicsBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDynamicsBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IDynamicsBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IDynamicsBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }

    this.underline = (spec: number): IDynamicsBuilder => {
        updates["underline"] = spec;
        delete childBuilders["underline;"];
        modifiedKeys["underline"] = true;
        return this;
    }

    this.overline = (spec: number): IDynamicsBuilder => {
        updates["overline"] = spec;
        delete childBuilders["overline;"];
        modifiedKeys["overline"] = true;
        return this;
    }

    this.lineThrough = (spec: number): IDynamicsBuilder => {
        updates["lineThrough"] = spec;
        delete childBuilders["lineThrough;"];
        modifiedKeys["lineThrough"] = true;
        return this;
    }

    this.enclosure = (spec: EnclosureShape): IDynamicsBuilder => {
        updates["enclosure"] = spec;
        delete childBuilders["enclosure;"];
        modifiedKeys["enclosure"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IDynamicsBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchDynamics(base: Dynamics, builder: (build: IDynamicsBuilder) => IDynamicsBuilder): IAny[] { return builder(new DynamicsBuilder(base)).patch(); }
export function buildDynamics(builder: (build: IDynamicsBuilder) => IDynamicsBuilder): Dynamics { return builder(new DynamicsBuilder()).build(); }

export interface IFingeringBuilder {
  build?: () => Fingering;
  patch: () => IAny[];
  substitution: (substitution: boolean) => IFingeringBuilder;
  finger: (finger: number) => IFingeringBuilder;
  alternate: (alternate: boolean) => IFingeringBuilder;
  defaultX: (defaultX: number) => IFingeringBuilder;
  relativeY: (relativeY: number) => IFingeringBuilder;
  defaultY: (defaultY: number) => IFingeringBuilder;
  relativeX: (relativeX: number) => IFingeringBuilder;
  fontFamily: (fontFamily: string) => IFingeringBuilder;
  fontWeight: (fontWeight: NormalBold) => IFingeringBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFingeringBuilder;
  fontSize: (fontSize: string) => IFingeringBuilder;
  color: (color: string) => IFingeringBuilder;
  placement: (placement: AboveBelow) => IFingeringBuilder;
}

class FingeringBuilder implements IFingeringBuilder {
  build: () => Fingering;
  patch: () => IAny[];
  substitution: (substitution: boolean) => IFingeringBuilder;
  finger: (finger: number) => IFingeringBuilder;
  alternate: (alternate: boolean) => IFingeringBuilder;
  defaultX: (defaultX: number) => IFingeringBuilder;
  relativeY: (relativeY: number) => IFingeringBuilder;
  defaultY: (defaultY: number) => IFingeringBuilder;
  relativeX: (relativeX: number) => IFingeringBuilder;
  fontFamily: (fontFamily: string) => IFingeringBuilder;
  fontWeight: (fontWeight: NormalBold) => IFingeringBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFingeringBuilder;
  fontSize: (fontSize: string) => IFingeringBuilder;
  color: (color: string) => IFingeringBuilder;
  placement: (placement: AboveBelow) => IFingeringBuilder;
  constructor(original?: Fingering) {
    let updates: Fingering = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Fingering => {
        checkInvariants();
        (updates as any)._class = "Fingering";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.substitution = (spec: boolean): IFingeringBuilder => {
        updates["substitution"] = spec;
        delete childBuilders["substitution;"];
        modifiedKeys["substitution"] = true;
        return this;
    }

    this.finger = (spec: number): IFingeringBuilder => {
        updates["finger"] = spec;
        delete childBuilders["finger;"];
        modifiedKeys["finger"] = true;
        return this;
    }

    this.alternate = (spec: boolean): IFingeringBuilder => {
        updates["alternate"] = spec;
        delete childBuilders["alternate;"];
        modifiedKeys["alternate"] = true;
        return this;
    }

    this.defaultX = (spec: number): IFingeringBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IFingeringBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IFingeringBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IFingeringBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IFingeringBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IFingeringBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IFingeringBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IFingeringBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IFingeringBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IFingeringBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchFingering(base: Fingering, builder: (build: IFingeringBuilder) => IFingeringBuilder): IAny[] { return builder(new FingeringBuilder(base)).patch(); }
export function buildFingering(builder: (build: IFingeringBuilder) => IFingeringBuilder): Fingering { return builder(new FingeringBuilder()).build(); }

export interface IFretBuilder {
  build?: () => Fret;
  patch: () => IAny[];
  fret: (fret: number) => IFretBuilder;
  fontFamily: (fontFamily: string) => IFretBuilder;
  fontWeight: (fontWeight: NormalBold) => IFretBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFretBuilder;
  fontSize: (fontSize: string) => IFretBuilder;
  color: (color: string) => IFretBuilder;
}

class FretBuilder implements IFretBuilder {
  build: () => Fret;
  patch: () => IAny[];
  fret: (fret: number) => IFretBuilder;
  fontFamily: (fontFamily: string) => IFretBuilder;
  fontWeight: (fontWeight: NormalBold) => IFretBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFretBuilder;
  fontSize: (fontSize: string) => IFretBuilder;
  color: (color: string) => IFretBuilder;
  constructor(original?: Fret) {
    let updates: Fret = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["fret"]) ||
          childBuilders["fret"] !== undefined ||
          updates.fret !== undefined,
        "fret is a required field");
    }

    if (!original) {
      this.build = (): Fret => {
        checkInvariants();
        (updates as any)._class = "Fret";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.fret = (spec: number): IFretBuilder => {
        updates["fret"] = spec;
        delete childBuilders["fret;"];
        modifiedKeys["fret"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IFretBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IFretBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IFretBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IFretBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IFretBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchFret(base: Fret, builder: (build: IFretBuilder) => IFretBuilder): IAny[] { return builder(new FretBuilder(base)).patch(); }
export function buildFret(builder: (build: IFretBuilder) => IFretBuilder): Fret { return builder(new FretBuilder()).build(); }

export interface IStringBuilder {
  build?: () => String;
  patch: () => IAny[];
  stringNum: (stringNum: number) => IStringBuilder;
  defaultX: (defaultX: number) => IStringBuilder;
  relativeY: (relativeY: number) => IStringBuilder;
  defaultY: (defaultY: number) => IStringBuilder;
  relativeX: (relativeX: number) => IStringBuilder;
  fontFamily: (fontFamily: string) => IStringBuilder;
  fontWeight: (fontWeight: NormalBold) => IStringBuilder;
  fontStyle: (fontStyle: NormalItalic) => IStringBuilder;
  fontSize: (fontSize: string) => IStringBuilder;
  color: (color: string) => IStringBuilder;
  placement: (placement: AboveBelow) => IStringBuilder;
}

class StringBuilder implements IStringBuilder {
  build: () => String;
  patch: () => IAny[];
  stringNum: (stringNum: number) => IStringBuilder;
  defaultX: (defaultX: number) => IStringBuilder;
  relativeY: (relativeY: number) => IStringBuilder;
  defaultY: (defaultY: number) => IStringBuilder;
  relativeX: (relativeX: number) => IStringBuilder;
  fontFamily: (fontFamily: string) => IStringBuilder;
  fontWeight: (fontWeight: NormalBold) => IStringBuilder;
  fontStyle: (fontStyle: NormalItalic) => IStringBuilder;
  fontSize: (fontSize: string) => IStringBuilder;
  color: (color: string) => IStringBuilder;
  placement: (placement: AboveBelow) => IStringBuilder;
  constructor(original?: String) {
    let updates: String = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["stringNum"]) ||
          childBuilders["stringNum"] !== undefined ||
          updates.stringNum !== undefined,
        "stringNum is a required field");
    }

    if (!original) {
      this.build = (): String => {
        checkInvariants();
        (updates as any)._class = "String";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.stringNum = (spec: number): IStringBuilder => {
        updates["stringNum"] = spec;
        delete childBuilders["stringNum;"];
        modifiedKeys["stringNum"] = true;
        return this;
    }

    this.defaultX = (spec: number): IStringBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IStringBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IStringBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IStringBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IStringBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IStringBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IStringBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IStringBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IStringBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IStringBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchString(base: String, builder: (build: IStringBuilder) => IStringBuilder): IAny[] { return builder(new StringBuilder(base)).patch(); }
export function buildString(builder: (build: IStringBuilder) => IStringBuilder): String { return builder(new StringBuilder()).build(); }

export interface IDisplayTextBuilder {
  build?: () => DisplayText;
  patch: () => IAny[];
  text: (text: string) => IDisplayTextBuilder;
  justify: (justify: LeftCenterRight) => IDisplayTextBuilder;
  defaultX: (defaultX: number) => IDisplayTextBuilder;
  relativeY: (relativeY: number) => IDisplayTextBuilder;
  defaultY: (defaultY: number) => IDisplayTextBuilder;
  relativeX: (relativeX: number) => IDisplayTextBuilder;
  fontFamily: (fontFamily: string) => IDisplayTextBuilder;
  fontWeight: (fontWeight: NormalBold) => IDisplayTextBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDisplayTextBuilder;
  fontSize: (fontSize: string) => IDisplayTextBuilder;
  color: (color: string) => IDisplayTextBuilder;
  halign: (halign: LeftCenterRight) => IDisplayTextBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IDisplayTextBuilder;
  underline: (underline: number) => IDisplayTextBuilder;
  overline: (overline: number) => IDisplayTextBuilder;
  lineThrough: (lineThrough: number) => IDisplayTextBuilder;
  rotation: (rotation: number) => IDisplayTextBuilder;
  letterSpacing: (letterSpacing: string) => IDisplayTextBuilder;
  lineHeight: (lineHeight: string) => IDisplayTextBuilder;
  dir: (dir: DirectionMode) => IDisplayTextBuilder;
  enclosure: (enclosure: EnclosureShape) => IDisplayTextBuilder;
}

class DisplayTextBuilder implements IDisplayTextBuilder {
  build: () => DisplayText;
  patch: () => IAny[];
  text: (text: string) => IDisplayTextBuilder;
  justify: (justify: LeftCenterRight) => IDisplayTextBuilder;
  defaultX: (defaultX: number) => IDisplayTextBuilder;
  relativeY: (relativeY: number) => IDisplayTextBuilder;
  defaultY: (defaultY: number) => IDisplayTextBuilder;
  relativeX: (relativeX: number) => IDisplayTextBuilder;
  fontFamily: (fontFamily: string) => IDisplayTextBuilder;
  fontWeight: (fontWeight: NormalBold) => IDisplayTextBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDisplayTextBuilder;
  fontSize: (fontSize: string) => IDisplayTextBuilder;
  color: (color: string) => IDisplayTextBuilder;
  halign: (halign: LeftCenterRight) => IDisplayTextBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IDisplayTextBuilder;
  underline: (underline: number) => IDisplayTextBuilder;
  overline: (overline: number) => IDisplayTextBuilder;
  lineThrough: (lineThrough: number) => IDisplayTextBuilder;
  rotation: (rotation: number) => IDisplayTextBuilder;
  letterSpacing: (letterSpacing: string) => IDisplayTextBuilder;
  lineHeight: (lineHeight: string) => IDisplayTextBuilder;
  dir: (dir: DirectionMode) => IDisplayTextBuilder;
  enclosure: (enclosure: EnclosureShape) => IDisplayTextBuilder;
  constructor(original?: DisplayText) {
    let updates: DisplayText = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["text"]) ||
          childBuilders["text"] !== undefined ||
          updates.text !== undefined,
        "text is a required field");
    }

    if (!original) {
      this.build = (): DisplayText => {
        checkInvariants();
        (updates as any)._class = "DisplayText";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.text = (spec: string): IDisplayTextBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.justify = (spec: LeftCenterRight): IDisplayTextBuilder => {
        updates["justify"] = spec;
        delete childBuilders["justify;"];
        modifiedKeys["justify"] = true;
        return this;
    }

    this.defaultX = (spec: number): IDisplayTextBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDisplayTextBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDisplayTextBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDisplayTextBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDisplayTextBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDisplayTextBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDisplayTextBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDisplayTextBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDisplayTextBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IDisplayTextBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IDisplayTextBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }

    this.underline = (spec: number): IDisplayTextBuilder => {
        updates["underline"] = spec;
        delete childBuilders["underline;"];
        modifiedKeys["underline"] = true;
        return this;
    }

    this.overline = (spec: number): IDisplayTextBuilder => {
        updates["overline"] = spec;
        delete childBuilders["overline;"];
        modifiedKeys["overline"] = true;
        return this;
    }

    this.lineThrough = (spec: number): IDisplayTextBuilder => {
        updates["lineThrough"] = spec;
        delete childBuilders["lineThrough;"];
        modifiedKeys["lineThrough"] = true;
        return this;
    }

    this.rotation = (spec: number): IDisplayTextBuilder => {
        updates["rotation"] = spec;
        delete childBuilders["rotation;"];
        modifiedKeys["rotation"] = true;
        return this;
    }

    this.letterSpacing = (spec: string): IDisplayTextBuilder => {
        updates["letterSpacing"] = spec;
        delete childBuilders["letterSpacing;"];
        modifiedKeys["letterSpacing"] = true;
        return this;
    }

    this.lineHeight = (spec: string): IDisplayTextBuilder => {
        updates["lineHeight"] = spec;
        delete childBuilders["lineHeight;"];
        modifiedKeys["lineHeight"] = true;
        return this;
    }

    this.dir = (spec: DirectionMode): IDisplayTextBuilder => {
        updates["dir"] = spec;
        delete childBuilders["dir;"];
        modifiedKeys["dir"] = true;
        return this;
    }

    this.enclosure = (spec: EnclosureShape): IDisplayTextBuilder => {
        updates["enclosure"] = spec;
        delete childBuilders["enclosure;"];
        modifiedKeys["enclosure"] = true;
        return this;
    }
  }
}
export function patchDisplayText(base: DisplayText, builder: (build: IDisplayTextBuilder) => IDisplayTextBuilder): IAny[] { return builder(new DisplayTextBuilder(base)).patch(); }
export function buildDisplayText(builder: (build: IDisplayTextBuilder) => IDisplayTextBuilder): DisplayText { return builder(new DisplayTextBuilder()).build(); }

export interface IAccidentalTextBuilder {
  build?: () => AccidentalText;
  patch: () => IAny[];
  text: (text: string) => IAccidentalTextBuilder;
  justify: (justify: LeftCenterRight) => IAccidentalTextBuilder;
  defaultX: (defaultX: number) => IAccidentalTextBuilder;
  relativeY: (relativeY: number) => IAccidentalTextBuilder;
  defaultY: (defaultY: number) => IAccidentalTextBuilder;
  relativeX: (relativeX: number) => IAccidentalTextBuilder;
  fontFamily: (fontFamily: string) => IAccidentalTextBuilder;
  fontWeight: (fontWeight: NormalBold) => IAccidentalTextBuilder;
  fontStyle: (fontStyle: NormalItalic) => IAccidentalTextBuilder;
  fontSize: (fontSize: string) => IAccidentalTextBuilder;
  color: (color: string) => IAccidentalTextBuilder;
  halign: (halign: LeftCenterRight) => IAccidentalTextBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IAccidentalTextBuilder;
  underline: (underline: number) => IAccidentalTextBuilder;
  overline: (overline: number) => IAccidentalTextBuilder;
  lineThrough: (lineThrough: number) => IAccidentalTextBuilder;
  rotation: (rotation: number) => IAccidentalTextBuilder;
  letterSpacing: (letterSpacing: string) => IAccidentalTextBuilder;
  lineHeight: (lineHeight: string) => IAccidentalTextBuilder;
  dir: (dir: DirectionMode) => IAccidentalTextBuilder;
  enclosure: (enclosure: EnclosureShape) => IAccidentalTextBuilder;
}

class AccidentalTextBuilder implements IAccidentalTextBuilder {
  build: () => AccidentalText;
  patch: () => IAny[];
  text: (text: string) => IAccidentalTextBuilder;
  justify: (justify: LeftCenterRight) => IAccidentalTextBuilder;
  defaultX: (defaultX: number) => IAccidentalTextBuilder;
  relativeY: (relativeY: number) => IAccidentalTextBuilder;
  defaultY: (defaultY: number) => IAccidentalTextBuilder;
  relativeX: (relativeX: number) => IAccidentalTextBuilder;
  fontFamily: (fontFamily: string) => IAccidentalTextBuilder;
  fontWeight: (fontWeight: NormalBold) => IAccidentalTextBuilder;
  fontStyle: (fontStyle: NormalItalic) => IAccidentalTextBuilder;
  fontSize: (fontSize: string) => IAccidentalTextBuilder;
  color: (color: string) => IAccidentalTextBuilder;
  halign: (halign: LeftCenterRight) => IAccidentalTextBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IAccidentalTextBuilder;
  underline: (underline: number) => IAccidentalTextBuilder;
  overline: (overline: number) => IAccidentalTextBuilder;
  lineThrough: (lineThrough: number) => IAccidentalTextBuilder;
  rotation: (rotation: number) => IAccidentalTextBuilder;
  letterSpacing: (letterSpacing: string) => IAccidentalTextBuilder;
  lineHeight: (lineHeight: string) => IAccidentalTextBuilder;
  dir: (dir: DirectionMode) => IAccidentalTextBuilder;
  enclosure: (enclosure: EnclosureShape) => IAccidentalTextBuilder;
  constructor(original?: AccidentalText) {
    let updates: AccidentalText = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["text"]) ||
          childBuilders["text"] !== undefined ||
          updates.text !== undefined,
        "text is a required field");
    }

    if (!original) {
      this.build = (): AccidentalText => {
        checkInvariants();
        (updates as any)._class = "AccidentalText";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.text = (spec: string): IAccidentalTextBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.justify = (spec: LeftCenterRight): IAccidentalTextBuilder => {
        updates["justify"] = spec;
        delete childBuilders["justify;"];
        modifiedKeys["justify"] = true;
        return this;
    }

    this.defaultX = (spec: number): IAccidentalTextBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IAccidentalTextBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IAccidentalTextBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IAccidentalTextBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IAccidentalTextBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IAccidentalTextBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IAccidentalTextBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IAccidentalTextBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IAccidentalTextBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IAccidentalTextBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IAccidentalTextBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }

    this.underline = (spec: number): IAccidentalTextBuilder => {
        updates["underline"] = spec;
        delete childBuilders["underline;"];
        modifiedKeys["underline"] = true;
        return this;
    }

    this.overline = (spec: number): IAccidentalTextBuilder => {
        updates["overline"] = spec;
        delete childBuilders["overline;"];
        modifiedKeys["overline"] = true;
        return this;
    }

    this.lineThrough = (spec: number): IAccidentalTextBuilder => {
        updates["lineThrough"] = spec;
        delete childBuilders["lineThrough;"];
        modifiedKeys["lineThrough"] = true;
        return this;
    }

    this.rotation = (spec: number): IAccidentalTextBuilder => {
        updates["rotation"] = spec;
        delete childBuilders["rotation;"];
        modifiedKeys["rotation"] = true;
        return this;
    }

    this.letterSpacing = (spec: string): IAccidentalTextBuilder => {
        updates["letterSpacing"] = spec;
        delete childBuilders["letterSpacing;"];
        modifiedKeys["letterSpacing"] = true;
        return this;
    }

    this.lineHeight = (spec: string): IAccidentalTextBuilder => {
        updates["lineHeight"] = spec;
        delete childBuilders["lineHeight;"];
        modifiedKeys["lineHeight"] = true;
        return this;
    }

    this.dir = (spec: DirectionMode): IAccidentalTextBuilder => {
        updates["dir"] = spec;
        delete childBuilders["dir;"];
        modifiedKeys["dir"] = true;
        return this;
    }

    this.enclosure = (spec: EnclosureShape): IAccidentalTextBuilder => {
        updates["enclosure"] = spec;
        delete childBuilders["enclosure;"];
        modifiedKeys["enclosure"] = true;
        return this;
    }
  }
}
export function patchAccidentalText(base: AccidentalText, builder: (build: IAccidentalTextBuilder) => IAccidentalTextBuilder): IAny[] { return builder(new AccidentalTextBuilder(base)).patch(); }
export function buildAccidentalText(builder: (build: IAccidentalTextBuilder) => IAccidentalTextBuilder): AccidentalText { return builder(new AccidentalTextBuilder()).build(); }

export interface IPartNameDisplayBuilder {
  build?: () => PartNameDisplay;
  patch: () => IAny[];
  nameAt: (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)) => IPartNameDisplayBuilder;
  nameSplice: (start: number, deleteCount: number, ...items: TextSegment[]) => IPartNameDisplayBuilder;
  name: (name: TextSegment[]) => IPartNameDisplayBuilder;
  printObject: (printObject: boolean) => IPartNameDisplayBuilder;
}

class PartNameDisplayBuilder implements IPartNameDisplayBuilder {
  build: () => PartNameDisplay;
  patch: () => IAny[];
  nameAt: (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)) => IPartNameDisplayBuilder;
  nameSplice: (start: number, deleteCount: number, ...items: TextSegment[]) => IPartNameDisplayBuilder;
  name: (name: TextSegment[]) => IPartNameDisplayBuilder;
  printObject: (printObject: boolean) => IPartNameDisplayBuilder;
  constructor(original?: PartNameDisplay) {
    let updates: PartNameDisplay = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["name"]) ||
          childBuilders["name"] !== undefined ||
          updates.name !== undefined,
        "name is a required field");
    }

    if (!original) {
      this.build = (): PartNameDisplay => {
        checkInvariants();
        (updates as any)._class = "PartNameDisplay";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.name = (spec: TextSegment[]): IPartNameDisplayBuilder => {
        updates["name"] = spec;
        delete childBuilders["name;"];
        modifiedKeys["name"] = true;
        return this;
    }

    this.nameAt = (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)): IPartNameDisplayBuilder => {
      makeReference("name");
      if (frozen["name"][idx]) {
          throw new Error("Patching name." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["name"] && !original["name"]) {
          // Clone snapshot.
          patches.push({p: ["name", idx], li: original._snapshot["name"]});
      }
      if (typeof build === 'function' && reference["name"][idx]) {
        let patch = (build as any)(new TextSegmentBuilder(reference["name"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["name", idx].concat(patch.p);
          return patch;
        }));
        frozen["name"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new TextSegmentBuilder(reference["name"][idx])).build() : build;
      if (original) {
        patches.push({p: ["name", idx], li: update});
      } else {
        updates["name"] = reference["name"]; // TODO: Merge?
      } 
      reference["name"][idx] = update;
      frozen["name"][idx] = true;
      return this;
    }

    this.nameSplice = (start: number, deleteCount: number, ...items: TextSegment[]): IPartNameDisplayBuilder => {
      makeReference("name");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["name"][idx]) {
            throw new Error("Replacing name." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["name"][idx];
          patches.push({p: ["name", idx], ld, li: items[idx - start]});
          frozen["name"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["name"][idx]) {
            throw new Error("Removing name." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["name"][idx];
          patches.push({p: ["name", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["name", idx], li: items[idx - start]});
          frozen["name"][idx] = true;
        }
      }
      reference["name"].splice(start, deleteCount, ...items);
      updates["name"] = reference["name"];
      frozen["name"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.printObject = (spec: boolean): IPartNameDisplayBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }
  }
}
export function patchPartNameDisplay(base: PartNameDisplay, builder: (build: IPartNameDisplayBuilder) => IPartNameDisplayBuilder): IAny[] { return builder(new PartNameDisplayBuilder(base)).patch(); }
export function buildPartNameDisplay(builder: (build: IPartNameDisplayBuilder) => IPartNameDisplayBuilder): PartNameDisplay { return builder(new PartNameDisplayBuilder()).build(); }

export interface IPartAbbreviationDisplayBuilder {
  build?: () => PartAbbreviationDisplay;
  patch: () => IAny[];
  nameAt: (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)) => IPartAbbreviationDisplayBuilder;
  nameSplice: (start: number, deleteCount: number, ...items: TextSegment[]) => IPartAbbreviationDisplayBuilder;
  name: (name: TextSegment[]) => IPartAbbreviationDisplayBuilder;
  printObject: (printObject: boolean) => IPartAbbreviationDisplayBuilder;
}

class PartAbbreviationDisplayBuilder implements IPartAbbreviationDisplayBuilder {
  build: () => PartAbbreviationDisplay;
  patch: () => IAny[];
  nameAt: (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)) => IPartAbbreviationDisplayBuilder;
  nameSplice: (start: number, deleteCount: number, ...items: TextSegment[]) => IPartAbbreviationDisplayBuilder;
  name: (name: TextSegment[]) => IPartAbbreviationDisplayBuilder;
  printObject: (printObject: boolean) => IPartAbbreviationDisplayBuilder;
  constructor(original?: PartAbbreviationDisplay) {
    let updates: PartAbbreviationDisplay = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["name"]) ||
          childBuilders["name"] !== undefined ||
          updates.name !== undefined,
        "name is a required field");
    }

    if (!original) {
      this.build = (): PartAbbreviationDisplay => {
        checkInvariants();
        (updates as any)._class = "PartAbbreviationDisplay";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.name = (spec: TextSegment[]): IPartAbbreviationDisplayBuilder => {
        updates["name"] = spec;
        delete childBuilders["name;"];
        modifiedKeys["name"] = true;
        return this;
    }

    this.nameAt = (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)): IPartAbbreviationDisplayBuilder => {
      makeReference("name");
      if (frozen["name"][idx]) {
          throw new Error("Patching name." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["name"] && !original["name"]) {
          // Clone snapshot.
          patches.push({p: ["name", idx], li: original._snapshot["name"]});
      }
      if (typeof build === 'function' && reference["name"][idx]) {
        let patch = (build as any)(new TextSegmentBuilder(reference["name"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["name", idx].concat(patch.p);
          return patch;
        }));
        frozen["name"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new TextSegmentBuilder(reference["name"][idx])).build() : build;
      if (original) {
        patches.push({p: ["name", idx], li: update});
      } else {
        updates["name"] = reference["name"]; // TODO: Merge?
      } 
      reference["name"][idx] = update;
      frozen["name"][idx] = true;
      return this;
    }

    this.nameSplice = (start: number, deleteCount: number, ...items: TextSegment[]): IPartAbbreviationDisplayBuilder => {
      makeReference("name");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["name"][idx]) {
            throw new Error("Replacing name." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["name"][idx];
          patches.push({p: ["name", idx], ld, li: items[idx - start]});
          frozen["name"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["name"][idx]) {
            throw new Error("Removing name." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["name"][idx];
          patches.push({p: ["name", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["name", idx], li: items[idx - start]});
          frozen["name"][idx] = true;
        }
      }
      reference["name"].splice(start, deleteCount, ...items);
      updates["name"] = reference["name"];
      frozen["name"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.printObject = (spec: boolean): IPartAbbreviationDisplayBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }
  }
}
export function patchPartAbbreviationDisplay(base: PartAbbreviationDisplay, builder: (build: IPartAbbreviationDisplayBuilder) => IPartAbbreviationDisplayBuilder): IAny[] { return builder(new PartAbbreviationDisplayBuilder(base)).patch(); }
export function buildPartAbbreviationDisplay(builder: (build: IPartAbbreviationDisplayBuilder) => IPartAbbreviationDisplayBuilder): PartAbbreviationDisplay { return builder(new PartAbbreviationDisplayBuilder()).build(); }

export interface IMidiDeviceBuilder {
  build?: () => MidiDevice;
  patch: () => IAny[];
  port: (port: number) => IMidiDeviceBuilder;
  deviceName: (deviceName: string) => IMidiDeviceBuilder;
  id: (id: number) => IMidiDeviceBuilder;
}

class MidiDeviceBuilder implements IMidiDeviceBuilder {
  build: () => MidiDevice;
  patch: () => IAny[];
  port: (port: number) => IMidiDeviceBuilder;
  deviceName: (deviceName: string) => IMidiDeviceBuilder;
  id: (id: number) => IMidiDeviceBuilder;
  constructor(original?: MidiDevice) {
    let updates: MidiDevice = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["deviceName"]) ||
          childBuilders["deviceName"] !== undefined ||
          updates.deviceName !== undefined,
        "deviceName is a required field");
    }

    if (!original) {
      this.build = (): MidiDevice => {
        checkInvariants();
        (updates as any)._class = "MidiDevice";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.port = (spec: number): IMidiDeviceBuilder => {
        updates["port"] = spec;
        delete childBuilders["port;"];
        modifiedKeys["port"] = true;
        return this;
    }

    this.deviceName = (spec: string): IMidiDeviceBuilder => {
        updates["deviceName"] = spec;
        delete childBuilders["deviceName;"];
        modifiedKeys["deviceName"] = true;
        return this;
    }

    this.id = (spec: number): IMidiDeviceBuilder => {
        updates["id"] = spec;
        delete childBuilders["id;"];
        modifiedKeys["id"] = true;
        return this;
    }
  }
}
export function patchMidiDevice(base: MidiDevice, builder: (build: IMidiDeviceBuilder) => IMidiDeviceBuilder): IAny[] { return builder(new MidiDeviceBuilder(base)).patch(); }
export function buildMidiDevice(builder: (build: IMidiDeviceBuilder) => IMidiDeviceBuilder): MidiDevice { return builder(new MidiDeviceBuilder()).build(); }

export interface IMidiInstrumentBuilder {
  build?: () => MidiInstrument;
  patch: () => IAny[];
  midiUnpitched: (midiUnpitched: number) => IMidiInstrumentBuilder;
  volume: (volume: number) => IMidiInstrumentBuilder;
  pan: (pan: number) => IMidiInstrumentBuilder;
  elevation: (elevation: number) => IMidiInstrumentBuilder;
  midiBank: (midiBank: number) => IMidiInstrumentBuilder;
  midiProgram: (midiProgram: number) => IMidiInstrumentBuilder;
  id: (id: string) => IMidiInstrumentBuilder;
  midiChannel: (midiChannel: number) => IMidiInstrumentBuilder;
  midiName: (midiName: string) => IMidiInstrumentBuilder;
}

class MidiInstrumentBuilder implements IMidiInstrumentBuilder {
  build: () => MidiInstrument;
  patch: () => IAny[];
  midiUnpitched: (midiUnpitched: number) => IMidiInstrumentBuilder;
  volume: (volume: number) => IMidiInstrumentBuilder;
  pan: (pan: number) => IMidiInstrumentBuilder;
  elevation: (elevation: number) => IMidiInstrumentBuilder;
  midiBank: (midiBank: number) => IMidiInstrumentBuilder;
  midiProgram: (midiProgram: number) => IMidiInstrumentBuilder;
  id: (id: string) => IMidiInstrumentBuilder;
  midiChannel: (midiChannel: number) => IMidiInstrumentBuilder;
  midiName: (midiName: string) => IMidiInstrumentBuilder;
  constructor(original?: MidiInstrument) {
    let updates: MidiInstrument = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["id"]) ||
          childBuilders["id"] !== undefined ||
          updates.id !== undefined,
        "id is a required field");
    }

    if (!original) {
      this.build = (): MidiInstrument => {
        checkInvariants();
        (updates as any)._class = "MidiInstrument";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.midiUnpitched = (spec: number): IMidiInstrumentBuilder => {
        updates["midiUnpitched"] = spec;
        delete childBuilders["midiUnpitched;"];
        modifiedKeys["midiUnpitched"] = true;
        return this;
    }

    this.volume = (spec: number): IMidiInstrumentBuilder => {
        updates["volume"] = spec;
        delete childBuilders["volume;"];
        modifiedKeys["volume"] = true;
        return this;
    }

    this.pan = (spec: number): IMidiInstrumentBuilder => {
        updates["pan"] = spec;
        delete childBuilders["pan;"];
        modifiedKeys["pan"] = true;
        return this;
    }

    this.elevation = (spec: number): IMidiInstrumentBuilder => {
        updates["elevation"] = spec;
        delete childBuilders["elevation;"];
        modifiedKeys["elevation"] = true;
        return this;
    }

    this.midiBank = (spec: number): IMidiInstrumentBuilder => {
        updates["midiBank"] = spec;
        delete childBuilders["midiBank;"];
        modifiedKeys["midiBank"] = true;
        return this;
    }

    this.midiProgram = (spec: number): IMidiInstrumentBuilder => {
        updates["midiProgram"] = spec;
        delete childBuilders["midiProgram;"];
        modifiedKeys["midiProgram"] = true;
        return this;
    }

    this.id = (spec: string): IMidiInstrumentBuilder => {
        updates["id"] = spec;
        delete childBuilders["id;"];
        modifiedKeys["id"] = true;
        return this;
    }

    this.midiChannel = (spec: number): IMidiInstrumentBuilder => {
        updates["midiChannel"] = spec;
        delete childBuilders["midiChannel;"];
        modifiedKeys["midiChannel"] = true;
        return this;
    }

    this.midiName = (spec: string): IMidiInstrumentBuilder => {
        updates["midiName"] = spec;
        delete childBuilders["midiName;"];
        modifiedKeys["midiName"] = true;
        return this;
    }
  }
}
export function patchMidiInstrument(base: MidiInstrument, builder: (build: IMidiInstrumentBuilder) => IMidiInstrumentBuilder): IAny[] { return builder(new MidiInstrumentBuilder(base)).patch(); }
export function buildMidiInstrument(builder: (build: IMidiInstrumentBuilder) => IMidiInstrumentBuilder): MidiInstrument { return builder(new MidiInstrumentBuilder()).build(); }

export interface IPlayBuilder {
  build?: () => Play;
  patch: () => IAny[];
  ipa: (ipa: string) => IPlayBuilder;
  mute: (mute: string) => IPlayBuilder;
  otherPlay: (build: OtherPlay | ((builder: IOtherPlayBuilder) => IOtherPlayBuilder)) => IPlayBuilder;
  semiPitched: (semiPitched: string) => IPlayBuilder;
  id: (id: string) => IPlayBuilder;
}

class PlayBuilder implements IPlayBuilder {
  build: () => Play;
  patch: () => IAny[];
  ipa: (ipa: string) => IPlayBuilder;
  mute: (mute: string) => IPlayBuilder;
  otherPlay: (build: OtherPlay | ((builder: IOtherPlayBuilder) => IOtherPlayBuilder)) => IPlayBuilder;
  semiPitched: (semiPitched: string) => IPlayBuilder;
  id: (id: string) => IPlayBuilder;
  constructor(original?: Play) {
    let updates: Play = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["id"]) ||
          childBuilders["id"] !== undefined ||
          updates.id !== undefined,
        "id is a required field");
    }

    if (!original) {
      this.build = (): Play => {
        checkInvariants();
        (updates as any)._class = "Play";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.ipa = (spec: string): IPlayBuilder => {
        updates["ipa"] = spec;
        delete childBuilders["ipa;"];
        modifiedKeys["ipa"] = true;
        return this;
    }

    this.mute = (spec: string): IPlayBuilder => {
        updates["mute"] = spec;
        delete childBuilders["mute;"];
        modifiedKeys["mute"] = true;
        return this;
    }

    this.otherPlay = (build: OtherPlay | ((builder: IOtherPlayBuilder) => IOtherPlayBuilder)): IPlayBuilder => {
      if (typeof build === 'function') {
        delete updates["otherPlay"]
        const builder = (build as any)(new OtherPlayBuilder(original && original["otherPlay"]));
        if (!original) updates["otherPlay"] = builder.build();
        else childBuilders["otherPlay"] = builder;
      } else {
        updates.otherPlay = build as any;
        delete childBuilders["otherPlay;"];
      }
      modifiedKeys["otherPlay"] = true;
      return this;
    }

    this.semiPitched = (spec: string): IPlayBuilder => {
        updates["semiPitched"] = spec;
        delete childBuilders["semiPitched;"];
        modifiedKeys["semiPitched"] = true;
        return this;
    }

    this.id = (spec: string): IPlayBuilder => {
        updates["id"] = spec;
        delete childBuilders["id;"];
        modifiedKeys["id"] = true;
        return this;
    }
  }
}
export function patchPlay(base: Play, builder: (build: IPlayBuilder) => IPlayBuilder): IAny[] { return builder(new PlayBuilder(base)).patch(); }
export function buildPlay(builder: (build: IPlayBuilder) => IPlayBuilder): Play { return builder(new PlayBuilder()).build(); }

export interface IOtherPlayBuilder {
  build?: () => OtherPlay;
  patch: () => IAny[];
  data: (data: string) => IOtherPlayBuilder;
  type: (type: string) => IOtherPlayBuilder;
}

class OtherPlayBuilder implements IOtherPlayBuilder {
  build: () => OtherPlay;
  patch: () => IAny[];
  data: (data: string) => IOtherPlayBuilder;
  type: (type: string) => IOtherPlayBuilder;
  constructor(original?: OtherPlay) {
    let updates: OtherPlay = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): OtherPlay => {
        checkInvariants();
        (updates as any)._class = "OtherPlay";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IOtherPlayBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.type = (spec: string): IOtherPlayBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }
  }
}
export function patchOtherPlay(base: OtherPlay, builder: (build: IOtherPlayBuilder) => IOtherPlayBuilder): IAny[] { return builder(new OtherPlayBuilder(base)).patch(); }
export function buildOtherPlay(builder: (build: IOtherPlayBuilder) => IOtherPlayBuilder): OtherPlay { return builder(new OtherPlayBuilder()).build(); }

export interface IScalingBuilder {
  build?: () => Scaling;
  patch: () => IAny[];
  tenths: (tenths: number) => IScalingBuilder;
  millimeters: (millimeters: number) => IScalingBuilder;
}

class ScalingBuilder implements IScalingBuilder {
  build: () => Scaling;
  patch: () => IAny[];
  tenths: (tenths: number) => IScalingBuilder;
  millimeters: (millimeters: number) => IScalingBuilder;
  constructor(original?: Scaling) {
    let updates: Scaling = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Scaling => {
        checkInvariants();
        (updates as any)._class = "Scaling";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.tenths = (spec: number): IScalingBuilder => {
        updates["tenths"] = spec;
        delete childBuilders["tenths;"];
        modifiedKeys["tenths"] = true;
        return this;
    }

    this.millimeters = (spec: number): IScalingBuilder => {
        updates["millimeters"] = spec;
        delete childBuilders["millimeters;"];
        modifiedKeys["millimeters"] = true;
        return this;
    }
  }
}
export function patchScaling(base: Scaling, builder: (build: IScalingBuilder) => IScalingBuilder): IAny[] { return builder(new ScalingBuilder(base)).patch(); }
export function buildScaling(builder: (build: IScalingBuilder) => IScalingBuilder): Scaling { return builder(new ScalingBuilder()).build(); }

export interface IPageMarginsBuilder {
  build?: () => PageMargins;
  patch: () => IAny[];
  topMargin: (topMargin: number) => IPageMarginsBuilder;
  leftMargin: (leftMargin: number) => IPageMarginsBuilder;
  bottomMargin: (bottomMargin: number) => IPageMarginsBuilder;
  type: (type: OddEvenBoth) => IPageMarginsBuilder;
  rightMargin: (rightMargin: number) => IPageMarginsBuilder;
}

class PageMarginsBuilder implements IPageMarginsBuilder {
  build: () => PageMargins;
  patch: () => IAny[];
  topMargin: (topMargin: number) => IPageMarginsBuilder;
  leftMargin: (leftMargin: number) => IPageMarginsBuilder;
  bottomMargin: (bottomMargin: number) => IPageMarginsBuilder;
  type: (type: OddEvenBoth) => IPageMarginsBuilder;
  rightMargin: (rightMargin: number) => IPageMarginsBuilder;
  constructor(original?: PageMargins) {
    let updates: PageMargins = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["topMargin"]) ||
          childBuilders["topMargin"] !== undefined ||
          updates.topMargin !== undefined,
        "topMargin is a required field");
      console.assert(
          (original && !modifiedKeys["leftMargin"]) ||
          childBuilders["leftMargin"] !== undefined ||
          updates.leftMargin !== undefined,
        "leftMargin is a required field");
      console.assert(
          (original && !modifiedKeys["bottomMargin"]) ||
          childBuilders["bottomMargin"] !== undefined ||
          updates.bottomMargin !== undefined,
        "bottomMargin is a required field");
      console.assert(
          (original && !modifiedKeys["rightMargin"]) ||
          childBuilders["rightMargin"] !== undefined ||
          updates.rightMargin !== undefined,
        "rightMargin is a required field");
    }

    if (!original) {
      this.build = (): PageMargins => {
        checkInvariants();
        (updates as any)._class = "PageMargins";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.topMargin = (spec: number): IPageMarginsBuilder => {
        updates["topMargin"] = spec;
        delete childBuilders["topMargin;"];
        modifiedKeys["topMargin"] = true;
        return this;
    }

    this.leftMargin = (spec: number): IPageMarginsBuilder => {
        updates["leftMargin"] = spec;
        delete childBuilders["leftMargin;"];
        modifiedKeys["leftMargin"] = true;
        return this;
    }

    this.bottomMargin = (spec: number): IPageMarginsBuilder => {
        updates["bottomMargin"] = spec;
        delete childBuilders["bottomMargin;"];
        modifiedKeys["bottomMargin"] = true;
        return this;
    }

    this.type = (spec: OddEvenBoth): IPageMarginsBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.rightMargin = (spec: number): IPageMarginsBuilder => {
        updates["rightMargin"] = spec;
        delete childBuilders["rightMargin;"];
        modifiedKeys["rightMargin"] = true;
        return this;
    }
  }
}
export function patchPageMargins(base: PageMargins, builder: (build: IPageMarginsBuilder) => IPageMarginsBuilder): IAny[] { return builder(new PageMarginsBuilder(base)).patch(); }
export function buildPageMargins(builder: (build: IPageMarginsBuilder) => IPageMarginsBuilder): PageMargins { return builder(new PageMarginsBuilder()).build(); }

export interface IPageLayoutBuilder {
  build?: () => PageLayout;
  patch: () => IAny[];
  pageHeight: (pageHeight: number) => IPageLayoutBuilder;
  pageWidth: (pageWidth: number) => IPageLayoutBuilder;
  pageMarginsAt: (idx: number, build: PageMargins | ((builder: IPageMarginsBuilder) => IPageMarginsBuilder)) => IPageLayoutBuilder;
  pageMarginsSplice: (start: number, deleteCount: number, ...items: PageMargins[]) => IPageLayoutBuilder;
  pageMargins: (pageMargins: PageMargins[]) => IPageLayoutBuilder;
}

class PageLayoutBuilder implements IPageLayoutBuilder {
  build: () => PageLayout;
  patch: () => IAny[];
  pageHeight: (pageHeight: number) => IPageLayoutBuilder;
  pageWidth: (pageWidth: number) => IPageLayoutBuilder;
  pageMarginsAt: (idx: number, build: PageMargins | ((builder: IPageMarginsBuilder) => IPageMarginsBuilder)) => IPageLayoutBuilder;
  pageMarginsSplice: (start: number, deleteCount: number, ...items: PageMargins[]) => IPageLayoutBuilder;
  pageMargins: (pageMargins: PageMargins[]) => IPageLayoutBuilder;
  constructor(original?: PageLayout) {
    let updates: PageLayout = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): PageLayout => {
        checkInvariants();
        (updates as any)._class = "PageLayout";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.pageHeight = (spec: number): IPageLayoutBuilder => {
        updates["pageHeight"] = spec;
        delete childBuilders["pageHeight;"];
        modifiedKeys["pageHeight"] = true;
        return this;
    }

    this.pageWidth = (spec: number): IPageLayoutBuilder => {
        updates["pageWidth"] = spec;
        delete childBuilders["pageWidth;"];
        modifiedKeys["pageWidth"] = true;
        return this;
    }

    this.pageMargins = (spec: PageMargins[]): IPageLayoutBuilder => {
        updates["pageMargins"] = spec;
        delete childBuilders["pageMargins;"];
        modifiedKeys["pageMargins"] = true;
        return this;
    }

    this.pageMarginsAt = (idx: number, build: PageMargins | ((builder: IPageMarginsBuilder) => IPageMarginsBuilder)): IPageLayoutBuilder => {
      makeReference("pageMargins");
      if (frozen["pageMargins"][idx]) {
          throw new Error("Patching pageMargins." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["pageMargins"] && !original["pageMargins"]) {
          // Clone snapshot.
          patches.push({p: ["pageMargins", idx], li: original._snapshot["pageMargins"]});
      }
      if (typeof build === 'function' && reference["pageMargins"][idx]) {
        let patch = (build as any)(new PageMarginsBuilder(reference["pageMargins"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["pageMargins", idx].concat(patch.p);
          return patch;
        }));
        frozen["pageMargins"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new PageMarginsBuilder(reference["pageMargins"][idx])).build() : build;
      if (original) {
        patches.push({p: ["pageMargins", idx], li: update});
      } else {
        updates["pageMargins"] = reference["pageMargins"]; // TODO: Merge?
      } 
      reference["pageMargins"][idx] = update;
      frozen["pageMargins"][idx] = true;
      return this;
    }

    this.pageMarginsSplice = (start: number, deleteCount: number, ...items: PageMargins[]): IPageLayoutBuilder => {
      makeReference("pageMargins");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["pageMargins"][idx]) {
            throw new Error("Replacing pageMargins." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["pageMargins"][idx];
          patches.push({p: ["pageMargins", idx], ld, li: items[idx - start]});
          frozen["pageMargins"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["pageMargins"][idx]) {
            throw new Error("Removing pageMargins." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["pageMargins"][idx];
          patches.push({p: ["pageMargins", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["pageMargins", idx], li: items[idx - start]});
          frozen["pageMargins"][idx] = true;
        }
      }
      reference["pageMargins"].splice(start, deleteCount, ...items);
      updates["pageMargins"] = reference["pageMargins"];
      frozen["pageMargins"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }
  }
}
export function patchPageLayout(base: PageLayout, builder: (build: IPageLayoutBuilder) => IPageLayoutBuilder): IAny[] { return builder(new PageLayoutBuilder(base)).patch(); }
export function buildPageLayout(builder: (build: IPageLayoutBuilder) => IPageLayoutBuilder): PageLayout { return builder(new PageLayoutBuilder()).build(); }

export interface ISystemLayoutBuilder {
  build?: () => SystemLayout;
  patch: () => IAny[];
  systemDividers: (build: SystemDividers | ((builder: ISystemDividersBuilder) => ISystemDividersBuilder)) => ISystemLayoutBuilder;
  systemMargins: (build: SystemMargins | ((builder: ISystemMarginsBuilder) => ISystemMarginsBuilder)) => ISystemLayoutBuilder;
  systemDistance: (systemDistance: number) => ISystemLayoutBuilder;
  topSystemDistance: (topSystemDistance: number) => ISystemLayoutBuilder;
}

class SystemLayoutBuilder implements ISystemLayoutBuilder {
  build: () => SystemLayout;
  patch: () => IAny[];
  systemDividers: (build: SystemDividers | ((builder: ISystemDividersBuilder) => ISystemDividersBuilder)) => ISystemLayoutBuilder;
  systemMargins: (build: SystemMargins | ((builder: ISystemMarginsBuilder) => ISystemMarginsBuilder)) => ISystemLayoutBuilder;
  systemDistance: (systemDistance: number) => ISystemLayoutBuilder;
  topSystemDistance: (topSystemDistance: number) => ISystemLayoutBuilder;
  constructor(original?: SystemLayout) {
    let updates: SystemLayout = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): SystemLayout => {
        checkInvariants();
        (updates as any)._class = "SystemLayout";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.systemDividers = (build: SystemDividers | ((builder: ISystemDividersBuilder) => ISystemDividersBuilder)): ISystemLayoutBuilder => {
      if (typeof build === 'function') {
        delete updates["systemDividers"]
        const builder = (build as any)(new SystemDividersBuilder(original && original["systemDividers"]));
        if (!original) updates["systemDividers"] = builder.build();
        else childBuilders["systemDividers"] = builder;
      } else {
        updates.systemDividers = build as any;
        delete childBuilders["systemDividers;"];
      }
      modifiedKeys["systemDividers"] = true;
      return this;
    }

    this.systemMargins = (build: SystemMargins | ((builder: ISystemMarginsBuilder) => ISystemMarginsBuilder)): ISystemLayoutBuilder => {
      if (typeof build === 'function') {
        delete updates["systemMargins"]
        const builder = (build as any)(new SystemMarginsBuilder(original && original["systemMargins"]));
        if (!original) updates["systemMargins"] = builder.build();
        else childBuilders["systemMargins"] = builder;
      } else {
        updates.systemMargins = build as any;
        delete childBuilders["systemMargins;"];
      }
      modifiedKeys["systemMargins"] = true;
      return this;
    }

    this.systemDistance = (spec: number): ISystemLayoutBuilder => {
        updates["systemDistance"] = spec;
        delete childBuilders["systemDistance;"];
        modifiedKeys["systemDistance"] = true;
        return this;
    }

    this.topSystemDistance = (spec: number): ISystemLayoutBuilder => {
        updates["topSystemDistance"] = spec;
        delete childBuilders["topSystemDistance;"];
        modifiedKeys["topSystemDistance"] = true;
        return this;
    }
  }
}
export function patchSystemLayout(base: SystemLayout, builder: (build: ISystemLayoutBuilder) => ISystemLayoutBuilder): IAny[] { return builder(new SystemLayoutBuilder(base)).patch(); }
export function buildSystemLayout(builder: (build: ISystemLayoutBuilder) => ISystemLayoutBuilder): SystemLayout { return builder(new SystemLayoutBuilder()).build(); }

export interface ISystemMarginsBuilder {
  build?: () => SystemMargins;
  patch: () => IAny[];
  leftMargin: (leftMargin: number) => ISystemMarginsBuilder;
  rightMargin: (rightMargin: number) => ISystemMarginsBuilder;
}

class SystemMarginsBuilder implements ISystemMarginsBuilder {
  build: () => SystemMargins;
  patch: () => IAny[];
  leftMargin: (leftMargin: number) => ISystemMarginsBuilder;
  rightMargin: (rightMargin: number) => ISystemMarginsBuilder;
  constructor(original?: SystemMargins) {
    let updates: SystemMargins = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["leftMargin"]) ||
          childBuilders["leftMargin"] !== undefined ||
          updates.leftMargin !== undefined,
        "leftMargin is a required field");
      console.assert(
          (original && !modifiedKeys["rightMargin"]) ||
          childBuilders["rightMargin"] !== undefined ||
          updates.rightMargin !== undefined,
        "rightMargin is a required field");
    }

    if (!original) {
      this.build = (): SystemMargins => {
        checkInvariants();
        (updates as any)._class = "SystemMargins";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.leftMargin = (spec: number): ISystemMarginsBuilder => {
        updates["leftMargin"] = spec;
        delete childBuilders["leftMargin;"];
        modifiedKeys["leftMargin"] = true;
        return this;
    }

    this.rightMargin = (spec: number): ISystemMarginsBuilder => {
        updates["rightMargin"] = spec;
        delete childBuilders["rightMargin;"];
        modifiedKeys["rightMargin"] = true;
        return this;
    }
  }
}
export function patchSystemMargins(base: SystemMargins, builder: (build: ISystemMarginsBuilder) => ISystemMarginsBuilder): IAny[] { return builder(new SystemMarginsBuilder(base)).patch(); }
export function buildSystemMargins(builder: (build: ISystemMarginsBuilder) => ISystemMarginsBuilder): SystemMargins { return builder(new SystemMarginsBuilder()).build(); }

export interface ISystemDividersBuilder {
  build?: () => SystemDividers;
  patch: () => IAny[];
  rightDivider: (build: RightDivider | ((builder: IRightDividerBuilder) => IRightDividerBuilder)) => ISystemDividersBuilder;
  leftDivider: (build: LeftDivider | ((builder: ILeftDividerBuilder) => ILeftDividerBuilder)) => ISystemDividersBuilder;
}

class SystemDividersBuilder implements ISystemDividersBuilder {
  build: () => SystemDividers;
  patch: () => IAny[];
  rightDivider: (build: RightDivider | ((builder: IRightDividerBuilder) => IRightDividerBuilder)) => ISystemDividersBuilder;
  leftDivider: (build: LeftDivider | ((builder: ILeftDividerBuilder) => ILeftDividerBuilder)) => ISystemDividersBuilder;
  constructor(original?: SystemDividers) {
    let updates: SystemDividers = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["rightDivider"]) ||
          childBuilders["rightDivider"] !== undefined ||
          updates.rightDivider !== undefined,
        "rightDivider is a required field");
      console.assert(
          (original && !modifiedKeys["leftDivider"]) ||
          childBuilders["leftDivider"] !== undefined ||
          updates.leftDivider !== undefined,
        "leftDivider is a required field");
    }

    if (!original) {
      this.build = (): SystemDividers => {
        checkInvariants();
        (updates as any)._class = "SystemDividers";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.rightDivider = (build: RightDivider | ((builder: IRightDividerBuilder) => IRightDividerBuilder)): ISystemDividersBuilder => {
      if (typeof build === 'function') {
        delete updates["rightDivider"]
        const builder = (build as any)(new RightDividerBuilder(original && original["rightDivider"]));
        if (!original) updates["rightDivider"] = builder.build();
        else childBuilders["rightDivider"] = builder;
      } else {
        updates.rightDivider = build as any;
        delete childBuilders["rightDivider;"];
      }
      modifiedKeys["rightDivider"] = true;
      return this;
    }

    this.leftDivider = (build: LeftDivider | ((builder: ILeftDividerBuilder) => ILeftDividerBuilder)): ISystemDividersBuilder => {
      if (typeof build === 'function') {
        delete updates["leftDivider"]
        const builder = (build as any)(new LeftDividerBuilder(original && original["leftDivider"]));
        if (!original) updates["leftDivider"] = builder.build();
        else childBuilders["leftDivider"] = builder;
      } else {
        updates.leftDivider = build as any;
        delete childBuilders["leftDivider;"];
      }
      modifiedKeys["leftDivider"] = true;
      return this;
    }
  }
}
export function patchSystemDividers(base: SystemDividers, builder: (build: ISystemDividersBuilder) => ISystemDividersBuilder): IAny[] { return builder(new SystemDividersBuilder(base)).patch(); }
export function buildSystemDividers(builder: (build: ISystemDividersBuilder) => ISystemDividersBuilder): SystemDividers { return builder(new SystemDividersBuilder()).build(); }

export interface ILeftDividerBuilder {
  build?: () => LeftDivider;
  patch: () => IAny[];
  printObject: (printObject: boolean) => ILeftDividerBuilder;
  defaultX: (defaultX: number) => ILeftDividerBuilder;
  relativeY: (relativeY: number) => ILeftDividerBuilder;
  defaultY: (defaultY: number) => ILeftDividerBuilder;
  relativeX: (relativeX: number) => ILeftDividerBuilder;
  fontFamily: (fontFamily: string) => ILeftDividerBuilder;
  fontWeight: (fontWeight: NormalBold) => ILeftDividerBuilder;
  fontStyle: (fontStyle: NormalItalic) => ILeftDividerBuilder;
  fontSize: (fontSize: string) => ILeftDividerBuilder;
  color: (color: string) => ILeftDividerBuilder;
  halign: (halign: LeftCenterRight) => ILeftDividerBuilder;
  valign: (valign: TopMiddleBottomBaseline) => ILeftDividerBuilder;
}

class LeftDividerBuilder implements ILeftDividerBuilder {
  build: () => LeftDivider;
  patch: () => IAny[];
  printObject: (printObject: boolean) => ILeftDividerBuilder;
  defaultX: (defaultX: number) => ILeftDividerBuilder;
  relativeY: (relativeY: number) => ILeftDividerBuilder;
  defaultY: (defaultY: number) => ILeftDividerBuilder;
  relativeX: (relativeX: number) => ILeftDividerBuilder;
  fontFamily: (fontFamily: string) => ILeftDividerBuilder;
  fontWeight: (fontWeight: NormalBold) => ILeftDividerBuilder;
  fontStyle: (fontStyle: NormalItalic) => ILeftDividerBuilder;
  fontSize: (fontSize: string) => ILeftDividerBuilder;
  color: (color: string) => ILeftDividerBuilder;
  halign: (halign: LeftCenterRight) => ILeftDividerBuilder;
  valign: (valign: TopMiddleBottomBaseline) => ILeftDividerBuilder;
  constructor(original?: LeftDivider) {
    let updates: LeftDivider = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): LeftDivider => {
        checkInvariants();
        (updates as any)._class = "LeftDivider";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.printObject = (spec: boolean): ILeftDividerBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.defaultX = (spec: number): ILeftDividerBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ILeftDividerBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ILeftDividerBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ILeftDividerBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ILeftDividerBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ILeftDividerBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ILeftDividerBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ILeftDividerBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ILeftDividerBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): ILeftDividerBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): ILeftDividerBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchLeftDivider(base: LeftDivider, builder: (build: ILeftDividerBuilder) => ILeftDividerBuilder): IAny[] { return builder(new LeftDividerBuilder(base)).patch(); }
export function buildLeftDivider(builder: (build: ILeftDividerBuilder) => ILeftDividerBuilder): LeftDivider { return builder(new LeftDividerBuilder()).build(); }

export interface IRightDividerBuilder {
  build?: () => RightDivider;
  patch: () => IAny[];
  printObject: (printObject: boolean) => IRightDividerBuilder;
  defaultX: (defaultX: number) => IRightDividerBuilder;
  relativeY: (relativeY: number) => IRightDividerBuilder;
  defaultY: (defaultY: number) => IRightDividerBuilder;
  relativeX: (relativeX: number) => IRightDividerBuilder;
  fontFamily: (fontFamily: string) => IRightDividerBuilder;
  fontWeight: (fontWeight: NormalBold) => IRightDividerBuilder;
  fontStyle: (fontStyle: NormalItalic) => IRightDividerBuilder;
  fontSize: (fontSize: string) => IRightDividerBuilder;
  color: (color: string) => IRightDividerBuilder;
  halign: (halign: LeftCenterRight) => IRightDividerBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IRightDividerBuilder;
}

class RightDividerBuilder implements IRightDividerBuilder {
  build: () => RightDivider;
  patch: () => IAny[];
  printObject: (printObject: boolean) => IRightDividerBuilder;
  defaultX: (defaultX: number) => IRightDividerBuilder;
  relativeY: (relativeY: number) => IRightDividerBuilder;
  defaultY: (defaultY: number) => IRightDividerBuilder;
  relativeX: (relativeX: number) => IRightDividerBuilder;
  fontFamily: (fontFamily: string) => IRightDividerBuilder;
  fontWeight: (fontWeight: NormalBold) => IRightDividerBuilder;
  fontStyle: (fontStyle: NormalItalic) => IRightDividerBuilder;
  fontSize: (fontSize: string) => IRightDividerBuilder;
  color: (color: string) => IRightDividerBuilder;
  halign: (halign: LeftCenterRight) => IRightDividerBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IRightDividerBuilder;
  constructor(original?: RightDivider) {
    let updates: RightDivider = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): RightDivider => {
        checkInvariants();
        (updates as any)._class = "RightDivider";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.printObject = (spec: boolean): IRightDividerBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.defaultX = (spec: number): IRightDividerBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IRightDividerBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IRightDividerBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IRightDividerBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IRightDividerBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IRightDividerBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IRightDividerBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IRightDividerBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IRightDividerBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IRightDividerBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IRightDividerBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchRightDivider(base: RightDivider, builder: (build: IRightDividerBuilder) => IRightDividerBuilder): IAny[] { return builder(new RightDividerBuilder(base)).patch(); }
export function buildRightDivider(builder: (build: IRightDividerBuilder) => IRightDividerBuilder): RightDivider { return builder(new RightDividerBuilder()).build(); }

export interface IStaffLayoutBuilder {
  build?: () => StaffLayout;
  patch: () => IAny[];
  staffDistance: (staffDistance: number) => IStaffLayoutBuilder;
  num: (num: number) => IStaffLayoutBuilder;
}

class StaffLayoutBuilder implements IStaffLayoutBuilder {
  build: () => StaffLayout;
  patch: () => IAny[];
  staffDistance: (staffDistance: number) => IStaffLayoutBuilder;
  num: (num: number) => IStaffLayoutBuilder;
  constructor(original?: StaffLayout) {
    let updates: StaffLayout = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["num"]) ||
          childBuilders["num"] !== undefined ||
          updates.num !== undefined,
        "num is a required field");
    }

    if (!original) {
      this.build = (): StaffLayout => {
        checkInvariants();
        (updates as any)._class = "StaffLayout";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.staffDistance = (spec: number): IStaffLayoutBuilder => {
        updates["staffDistance"] = spec;
        delete childBuilders["staffDistance;"];
        modifiedKeys["staffDistance"] = true;
        return this;
    }

    this.num = (spec: number): IStaffLayoutBuilder => {
        updates["num"] = spec;
        delete childBuilders["num;"];
        modifiedKeys["num"] = true;
        return this;
    }
  }
}
export function patchStaffLayout(base: StaffLayout, builder: (build: IStaffLayoutBuilder) => IStaffLayoutBuilder): IAny[] { return builder(new StaffLayoutBuilder(base)).patch(); }
export function buildStaffLayout(builder: (build: IStaffLayoutBuilder) => IStaffLayoutBuilder): StaffLayout { return builder(new StaffLayoutBuilder()).build(); }

export interface IMeasureLayoutBuilder {
  build?: () => MeasureLayout;
  patch: () => IAny[];
  measureDistance: (measureDistance: number) => IMeasureLayoutBuilder;
}

class MeasureLayoutBuilder implements IMeasureLayoutBuilder {
  build: () => MeasureLayout;
  patch: () => IAny[];
  measureDistance: (measureDistance: number) => IMeasureLayoutBuilder;
  constructor(original?: MeasureLayout) {
    let updates: MeasureLayout = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): MeasureLayout => {
        checkInvariants();
        (updates as any)._class = "MeasureLayout";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.measureDistance = (spec: number): IMeasureLayoutBuilder => {
        updates["measureDistance"] = spec;
        delete childBuilders["measureDistance;"];
        modifiedKeys["measureDistance"] = true;
        return this;
    }
  }
}
export function patchMeasureLayout(base: MeasureLayout, builder: (build: IMeasureLayoutBuilder) => IMeasureLayoutBuilder): IAny[] { return builder(new MeasureLayoutBuilder(base)).patch(); }
export function buildMeasureLayout(builder: (build: IMeasureLayoutBuilder) => IMeasureLayoutBuilder): MeasureLayout { return builder(new MeasureLayoutBuilder()).build(); }

export interface ILineWidthBuilder {
  build?: () => LineWidth;
  patch: () => IAny[];
  tenths: (tenths: number) => ILineWidthBuilder;
  type: (type: string) => ILineWidthBuilder;
}

class LineWidthBuilder implements ILineWidthBuilder {
  build: () => LineWidth;
  patch: () => IAny[];
  tenths: (tenths: number) => ILineWidthBuilder;
  type: (type: string) => ILineWidthBuilder;
  constructor(original?: LineWidth) {
    let updates: LineWidth = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["tenths"]) ||
          childBuilders["tenths"] !== undefined ||
          updates.tenths !== undefined,
        "tenths is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): LineWidth => {
        checkInvariants();
        (updates as any)._class = "LineWidth";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.tenths = (spec: number): ILineWidthBuilder => {
        updates["tenths"] = spec;
        delete childBuilders["tenths;"];
        modifiedKeys["tenths"] = true;
        return this;
    }

    this.type = (spec: string): ILineWidthBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }
  }
}
export function patchLineWidth(base: LineWidth, builder: (build: ILineWidthBuilder) => ILineWidthBuilder): IAny[] { return builder(new LineWidthBuilder(base)).patch(); }
export function buildLineWidth(builder: (build: ILineWidthBuilder) => ILineWidthBuilder): LineWidth { return builder(new LineWidthBuilder()).build(); }

export interface INoteSizeBuilder {
  build?: () => NoteSize;
  patch: () => IAny[];
  size: (size: number) => INoteSizeBuilder;
  type: (type: CueGraceLarge) => INoteSizeBuilder;
}

class NoteSizeBuilder implements INoteSizeBuilder {
  build: () => NoteSize;
  patch: () => IAny[];
  size: (size: number) => INoteSizeBuilder;
  type: (type: CueGraceLarge) => INoteSizeBuilder;
  constructor(original?: NoteSize) {
    let updates: NoteSize = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["size"]) ||
          childBuilders["size"] !== undefined ||
          updates.size !== undefined,
        "size is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): NoteSize => {
        checkInvariants();
        (updates as any)._class = "NoteSize";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.size = (spec: number): INoteSizeBuilder => {
        updates["size"] = spec;
        delete childBuilders["size;"];
        modifiedKeys["size"] = true;
        return this;
    }

    this.type = (spec: CueGraceLarge): INoteSizeBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }
  }
}
export function patchNoteSize(base: NoteSize, builder: (build: INoteSizeBuilder) => INoteSizeBuilder): IAny[] { return builder(new NoteSizeBuilder(base)).patch(); }
export function buildNoteSize(builder: (build: INoteSizeBuilder) => INoteSizeBuilder): NoteSize { return builder(new NoteSizeBuilder()).build(); }

export interface IDistanceBuilder {
  build?: () => Distance;
  patch: () => IAny[];
  tenths: (tenths: number) => IDistanceBuilder;
  type: (type: string) => IDistanceBuilder;
}

class DistanceBuilder implements IDistanceBuilder {
  build: () => Distance;
  patch: () => IAny[];
  tenths: (tenths: number) => IDistanceBuilder;
  type: (type: string) => IDistanceBuilder;
  constructor(original?: Distance) {
    let updates: Distance = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["tenths"]) ||
          childBuilders["tenths"] !== undefined ||
          updates.tenths !== undefined,
        "tenths is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Distance => {
        checkInvariants();
        (updates as any)._class = "Distance";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.tenths = (spec: number): IDistanceBuilder => {
        updates["tenths"] = spec;
        delete childBuilders["tenths;"];
        modifiedKeys["tenths"] = true;
        return this;
    }

    this.type = (spec: string): IDistanceBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }
  }
}
export function patchDistance(base: Distance, builder: (build: IDistanceBuilder) => IDistanceBuilder): IAny[] { return builder(new DistanceBuilder(base)).patch(); }
export function buildDistance(builder: (build: IDistanceBuilder) => IDistanceBuilder): Distance { return builder(new DistanceBuilder()).build(); }

export interface IAppearanceBuilder {
  build?: () => Appearance;
  patch: () => IAny[];
  set: (key: string, val: NoteSize) => IAppearanceBuilder;
  otherAppearances: (otherAppearances: string[]) => IAppearanceBuilder;
}

class AppearanceBuilder implements IAppearanceBuilder {
  build: () => Appearance;
  patch: () => IAny[];
  set: (key: string, val: NoteSize) => IAppearanceBuilder;
  otherAppearances: (otherAppearances: string[]) => IAppearanceBuilder;
  constructor(original?: Appearance) {
    let updates: Appearance = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Appearance => {
        checkInvariants();
        (updates as any)._class = "Appearance";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
    this.set = (key: string, val: NoteSize): IAppearanceBuilder => {
      updates[key] = val;
      modifiedKeys[key] = true;
      return this;
    }

    this.otherAppearances = (spec: string[]): IAppearanceBuilder => {
        updates["otherAppearances"] = spec;
        delete childBuilders["otherAppearances;"];
        modifiedKeys["otherAppearances"] = true;
        return this;
    }
  }
}
export function patchAppearance(base: Appearance, builder: (build: IAppearanceBuilder) => IAppearanceBuilder): IAny[] { return builder(new AppearanceBuilder(base)).patch(); }
export function buildAppearance(builder: (build: IAppearanceBuilder) => IAppearanceBuilder): Appearance { return builder(new AppearanceBuilder()).build(); }

export interface ICreatorBuilder {
  build?: () => Creator;
  patch: () => IAny[];
  creator: (creator: string) => ICreatorBuilder;
  type: (type: string) => ICreatorBuilder;
}

class CreatorBuilder implements ICreatorBuilder {
  build: () => Creator;
  patch: () => IAny[];
  creator: (creator: string) => ICreatorBuilder;
  type: (type: string) => ICreatorBuilder;
  constructor(original?: Creator) {
    let updates: Creator = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["creator"]) ||
          childBuilders["creator"] !== undefined ||
          updates.creator !== undefined,
        "creator is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Creator => {
        checkInvariants();
        (updates as any)._class = "Creator";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.creator = (spec: string): ICreatorBuilder => {
        updates["creator"] = spec;
        delete childBuilders["creator;"];
        modifiedKeys["creator"] = true;
        return this;
    }

    this.type = (spec: string): ICreatorBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }
  }
}
export function patchCreator(base: Creator, builder: (build: ICreatorBuilder) => ICreatorBuilder): IAny[] { return builder(new CreatorBuilder(base)).patch(); }
export function buildCreator(builder: (build: ICreatorBuilder) => ICreatorBuilder): Creator { return builder(new CreatorBuilder()).build(); }

export interface IRightsBuilder {
  build?: () => Rights;
  patch: () => IAny[];
  type: (type: string) => IRightsBuilder;
  rights: (rights: string) => IRightsBuilder;
}

class RightsBuilder implements IRightsBuilder {
  build: () => Rights;
  patch: () => IAny[];
  type: (type: string) => IRightsBuilder;
  rights: (rights: string) => IRightsBuilder;
  constructor(original?: Rights) {
    let updates: Rights = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
      console.assert(
          (original && !modifiedKeys["rights"]) ||
          childBuilders["rights"] !== undefined ||
          updates.rights !== undefined,
        "rights is a required field");
    }

    if (!original) {
      this.build = (): Rights => {
        checkInvariants();
        (updates as any)._class = "Rights";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.type = (spec: string): IRightsBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.rights = (spec: string): IRightsBuilder => {
        updates["rights"] = spec;
        delete childBuilders["rights;"];
        modifiedKeys["rights"] = true;
        return this;
    }
  }
}
export function patchRights(base: Rights, builder: (build: IRightsBuilder) => IRightsBuilder): IAny[] { return builder(new RightsBuilder(base)).patch(); }
export function buildRights(builder: (build: IRightsBuilder) => IRightsBuilder): Rights { return builder(new RightsBuilder()).build(); }

export interface IEncoderBuilder {
  build?: () => Encoder;
  patch: () => IAny[];
  encoder: (encoder: string) => IEncoderBuilder;
  type: (type: string) => IEncoderBuilder;
}

class EncoderBuilder implements IEncoderBuilder {
  build: () => Encoder;
  patch: () => IAny[];
  encoder: (encoder: string) => IEncoderBuilder;
  type: (type: string) => IEncoderBuilder;
  constructor(original?: Encoder) {
    let updates: Encoder = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["encoder"]) ||
          childBuilders["encoder"] !== undefined ||
          updates.encoder !== undefined,
        "encoder is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Encoder => {
        checkInvariants();
        (updates as any)._class = "Encoder";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.encoder = (spec: string): IEncoderBuilder => {
        updates["encoder"] = spec;
        delete childBuilders["encoder;"];
        modifiedKeys["encoder"] = true;
        return this;
    }

    this.type = (spec: string): IEncoderBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }
  }
}
export function patchEncoder(base: Encoder, builder: (build: IEncoderBuilder) => IEncoderBuilder): IAny[] { return builder(new EncoderBuilder(base)).patch(); }
export function buildEncoder(builder: (build: IEncoderBuilder) => IEncoderBuilder): Encoder { return builder(new EncoderBuilder()).build(); }

export interface IRelationBuilder {
  build?: () => Relation;
  patch: () => IAny[];
  type: (type: string) => IRelationBuilder;
  data: (data: string) => IRelationBuilder;
}

class RelationBuilder implements IRelationBuilder {
  build: () => Relation;
  patch: () => IAny[];
  type: (type: string) => IRelationBuilder;
  data: (data: string) => IRelationBuilder;
  constructor(original?: Relation) {
    let updates: Relation = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): Relation => {
        checkInvariants();
        (updates as any)._class = "Relation";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.type = (spec: string): IRelationBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.data = (spec: string): IRelationBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }
  }
}
export function patchRelation(base: Relation, builder: (build: IRelationBuilder) => IRelationBuilder): IAny[] { return builder(new RelationBuilder(base)).patch(); }
export function buildRelation(builder: (build: IRelationBuilder) => IRelationBuilder): Relation { return builder(new RelationBuilder()).build(); }

export interface IMiscellaneousFieldBuilder {
  build?: () => MiscellaneousField;
  patch: () => IAny[];
  data: (data: string) => IMiscellaneousFieldBuilder;
  name: (name: string) => IMiscellaneousFieldBuilder;
}

class MiscellaneousFieldBuilder implements IMiscellaneousFieldBuilder {
  build: () => MiscellaneousField;
  patch: () => IAny[];
  data: (data: string) => IMiscellaneousFieldBuilder;
  name: (name: string) => IMiscellaneousFieldBuilder;
  constructor(original?: MiscellaneousField) {
    let updates: MiscellaneousField = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
      console.assert(
          (original && !modifiedKeys["name"]) ||
          childBuilders["name"] !== undefined ||
          updates.name !== undefined,
        "name is a required field");
    }

    if (!original) {
      this.build = (): MiscellaneousField => {
        checkInvariants();
        (updates as any)._class = "MiscellaneousField";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IMiscellaneousFieldBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.name = (spec: string): IMiscellaneousFieldBuilder => {
        updates["name"] = spec;
        delete childBuilders["name;"];
        modifiedKeys["name"] = true;
        return this;
    }
  }
}
export function patchMiscellaneousField(base: MiscellaneousField, builder: (build: IMiscellaneousFieldBuilder) => IMiscellaneousFieldBuilder): IAny[] { return builder(new MiscellaneousFieldBuilder(base)).patch(); }
export function buildMiscellaneousField(builder: (build: IMiscellaneousFieldBuilder) => IMiscellaneousFieldBuilder): MiscellaneousField { return builder(new MiscellaneousFieldBuilder()).build(); }

export interface IMiscellaneousBuilder {
  build?: () => Miscellaneous;
  patch: () => IAny[];
  miscellaneousFieldsAt: (idx: number, build: MiscellaneousField | ((builder: IMiscellaneousFieldBuilder) => IMiscellaneousFieldBuilder)) => IMiscellaneousBuilder;
  miscellaneousFieldsSplice: (start: number, deleteCount: number, ...items: MiscellaneousField[]) => IMiscellaneousBuilder;
  miscellaneousFields: (miscellaneousFields: MiscellaneousField[]) => IMiscellaneousBuilder;
}

class MiscellaneousBuilder implements IMiscellaneousBuilder {
  build: () => Miscellaneous;
  patch: () => IAny[];
  miscellaneousFieldsAt: (idx: number, build: MiscellaneousField | ((builder: IMiscellaneousFieldBuilder) => IMiscellaneousFieldBuilder)) => IMiscellaneousBuilder;
  miscellaneousFieldsSplice: (start: number, deleteCount: number, ...items: MiscellaneousField[]) => IMiscellaneousBuilder;
  miscellaneousFields: (miscellaneousFields: MiscellaneousField[]) => IMiscellaneousBuilder;
  constructor(original?: Miscellaneous) {
    let updates: Miscellaneous = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Miscellaneous => {
        checkInvariants();
        (updates as any)._class = "Miscellaneous";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.miscellaneousFields = (spec: MiscellaneousField[]): IMiscellaneousBuilder => {
        updates["miscellaneousFields"] = spec;
        delete childBuilders["miscellaneousFields;"];
        modifiedKeys["miscellaneousFields"] = true;
        return this;
    }

    this.miscellaneousFieldsAt = (idx: number, build: MiscellaneousField | ((builder: IMiscellaneousFieldBuilder) => IMiscellaneousFieldBuilder)): IMiscellaneousBuilder => {
      makeReference("miscellaneousFields");
      if (frozen["miscellaneousFields"][idx]) {
          throw new Error("Patching miscellaneousFields." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["miscellaneousFields"] && !original["miscellaneousFields"]) {
          // Clone snapshot.
          patches.push({p: ["miscellaneousFields", idx], li: original._snapshot["miscellaneousFields"]});
      }
      if (typeof build === 'function' && reference["miscellaneousFields"][idx]) {
        let patch = (build as any)(new MiscellaneousFieldBuilder(reference["miscellaneousFields"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["miscellaneousFields", idx].concat(patch.p);
          return patch;
        }));
        frozen["miscellaneousFields"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new MiscellaneousFieldBuilder(reference["miscellaneousFields"][idx])).build() : build;
      if (original) {
        patches.push({p: ["miscellaneousFields", idx], li: update});
      } else {
        updates["miscellaneousFields"] = reference["miscellaneousFields"]; // TODO: Merge?
      } 
      reference["miscellaneousFields"][idx] = update;
      frozen["miscellaneousFields"][idx] = true;
      return this;
    }

    this.miscellaneousFieldsSplice = (start: number, deleteCount: number, ...items: MiscellaneousField[]): IMiscellaneousBuilder => {
      makeReference("miscellaneousFields");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["miscellaneousFields"][idx]) {
            throw new Error("Replacing miscellaneousFields." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["miscellaneousFields"][idx];
          patches.push({p: ["miscellaneousFields", idx], ld, li: items[idx - start]});
          frozen["miscellaneousFields"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["miscellaneousFields"][idx]) {
            throw new Error("Removing miscellaneousFields." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["miscellaneousFields"][idx];
          patches.push({p: ["miscellaneousFields", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["miscellaneousFields", idx], li: items[idx - start]});
          frozen["miscellaneousFields"][idx] = true;
        }
      }
      reference["miscellaneousFields"].splice(start, deleteCount, ...items);
      updates["miscellaneousFields"] = reference["miscellaneousFields"];
      frozen["miscellaneousFields"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }
  }
}
export function patchMiscellaneous(base: Miscellaneous, builder: (build: IMiscellaneousBuilder) => IMiscellaneousBuilder): IAny[] { return builder(new MiscellaneousBuilder(base)).patch(); }
export function buildMiscellaneous(builder: (build: IMiscellaneousBuilder) => IMiscellaneousBuilder): Miscellaneous { return builder(new MiscellaneousBuilder()).build(); }

export interface IIdentificationBuilder {
  build?: () => Identification;
  patch: () => IAny[];
  miscellaneous: (build: Miscellaneous | ((builder: IMiscellaneousBuilder) => IMiscellaneousBuilder)) => IIdentificationBuilder;
  creatorsAt: (idx: number, build: Creator | ((builder: ICreatorBuilder) => ICreatorBuilder)) => IIdentificationBuilder;
  creatorsSplice: (start: number, deleteCount: number, ...items: Creator[]) => IIdentificationBuilder;
  creators: (creators: Creator[]) => IIdentificationBuilder;
  relationsAt: (idx: number, build: Relation | ((builder: IRelationBuilder) => IRelationBuilder)) => IIdentificationBuilder;
  relationsSplice: (start: number, deleteCount: number, ...items: Relation[]) => IIdentificationBuilder;
  relations: (relations: Relation[]) => IIdentificationBuilder;
  rightsAt: (idx: number, build: Rights | ((builder: IRightsBuilder) => IRightsBuilder)) => IIdentificationBuilder;
  rightsSplice: (start: number, deleteCount: number, ...items: Rights[]) => IIdentificationBuilder;
  rights: (rights: Rights[]) => IIdentificationBuilder;
  encoding: (build: Encoding | ((builder: IEncodingBuilder) => IEncodingBuilder)) => IIdentificationBuilder;
  source: (source: string) => IIdentificationBuilder;
}

class IdentificationBuilder implements IIdentificationBuilder {
  build: () => Identification;
  patch: () => IAny[];
  miscellaneous: (build: Miscellaneous | ((builder: IMiscellaneousBuilder) => IMiscellaneousBuilder)) => IIdentificationBuilder;
  creatorsAt: (idx: number, build: Creator | ((builder: ICreatorBuilder) => ICreatorBuilder)) => IIdentificationBuilder;
  creatorsSplice: (start: number, deleteCount: number, ...items: Creator[]) => IIdentificationBuilder;
  creators: (creators: Creator[]) => IIdentificationBuilder;
  relationsAt: (idx: number, build: Relation | ((builder: IRelationBuilder) => IRelationBuilder)) => IIdentificationBuilder;
  relationsSplice: (start: number, deleteCount: number, ...items: Relation[]) => IIdentificationBuilder;
  relations: (relations: Relation[]) => IIdentificationBuilder;
  rightsAt: (idx: number, build: Rights | ((builder: IRightsBuilder) => IRightsBuilder)) => IIdentificationBuilder;
  rightsSplice: (start: number, deleteCount: number, ...items: Rights[]) => IIdentificationBuilder;
  rights: (rights: Rights[]) => IIdentificationBuilder;
  encoding: (build: Encoding | ((builder: IEncodingBuilder) => IEncodingBuilder)) => IIdentificationBuilder;
  source: (source: string) => IIdentificationBuilder;
  constructor(original?: Identification) {
    let updates: Identification = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Identification => {
        checkInvariants();
        (updates as any)._class = "Identification";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.miscellaneous = (build: Miscellaneous | ((builder: IMiscellaneousBuilder) => IMiscellaneousBuilder)): IIdentificationBuilder => {
      if (typeof build === 'function') {
        delete updates["miscellaneous"]
        const builder = (build as any)(new MiscellaneousBuilder(original && original["miscellaneous"]));
        if (!original) updates["miscellaneous"] = builder.build();
        else childBuilders["miscellaneous"] = builder;
      } else {
        updates.miscellaneous = build as any;
        delete childBuilders["miscellaneous;"];
      }
      modifiedKeys["miscellaneous"] = true;
      return this;
    }

    this.creators = (spec: Creator[]): IIdentificationBuilder => {
        updates["creators"] = spec;
        delete childBuilders["creators;"];
        modifiedKeys["creators"] = true;
        return this;
    }

    this.creatorsAt = (idx: number, build: Creator | ((builder: ICreatorBuilder) => ICreatorBuilder)): IIdentificationBuilder => {
      makeReference("creators");
      if (frozen["creators"][idx]) {
          throw new Error("Patching creators." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["creators"] && !original["creators"]) {
          // Clone snapshot.
          patches.push({p: ["creators", idx], li: original._snapshot["creators"]});
      }
      if (typeof build === 'function' && reference["creators"][idx]) {
        let patch = (build as any)(new CreatorBuilder(reference["creators"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["creators", idx].concat(patch.p);
          return patch;
        }));
        frozen["creators"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new CreatorBuilder(reference["creators"][idx])).build() : build;
      if (original) {
        patches.push({p: ["creators", idx], li: update});
      } else {
        updates["creators"] = reference["creators"]; // TODO: Merge?
      } 
      reference["creators"][idx] = update;
      frozen["creators"][idx] = true;
      return this;
    }

    this.creatorsSplice = (start: number, deleteCount: number, ...items: Creator[]): IIdentificationBuilder => {
      makeReference("creators");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["creators"][idx]) {
            throw new Error("Replacing creators." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["creators"][idx];
          patches.push({p: ["creators", idx], ld, li: items[idx - start]});
          frozen["creators"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["creators"][idx]) {
            throw new Error("Removing creators." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["creators"][idx];
          patches.push({p: ["creators", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["creators", idx], li: items[idx - start]});
          frozen["creators"][idx] = true;
        }
      }
      reference["creators"].splice(start, deleteCount, ...items);
      updates["creators"] = reference["creators"];
      frozen["creators"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.relations = (spec: Relation[]): IIdentificationBuilder => {
        updates["relations"] = spec;
        delete childBuilders["relations;"];
        modifiedKeys["relations"] = true;
        return this;
    }

    this.relationsAt = (idx: number, build: Relation | ((builder: IRelationBuilder) => IRelationBuilder)): IIdentificationBuilder => {
      makeReference("relations");
      if (frozen["relations"][idx]) {
          throw new Error("Patching relations." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["relations"] && !original["relations"]) {
          // Clone snapshot.
          patches.push({p: ["relations", idx], li: original._snapshot["relations"]});
      }
      if (typeof build === 'function' && reference["relations"][idx]) {
        let patch = (build as any)(new RelationBuilder(reference["relations"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["relations", idx].concat(patch.p);
          return patch;
        }));
        frozen["relations"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new RelationBuilder(reference["relations"][idx])).build() : build;
      if (original) {
        patches.push({p: ["relations", idx], li: update});
      } else {
        updates["relations"] = reference["relations"]; // TODO: Merge?
      } 
      reference["relations"][idx] = update;
      frozen["relations"][idx] = true;
      return this;
    }

    this.relationsSplice = (start: number, deleteCount: number, ...items: Relation[]): IIdentificationBuilder => {
      makeReference("relations");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["relations"][idx]) {
            throw new Error("Replacing relations." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["relations"][idx];
          patches.push({p: ["relations", idx], ld, li: items[idx - start]});
          frozen["relations"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["relations"][idx]) {
            throw new Error("Removing relations." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["relations"][idx];
          patches.push({p: ["relations", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["relations", idx], li: items[idx - start]});
          frozen["relations"][idx] = true;
        }
      }
      reference["relations"].splice(start, deleteCount, ...items);
      updates["relations"] = reference["relations"];
      frozen["relations"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.rights = (spec: Rights[]): IIdentificationBuilder => {
        updates["rights"] = spec;
        delete childBuilders["rights;"];
        modifiedKeys["rights"] = true;
        return this;
    }

    this.rightsAt = (idx: number, build: Rights | ((builder: IRightsBuilder) => IRightsBuilder)): IIdentificationBuilder => {
      makeReference("rights");
      if (frozen["rights"][idx]) {
          throw new Error("Patching rights." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["rights"] && !original["rights"]) {
          // Clone snapshot.
          patches.push({p: ["rights", idx], li: original._snapshot["rights"]});
      }
      if (typeof build === 'function' && reference["rights"][idx]) {
        let patch = (build as any)(new RightsBuilder(reference["rights"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["rights", idx].concat(patch.p);
          return patch;
        }));
        frozen["rights"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new RightsBuilder(reference["rights"][idx])).build() : build;
      if (original) {
        patches.push({p: ["rights", idx], li: update});
      } else {
        updates["rights"] = reference["rights"]; // TODO: Merge?
      } 
      reference["rights"][idx] = update;
      frozen["rights"][idx] = true;
      return this;
    }

    this.rightsSplice = (start: number, deleteCount: number, ...items: Rights[]): IIdentificationBuilder => {
      makeReference("rights");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["rights"][idx]) {
            throw new Error("Replacing rights." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["rights"][idx];
          patches.push({p: ["rights", idx], ld, li: items[idx - start]});
          frozen["rights"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["rights"][idx]) {
            throw new Error("Removing rights." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["rights"][idx];
          patches.push({p: ["rights", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["rights", idx], li: items[idx - start]});
          frozen["rights"][idx] = true;
        }
      }
      reference["rights"].splice(start, deleteCount, ...items);
      updates["rights"] = reference["rights"];
      frozen["rights"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.encoding = (build: Encoding | ((builder: IEncodingBuilder) => IEncodingBuilder)): IIdentificationBuilder => {
      if (typeof build === 'function') {
        delete updates["encoding"]
        const builder = (build as any)(new EncodingBuilder(original && original["encoding"]));
        if (!original) updates["encoding"] = builder.build();
        else childBuilders["encoding"] = builder;
      } else {
        updates.encoding = build as any;
        delete childBuilders["encoding;"];
      }
      modifiedKeys["encoding"] = true;
      return this;
    }

    this.source = (spec: string): IIdentificationBuilder => {
        updates["source"] = spec;
        delete childBuilders["source;"];
        modifiedKeys["source"] = true;
        return this;
    }
  }
}
export function patchIdentification(base: Identification, builder: (build: IIdentificationBuilder) => IIdentificationBuilder): IAny[] { return builder(new IdentificationBuilder(base)).patch(); }
export function buildIdentification(builder: (build: IIdentificationBuilder) => IIdentificationBuilder): Identification { return builder(new IdentificationBuilder()).build(); }

export interface ISupportsBuilder {
  build?: () => Supports;
  patch: () => IAny[];
  element: (element: string) => ISupportsBuilder;
  attribute: (attribute: string) => ISupportsBuilder;
  value: (value: string) => ISupportsBuilder;
  type: (type: boolean) => ISupportsBuilder;
}

class SupportsBuilder implements ISupportsBuilder {
  build: () => Supports;
  patch: () => IAny[];
  element: (element: string) => ISupportsBuilder;
  attribute: (attribute: string) => ISupportsBuilder;
  value: (value: string) => ISupportsBuilder;
  type: (type: boolean) => ISupportsBuilder;
  constructor(original?: Supports) {
    let updates: Supports = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["element"]) ||
          childBuilders["element"] !== undefined ||
          updates.element !== undefined,
        "element is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Supports => {
        checkInvariants();
        (updates as any)._class = "Supports";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.element = (spec: string): ISupportsBuilder => {
        updates["element"] = spec;
        delete childBuilders["element;"];
        modifiedKeys["element"] = true;
        return this;
    }

    this.attribute = (spec: string): ISupportsBuilder => {
        updates["attribute"] = spec;
        delete childBuilders["attribute;"];
        modifiedKeys["attribute"] = true;
        return this;
    }

    this.value = (spec: string): ISupportsBuilder => {
        updates["value"] = spec;
        delete childBuilders["value;"];
        modifiedKeys["value"] = true;
        return this;
    }

    this.type = (spec: boolean): ISupportsBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }
  }
}
export function patchSupports(base: Supports, builder: (build: ISupportsBuilder) => ISupportsBuilder): IAny[] { return builder(new SupportsBuilder(base)).patch(); }
export function buildSupports(builder: (build: ISupportsBuilder) => ISupportsBuilder): Supports { return builder(new SupportsBuilder()).build(); }

export interface IEncodingBuilder {
  build?: () => Encoding;
  patch: () => IAny[];
  encodingDescriptions: (encodingDescriptions: string[]) => IEncodingBuilder;
  encodingDate: (build: EncodingDate | ((builder: IEncodingDateBuilder) => IEncodingDateBuilder)) => IEncodingBuilder;
  set: (key: string, val: Supports) => IEncodingBuilder;
  encodersAt: (idx: number, build: Encoder | ((builder: IEncoderBuilder) => IEncoderBuilder)) => IEncodingBuilder;
  encodersSplice: (start: number, deleteCount: number, ...items: Encoder[]) => IEncodingBuilder;
  encoders: (encoders: Encoder[]) => IEncodingBuilder;
  softwares: (softwares: string[]) => IEncodingBuilder;
}

class EncodingBuilder implements IEncodingBuilder {
  build: () => Encoding;
  patch: () => IAny[];
  encodingDescriptions: (encodingDescriptions: string[]) => IEncodingBuilder;
  encodingDate: (build: EncodingDate | ((builder: IEncodingDateBuilder) => IEncodingDateBuilder)) => IEncodingBuilder;
  set: (key: string, val: Supports) => IEncodingBuilder;
  encodersAt: (idx: number, build: Encoder | ((builder: IEncoderBuilder) => IEncoderBuilder)) => IEncodingBuilder;
  encodersSplice: (start: number, deleteCount: number, ...items: Encoder[]) => IEncodingBuilder;
  encoders: (encoders: Encoder[]) => IEncodingBuilder;
  softwares: (softwares: string[]) => IEncodingBuilder;
  constructor(original?: Encoding) {
    let updates: Encoding = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Encoding => {
        checkInvariants();
        (updates as any)._class = "Encoding";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.encodingDescriptions = (spec: string[]): IEncodingBuilder => {
        updates["encodingDescriptions"] = spec;
        delete childBuilders["encodingDescriptions;"];
        modifiedKeys["encodingDescriptions"] = true;
        return this;
    }

    this.encodingDate = (build: EncodingDate | ((builder: IEncodingDateBuilder) => IEncodingDateBuilder)): IEncodingBuilder => {
      if (typeof build === 'function') {
        delete updates["encodingDate"]
        const builder = (build as any)(new EncodingDateBuilder(original && original["encodingDate"]));
        if (!original) updates["encodingDate"] = builder.build();
        else childBuilders["encodingDate"] = builder;
      } else {
        updates.encodingDate = build as any;
        delete childBuilders["encodingDate;"];
      }
      modifiedKeys["encodingDate"] = true;
      return this;
    }
    this.set = (key: string, val: Supports): IEncodingBuilder => {
      updates[key] = val;
      modifiedKeys[key] = true;
      return this;
    }

    this.encoders = (spec: Encoder[]): IEncodingBuilder => {
        updates["encoders"] = spec;
        delete childBuilders["encoders;"];
        modifiedKeys["encoders"] = true;
        return this;
    }

    this.encodersAt = (idx: number, build: Encoder | ((builder: IEncoderBuilder) => IEncoderBuilder)): IEncodingBuilder => {
      makeReference("encoders");
      if (frozen["encoders"][idx]) {
          throw new Error("Patching encoders." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["encoders"] && !original["encoders"]) {
          // Clone snapshot.
          patches.push({p: ["encoders", idx], li: original._snapshot["encoders"]});
      }
      if (typeof build === 'function' && reference["encoders"][idx]) {
        let patch = (build as any)(new EncoderBuilder(reference["encoders"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["encoders", idx].concat(patch.p);
          return patch;
        }));
        frozen["encoders"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new EncoderBuilder(reference["encoders"][idx])).build() : build;
      if (original) {
        patches.push({p: ["encoders", idx], li: update});
      } else {
        updates["encoders"] = reference["encoders"]; // TODO: Merge?
      } 
      reference["encoders"][idx] = update;
      frozen["encoders"][idx] = true;
      return this;
    }

    this.encodersSplice = (start: number, deleteCount: number, ...items: Encoder[]): IEncodingBuilder => {
      makeReference("encoders");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["encoders"][idx]) {
            throw new Error("Replacing encoders." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["encoders"][idx];
          patches.push({p: ["encoders", idx], ld, li: items[idx - start]});
          frozen["encoders"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["encoders"][idx]) {
            throw new Error("Removing encoders." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["encoders"][idx];
          patches.push({p: ["encoders", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["encoders", idx], li: items[idx - start]});
          frozen["encoders"][idx] = true;
        }
      }
      reference["encoders"].splice(start, deleteCount, ...items);
      updates["encoders"] = reference["encoders"];
      frozen["encoders"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.softwares = (spec: string[]): IEncodingBuilder => {
        updates["softwares"] = spec;
        delete childBuilders["softwares;"];
        modifiedKeys["softwares"] = true;
        return this;
    }
  }
}
export function patchEncoding(base: Encoding, builder: (build: IEncodingBuilder) => IEncodingBuilder): IAny[] { return builder(new EncodingBuilder(base)).patch(); }
export function buildEncoding(builder: (build: IEncodingBuilder) => IEncodingBuilder): Encoding { return builder(new EncodingBuilder()).build(); }

export interface ITimeSeparatorBuilder {
  build?: () => TimeSeparator;
  patch: () => IAny[];
  separator: (separator: SeparatorType) => ITimeSeparatorBuilder;
}

class TimeSeparatorBuilder implements ITimeSeparatorBuilder {
  build: () => TimeSeparator;
  patch: () => IAny[];
  separator: (separator: SeparatorType) => ITimeSeparatorBuilder;
  constructor(original?: TimeSeparator) {
    let updates: TimeSeparator = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): TimeSeparator => {
        checkInvariants();
        (updates as any)._class = "TimeSeparator";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.separator = (spec: SeparatorType): ITimeSeparatorBuilder => {
        updates["separator"] = spec;
        delete childBuilders["separator;"];
        modifiedKeys["separator"] = true;
        return this;
    }
  }
}
export function patchTimeSeparator(base: TimeSeparator, builder: (build: ITimeSeparatorBuilder) => ITimeSeparatorBuilder): IAny[] { return builder(new TimeSeparatorBuilder(base)).patch(); }
export function buildTimeSeparator(builder: (build: ITimeSeparatorBuilder) => ITimeSeparatorBuilder): TimeSeparator { return builder(new TimeSeparatorBuilder()).build(); }

export interface ITimeSymbolBuilder {
  build?: () => TimeSymbol;
  patch: () => IAny[];
  symbol: (symbol: TimeSymbolType) => ITimeSymbolBuilder;
}

class TimeSymbolBuilder implements ITimeSymbolBuilder {
  build: () => TimeSymbol;
  patch: () => IAny[];
  symbol: (symbol: TimeSymbolType) => ITimeSymbolBuilder;
  constructor(original?: TimeSymbol) {
    let updates: TimeSymbol = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): TimeSymbol => {
        checkInvariants();
        (updates as any)._class = "TimeSymbol";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.symbol = (spec: TimeSymbolType): ITimeSymbolBuilder => {
        updates["symbol"] = spec;
        delete childBuilders["symbol;"];
        modifiedKeys["symbol"] = true;
        return this;
    }
  }
}
export function patchTimeSymbol(base: TimeSymbol, builder: (build: ITimeSymbolBuilder) => ITimeSymbolBuilder): IAny[] { return builder(new TimeSymbolBuilder(base)).patch(); }
export function buildTimeSymbol(builder: (build: ITimeSymbolBuilder) => ITimeSymbolBuilder): TimeSymbol { return builder(new TimeSymbolBuilder()).build(); }

export interface ICancelBuilder {
  build?: () => Cancel;
  patch: () => IAny[];
  fifths: (fifths: number) => ICancelBuilder;
  location: (location: CancelLocation) => ICancelBuilder;
}

class CancelBuilder implements ICancelBuilder {
  build: () => Cancel;
  patch: () => IAny[];
  fifths: (fifths: number) => ICancelBuilder;
  location: (location: CancelLocation) => ICancelBuilder;
  constructor(original?: Cancel) {
    let updates: Cancel = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["fifths"]) ||
          childBuilders["fifths"] !== undefined ||
          updates.fifths !== undefined,
        "fifths is a required field");
    }

    if (!original) {
      this.build = (): Cancel => {
        checkInvariants();
        (updates as any)._class = "Cancel";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.fifths = (spec: number): ICancelBuilder => {
        updates["fifths"] = spec;
        delete childBuilders["fifths;"];
        modifiedKeys["fifths"] = true;
        return this;
    }

    this.location = (spec: CancelLocation): ICancelBuilder => {
        updates["location"] = spec;
        delete childBuilders["location;"];
        modifiedKeys["location"] = true;
        return this;
    }
  }
}
export function patchCancel(base: Cancel, builder: (build: ICancelBuilder) => ICancelBuilder): IAny[] { return builder(new CancelBuilder(base)).patch(); }
export function buildCancel(builder: (build: ICancelBuilder) => ICancelBuilder): Cancel { return builder(new CancelBuilder()).build(); }

export interface IKeyOctaveBuilder {
  build?: () => KeyOctave;
  patch: () => IAny[];
  octave: (octave: number) => IKeyOctaveBuilder;
  number: (number: number) => IKeyOctaveBuilder;
  cancel: (cancel: boolean) => IKeyOctaveBuilder;
}

class KeyOctaveBuilder implements IKeyOctaveBuilder {
  build: () => KeyOctave;
  patch: () => IAny[];
  octave: (octave: number) => IKeyOctaveBuilder;
  number: (number: number) => IKeyOctaveBuilder;
  cancel: (cancel: boolean) => IKeyOctaveBuilder;
  constructor(original?: KeyOctave) {
    let updates: KeyOctave = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["octave"]) ||
          childBuilders["octave"] !== undefined ||
          updates.octave !== undefined,
        "octave is a required field");
      console.assert(
          (original && !modifiedKeys["number"]) ||
          childBuilders["number"] !== undefined ||
          updates.number !== undefined,
        "number is a required field");
    }

    if (!original) {
      this.build = (): KeyOctave => {
        checkInvariants();
        (updates as any)._class = "KeyOctave";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.octave = (spec: number): IKeyOctaveBuilder => {
        updates["octave"] = spec;
        delete childBuilders["octave;"];
        modifiedKeys["octave"] = true;
        return this;
    }

    this.number = (spec: number): IKeyOctaveBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.cancel = (spec: boolean): IKeyOctaveBuilder => {
        updates["cancel"] = spec;
        delete childBuilders["cancel;"];
        modifiedKeys["cancel"] = true;
        return this;
    }
  }
}
export function patchKeyOctave(base: KeyOctave, builder: (build: IKeyOctaveBuilder) => IKeyOctaveBuilder): IAny[] { return builder(new KeyOctaveBuilder(base)).patch(); }
export function buildKeyOctave(builder: (build: IKeyOctaveBuilder) => IKeyOctaveBuilder): KeyOctave { return builder(new KeyOctaveBuilder()).build(); }

export interface IKeyBuilder {
  build?: () => Key;
  patch: () => IAny[];
  cancel: (build: Cancel | ((builder: ICancelBuilder) => ICancelBuilder)) => IKeyBuilder;
  keySteps: (keySteps: string[]) => IKeyBuilder;
  keyOctavesAt: (idx: number, build: KeyOctave | ((builder: IKeyOctaveBuilder) => IKeyOctaveBuilder)) => IKeyBuilder;
  keyOctavesSplice: (start: number, deleteCount: number, ...items: KeyOctave[]) => IKeyBuilder;
  keyOctaves: (keyOctaves: KeyOctave[]) => IKeyBuilder;
  number: (number: number) => IKeyBuilder;
  fifths: (fifths: number) => IKeyBuilder;
  keyAlters: (keyAlters: string[]) => IKeyBuilder;
  keyAccidentals: (keyAccidentals: string[]) => IKeyBuilder;
  mode: (mode: string) => IKeyBuilder;
  defaultX: (defaultX: number) => IKeyBuilder;
  relativeY: (relativeY: number) => IKeyBuilder;
  defaultY: (defaultY: number) => IKeyBuilder;
  relativeX: (relativeX: number) => IKeyBuilder;
  fontFamily: (fontFamily: string) => IKeyBuilder;
  fontWeight: (fontWeight: NormalBold) => IKeyBuilder;
  fontStyle: (fontStyle: NormalItalic) => IKeyBuilder;
  fontSize: (fontSize: string) => IKeyBuilder;
  color: (color: string) => IKeyBuilder;
  printObject: (printObject: boolean) => IKeyBuilder;
}

class KeyBuilder implements IKeyBuilder {
  build: () => Key;
  patch: () => IAny[];
  cancel: (build: Cancel | ((builder: ICancelBuilder) => ICancelBuilder)) => IKeyBuilder;
  keySteps: (keySteps: string[]) => IKeyBuilder;
  keyOctavesAt: (idx: number, build: KeyOctave | ((builder: IKeyOctaveBuilder) => IKeyOctaveBuilder)) => IKeyBuilder;
  keyOctavesSplice: (start: number, deleteCount: number, ...items: KeyOctave[]) => IKeyBuilder;
  keyOctaves: (keyOctaves: KeyOctave[]) => IKeyBuilder;
  number: (number: number) => IKeyBuilder;
  fifths: (fifths: number) => IKeyBuilder;
  keyAlters: (keyAlters: string[]) => IKeyBuilder;
  keyAccidentals: (keyAccidentals: string[]) => IKeyBuilder;
  mode: (mode: string) => IKeyBuilder;
  defaultX: (defaultX: number) => IKeyBuilder;
  relativeY: (relativeY: number) => IKeyBuilder;
  defaultY: (defaultY: number) => IKeyBuilder;
  relativeX: (relativeX: number) => IKeyBuilder;
  fontFamily: (fontFamily: string) => IKeyBuilder;
  fontWeight: (fontWeight: NormalBold) => IKeyBuilder;
  fontStyle: (fontStyle: NormalItalic) => IKeyBuilder;
  fontSize: (fontSize: string) => IKeyBuilder;
  color: (color: string) => IKeyBuilder;
  printObject: (printObject: boolean) => IKeyBuilder;
  constructor(original?: Key) {
    let updates: Key = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Key => {
        checkInvariants();
        (updates as any)._class = "Key";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.cancel = (build: Cancel | ((builder: ICancelBuilder) => ICancelBuilder)): IKeyBuilder => {
      if (typeof build === 'function') {
        delete updates["cancel"]
        const builder = (build as any)(new CancelBuilder(original && original["cancel"]));
        if (!original) updates["cancel"] = builder.build();
        else childBuilders["cancel"] = builder;
      } else {
        updates.cancel = build as any;
        delete childBuilders["cancel;"];
      }
      modifiedKeys["cancel"] = true;
      return this;
    }

    this.keySteps = (spec: string[]): IKeyBuilder => {
        updates["keySteps"] = spec;
        delete childBuilders["keySteps;"];
        modifiedKeys["keySteps"] = true;
        return this;
    }

    this.keyOctaves = (spec: KeyOctave[]): IKeyBuilder => {
        updates["keyOctaves"] = spec;
        delete childBuilders["keyOctaves;"];
        modifiedKeys["keyOctaves"] = true;
        return this;
    }

    this.keyOctavesAt = (idx: number, build: KeyOctave | ((builder: IKeyOctaveBuilder) => IKeyOctaveBuilder)): IKeyBuilder => {
      makeReference("keyOctaves");
      if (frozen["keyOctaves"][idx]) {
          throw new Error("Patching keyOctaves." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["keyOctaves"] && !original["keyOctaves"]) {
          // Clone snapshot.
          patches.push({p: ["keyOctaves", idx], li: original._snapshot["keyOctaves"]});
      }
      if (typeof build === 'function' && reference["keyOctaves"][idx]) {
        let patch = (build as any)(new KeyOctaveBuilder(reference["keyOctaves"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["keyOctaves", idx].concat(patch.p);
          return patch;
        }));
        frozen["keyOctaves"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new KeyOctaveBuilder(reference["keyOctaves"][idx])).build() : build;
      if (original) {
        patches.push({p: ["keyOctaves", idx], li: update});
      } else {
        updates["keyOctaves"] = reference["keyOctaves"]; // TODO: Merge?
      } 
      reference["keyOctaves"][idx] = update;
      frozen["keyOctaves"][idx] = true;
      return this;
    }

    this.keyOctavesSplice = (start: number, deleteCount: number, ...items: KeyOctave[]): IKeyBuilder => {
      makeReference("keyOctaves");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["keyOctaves"][idx]) {
            throw new Error("Replacing keyOctaves." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["keyOctaves"][idx];
          patches.push({p: ["keyOctaves", idx], ld, li: items[idx - start]});
          frozen["keyOctaves"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["keyOctaves"][idx]) {
            throw new Error("Removing keyOctaves." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["keyOctaves"][idx];
          patches.push({p: ["keyOctaves", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["keyOctaves", idx], li: items[idx - start]});
          frozen["keyOctaves"][idx] = true;
        }
      }
      reference["keyOctaves"].splice(start, deleteCount, ...items);
      updates["keyOctaves"] = reference["keyOctaves"];
      frozen["keyOctaves"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.number = (spec: number): IKeyBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.fifths = (spec: number): IKeyBuilder => {
        updates["fifths"] = spec;
        delete childBuilders["fifths;"];
        modifiedKeys["fifths"] = true;
        return this;
    }

    this.keyAlters = (spec: string[]): IKeyBuilder => {
        updates["keyAlters"] = spec;
        delete childBuilders["keyAlters;"];
        modifiedKeys["keyAlters"] = true;
        return this;
    }

    this.keyAccidentals = (spec: string[]): IKeyBuilder => {
        updates["keyAccidentals"] = spec;
        delete childBuilders["keyAccidentals;"];
        modifiedKeys["keyAccidentals"] = true;
        return this;
    }

    this.mode = (spec: string): IKeyBuilder => {
        updates["mode"] = spec;
        delete childBuilders["mode;"];
        modifiedKeys["mode"] = true;
        return this;
    }

    this.defaultX = (spec: number): IKeyBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IKeyBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IKeyBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IKeyBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IKeyBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IKeyBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IKeyBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IKeyBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IKeyBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.printObject = (spec: boolean): IKeyBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }
  }
}
export function patchKey(base: Key, builder: (build: IKeyBuilder) => IKeyBuilder): IAny[] { return builder(new KeyBuilder(base)).patch(); }
export function buildKey(builder: (build: IKeyBuilder) => IKeyBuilder): Key { return builder(new KeyBuilder()).build(); }

export interface ITimeBuilder {
  build?: () => Time;
  patch: () => IAny[];
  interchangeable: (build: Interchangeable | ((builder: IInterchangeableBuilder) => IInterchangeableBuilder)) => ITimeBuilder;
  beats: (beats: string[]) => ITimeBuilder;
  beatTypes: (beatTypes: number[]) => ITimeBuilder;
  senzaMisura: (senzaMisura: string) => ITimeBuilder;
  printObject: (printObject: boolean) => ITimeBuilder;
  defaultX: (defaultX: number) => ITimeBuilder;
  relativeY: (relativeY: number) => ITimeBuilder;
  defaultY: (defaultY: number) => ITimeBuilder;
  relativeX: (relativeX: number) => ITimeBuilder;
  fontFamily: (fontFamily: string) => ITimeBuilder;
  fontWeight: (fontWeight: NormalBold) => ITimeBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITimeBuilder;
  fontSize: (fontSize: string) => ITimeBuilder;
  color: (color: string) => ITimeBuilder;
  halign: (halign: LeftCenterRight) => ITimeBuilder;
  valign: (valign: TopMiddleBottomBaseline) => ITimeBuilder;
  symbol: (symbol: TimeSymbolType) => ITimeBuilder;
  separator: (separator: SeparatorType) => ITimeBuilder;
}

class TimeBuilder implements ITimeBuilder {
  build: () => Time;
  patch: () => IAny[];
  interchangeable: (build: Interchangeable | ((builder: IInterchangeableBuilder) => IInterchangeableBuilder)) => ITimeBuilder;
  beats: (beats: string[]) => ITimeBuilder;
  beatTypes: (beatTypes: number[]) => ITimeBuilder;
  senzaMisura: (senzaMisura: string) => ITimeBuilder;
  printObject: (printObject: boolean) => ITimeBuilder;
  defaultX: (defaultX: number) => ITimeBuilder;
  relativeY: (relativeY: number) => ITimeBuilder;
  defaultY: (defaultY: number) => ITimeBuilder;
  relativeX: (relativeX: number) => ITimeBuilder;
  fontFamily: (fontFamily: string) => ITimeBuilder;
  fontWeight: (fontWeight: NormalBold) => ITimeBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITimeBuilder;
  fontSize: (fontSize: string) => ITimeBuilder;
  color: (color: string) => ITimeBuilder;
  halign: (halign: LeftCenterRight) => ITimeBuilder;
  valign: (valign: TopMiddleBottomBaseline) => ITimeBuilder;
  symbol: (symbol: TimeSymbolType) => ITimeBuilder;
  separator: (separator: SeparatorType) => ITimeBuilder;
  constructor(original?: Time) {
    let updates: Time = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["beats"]) ||
          childBuilders["beats"] !== undefined ||
          updates.beats !== undefined,
        "beats is a required field");
      console.assert(
          (original && !modifiedKeys["beatTypes"]) ||
          childBuilders["beatTypes"] !== undefined ||
          updates.beatTypes !== undefined,
        "beatTypes is a required field");
    }

    if (!original) {
      this.build = (): Time => {
        checkInvariants();
        (updates as any)._class = "Time";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.interchangeable = (build: Interchangeable | ((builder: IInterchangeableBuilder) => IInterchangeableBuilder)): ITimeBuilder => {
      if (typeof build === 'function') {
        delete updates["interchangeable"]
        const builder = (build as any)(new InterchangeableBuilder(original && original["interchangeable"]));
        if (!original) updates["interchangeable"] = builder.build();
        else childBuilders["interchangeable"] = builder;
      } else {
        updates.interchangeable = build as any;
        delete childBuilders["interchangeable;"];
      }
      modifiedKeys["interchangeable"] = true;
      return this;
    }

    this.beats = (spec: string[]): ITimeBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.beatTypes = (spec: number[]): ITimeBuilder => {
        updates["beatTypes"] = spec;
        delete childBuilders["beatTypes;"];
        modifiedKeys["beatTypes"] = true;
        return this;
    }

    this.senzaMisura = (spec: string): ITimeBuilder => {
        updates["senzaMisura"] = spec;
        delete childBuilders["senzaMisura;"];
        modifiedKeys["senzaMisura"] = true;
        return this;
    }

    this.printObject = (spec: boolean): ITimeBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.defaultX = (spec: number): ITimeBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ITimeBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ITimeBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ITimeBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ITimeBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ITimeBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ITimeBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ITimeBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ITimeBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): ITimeBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): ITimeBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }

    this.symbol = (spec: TimeSymbolType): ITimeBuilder => {
        updates["symbol"] = spec;
        delete childBuilders["symbol;"];
        modifiedKeys["symbol"] = true;
        return this;
    }

    this.separator = (spec: SeparatorType): ITimeBuilder => {
        updates["separator"] = spec;
        delete childBuilders["separator;"];
        modifiedKeys["separator"] = true;
        return this;
    }
  }
}
export function patchTime(base: Time, builder: (build: ITimeBuilder) => ITimeBuilder): IAny[] { return builder(new TimeBuilder(base)).patch(); }
export function buildTime(builder: (build: ITimeBuilder) => ITimeBuilder): Time { return builder(new TimeBuilder()).build(); }

export interface IInterchangeableBuilder {
  build?: () => Interchangeable;
  patch: () => IAny[];
  beats: (beats: string[]) => IInterchangeableBuilder;
  beatTypes: (beatTypes: number[]) => IInterchangeableBuilder;
  timeRelation: (timeRelation: string) => IInterchangeableBuilder;
  symbol: (symbol: TimeSymbolType) => IInterchangeableBuilder;
  separator: (separator: SeparatorType) => IInterchangeableBuilder;
}

class InterchangeableBuilder implements IInterchangeableBuilder {
  build: () => Interchangeable;
  patch: () => IAny[];
  beats: (beats: string[]) => IInterchangeableBuilder;
  beatTypes: (beatTypes: number[]) => IInterchangeableBuilder;
  timeRelation: (timeRelation: string) => IInterchangeableBuilder;
  symbol: (symbol: TimeSymbolType) => IInterchangeableBuilder;
  separator: (separator: SeparatorType) => IInterchangeableBuilder;
  constructor(original?: Interchangeable) {
    let updates: Interchangeable = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["beats"]) ||
          childBuilders["beats"] !== undefined ||
          updates.beats !== undefined,
        "beats is a required field");
      console.assert(
          (original && !modifiedKeys["beatTypes"]) ||
          childBuilders["beatTypes"] !== undefined ||
          updates.beatTypes !== undefined,
        "beatTypes is a required field");
    }

    if (!original) {
      this.build = (): Interchangeable => {
        checkInvariants();
        (updates as any)._class = "Interchangeable";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.beats = (spec: string[]): IInterchangeableBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.beatTypes = (spec: number[]): IInterchangeableBuilder => {
        updates["beatTypes"] = spec;
        delete childBuilders["beatTypes;"];
        modifiedKeys["beatTypes"] = true;
        return this;
    }

    this.timeRelation = (spec: string): IInterchangeableBuilder => {
        updates["timeRelation"] = spec;
        delete childBuilders["timeRelation;"];
        modifiedKeys["timeRelation"] = true;
        return this;
    }

    this.symbol = (spec: TimeSymbolType): IInterchangeableBuilder => {
        updates["symbol"] = spec;
        delete childBuilders["symbol;"];
        modifiedKeys["symbol"] = true;
        return this;
    }

    this.separator = (spec: SeparatorType): IInterchangeableBuilder => {
        updates["separator"] = spec;
        delete childBuilders["separator;"];
        modifiedKeys["separator"] = true;
        return this;
    }
  }
}
export function patchInterchangeable(base: Interchangeable, builder: (build: IInterchangeableBuilder) => IInterchangeableBuilder): IAny[] { return builder(new InterchangeableBuilder(base)).patch(); }
export function buildInterchangeable(builder: (build: IInterchangeableBuilder) => IInterchangeableBuilder): Interchangeable { return builder(new InterchangeableBuilder()).build(); }

export interface IPartSymbolBuilder {
  build?: () => PartSymbol;
  patch: () => IAny[];
  topStaff: (topStaff: number) => IPartSymbolBuilder;
  type: (type: PartSymbolType) => IPartSymbolBuilder;
  bottomStaff: (bottomStaff: number) => IPartSymbolBuilder;
  defaultX: (defaultX: number) => IPartSymbolBuilder;
  relativeY: (relativeY: number) => IPartSymbolBuilder;
  defaultY: (defaultY: number) => IPartSymbolBuilder;
  relativeX: (relativeX: number) => IPartSymbolBuilder;
  color: (color: string) => IPartSymbolBuilder;
}

class PartSymbolBuilder implements IPartSymbolBuilder {
  build: () => PartSymbol;
  patch: () => IAny[];
  topStaff: (topStaff: number) => IPartSymbolBuilder;
  type: (type: PartSymbolType) => IPartSymbolBuilder;
  bottomStaff: (bottomStaff: number) => IPartSymbolBuilder;
  defaultX: (defaultX: number) => IPartSymbolBuilder;
  relativeY: (relativeY: number) => IPartSymbolBuilder;
  defaultY: (defaultY: number) => IPartSymbolBuilder;
  relativeX: (relativeX: number) => IPartSymbolBuilder;
  color: (color: string) => IPartSymbolBuilder;
  constructor(original?: PartSymbol) {
    let updates: PartSymbol = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): PartSymbol => {
        checkInvariants();
        (updates as any)._class = "PartSymbol";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.topStaff = (spec: number): IPartSymbolBuilder => {
        updates["topStaff"] = spec;
        delete childBuilders["topStaff;"];
        modifiedKeys["topStaff"] = true;
        return this;
    }

    this.type = (spec: PartSymbolType): IPartSymbolBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.bottomStaff = (spec: number): IPartSymbolBuilder => {
        updates["bottomStaff"] = spec;
        delete childBuilders["bottomStaff;"];
        modifiedKeys["bottomStaff"] = true;
        return this;
    }

    this.defaultX = (spec: number): IPartSymbolBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IPartSymbolBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IPartSymbolBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IPartSymbolBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.color = (spec: string): IPartSymbolBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchPartSymbol(base: PartSymbol, builder: (build: IPartSymbolBuilder) => IPartSymbolBuilder): IAny[] { return builder(new PartSymbolBuilder(base)).patch(); }
export function buildPartSymbol(builder: (build: IPartSymbolBuilder) => IPartSymbolBuilder): PartSymbol { return builder(new PartSymbolBuilder()).build(); }

export interface IClefBuilder {
  build?: () => Clef;
  patch: () => IAny[];
  clefOctaveChange: (clefOctaveChange: string) => IClefBuilder;
  sign: (sign: string) => IClefBuilder;
  number: (number: number) => IClefBuilder;
  size: (size: SymbolSize) => IClefBuilder;
  line: (line: number) => IClefBuilder;
  afterBarline: (afterBarline: boolean) => IClefBuilder;
  additional: (additional: boolean) => IClefBuilder;
  defaultX: (defaultX: number) => IClefBuilder;
  relativeY: (relativeY: number) => IClefBuilder;
  defaultY: (defaultY: number) => IClefBuilder;
  relativeX: (relativeX: number) => IClefBuilder;
  fontFamily: (fontFamily: string) => IClefBuilder;
  fontWeight: (fontWeight: NormalBold) => IClefBuilder;
  fontStyle: (fontStyle: NormalItalic) => IClefBuilder;
  fontSize: (fontSize: string) => IClefBuilder;
  color: (color: string) => IClefBuilder;
  printObject: (printObject: boolean) => IClefBuilder;
}

class ClefBuilder implements IClefBuilder {
  build: () => Clef;
  patch: () => IAny[];
  clefOctaveChange: (clefOctaveChange: string) => IClefBuilder;
  sign: (sign: string) => IClefBuilder;
  number: (number: number) => IClefBuilder;
  size: (size: SymbolSize) => IClefBuilder;
  line: (line: number) => IClefBuilder;
  afterBarline: (afterBarline: boolean) => IClefBuilder;
  additional: (additional: boolean) => IClefBuilder;
  defaultX: (defaultX: number) => IClefBuilder;
  relativeY: (relativeY: number) => IClefBuilder;
  defaultY: (defaultY: number) => IClefBuilder;
  relativeX: (relativeX: number) => IClefBuilder;
  fontFamily: (fontFamily: string) => IClefBuilder;
  fontWeight: (fontWeight: NormalBold) => IClefBuilder;
  fontStyle: (fontStyle: NormalItalic) => IClefBuilder;
  fontSize: (fontSize: string) => IClefBuilder;
  color: (color: string) => IClefBuilder;
  printObject: (printObject: boolean) => IClefBuilder;
  constructor(original?: Clef) {
    let updates: Clef = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["sign"]) ||
          childBuilders["sign"] !== undefined ||
          updates.sign !== undefined,
        "sign is a required field");
      console.assert(
          (original && !modifiedKeys["line"]) ||
          childBuilders["line"] !== undefined ||
          updates.line !== undefined,
        "line is a required field");
    }

    if (!original) {
      this.build = (): Clef => {
        checkInvariants();
        (updates as any)._class = "Clef";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.clefOctaveChange = (spec: string): IClefBuilder => {
        updates["clefOctaveChange"] = spec;
        delete childBuilders["clefOctaveChange;"];
        modifiedKeys["clefOctaveChange"] = true;
        return this;
    }

    this.sign = (spec: string): IClefBuilder => {
        updates["sign"] = spec;
        delete childBuilders["sign;"];
        modifiedKeys["sign"] = true;
        return this;
    }

    this.number = (spec: number): IClefBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.size = (spec: SymbolSize): IClefBuilder => {
        updates["size"] = spec;
        delete childBuilders["size;"];
        modifiedKeys["size"] = true;
        return this;
    }

    this.line = (spec: number): IClefBuilder => {
        updates["line"] = spec;
        delete childBuilders["line;"];
        modifiedKeys["line"] = true;
        return this;
    }

    this.afterBarline = (spec: boolean): IClefBuilder => {
        updates["afterBarline"] = spec;
        delete childBuilders["afterBarline;"];
        modifiedKeys["afterBarline"] = true;
        return this;
    }

    this.additional = (spec: boolean): IClefBuilder => {
        updates["additional"] = spec;
        delete childBuilders["additional;"];
        modifiedKeys["additional"] = true;
        return this;
    }

    this.defaultX = (spec: number): IClefBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IClefBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IClefBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IClefBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IClefBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IClefBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IClefBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IClefBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IClefBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.printObject = (spec: boolean): IClefBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }
  }
}
export function patchClef(base: Clef, builder: (build: IClefBuilder) => IClefBuilder): IAny[] { return builder(new ClefBuilder(base)).patch(); }
export function buildClef(builder: (build: IClefBuilder) => IClefBuilder): Clef { return builder(new ClefBuilder()).build(); }

export interface IStaffTuningBuilder {
  build?: () => StaffTuning;
  patch: () => IAny[];
  tuningAlter: (tuningAlter: string) => IStaffTuningBuilder;
  line: (line: string) => IStaffTuningBuilder;
  tuningStep: (tuningStep: string) => IStaffTuningBuilder;
  tuningOctave: (tuningOctave: string) => IStaffTuningBuilder;
}

class StaffTuningBuilder implements IStaffTuningBuilder {
  build: () => StaffTuning;
  patch: () => IAny[];
  tuningAlter: (tuningAlter: string) => IStaffTuningBuilder;
  line: (line: string) => IStaffTuningBuilder;
  tuningStep: (tuningStep: string) => IStaffTuningBuilder;
  tuningOctave: (tuningOctave: string) => IStaffTuningBuilder;
  constructor(original?: StaffTuning) {
    let updates: StaffTuning = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["line"]) ||
          childBuilders["line"] !== undefined ||
          updates.line !== undefined,
        "line is a required field");
      console.assert(
          (original && !modifiedKeys["tuningStep"]) ||
          childBuilders["tuningStep"] !== undefined ||
          updates.tuningStep !== undefined,
        "tuningStep is a required field");
      console.assert(
          (original && !modifiedKeys["tuningOctave"]) ||
          childBuilders["tuningOctave"] !== undefined ||
          updates.tuningOctave !== undefined,
        "tuningOctave is a required field");
    }

    if (!original) {
      this.build = (): StaffTuning => {
        checkInvariants();
        (updates as any)._class = "StaffTuning";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.tuningAlter = (spec: string): IStaffTuningBuilder => {
        updates["tuningAlter"] = spec;
        delete childBuilders["tuningAlter;"];
        modifiedKeys["tuningAlter"] = true;
        return this;
    }

    this.line = (spec: string): IStaffTuningBuilder => {
        updates["line"] = spec;
        delete childBuilders["line;"];
        modifiedKeys["line"] = true;
        return this;
    }

    this.tuningStep = (spec: string): IStaffTuningBuilder => {
        updates["tuningStep"] = spec;
        delete childBuilders["tuningStep;"];
        modifiedKeys["tuningStep"] = true;
        return this;
    }

    this.tuningOctave = (spec: string): IStaffTuningBuilder => {
        updates["tuningOctave"] = spec;
        delete childBuilders["tuningOctave;"];
        modifiedKeys["tuningOctave"] = true;
        return this;
    }
  }
}
export function patchStaffTuning(base: StaffTuning, builder: (build: IStaffTuningBuilder) => IStaffTuningBuilder): IAny[] { return builder(new StaffTuningBuilder(base)).patch(); }
export function buildStaffTuning(builder: (build: IStaffTuningBuilder) => IStaffTuningBuilder): StaffTuning { return builder(new StaffTuningBuilder()).build(); }

export interface IStaffDetailsBuilder {
  build?: () => StaffDetails;
  patch: () => IAny[];
  staffLines: (staffLines: number) => IStaffDetailsBuilder;
  staffTuningsAt: (idx: number, build: StaffTuning | ((builder: IStaffTuningBuilder) => IStaffTuningBuilder)) => IStaffDetailsBuilder;
  staffTuningsSplice: (start: number, deleteCount: number, ...items: StaffTuning[]) => IStaffDetailsBuilder;
  staffTunings: (staffTunings: StaffTuning[]) => IStaffDetailsBuilder;
  staffSize: (staffSize: number) => IStaffDetailsBuilder;
  showFrets: (showFrets: ShowFretsType) => IStaffDetailsBuilder;
  capo: (capo: string) => IStaffDetailsBuilder;
  number: (number: number) => IStaffDetailsBuilder;
  staffType: (staffType: string) => IStaffDetailsBuilder;
  printObject: (printObject: boolean) => IStaffDetailsBuilder;
  printSpacing: (printSpacing: boolean) => IStaffDetailsBuilder;
}

class StaffDetailsBuilder implements IStaffDetailsBuilder {
  build: () => StaffDetails;
  patch: () => IAny[];
  staffLines: (staffLines: number) => IStaffDetailsBuilder;
  staffTuningsAt: (idx: number, build: StaffTuning | ((builder: IStaffTuningBuilder) => IStaffTuningBuilder)) => IStaffDetailsBuilder;
  staffTuningsSplice: (start: number, deleteCount: number, ...items: StaffTuning[]) => IStaffDetailsBuilder;
  staffTunings: (staffTunings: StaffTuning[]) => IStaffDetailsBuilder;
  staffSize: (staffSize: number) => IStaffDetailsBuilder;
  showFrets: (showFrets: ShowFretsType) => IStaffDetailsBuilder;
  capo: (capo: string) => IStaffDetailsBuilder;
  number: (number: number) => IStaffDetailsBuilder;
  staffType: (staffType: string) => IStaffDetailsBuilder;
  printObject: (printObject: boolean) => IStaffDetailsBuilder;
  printSpacing: (printSpacing: boolean) => IStaffDetailsBuilder;
  constructor(original?: StaffDetails) {
    let updates: StaffDetails = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): StaffDetails => {
        checkInvariants();
        (updates as any)._class = "StaffDetails";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.staffLines = (spec: number): IStaffDetailsBuilder => {
        updates["staffLines"] = spec;
        delete childBuilders["staffLines;"];
        modifiedKeys["staffLines"] = true;
        return this;
    }

    this.staffTunings = (spec: StaffTuning[]): IStaffDetailsBuilder => {
        updates["staffTunings"] = spec;
        delete childBuilders["staffTunings;"];
        modifiedKeys["staffTunings"] = true;
        return this;
    }

    this.staffTuningsAt = (idx: number, build: StaffTuning | ((builder: IStaffTuningBuilder) => IStaffTuningBuilder)): IStaffDetailsBuilder => {
      makeReference("staffTunings");
      if (frozen["staffTunings"][idx]) {
          throw new Error("Patching staffTunings." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["staffTunings"] && !original["staffTunings"]) {
          // Clone snapshot.
          patches.push({p: ["staffTunings", idx], li: original._snapshot["staffTunings"]});
      }
      if (typeof build === 'function' && reference["staffTunings"][idx]) {
        let patch = (build as any)(new StaffTuningBuilder(reference["staffTunings"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["staffTunings", idx].concat(patch.p);
          return patch;
        }));
        frozen["staffTunings"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new StaffTuningBuilder(reference["staffTunings"][idx])).build() : build;
      if (original) {
        patches.push({p: ["staffTunings", idx], li: update});
      } else {
        updates["staffTunings"] = reference["staffTunings"]; // TODO: Merge?
      } 
      reference["staffTunings"][idx] = update;
      frozen["staffTunings"][idx] = true;
      return this;
    }

    this.staffTuningsSplice = (start: number, deleteCount: number, ...items: StaffTuning[]): IStaffDetailsBuilder => {
      makeReference("staffTunings");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["staffTunings"][idx]) {
            throw new Error("Replacing staffTunings." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["staffTunings"][idx];
          patches.push({p: ["staffTunings", idx], ld, li: items[idx - start]});
          frozen["staffTunings"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["staffTunings"][idx]) {
            throw new Error("Removing staffTunings." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["staffTunings"][idx];
          patches.push({p: ["staffTunings", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["staffTunings", idx], li: items[idx - start]});
          frozen["staffTunings"][idx] = true;
        }
      }
      reference["staffTunings"].splice(start, deleteCount, ...items);
      updates["staffTunings"] = reference["staffTunings"];
      frozen["staffTunings"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.staffSize = (spec: number): IStaffDetailsBuilder => {
        updates["staffSize"] = spec;
        delete childBuilders["staffSize;"];
        modifiedKeys["staffSize"] = true;
        return this;
    }

    this.showFrets = (spec: ShowFretsType): IStaffDetailsBuilder => {
        updates["showFrets"] = spec;
        delete childBuilders["showFrets;"];
        modifiedKeys["showFrets"] = true;
        return this;
    }

    this.capo = (spec: string): IStaffDetailsBuilder => {
        updates["capo"] = spec;
        delete childBuilders["capo;"];
        modifiedKeys["capo"] = true;
        return this;
    }

    this.number = (spec: number): IStaffDetailsBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.staffType = (spec: string): IStaffDetailsBuilder => {
        updates["staffType"] = spec;
        delete childBuilders["staffType;"];
        modifiedKeys["staffType"] = true;
        return this;
    }

    this.printObject = (spec: boolean): IStaffDetailsBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.printSpacing = (spec: boolean): IStaffDetailsBuilder => {
        updates["printSpacing"] = spec;
        delete childBuilders["printSpacing;"];
        modifiedKeys["printSpacing"] = true;
        return this;
    }
  }
}
export function patchStaffDetails(base: StaffDetails, builder: (build: IStaffDetailsBuilder) => IStaffDetailsBuilder): IAny[] { return builder(new StaffDetailsBuilder(base)).patch(); }
export function buildStaffDetails(builder: (build: IStaffDetailsBuilder) => IStaffDetailsBuilder): StaffDetails { return builder(new StaffDetailsBuilder()).build(); }

export interface IDoubleBuilder {
  build?: () => Double;
  patch: () => IAny[];
}

class DoubleBuilder implements IDoubleBuilder {
  build: () => Double;
  patch: () => IAny[];
  constructor(original?: Double) {
    let updates: Double = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Double => {
        checkInvariants();
        (updates as any)._class = "Double";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchDouble(base: Double, builder: (build: IDoubleBuilder) => IDoubleBuilder): IAny[] { return builder(new DoubleBuilder(base)).patch(); }
export function buildDouble(builder: (build: IDoubleBuilder) => IDoubleBuilder): Double { return builder(new DoubleBuilder()).build(); }

export interface ITransposeBuilder {
  build?: () => Transpose;
  patch: () => IAny[];
  number: (number: number) => ITransposeBuilder;
  diatonic: (diatonic: string) => ITransposeBuilder;
  octaveChange: (octaveChange: string) => ITransposeBuilder;
  double: (build: Double | ((builder: IDoubleBuilder) => IDoubleBuilder)) => ITransposeBuilder;
  chromatic: (chromatic: string) => ITransposeBuilder;
}

class TransposeBuilder implements ITransposeBuilder {
  build: () => Transpose;
  patch: () => IAny[];
  number: (number: number) => ITransposeBuilder;
  diatonic: (diatonic: string) => ITransposeBuilder;
  octaveChange: (octaveChange: string) => ITransposeBuilder;
  double: (build: Double | ((builder: IDoubleBuilder) => IDoubleBuilder)) => ITransposeBuilder;
  chromatic: (chromatic: string) => ITransposeBuilder;
  constructor(original?: Transpose) {
    let updates: Transpose = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["chromatic"]) ||
          childBuilders["chromatic"] !== undefined ||
          updates.chromatic !== undefined,
        "chromatic is a required field");
    }

    if (!original) {
      this.build = (): Transpose => {
        checkInvariants();
        (updates as any)._class = "Transpose";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: number): ITransposeBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.diatonic = (spec: string): ITransposeBuilder => {
        updates["diatonic"] = spec;
        delete childBuilders["diatonic;"];
        modifiedKeys["diatonic"] = true;
        return this;
    }

    this.octaveChange = (spec: string): ITransposeBuilder => {
        updates["octaveChange"] = spec;
        delete childBuilders["octaveChange;"];
        modifiedKeys["octaveChange"] = true;
        return this;
    }

    this.double = (build: Double | ((builder: IDoubleBuilder) => IDoubleBuilder)): ITransposeBuilder => {
      if (typeof build === 'function') {
        delete updates["double"]
        const builder = (build as any)(new DoubleBuilder(original && original["double"]));
        if (!original) updates["double"] = builder.build();
        else childBuilders["double"] = builder;
      } else {
        updates.double = build as any;
        delete childBuilders["double;"];
      }
      modifiedKeys["double"] = true;
      return this;
    }

    this.chromatic = (spec: string): ITransposeBuilder => {
        updates["chromatic"] = spec;
        delete childBuilders["chromatic;"];
        modifiedKeys["chromatic"] = true;
        return this;
    }
  }
}
export function patchTranspose(base: Transpose, builder: (build: ITransposeBuilder) => ITransposeBuilder): IAny[] { return builder(new TransposeBuilder(base)).patch(); }
export function buildTranspose(builder: (build: ITransposeBuilder) => ITransposeBuilder): Transpose { return builder(new TransposeBuilder()).build(); }

export interface IDirectiveBuilder {
  build?: () => Directive;
  patch: () => IAny[];
  data: (data: string) => IDirectiveBuilder;
  defaultX: (defaultX: number) => IDirectiveBuilder;
  relativeY: (relativeY: number) => IDirectiveBuilder;
  defaultY: (defaultY: number) => IDirectiveBuilder;
  relativeX: (relativeX: number) => IDirectiveBuilder;
  fontFamily: (fontFamily: string) => IDirectiveBuilder;
  fontWeight: (fontWeight: NormalBold) => IDirectiveBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDirectiveBuilder;
  fontSize: (fontSize: string) => IDirectiveBuilder;
  color: (color: string) => IDirectiveBuilder;
}

class DirectiveBuilder implements IDirectiveBuilder {
  build: () => Directive;
  patch: () => IAny[];
  data: (data: string) => IDirectiveBuilder;
  defaultX: (defaultX: number) => IDirectiveBuilder;
  relativeY: (relativeY: number) => IDirectiveBuilder;
  defaultY: (defaultY: number) => IDirectiveBuilder;
  relativeX: (relativeX: number) => IDirectiveBuilder;
  fontFamily: (fontFamily: string) => IDirectiveBuilder;
  fontWeight: (fontWeight: NormalBold) => IDirectiveBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDirectiveBuilder;
  fontSize: (fontSize: string) => IDirectiveBuilder;
  color: (color: string) => IDirectiveBuilder;
  constructor(original?: Directive) {
    let updates: Directive = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): Directive => {
        checkInvariants();
        (updates as any)._class = "Directive";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IDirectiveBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IDirectiveBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDirectiveBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDirectiveBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDirectiveBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDirectiveBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDirectiveBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDirectiveBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDirectiveBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDirectiveBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchDirective(base: Directive, builder: (build: IDirectiveBuilder) => IDirectiveBuilder): IAny[] { return builder(new DirectiveBuilder(base)).patch(); }
export function buildDirective(builder: (build: IDirectiveBuilder) => IDirectiveBuilder): Directive { return builder(new DirectiveBuilder()).build(); }

export interface ISlashDotBuilder {
  build?: () => SlashDot;
  patch: () => IAny[];
}

class SlashDotBuilder implements ISlashDotBuilder {
  build: () => SlashDot;
  patch: () => IAny[];
  constructor(original?: SlashDot) {
    let updates: SlashDot = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): SlashDot => {
        checkInvariants();
        (updates as any)._class = "SlashDot";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchSlashDot(base: SlashDot, builder: (build: ISlashDotBuilder) => ISlashDotBuilder): IAny[] { return builder(new SlashDotBuilder(base)).patch(); }
export function buildSlashDot(builder: (build: ISlashDotBuilder) => ISlashDotBuilder): SlashDot { return builder(new SlashDotBuilder()).build(); }

export interface IMultipleRestBuilder {
  build?: () => MultipleRest;
  patch: () => IAny[];
  useSymbols: (useSymbols: boolean) => IMultipleRestBuilder;
  count: (count: number) => IMultipleRestBuilder;
}

class MultipleRestBuilder implements IMultipleRestBuilder {
  build: () => MultipleRest;
  patch: () => IAny[];
  useSymbols: (useSymbols: boolean) => IMultipleRestBuilder;
  count: (count: number) => IMultipleRestBuilder;
  constructor(original?: MultipleRest) {
    let updates: MultipleRest = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["count"]) ||
          childBuilders["count"] !== undefined ||
          updates.count !== undefined,
        "count is a required field");
    }

    if (!original) {
      this.build = (): MultipleRest => {
        checkInvariants();
        (updates as any)._class = "MultipleRest";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.useSymbols = (spec: boolean): IMultipleRestBuilder => {
        updates["useSymbols"] = spec;
        delete childBuilders["useSymbols;"];
        modifiedKeys["useSymbols"] = true;
        return this;
    }

    this.count = (spec: number): IMultipleRestBuilder => {
        updates["count"] = spec;
        delete childBuilders["count;"];
        modifiedKeys["count"] = true;
        return this;
    }
  }
}
export function patchMultipleRest(base: MultipleRest, builder: (build: IMultipleRestBuilder) => IMultipleRestBuilder): IAny[] { return builder(new MultipleRestBuilder(base)).patch(); }
export function buildMultipleRest(builder: (build: IMultipleRestBuilder) => IMultipleRestBuilder): MultipleRest { return builder(new MultipleRestBuilder()).build(); }

export interface IMeasureRepeatBuilder {
  build?: () => MeasureRepeat;
  patch: () => IAny[];
  data: (data: string) => IMeasureRepeatBuilder;
  type: (type: StartStop) => IMeasureRepeatBuilder;
  slashes: (slashes: number) => IMeasureRepeatBuilder;
}

class MeasureRepeatBuilder implements IMeasureRepeatBuilder {
  build: () => MeasureRepeat;
  patch: () => IAny[];
  data: (data: string) => IMeasureRepeatBuilder;
  type: (type: StartStop) => IMeasureRepeatBuilder;
  slashes: (slashes: number) => IMeasureRepeatBuilder;
  constructor(original?: MeasureRepeat) {
    let updates: MeasureRepeat = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): MeasureRepeat => {
        checkInvariants();
        (updates as any)._class = "MeasureRepeat";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IMeasureRepeatBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.type = (spec: StartStop): IMeasureRepeatBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.slashes = (spec: number): IMeasureRepeatBuilder => {
        updates["slashes"] = spec;
        delete childBuilders["slashes;"];
        modifiedKeys["slashes"] = true;
        return this;
    }
  }
}
export function patchMeasureRepeat(base: MeasureRepeat, builder: (build: IMeasureRepeatBuilder) => IMeasureRepeatBuilder): IAny[] { return builder(new MeasureRepeatBuilder(base)).patch(); }
export function buildMeasureRepeat(builder: (build: IMeasureRepeatBuilder) => IMeasureRepeatBuilder): MeasureRepeat { return builder(new MeasureRepeatBuilder()).build(); }

export interface IBeatRepeatBuilder {
  build?: () => BeatRepeat;
  patch: () => IAny[];
  slashType: (slashType: string) => IBeatRepeatBuilder;
  useDots: (useDots: boolean) => IBeatRepeatBuilder;
  slashDotsAt: (idx: number, build: SlashDot | ((builder: ISlashDotBuilder) => ISlashDotBuilder)) => IBeatRepeatBuilder;
  slashDotsSplice: (start: number, deleteCount: number, ...items: SlashDot[]) => IBeatRepeatBuilder;
  slashDots: (slashDots: SlashDot[]) => IBeatRepeatBuilder;
  slases: (slases: number) => IBeatRepeatBuilder;
  type: (type: StartStop) => IBeatRepeatBuilder;
}

class BeatRepeatBuilder implements IBeatRepeatBuilder {
  build: () => BeatRepeat;
  patch: () => IAny[];
  slashType: (slashType: string) => IBeatRepeatBuilder;
  useDots: (useDots: boolean) => IBeatRepeatBuilder;
  slashDotsAt: (idx: number, build: SlashDot | ((builder: ISlashDotBuilder) => ISlashDotBuilder)) => IBeatRepeatBuilder;
  slashDotsSplice: (start: number, deleteCount: number, ...items: SlashDot[]) => IBeatRepeatBuilder;
  slashDots: (slashDots: SlashDot[]) => IBeatRepeatBuilder;
  slases: (slases: number) => IBeatRepeatBuilder;
  type: (type: StartStop) => IBeatRepeatBuilder;
  constructor(original?: BeatRepeat) {
    let updates: BeatRepeat = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): BeatRepeat => {
        checkInvariants();
        (updates as any)._class = "BeatRepeat";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.slashType = (spec: string): IBeatRepeatBuilder => {
        updates["slashType"] = spec;
        delete childBuilders["slashType;"];
        modifiedKeys["slashType"] = true;
        return this;
    }

    this.useDots = (spec: boolean): IBeatRepeatBuilder => {
        updates["useDots"] = spec;
        delete childBuilders["useDots;"];
        modifiedKeys["useDots"] = true;
        return this;
    }

    this.slashDots = (spec: SlashDot[]): IBeatRepeatBuilder => {
        updates["slashDots"] = spec;
        delete childBuilders["slashDots;"];
        modifiedKeys["slashDots"] = true;
        return this;
    }

    this.slashDotsAt = (idx: number, build: SlashDot | ((builder: ISlashDotBuilder) => ISlashDotBuilder)): IBeatRepeatBuilder => {
      makeReference("slashDots");
      if (frozen["slashDots"][idx]) {
          throw new Error("Patching slashDots." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["slashDots"] && !original["slashDots"]) {
          // Clone snapshot.
          patches.push({p: ["slashDots", idx], li: original._snapshot["slashDots"]});
      }
      if (typeof build === 'function' && reference["slashDots"][idx]) {
        let patch = (build as any)(new SlashDotBuilder(reference["slashDots"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["slashDots", idx].concat(patch.p);
          return patch;
        }));
        frozen["slashDots"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new SlashDotBuilder(reference["slashDots"][idx])).build() : build;
      if (original) {
        patches.push({p: ["slashDots", idx], li: update});
      } else {
        updates["slashDots"] = reference["slashDots"]; // TODO: Merge?
      } 
      reference["slashDots"][idx] = update;
      frozen["slashDots"][idx] = true;
      return this;
    }

    this.slashDotsSplice = (start: number, deleteCount: number, ...items: SlashDot[]): IBeatRepeatBuilder => {
      makeReference("slashDots");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["slashDots"][idx]) {
            throw new Error("Replacing slashDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["slashDots"][idx];
          patches.push({p: ["slashDots", idx], ld, li: items[idx - start]});
          frozen["slashDots"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["slashDots"][idx]) {
            throw new Error("Removing slashDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["slashDots"][idx];
          patches.push({p: ["slashDots", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["slashDots", idx], li: items[idx - start]});
          frozen["slashDots"][idx] = true;
        }
      }
      reference["slashDots"].splice(start, deleteCount, ...items);
      updates["slashDots"] = reference["slashDots"];
      frozen["slashDots"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.slases = (spec: number): IBeatRepeatBuilder => {
        updates["slases"] = spec;
        delete childBuilders["slases;"];
        modifiedKeys["slases"] = true;
        return this;
    }

    this.type = (spec: StartStop): IBeatRepeatBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }
  }
}
export function patchBeatRepeat(base: BeatRepeat, builder: (build: IBeatRepeatBuilder) => IBeatRepeatBuilder): IAny[] { return builder(new BeatRepeatBuilder(base)).patch(); }
export function buildBeatRepeat(builder: (build: IBeatRepeatBuilder) => IBeatRepeatBuilder): BeatRepeat { return builder(new BeatRepeatBuilder()).build(); }

export interface ISlashBuilder {
  build?: () => Slash;
  patch: () => IAny[];
  slashType: (slashType: string) => ISlashBuilder;
  useDots: (useDots: boolean) => ISlashBuilder;
  useStems: (useStems: boolean) => ISlashBuilder;
  slashDotsAt: (idx: number, build: SlashDot | ((builder: ISlashDotBuilder) => ISlashDotBuilder)) => ISlashBuilder;
  slashDotsSplice: (start: number, deleteCount: number, ...items: SlashDot[]) => ISlashBuilder;
  slashDots: (slashDots: SlashDot[]) => ISlashBuilder;
  type: (type: StartStop) => ISlashBuilder;
}

class SlashBuilder implements ISlashBuilder {
  build: () => Slash;
  patch: () => IAny[];
  slashType: (slashType: string) => ISlashBuilder;
  useDots: (useDots: boolean) => ISlashBuilder;
  useStems: (useStems: boolean) => ISlashBuilder;
  slashDotsAt: (idx: number, build: SlashDot | ((builder: ISlashDotBuilder) => ISlashDotBuilder)) => ISlashBuilder;
  slashDotsSplice: (start: number, deleteCount: number, ...items: SlashDot[]) => ISlashBuilder;
  slashDots: (slashDots: SlashDot[]) => ISlashBuilder;
  type: (type: StartStop) => ISlashBuilder;
  constructor(original?: Slash) {
    let updates: Slash = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Slash => {
        checkInvariants();
        (updates as any)._class = "Slash";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.slashType = (spec: string): ISlashBuilder => {
        updates["slashType"] = spec;
        delete childBuilders["slashType;"];
        modifiedKeys["slashType"] = true;
        return this;
    }

    this.useDots = (spec: boolean): ISlashBuilder => {
        updates["useDots"] = spec;
        delete childBuilders["useDots;"];
        modifiedKeys["useDots"] = true;
        return this;
    }

    this.useStems = (spec: boolean): ISlashBuilder => {
        updates["useStems"] = spec;
        delete childBuilders["useStems;"];
        modifiedKeys["useStems"] = true;
        return this;
    }

    this.slashDots = (spec: SlashDot[]): ISlashBuilder => {
        updates["slashDots"] = spec;
        delete childBuilders["slashDots;"];
        modifiedKeys["slashDots"] = true;
        return this;
    }

    this.slashDotsAt = (idx: number, build: SlashDot | ((builder: ISlashDotBuilder) => ISlashDotBuilder)): ISlashBuilder => {
      makeReference("slashDots");
      if (frozen["slashDots"][idx]) {
          throw new Error("Patching slashDots." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["slashDots"] && !original["slashDots"]) {
          // Clone snapshot.
          patches.push({p: ["slashDots", idx], li: original._snapshot["slashDots"]});
      }
      if (typeof build === 'function' && reference["slashDots"][idx]) {
        let patch = (build as any)(new SlashDotBuilder(reference["slashDots"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["slashDots", idx].concat(patch.p);
          return patch;
        }));
        frozen["slashDots"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new SlashDotBuilder(reference["slashDots"][idx])).build() : build;
      if (original) {
        patches.push({p: ["slashDots", idx], li: update});
      } else {
        updates["slashDots"] = reference["slashDots"]; // TODO: Merge?
      } 
      reference["slashDots"][idx] = update;
      frozen["slashDots"][idx] = true;
      return this;
    }

    this.slashDotsSplice = (start: number, deleteCount: number, ...items: SlashDot[]): ISlashBuilder => {
      makeReference("slashDots");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["slashDots"][idx]) {
            throw new Error("Replacing slashDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["slashDots"][idx];
          patches.push({p: ["slashDots", idx], ld, li: items[idx - start]});
          frozen["slashDots"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["slashDots"][idx]) {
            throw new Error("Removing slashDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["slashDots"][idx];
          patches.push({p: ["slashDots", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["slashDots", idx], li: items[idx - start]});
          frozen["slashDots"][idx] = true;
        }
      }
      reference["slashDots"].splice(start, deleteCount, ...items);
      updates["slashDots"] = reference["slashDots"];
      frozen["slashDots"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.type = (spec: StartStop): ISlashBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }
  }
}
export function patchSlash(base: Slash, builder: (build: ISlashBuilder) => ISlashBuilder): IAny[] { return builder(new SlashBuilder(base)).patch(); }
export function buildSlash(builder: (build: ISlashBuilder) => ISlashBuilder): Slash { return builder(new SlashBuilder()).build(); }

export interface IMeasureStyleBuilder {
  build?: () => MeasureStyle;
  patch: () => IAny[];
  measureRepeat: (build: MeasureRepeat | ((builder: IMeasureRepeatBuilder) => IMeasureRepeatBuilder)) => IMeasureStyleBuilder;
  beatRepeat: (build: BeatRepeat | ((builder: IBeatRepeatBuilder) => IBeatRepeatBuilder)) => IMeasureStyleBuilder;
  multipleRest: (build: MultipleRest | ((builder: IMultipleRestBuilder) => IMultipleRestBuilder)) => IMeasureStyleBuilder;
  slash: (build: Slash | ((builder: ISlashBuilder) => ISlashBuilder)) => IMeasureStyleBuilder;
  number: (number: number) => IMeasureStyleBuilder;
  fontFamily: (fontFamily: string) => IMeasureStyleBuilder;
  fontWeight: (fontWeight: NormalBold) => IMeasureStyleBuilder;
  fontStyle: (fontStyle: NormalItalic) => IMeasureStyleBuilder;
  fontSize: (fontSize: string) => IMeasureStyleBuilder;
  color: (color: string) => IMeasureStyleBuilder;
}

class MeasureStyleBuilder implements IMeasureStyleBuilder {
  build: () => MeasureStyle;
  patch: () => IAny[];
  measureRepeat: (build: MeasureRepeat | ((builder: IMeasureRepeatBuilder) => IMeasureRepeatBuilder)) => IMeasureStyleBuilder;
  beatRepeat: (build: BeatRepeat | ((builder: IBeatRepeatBuilder) => IBeatRepeatBuilder)) => IMeasureStyleBuilder;
  multipleRest: (build: MultipleRest | ((builder: IMultipleRestBuilder) => IMultipleRestBuilder)) => IMeasureStyleBuilder;
  slash: (build: Slash | ((builder: ISlashBuilder) => ISlashBuilder)) => IMeasureStyleBuilder;
  number: (number: number) => IMeasureStyleBuilder;
  fontFamily: (fontFamily: string) => IMeasureStyleBuilder;
  fontWeight: (fontWeight: NormalBold) => IMeasureStyleBuilder;
  fontStyle: (fontStyle: NormalItalic) => IMeasureStyleBuilder;
  fontSize: (fontSize: string) => IMeasureStyleBuilder;
  color: (color: string) => IMeasureStyleBuilder;
  constructor(original?: MeasureStyle) {
    let updates: MeasureStyle = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): MeasureStyle => {
        checkInvariants();
        (updates as any)._class = "MeasureStyle";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.measureRepeat = (build: MeasureRepeat | ((builder: IMeasureRepeatBuilder) => IMeasureRepeatBuilder)): IMeasureStyleBuilder => {
      if (typeof build === 'function') {
        delete updates["measureRepeat"]
        const builder = (build as any)(new MeasureRepeatBuilder(original && original["measureRepeat"]));
        if (!original) updates["measureRepeat"] = builder.build();
        else childBuilders["measureRepeat"] = builder;
      } else {
        updates.measureRepeat = build as any;
        delete childBuilders["measureRepeat;"];
      }
      modifiedKeys["measureRepeat"] = true;
      return this;
    }

    this.beatRepeat = (build: BeatRepeat | ((builder: IBeatRepeatBuilder) => IBeatRepeatBuilder)): IMeasureStyleBuilder => {
      if (typeof build === 'function') {
        delete updates["beatRepeat"]
        const builder = (build as any)(new BeatRepeatBuilder(original && original["beatRepeat"]));
        if (!original) updates["beatRepeat"] = builder.build();
        else childBuilders["beatRepeat"] = builder;
      } else {
        updates.beatRepeat = build as any;
        delete childBuilders["beatRepeat;"];
      }
      modifiedKeys["beatRepeat"] = true;
      return this;
    }

    this.multipleRest = (build: MultipleRest | ((builder: IMultipleRestBuilder) => IMultipleRestBuilder)): IMeasureStyleBuilder => {
      if (typeof build === 'function') {
        delete updates["multipleRest"]
        const builder = (build as any)(new MultipleRestBuilder(original && original["multipleRest"]));
        if (!original) updates["multipleRest"] = builder.build();
        else childBuilders["multipleRest"] = builder;
      } else {
        updates.multipleRest = build as any;
        delete childBuilders["multipleRest;"];
      }
      modifiedKeys["multipleRest"] = true;
      return this;
    }

    this.slash = (build: Slash | ((builder: ISlashBuilder) => ISlashBuilder)): IMeasureStyleBuilder => {
      if (typeof build === 'function') {
        delete updates["slash"]
        const builder = (build as any)(new SlashBuilder(original && original["slash"]));
        if (!original) updates["slash"] = builder.build();
        else childBuilders["slash"] = builder;
      } else {
        updates.slash = build as any;
        delete childBuilders["slash;"];
      }
      modifiedKeys["slash"] = true;
      return this;
    }

    this.number = (spec: number): IMeasureStyleBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IMeasureStyleBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IMeasureStyleBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IMeasureStyleBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IMeasureStyleBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IMeasureStyleBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchMeasureStyle(base: MeasureStyle, builder: (build: IMeasureStyleBuilder) => IMeasureStyleBuilder): IAny[] { return builder(new MeasureStyleBuilder(base)).patch(); }
export function buildMeasureStyle(builder: (build: IMeasureStyleBuilder) => IMeasureStyleBuilder): MeasureStyle { return builder(new MeasureStyleBuilder()).build(); }

export interface IAttributesBuilder {
  build?: () => Attributes;
  patch: () => IAny[];
  divisions: (divisions: number) => IAttributesBuilder;
  partSymbol: (build: PartSymbol | ((builder: IPartSymbolBuilder) => IPartSymbolBuilder)) => IAttributesBuilder;
  clefsAt: (idx: number, build: Clef | ((builder: IClefBuilder) => IClefBuilder)) => IAttributesBuilder;
  clefsSplice: (start: number, deleteCount: number, ...items: Clef[]) => IAttributesBuilder;
  clefs: (clefs: Clef[]) => IAttributesBuilder;
  measureStylesAt: (idx: number, build: MeasureStyle | ((builder: IMeasureStyleBuilder) => IMeasureStyleBuilder)) => IAttributesBuilder;
  measureStylesSplice: (start: number, deleteCount: number, ...items: MeasureStyle[]) => IAttributesBuilder;
  measureStyles: (measureStyles: MeasureStyle[]) => IAttributesBuilder;
  timesAt: (idx: number, build: Time | ((builder: ITimeBuilder) => ITimeBuilder)) => IAttributesBuilder;
  timesSplice: (start: number, deleteCount: number, ...items: Time[]) => IAttributesBuilder;
  times: (times: Time[]) => IAttributesBuilder;
  staffDetailsAt: (idx: number, build: StaffDetails | ((builder: IStaffDetailsBuilder) => IStaffDetailsBuilder)) => IAttributesBuilder;
  staffDetailsSplice: (start: number, deleteCount: number, ...items: StaffDetails[]) => IAttributesBuilder;
  staffDetails: (staffDetails: StaffDetails[]) => IAttributesBuilder;
  transposesAt: (idx: number, build: Transpose | ((builder: ITransposeBuilder) => ITransposeBuilder)) => IAttributesBuilder;
  transposesSplice: (start: number, deleteCount: number, ...items: Transpose[]) => IAttributesBuilder;
  transposes: (transposes: Transpose[]) => IAttributesBuilder;
  staves: (staves: number) => IAttributesBuilder;
  instruments: (instruments: string) => IAttributesBuilder;
  keySignaturesAt: (idx: number, build: Key | ((builder: IKeyBuilder) => IKeyBuilder)) => IAttributesBuilder;
  keySignaturesSplice: (start: number, deleteCount: number, ...items: Key[]) => IAttributesBuilder;
  keySignatures: (keySignatures: Key[]) => IAttributesBuilder;
  directivesAt: (idx: number, build: Directive | ((builder: IDirectiveBuilder) => IDirectiveBuilder)) => IAttributesBuilder;
  directivesSplice: (start: number, deleteCount: number, ...items: Directive[]) => IAttributesBuilder;
  directives: (directives: Directive[]) => IAttributesBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IAttributesBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IAttributesBuilder;
}

class AttributesBuilder implements IAttributesBuilder {
  build: () => Attributes;
  patch: () => IAny[];
  divisions: (divisions: number) => IAttributesBuilder;
  partSymbol: (build: PartSymbol | ((builder: IPartSymbolBuilder) => IPartSymbolBuilder)) => IAttributesBuilder;
  clefsAt: (idx: number, build: Clef | ((builder: IClefBuilder) => IClefBuilder)) => IAttributesBuilder;
  clefsSplice: (start: number, deleteCount: number, ...items: Clef[]) => IAttributesBuilder;
  clefs: (clefs: Clef[]) => IAttributesBuilder;
  measureStylesAt: (idx: number, build: MeasureStyle | ((builder: IMeasureStyleBuilder) => IMeasureStyleBuilder)) => IAttributesBuilder;
  measureStylesSplice: (start: number, deleteCount: number, ...items: MeasureStyle[]) => IAttributesBuilder;
  measureStyles: (measureStyles: MeasureStyle[]) => IAttributesBuilder;
  timesAt: (idx: number, build: Time | ((builder: ITimeBuilder) => ITimeBuilder)) => IAttributesBuilder;
  timesSplice: (start: number, deleteCount: number, ...items: Time[]) => IAttributesBuilder;
  times: (times: Time[]) => IAttributesBuilder;
  staffDetailsAt: (idx: number, build: StaffDetails | ((builder: IStaffDetailsBuilder) => IStaffDetailsBuilder)) => IAttributesBuilder;
  staffDetailsSplice: (start: number, deleteCount: number, ...items: StaffDetails[]) => IAttributesBuilder;
  staffDetails: (staffDetails: StaffDetails[]) => IAttributesBuilder;
  transposesAt: (idx: number, build: Transpose | ((builder: ITransposeBuilder) => ITransposeBuilder)) => IAttributesBuilder;
  transposesSplice: (start: number, deleteCount: number, ...items: Transpose[]) => IAttributesBuilder;
  transposes: (transposes: Transpose[]) => IAttributesBuilder;
  staves: (staves: number) => IAttributesBuilder;
  instruments: (instruments: string) => IAttributesBuilder;
  keySignaturesAt: (idx: number, build: Key | ((builder: IKeyBuilder) => IKeyBuilder)) => IAttributesBuilder;
  keySignaturesSplice: (start: number, deleteCount: number, ...items: Key[]) => IAttributesBuilder;
  keySignatures: (keySignatures: Key[]) => IAttributesBuilder;
  directivesAt: (idx: number, build: Directive | ((builder: IDirectiveBuilder) => IDirectiveBuilder)) => IAttributesBuilder;
  directivesSplice: (start: number, deleteCount: number, ...items: Directive[]) => IAttributesBuilder;
  directives: (directives: Directive[]) => IAttributesBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IAttributesBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IAttributesBuilder;
  constructor(original?: Attributes) {
    let updates: Attributes = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Attributes => {
        checkInvariants();
        (updates as any)._class = "Attributes";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.divisions = (spec: number): IAttributesBuilder => {
        updates["divisions"] = spec;
        delete childBuilders["divisions;"];
        modifiedKeys["divisions"] = true;
        return this;
    }

    this.partSymbol = (build: PartSymbol | ((builder: IPartSymbolBuilder) => IPartSymbolBuilder)): IAttributesBuilder => {
      if (typeof build === 'function') {
        delete updates["partSymbol"]
        const builder = (build as any)(new PartSymbolBuilder(original && original["partSymbol"]));
        if (!original) updates["partSymbol"] = builder.build();
        else childBuilders["partSymbol"] = builder;
      } else {
        updates.partSymbol = build as any;
        delete childBuilders["partSymbol;"];
      }
      modifiedKeys["partSymbol"] = true;
      return this;
    }

    this.clefs = (spec: Clef[]): IAttributesBuilder => {
        updates["clefs"] = spec;
        delete childBuilders["clefs;"];
        modifiedKeys["clefs"] = true;
        return this;
    }

    this.clefsAt = (idx: number, build: Clef | ((builder: IClefBuilder) => IClefBuilder)): IAttributesBuilder => {
      makeReference("clefs");
      if (frozen["clefs"][idx]) {
          throw new Error("Patching clefs." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["clefs"] && !original["clefs"]) {
          // Clone snapshot.
          patches.push({p: ["clefs", idx], li: original._snapshot["clefs"]});
      }
      if (typeof build === 'function' && reference["clefs"][idx]) {
        let patch = (build as any)(new ClefBuilder(reference["clefs"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["clefs", idx].concat(patch.p);
          return patch;
        }));
        frozen["clefs"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new ClefBuilder(reference["clefs"][idx])).build() : build;
      if (original) {
        patches.push({p: ["clefs", idx], li: update});
      } else {
        updates["clefs"] = reference["clefs"]; // TODO: Merge?
      } 
      reference["clefs"][idx] = update;
      frozen["clefs"][idx] = true;
      return this;
    }

    this.clefsSplice = (start: number, deleteCount: number, ...items: Clef[]): IAttributesBuilder => {
      makeReference("clefs");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["clefs"][idx]) {
            throw new Error("Replacing clefs." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["clefs"][idx];
          patches.push({p: ["clefs", idx], ld, li: items[idx - start]});
          frozen["clefs"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["clefs"][idx]) {
            throw new Error("Removing clefs." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["clefs"][idx];
          patches.push({p: ["clefs", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["clefs", idx], li: items[idx - start]});
          frozen["clefs"][idx] = true;
        }
      }
      reference["clefs"].splice(start, deleteCount, ...items);
      updates["clefs"] = reference["clefs"];
      frozen["clefs"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.measureStyles = (spec: MeasureStyle[]): IAttributesBuilder => {
        updates["measureStyles"] = spec;
        delete childBuilders["measureStyles;"];
        modifiedKeys["measureStyles"] = true;
        return this;
    }

    this.measureStylesAt = (idx: number, build: MeasureStyle | ((builder: IMeasureStyleBuilder) => IMeasureStyleBuilder)): IAttributesBuilder => {
      makeReference("measureStyles");
      if (frozen["measureStyles"][idx]) {
          throw new Error("Patching measureStyles." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["measureStyles"] && !original["measureStyles"]) {
          // Clone snapshot.
          patches.push({p: ["measureStyles", idx], li: original._snapshot["measureStyles"]});
      }
      if (typeof build === 'function' && reference["measureStyles"][idx]) {
        let patch = (build as any)(new MeasureStyleBuilder(reference["measureStyles"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["measureStyles", idx].concat(patch.p);
          return patch;
        }));
        frozen["measureStyles"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new MeasureStyleBuilder(reference["measureStyles"][idx])).build() : build;
      if (original) {
        patches.push({p: ["measureStyles", idx], li: update});
      } else {
        updates["measureStyles"] = reference["measureStyles"]; // TODO: Merge?
      } 
      reference["measureStyles"][idx] = update;
      frozen["measureStyles"][idx] = true;
      return this;
    }

    this.measureStylesSplice = (start: number, deleteCount: number, ...items: MeasureStyle[]): IAttributesBuilder => {
      makeReference("measureStyles");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["measureStyles"][idx]) {
            throw new Error("Replacing measureStyles." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["measureStyles"][idx];
          patches.push({p: ["measureStyles", idx], ld, li: items[idx - start]});
          frozen["measureStyles"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["measureStyles"][idx]) {
            throw new Error("Removing measureStyles." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["measureStyles"][idx];
          patches.push({p: ["measureStyles", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["measureStyles", idx], li: items[idx - start]});
          frozen["measureStyles"][idx] = true;
        }
      }
      reference["measureStyles"].splice(start, deleteCount, ...items);
      updates["measureStyles"] = reference["measureStyles"];
      frozen["measureStyles"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.times = (spec: Time[]): IAttributesBuilder => {
        updates["times"] = spec;
        delete childBuilders["times;"];
        modifiedKeys["times"] = true;
        return this;
    }

    this.timesAt = (idx: number, build: Time | ((builder: ITimeBuilder) => ITimeBuilder)): IAttributesBuilder => {
      makeReference("times");
      if (frozen["times"][idx]) {
          throw new Error("Patching times." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["times"] && !original["times"]) {
          // Clone snapshot.
          patches.push({p: ["times", idx], li: original._snapshot["times"]});
      }
      if (typeof build === 'function' && reference["times"][idx]) {
        let patch = (build as any)(new TimeBuilder(reference["times"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["times", idx].concat(patch.p);
          return patch;
        }));
        frozen["times"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new TimeBuilder(reference["times"][idx])).build() : build;
      if (original) {
        patches.push({p: ["times", idx], li: update});
      } else {
        updates["times"] = reference["times"]; // TODO: Merge?
      } 
      reference["times"][idx] = update;
      frozen["times"][idx] = true;
      return this;
    }

    this.timesSplice = (start: number, deleteCount: number, ...items: Time[]): IAttributesBuilder => {
      makeReference("times");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["times"][idx]) {
            throw new Error("Replacing times." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["times"][idx];
          patches.push({p: ["times", idx], ld, li: items[idx - start]});
          frozen["times"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["times"][idx]) {
            throw new Error("Removing times." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["times"][idx];
          patches.push({p: ["times", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["times", idx], li: items[idx - start]});
          frozen["times"][idx] = true;
        }
      }
      reference["times"].splice(start, deleteCount, ...items);
      updates["times"] = reference["times"];
      frozen["times"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.staffDetails = (spec: StaffDetails[]): IAttributesBuilder => {
        updates["staffDetails"] = spec;
        delete childBuilders["staffDetails;"];
        modifiedKeys["staffDetails"] = true;
        return this;
    }

    this.staffDetailsAt = (idx: number, build: StaffDetails | ((builder: IStaffDetailsBuilder) => IStaffDetailsBuilder)): IAttributesBuilder => {
      makeReference("staffDetails");
      if (frozen["staffDetails"][idx]) {
          throw new Error("Patching staffDetails." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["staffDetails"] && !original["staffDetails"]) {
          // Clone snapshot.
          patches.push({p: ["staffDetails", idx], li: original._snapshot["staffDetails"]});
      }
      if (typeof build === 'function' && reference["staffDetails"][idx]) {
        let patch = (build as any)(new StaffDetailsBuilder(reference["staffDetails"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["staffDetails", idx].concat(patch.p);
          return patch;
        }));
        frozen["staffDetails"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new StaffDetailsBuilder(reference["staffDetails"][idx])).build() : build;
      if (original) {
        patches.push({p: ["staffDetails", idx], li: update});
      } else {
        updates["staffDetails"] = reference["staffDetails"]; // TODO: Merge?
      } 
      reference["staffDetails"][idx] = update;
      frozen["staffDetails"][idx] = true;
      return this;
    }

    this.staffDetailsSplice = (start: number, deleteCount: number, ...items: StaffDetails[]): IAttributesBuilder => {
      makeReference("staffDetails");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["staffDetails"][idx]) {
            throw new Error("Replacing staffDetails." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["staffDetails"][idx];
          patches.push({p: ["staffDetails", idx], ld, li: items[idx - start]});
          frozen["staffDetails"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["staffDetails"][idx]) {
            throw new Error("Removing staffDetails." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["staffDetails"][idx];
          patches.push({p: ["staffDetails", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["staffDetails", idx], li: items[idx - start]});
          frozen["staffDetails"][idx] = true;
        }
      }
      reference["staffDetails"].splice(start, deleteCount, ...items);
      updates["staffDetails"] = reference["staffDetails"];
      frozen["staffDetails"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.transposes = (spec: Transpose[]): IAttributesBuilder => {
        updates["transposes"] = spec;
        delete childBuilders["transposes;"];
        modifiedKeys["transposes"] = true;
        return this;
    }

    this.transposesAt = (idx: number, build: Transpose | ((builder: ITransposeBuilder) => ITransposeBuilder)): IAttributesBuilder => {
      makeReference("transposes");
      if (frozen["transposes"][idx]) {
          throw new Error("Patching transposes." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["transposes"] && !original["transposes"]) {
          // Clone snapshot.
          patches.push({p: ["transposes", idx], li: original._snapshot["transposes"]});
      }
      if (typeof build === 'function' && reference["transposes"][idx]) {
        let patch = (build as any)(new TransposeBuilder(reference["transposes"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["transposes", idx].concat(patch.p);
          return patch;
        }));
        frozen["transposes"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new TransposeBuilder(reference["transposes"][idx])).build() : build;
      if (original) {
        patches.push({p: ["transposes", idx], li: update});
      } else {
        updates["transposes"] = reference["transposes"]; // TODO: Merge?
      } 
      reference["transposes"][idx] = update;
      frozen["transposes"][idx] = true;
      return this;
    }

    this.transposesSplice = (start: number, deleteCount: number, ...items: Transpose[]): IAttributesBuilder => {
      makeReference("transposes");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["transposes"][idx]) {
            throw new Error("Replacing transposes." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["transposes"][idx];
          patches.push({p: ["transposes", idx], ld, li: items[idx - start]});
          frozen["transposes"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["transposes"][idx]) {
            throw new Error("Removing transposes." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["transposes"][idx];
          patches.push({p: ["transposes", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["transposes", idx], li: items[idx - start]});
          frozen["transposes"][idx] = true;
        }
      }
      reference["transposes"].splice(start, deleteCount, ...items);
      updates["transposes"] = reference["transposes"];
      frozen["transposes"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.staves = (spec: number): IAttributesBuilder => {
        updates["staves"] = spec;
        delete childBuilders["staves;"];
        modifiedKeys["staves"] = true;
        return this;
    }

    this.instruments = (spec: string): IAttributesBuilder => {
        updates["instruments"] = spec;
        delete childBuilders["instruments;"];
        modifiedKeys["instruments"] = true;
        return this;
    }

    this.keySignatures = (spec: Key[]): IAttributesBuilder => {
        updates["keySignatures"] = spec;
        delete childBuilders["keySignatures;"];
        modifiedKeys["keySignatures"] = true;
        return this;
    }

    this.keySignaturesAt = (idx: number, build: Key | ((builder: IKeyBuilder) => IKeyBuilder)): IAttributesBuilder => {
      makeReference("keySignatures");
      if (frozen["keySignatures"][idx]) {
          throw new Error("Patching keySignatures." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["keySignatures"] && !original["keySignatures"]) {
          // Clone snapshot.
          patches.push({p: ["keySignatures", idx], li: original._snapshot["keySignatures"]});
      }
      if (typeof build === 'function' && reference["keySignatures"][idx]) {
        let patch = (build as any)(new KeyBuilder(reference["keySignatures"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["keySignatures", idx].concat(patch.p);
          return patch;
        }));
        frozen["keySignatures"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new KeyBuilder(reference["keySignatures"][idx])).build() : build;
      if (original) {
        patches.push({p: ["keySignatures", idx], li: update});
      } else {
        updates["keySignatures"] = reference["keySignatures"]; // TODO: Merge?
      } 
      reference["keySignatures"][idx] = update;
      frozen["keySignatures"][idx] = true;
      return this;
    }

    this.keySignaturesSplice = (start: number, deleteCount: number, ...items: Key[]): IAttributesBuilder => {
      makeReference("keySignatures");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["keySignatures"][idx]) {
            throw new Error("Replacing keySignatures." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["keySignatures"][idx];
          patches.push({p: ["keySignatures", idx], ld, li: items[idx - start]});
          frozen["keySignatures"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["keySignatures"][idx]) {
            throw new Error("Removing keySignatures." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["keySignatures"][idx];
          patches.push({p: ["keySignatures", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["keySignatures", idx], li: items[idx - start]});
          frozen["keySignatures"][idx] = true;
        }
      }
      reference["keySignatures"].splice(start, deleteCount, ...items);
      updates["keySignatures"] = reference["keySignatures"];
      frozen["keySignatures"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.directives = (spec: Directive[]): IAttributesBuilder => {
        updates["directives"] = spec;
        delete childBuilders["directives;"];
        modifiedKeys["directives"] = true;
        return this;
    }

    this.directivesAt = (idx: number, build: Directive | ((builder: IDirectiveBuilder) => IDirectiveBuilder)): IAttributesBuilder => {
      makeReference("directives");
      if (frozen["directives"][idx]) {
          throw new Error("Patching directives." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["directives"] && !original["directives"]) {
          // Clone snapshot.
          patches.push({p: ["directives", idx], li: original._snapshot["directives"]});
      }
      if (typeof build === 'function' && reference["directives"][idx]) {
        let patch = (build as any)(new DirectiveBuilder(reference["directives"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["directives", idx].concat(patch.p);
          return patch;
        }));
        frozen["directives"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new DirectiveBuilder(reference["directives"][idx])).build() : build;
      if (original) {
        patches.push({p: ["directives", idx], li: update});
      } else {
        updates["directives"] = reference["directives"]; // TODO: Merge?
      } 
      reference["directives"][idx] = update;
      frozen["directives"][idx] = true;
      return this;
    }

    this.directivesSplice = (start: number, deleteCount: number, ...items: Directive[]): IAttributesBuilder => {
      makeReference("directives");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["directives"][idx]) {
            throw new Error("Replacing directives." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["directives"][idx];
          patches.push({p: ["directives", idx], ld, li: items[idx - start]});
          frozen["directives"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["directives"][idx]) {
            throw new Error("Removing directives." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["directives"][idx];
          patches.push({p: ["directives", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["directives", idx], li: items[idx - start]});
          frozen["directives"][idx] = true;
        }
      }
      reference["directives"].splice(start, deleteCount, ...items);
      updates["directives"] = reference["directives"];
      frozen["directives"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.footnote = (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)): IAttributesBuilder => {
      if (typeof build === 'function') {
        delete updates["footnote"]
        const builder = (build as any)(new FootnoteBuilder(original && original["footnote"]));
        if (!original) updates["footnote"] = builder.build();
        else childBuilders["footnote"] = builder;
      } else {
        updates.footnote = build as any;
        delete childBuilders["footnote;"];
      }
      modifiedKeys["footnote"] = true;
      return this;
    }

    this.level = (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)): IAttributesBuilder => {
      if (typeof build === 'function') {
        delete updates["level"]
        const builder = (build as any)(new LevelBuilder(original && original["level"]));
        if (!original) updates["level"] = builder.build();
        else childBuilders["level"] = builder;
      } else {
        updates.level = build as any;
        delete childBuilders["level;"];
      }
      modifiedKeys["level"] = true;
      return this;
    }
  }
}
export function patchAttributes(base: Attributes, builder: (build: IAttributesBuilder) => IAttributesBuilder): IAny[] { return builder(new AttributesBuilder(base)).patch(); }
export function buildAttributes(builder: (build: IAttributesBuilder) => IAttributesBuilder): Attributes { return builder(new AttributesBuilder()).build(); }

export interface ICueBuilder {
  build?: () => Cue;
  patch: () => IAny[];
}

class CueBuilder implements ICueBuilder {
  build: () => Cue;
  patch: () => IAny[];
  constructor(original?: Cue) {
    let updates: Cue = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Cue => {
        checkInvariants();
        (updates as any)._class = "Cue";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchCue(base: Cue, builder: (build: ICueBuilder) => ICueBuilder): IAny[] { return builder(new CueBuilder(base)).patch(); }
export function buildCue(builder: (build: ICueBuilder) => ICueBuilder): Cue { return builder(new CueBuilder()).build(); }

export interface IGraceBuilder {
  build?: () => Grace;
  patch: () => IAny[];
  makeTime: (makeTime: string) => IGraceBuilder;
  stealTimePrevious: (stealTimePrevious: string) => IGraceBuilder;
  slash: (slash: boolean) => IGraceBuilder;
  stealTimeFollowing: (stealTimeFollowing: string) => IGraceBuilder;
}

class GraceBuilder implements IGraceBuilder {
  build: () => Grace;
  patch: () => IAny[];
  makeTime: (makeTime: string) => IGraceBuilder;
  stealTimePrevious: (stealTimePrevious: string) => IGraceBuilder;
  slash: (slash: boolean) => IGraceBuilder;
  stealTimeFollowing: (stealTimeFollowing: string) => IGraceBuilder;
  constructor(original?: Grace) {
    let updates: Grace = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Grace => {
        checkInvariants();
        (updates as any)._class = "Grace";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.makeTime = (spec: string): IGraceBuilder => {
        updates["makeTime"] = spec;
        delete childBuilders["makeTime;"];
        modifiedKeys["makeTime"] = true;
        return this;
    }

    this.stealTimePrevious = (spec: string): IGraceBuilder => {
        updates["stealTimePrevious"] = spec;
        delete childBuilders["stealTimePrevious;"];
        modifiedKeys["stealTimePrevious"] = true;
        return this;
    }

    this.slash = (spec: boolean): IGraceBuilder => {
        updates["slash"] = spec;
        delete childBuilders["slash;"];
        modifiedKeys["slash"] = true;
        return this;
    }

    this.stealTimeFollowing = (spec: string): IGraceBuilder => {
        updates["stealTimeFollowing"] = spec;
        delete childBuilders["stealTimeFollowing;"];
        modifiedKeys["stealTimeFollowing"] = true;
        return this;
    }
  }
}
export function patchGrace(base: Grace, builder: (build: IGraceBuilder) => IGraceBuilder): IAny[] { return builder(new GraceBuilder(base)).patch(); }
export function buildGrace(builder: (build: IGraceBuilder) => IGraceBuilder): Grace { return builder(new GraceBuilder()).build(); }

export interface IChordBuilder {
  build?: () => Chord;
  patch: () => IAny[];
}

class ChordBuilder implements IChordBuilder {
  build: () => Chord;
  patch: () => IAny[];
  constructor(original?: Chord) {
    let updates: Chord = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Chord => {
        checkInvariants();
        (updates as any)._class = "Chord";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchChord(base: Chord, builder: (build: IChordBuilder) => IChordBuilder): IAny[] { return builder(new ChordBuilder(base)).patch(); }
export function buildChord(builder: (build: IChordBuilder) => IChordBuilder): Chord { return builder(new ChordBuilder()).build(); }

export interface IUnpitchedBuilder {
  build?: () => Unpitched;
  patch: () => IAny[];
  displayStep: (displayStep: string) => IUnpitchedBuilder;
  displayOctave: (displayOctave: number) => IUnpitchedBuilder;
}

class UnpitchedBuilder implements IUnpitchedBuilder {
  build: () => Unpitched;
  patch: () => IAny[];
  displayStep: (displayStep: string) => IUnpitchedBuilder;
  displayOctave: (displayOctave: number) => IUnpitchedBuilder;
  constructor(original?: Unpitched) {
    let updates: Unpitched = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Unpitched => {
        checkInvariants();
        (updates as any)._class = "Unpitched";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.displayStep = (spec: string): IUnpitchedBuilder => {
        updates["displayStep"] = spec;
        delete childBuilders["displayStep;"];
        modifiedKeys["displayStep"] = true;
        return this;
    }

    this.displayOctave = (spec: number): IUnpitchedBuilder => {
        updates["displayOctave"] = spec;
        delete childBuilders["displayOctave;"];
        modifiedKeys["displayOctave"] = true;
        return this;
    }
  }
}
export function patchUnpitched(base: Unpitched, builder: (build: IUnpitchedBuilder) => IUnpitchedBuilder): IAny[] { return builder(new UnpitchedBuilder(base)).patch(); }
export function buildUnpitched(builder: (build: IUnpitchedBuilder) => IUnpitchedBuilder): Unpitched { return builder(new UnpitchedBuilder()).build(); }

export interface IPitchBuilder {
  build?: () => Pitch;
  patch: () => IAny[];
  alter: (alter: number) => IPitchBuilder;
  step: (step: string) => IPitchBuilder;
  octave: (octave: number) => IPitchBuilder;
}

class PitchBuilder implements IPitchBuilder {
  build: () => Pitch;
  patch: () => IAny[];
  alter: (alter: number) => IPitchBuilder;
  step: (step: string) => IPitchBuilder;
  octave: (octave: number) => IPitchBuilder;
  constructor(original?: Pitch) {
    let updates: Pitch = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["octave"]) ||
          childBuilders["octave"] !== undefined ||
          updates.octave !== undefined,
        "octave is a required field");
    }

    if (!original) {
      this.build = (): Pitch => {
        checkInvariants();
        (updates as any)._class = "Pitch";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.alter = (spec: number): IPitchBuilder => {
        updates["alter"] = spec;
        delete childBuilders["alter;"];
        modifiedKeys["alter"] = true;
        return this;
    }

    this.step = (spec: string): IPitchBuilder => {
        updates["step"] = spec;
        delete childBuilders["step;"];
        modifiedKeys["step"] = true;
        return this;
    }

    this.octave = (spec: number): IPitchBuilder => {
        updates["octave"] = spec;
        delete childBuilders["octave;"];
        modifiedKeys["octave"] = true;
        return this;
    }
  }
}
export function patchPitch(base: Pitch, builder: (build: IPitchBuilder) => IPitchBuilder): IAny[] { return builder(new PitchBuilder(base)).patch(); }
export function buildPitch(builder: (build: IPitchBuilder) => IPitchBuilder): Pitch { return builder(new PitchBuilder()).build(); }

export interface IFullNoteBuilder {
  build?: () => FullNote;
  patch: () => IAny[];
  unpitched: (build: Unpitched | ((builder: IUnpitchedBuilder) => IUnpitchedBuilder)) => IFullNoteBuilder;
  chord: (build: Chord | ((builder: IChordBuilder) => IChordBuilder)) => IFullNoteBuilder;
  pitch: (build: Pitch | ((builder: IPitchBuilder) => IPitchBuilder)) => IFullNoteBuilder;
  rest: (build: Rest | ((builder: IRestBuilder) => IRestBuilder)) => IFullNoteBuilder;
}

class FullNoteBuilder implements IFullNoteBuilder {
  build: () => FullNote;
  patch: () => IAny[];
  unpitched: (build: Unpitched | ((builder: IUnpitchedBuilder) => IUnpitchedBuilder)) => IFullNoteBuilder;
  chord: (build: Chord | ((builder: IChordBuilder) => IChordBuilder)) => IFullNoteBuilder;
  pitch: (build: Pitch | ((builder: IPitchBuilder) => IPitchBuilder)) => IFullNoteBuilder;
  rest: (build: Rest | ((builder: IRestBuilder) => IRestBuilder)) => IFullNoteBuilder;
  constructor(original?: FullNote) {
    let updates: FullNote = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): FullNote => {
        checkInvariants();
        (updates as any)._class = "FullNote";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.unpitched = (build: Unpitched | ((builder: IUnpitchedBuilder) => IUnpitchedBuilder)): IFullNoteBuilder => {
      if (typeof build === 'function') {
        delete updates["unpitched"]
        const builder = (build as any)(new UnpitchedBuilder(original && original["unpitched"]));
        if (!original) updates["unpitched"] = builder.build();
        else childBuilders["unpitched"] = builder;
      } else {
        updates.unpitched = build as any;
        delete childBuilders["unpitched;"];
      }
      modifiedKeys["unpitched"] = true;
      return this;
    }

    this.chord = (build: Chord | ((builder: IChordBuilder) => IChordBuilder)): IFullNoteBuilder => {
      if (typeof build === 'function') {
        delete updates["chord"]
        const builder = (build as any)(new ChordBuilder(original && original["chord"]));
        if (!original) updates["chord"] = builder.build();
        else childBuilders["chord"] = builder;
      } else {
        updates.chord = build as any;
        delete childBuilders["chord;"];
      }
      modifiedKeys["chord"] = true;
      return this;
    }

    this.pitch = (build: Pitch | ((builder: IPitchBuilder) => IPitchBuilder)): IFullNoteBuilder => {
      if (typeof build === 'function') {
        delete updates["pitch"]
        const builder = (build as any)(new PitchBuilder(original && original["pitch"]));
        if (!original) updates["pitch"] = builder.build();
        else childBuilders["pitch"] = builder;
      } else {
        updates.pitch = build as any;
        delete childBuilders["pitch;"];
      }
      modifiedKeys["pitch"] = true;
      return this;
    }

    this.rest = (build: Rest | ((builder: IRestBuilder) => IRestBuilder)): IFullNoteBuilder => {
      if (typeof build === 'function') {
        delete updates["rest"]
        const builder = (build as any)(new RestBuilder(original && original["rest"]));
        if (!original) updates["rest"] = builder.build();
        else childBuilders["rest"] = builder;
      } else {
        updates.rest = build as any;
        delete childBuilders["rest;"];
      }
      modifiedKeys["rest"] = true;
      return this;
    }
  }
}
export function patchFullNote(base: FullNote, builder: (build: IFullNoteBuilder) => IFullNoteBuilder): IAny[] { return builder(new FullNoteBuilder(base)).patch(); }
export function buildFullNote(builder: (build: IFullNoteBuilder) => IFullNoteBuilder): FullNote { return builder(new FullNoteBuilder()).build(); }

export interface IRestBuilder {
  build?: () => Rest;
  patch: () => IAny[];
  measure: (measure: boolean) => IRestBuilder;
  displayStep: (displayStep: string) => IRestBuilder;
  displayOctave: (displayOctave: number) => IRestBuilder;
}

class RestBuilder implements IRestBuilder {
  build: () => Rest;
  patch: () => IAny[];
  measure: (measure: boolean) => IRestBuilder;
  displayStep: (displayStep: string) => IRestBuilder;
  displayOctave: (displayOctave: number) => IRestBuilder;
  constructor(original?: Rest) {
    let updates: Rest = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Rest => {
        checkInvariants();
        (updates as any)._class = "Rest";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.measure = (spec: boolean): IRestBuilder => {
        updates["measure"] = spec;
        delete childBuilders["measure;"];
        modifiedKeys["measure"] = true;
        return this;
    }

    this.displayStep = (spec: string): IRestBuilder => {
        updates["displayStep"] = spec;
        delete childBuilders["displayStep;"];
        modifiedKeys["displayStep"] = true;
        return this;
    }

    this.displayOctave = (spec: number): IRestBuilder => {
        updates["displayOctave"] = spec;
        delete childBuilders["displayOctave;"];
        modifiedKeys["displayOctave"] = true;
        return this;
    }
  }
}
export function patchRest(base: Rest, builder: (build: IRestBuilder) => IRestBuilder): IAny[] { return builder(new RestBuilder(base)).patch(); }
export function buildRest(builder: (build: IRestBuilder) => IRestBuilder): Rest { return builder(new RestBuilder()).build(); }

export interface ITieBuilder {
  build?: () => Tie;
  patch: () => IAny[];
  type: (type: StartStop) => ITieBuilder;
  timeOnly: (timeOnly: string) => ITieBuilder;
}

class TieBuilder implements ITieBuilder {
  build: () => Tie;
  patch: () => IAny[];
  type: (type: StartStop) => ITieBuilder;
  timeOnly: (timeOnly: string) => ITieBuilder;
  constructor(original?: Tie) {
    let updates: Tie = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Tie => {
        checkInvariants();
        (updates as any)._class = "Tie";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.type = (spec: StartStop): ITieBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.timeOnly = (spec: string): ITieBuilder => {
        updates["timeOnly"] = spec;
        delete childBuilders["timeOnly;"];
        modifiedKeys["timeOnly"] = true;
        return this;
    }
  }
}
export function patchTie(base: Tie, builder: (build: ITieBuilder) => ITieBuilder): IAny[] { return builder(new TieBuilder(base)).patch(); }
export function buildTie(builder: (build: ITieBuilder) => ITieBuilder): Tie { return builder(new TieBuilder()).build(); }

export interface IInstrumentBuilder {
  build?: () => Instrument;
  patch: () => IAny[];
  id: (id: string) => IInstrumentBuilder;
}

class InstrumentBuilder implements IInstrumentBuilder {
  build: () => Instrument;
  patch: () => IAny[];
  id: (id: string) => IInstrumentBuilder;
  constructor(original?: Instrument) {
    let updates: Instrument = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["id"]) ||
          childBuilders["id"] !== undefined ||
          updates.id !== undefined,
        "id is a required field");
    }

    if (!original) {
      this.build = (): Instrument => {
        checkInvariants();
        (updates as any)._class = "Instrument";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.id = (spec: string): IInstrumentBuilder => {
        updates["id"] = spec;
        delete childBuilders["id;"];
        modifiedKeys["id"] = true;
        return this;
    }
  }
}
export function patchInstrument(base: Instrument, builder: (build: IInstrumentBuilder) => IInstrumentBuilder): IAny[] { return builder(new InstrumentBuilder(base)).patch(); }
export function buildInstrument(builder: (build: IInstrumentBuilder) => IInstrumentBuilder): Instrument { return builder(new InstrumentBuilder()).build(); }

export interface INoteBuilder {
  build?: () => Note;
  patch: () => IAny[];
  noteheadText: (build: NoteheadText | ((builder: INoteheadTextBuilder) => INoteheadTextBuilder)) => INoteBuilder;
  timeModification: (build: TimeModification | ((builder: ITimeModificationBuilder) => ITimeModificationBuilder)) => INoteBuilder;
  accidental: (build: Accidental | ((builder: IAccidentalBuilder) => IAccidentalBuilder)) => INoteBuilder;
  instrument: (build: Instrument | ((builder: IInstrumentBuilder) => IInstrumentBuilder)) => INoteBuilder;
  attack: (attack: number) => INoteBuilder;
  endDynamics: (endDynamics: number) => INoteBuilder;
  lyricsAt: (idx: number, build: Lyric | ((builder: ILyricBuilder) => ILyricBuilder)) => INoteBuilder;
  lyricsSplice: (start: number, deleteCount: number, ...items: Lyric[]) => INoteBuilder;
  lyrics: (lyrics: Lyric[]) => INoteBuilder;
  dotsAt: (idx: number, build: Dot | ((builder: IDotBuilder) => IDotBuilder)) => INoteBuilder;
  dotsSplice: (start: number, deleteCount: number, ...items: Dot[]) => INoteBuilder;
  dots: (dots: Dot[]) => INoteBuilder;
  notationsAt: (idx: number, build: Notations | ((builder: INotationsBuilder) => INotationsBuilder)) => INoteBuilder;
  notationsSplice: (start: number, deleteCount: number, ...items: Notations[]) => INoteBuilder;
  notations: (notations: Notations[]) => INoteBuilder;
  stem: (build: Stem | ((builder: IStemBuilder) => IStemBuilder)) => INoteBuilder;
  noteType: (build: Type | ((builder: ITypeBuilder) => ITypeBuilder)) => INoteBuilder;
  pizzicato: (pizzicato: boolean) => INoteBuilder;
  cue: (build: Cue | ((builder: ICueBuilder) => ICueBuilder)) => INoteBuilder;
  duration: (duration: number) => INoteBuilder;
  tiesAt: (idx: number, build: Tie | ((builder: ITieBuilder) => ITieBuilder)) => INoteBuilder;
  tiesSplice: (start: number, deleteCount: number, ...items: Tie[]) => INoteBuilder;
  ties: (ties: Tie[]) => INoteBuilder;
  dynamics: (dynamics: number) => INoteBuilder;
  play: (build: Play | ((builder: IPlayBuilder) => IPlayBuilder)) => INoteBuilder;
  staff: (staff: number) => INoteBuilder;
  grace: (build: Grace | ((builder: IGraceBuilder) => IGraceBuilder)) => INoteBuilder;
  notehead: (build: Notehead | ((builder: INoteheadBuilder) => INoteheadBuilder)) => INoteBuilder;
  release: (release: number) => INoteBuilder;
  beamsAt: (idx: number, build: Beam | ((builder: IBeamBuilder) => IBeamBuilder)) => INoteBuilder;
  beamsSplice: (start: number, deleteCount: number, ...items: Beam[]) => INoteBuilder;
  beams: (beams: Beam[]) => INoteBuilder;
  defaultX: (defaultX: number) => INoteBuilder;
  relativeY: (relativeY: number) => INoteBuilder;
  defaultY: (defaultY: number) => INoteBuilder;
  relativeX: (relativeX: number) => INoteBuilder;
  fontFamily: (fontFamily: string) => INoteBuilder;
  fontWeight: (fontWeight: NormalBold) => INoteBuilder;
  fontStyle: (fontStyle: NormalItalic) => INoteBuilder;
  fontSize: (fontSize: string) => INoteBuilder;
  color: (color: string) => INoteBuilder;
  timeOnly: (timeOnly: string) => INoteBuilder;
  voice: (voice: number) => INoteBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => INoteBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => INoteBuilder;
  printDot: (printDot: boolean) => INoteBuilder;
  printLyric: (printLyric: boolean) => INoteBuilder;
  printObject: (printObject: boolean) => INoteBuilder;
  printSpacing: (printSpacing: boolean) => INoteBuilder;
  unpitched: (build: Unpitched | ((builder: IUnpitchedBuilder) => IUnpitchedBuilder)) => INoteBuilder;
  chord: (build: Chord | ((builder: IChordBuilder) => IChordBuilder)) => INoteBuilder;
  pitch: (build: Pitch | ((builder: IPitchBuilder) => IPitchBuilder)) => INoteBuilder;
  rest: (build: Rest | ((builder: IRestBuilder) => IRestBuilder)) => INoteBuilder;
}

class NoteBuilder implements INoteBuilder {
  build: () => Note;
  patch: () => IAny[];
  noteheadText: (build: NoteheadText | ((builder: INoteheadTextBuilder) => INoteheadTextBuilder)) => INoteBuilder;
  timeModification: (build: TimeModification | ((builder: ITimeModificationBuilder) => ITimeModificationBuilder)) => INoteBuilder;
  accidental: (build: Accidental | ((builder: IAccidentalBuilder) => IAccidentalBuilder)) => INoteBuilder;
  instrument: (build: Instrument | ((builder: IInstrumentBuilder) => IInstrumentBuilder)) => INoteBuilder;
  attack: (attack: number) => INoteBuilder;
  endDynamics: (endDynamics: number) => INoteBuilder;
  lyricsAt: (idx: number, build: Lyric | ((builder: ILyricBuilder) => ILyricBuilder)) => INoteBuilder;
  lyricsSplice: (start: number, deleteCount: number, ...items: Lyric[]) => INoteBuilder;
  lyrics: (lyrics: Lyric[]) => INoteBuilder;
  dotsAt: (idx: number, build: Dot | ((builder: IDotBuilder) => IDotBuilder)) => INoteBuilder;
  dotsSplice: (start: number, deleteCount: number, ...items: Dot[]) => INoteBuilder;
  dots: (dots: Dot[]) => INoteBuilder;
  notationsAt: (idx: number, build: Notations | ((builder: INotationsBuilder) => INotationsBuilder)) => INoteBuilder;
  notationsSplice: (start: number, deleteCount: number, ...items: Notations[]) => INoteBuilder;
  notations: (notations: Notations[]) => INoteBuilder;
  stem: (build: Stem | ((builder: IStemBuilder) => IStemBuilder)) => INoteBuilder;
  noteType: (build: Type | ((builder: ITypeBuilder) => ITypeBuilder)) => INoteBuilder;
  pizzicato: (pizzicato: boolean) => INoteBuilder;
  cue: (build: Cue | ((builder: ICueBuilder) => ICueBuilder)) => INoteBuilder;
  duration: (duration: number) => INoteBuilder;
  tiesAt: (idx: number, build: Tie | ((builder: ITieBuilder) => ITieBuilder)) => INoteBuilder;
  tiesSplice: (start: number, deleteCount: number, ...items: Tie[]) => INoteBuilder;
  ties: (ties: Tie[]) => INoteBuilder;
  dynamics: (dynamics: number) => INoteBuilder;
  play: (build: Play | ((builder: IPlayBuilder) => IPlayBuilder)) => INoteBuilder;
  staff: (staff: number) => INoteBuilder;
  grace: (build: Grace | ((builder: IGraceBuilder) => IGraceBuilder)) => INoteBuilder;
  notehead: (build: Notehead | ((builder: INoteheadBuilder) => INoteheadBuilder)) => INoteBuilder;
  release: (release: number) => INoteBuilder;
  beamsAt: (idx: number, build: Beam | ((builder: IBeamBuilder) => IBeamBuilder)) => INoteBuilder;
  beamsSplice: (start: number, deleteCount: number, ...items: Beam[]) => INoteBuilder;
  beams: (beams: Beam[]) => INoteBuilder;
  defaultX: (defaultX: number) => INoteBuilder;
  relativeY: (relativeY: number) => INoteBuilder;
  defaultY: (defaultY: number) => INoteBuilder;
  relativeX: (relativeX: number) => INoteBuilder;
  fontFamily: (fontFamily: string) => INoteBuilder;
  fontWeight: (fontWeight: NormalBold) => INoteBuilder;
  fontStyle: (fontStyle: NormalItalic) => INoteBuilder;
  fontSize: (fontSize: string) => INoteBuilder;
  color: (color: string) => INoteBuilder;
  timeOnly: (timeOnly: string) => INoteBuilder;
  voice: (voice: number) => INoteBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => INoteBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => INoteBuilder;
  printDot: (printDot: boolean) => INoteBuilder;
  printLyric: (printLyric: boolean) => INoteBuilder;
  printObject: (printObject: boolean) => INoteBuilder;
  printSpacing: (printSpacing: boolean) => INoteBuilder;
  unpitched: (build: Unpitched | ((builder: IUnpitchedBuilder) => IUnpitchedBuilder)) => INoteBuilder;
  chord: (build: Chord | ((builder: IChordBuilder) => IChordBuilder)) => INoteBuilder;
  pitch: (build: Pitch | ((builder: IPitchBuilder) => IPitchBuilder)) => INoteBuilder;
  rest: (build: Rest | ((builder: IRestBuilder) => IRestBuilder)) => INoteBuilder;
  constructor(original?: Note) {
    let updates: Note = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Note => {
        checkInvariants();
        (updates as any)._class = "Note";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.noteheadText = (build: NoteheadText | ((builder: INoteheadTextBuilder) => INoteheadTextBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["noteheadText"]
        const builder = (build as any)(new NoteheadTextBuilder(original && original["noteheadText"]));
        if (!original) updates["noteheadText"] = builder.build();
        else childBuilders["noteheadText"] = builder;
      } else {
        updates.noteheadText = build as any;
        delete childBuilders["noteheadText;"];
      }
      modifiedKeys["noteheadText"] = true;
      return this;
    }

    this.timeModification = (build: TimeModification | ((builder: ITimeModificationBuilder) => ITimeModificationBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["timeModification"]
        const builder = (build as any)(new TimeModificationBuilder(original && original["timeModification"]));
        if (!original) updates["timeModification"] = builder.build();
        else childBuilders["timeModification"] = builder;
      } else {
        updates.timeModification = build as any;
        delete childBuilders["timeModification;"];
      }
      modifiedKeys["timeModification"] = true;
      return this;
    }

    this.accidental = (build: Accidental | ((builder: IAccidentalBuilder) => IAccidentalBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["accidental"]
        const builder = (build as any)(new AccidentalBuilder(original && original["accidental"]));
        if (!original) updates["accidental"] = builder.build();
        else childBuilders["accidental"] = builder;
      } else {
        updates.accidental = build as any;
        delete childBuilders["accidental;"];
      }
      modifiedKeys["accidental"] = true;
      return this;
    }

    this.instrument = (build: Instrument | ((builder: IInstrumentBuilder) => IInstrumentBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["instrument"]
        const builder = (build as any)(new InstrumentBuilder(original && original["instrument"]));
        if (!original) updates["instrument"] = builder.build();
        else childBuilders["instrument"] = builder;
      } else {
        updates.instrument = build as any;
        delete childBuilders["instrument;"];
      }
      modifiedKeys["instrument"] = true;
      return this;
    }

    this.attack = (spec: number): INoteBuilder => {
        updates["attack"] = spec;
        delete childBuilders["attack;"];
        modifiedKeys["attack"] = true;
        return this;
    }

    this.endDynamics = (spec: number): INoteBuilder => {
        updates["endDynamics"] = spec;
        delete childBuilders["endDynamics;"];
        modifiedKeys["endDynamics"] = true;
        return this;
    }

    this.lyrics = (spec: Lyric[]): INoteBuilder => {
        updates["lyrics"] = spec;
        delete childBuilders["lyrics;"];
        modifiedKeys["lyrics"] = true;
        return this;
    }

    this.lyricsAt = (idx: number, build: Lyric | ((builder: ILyricBuilder) => ILyricBuilder)): INoteBuilder => {
      makeReference("lyrics");
      if (frozen["lyrics"][idx]) {
          throw new Error("Patching lyrics." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["lyrics"] && !original["lyrics"]) {
          // Clone snapshot.
          patches.push({p: ["lyrics", idx], li: original._snapshot["lyrics"]});
      }
      if (typeof build === 'function' && reference["lyrics"][idx]) {
        let patch = (build as any)(new LyricBuilder(reference["lyrics"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["lyrics", idx].concat(patch.p);
          return patch;
        }));
        frozen["lyrics"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new LyricBuilder(reference["lyrics"][idx])).build() : build;
      if (original) {
        patches.push({p: ["lyrics", idx], li: update});
      } else {
        updates["lyrics"] = reference["lyrics"]; // TODO: Merge?
      } 
      reference["lyrics"][idx] = update;
      frozen["lyrics"][idx] = true;
      return this;
    }

    this.lyricsSplice = (start: number, deleteCount: number, ...items: Lyric[]): INoteBuilder => {
      makeReference("lyrics");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["lyrics"][idx]) {
            throw new Error("Replacing lyrics." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["lyrics"][idx];
          patches.push({p: ["lyrics", idx], ld, li: items[idx - start]});
          frozen["lyrics"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["lyrics"][idx]) {
            throw new Error("Removing lyrics." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["lyrics"][idx];
          patches.push({p: ["lyrics", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["lyrics", idx], li: items[idx - start]});
          frozen["lyrics"][idx] = true;
        }
      }
      reference["lyrics"].splice(start, deleteCount, ...items);
      updates["lyrics"] = reference["lyrics"];
      frozen["lyrics"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.dots = (spec: Dot[]): INoteBuilder => {
        updates["dots"] = spec;
        delete childBuilders["dots;"];
        modifiedKeys["dots"] = true;
        return this;
    }

    this.dotsAt = (idx: number, build: Dot | ((builder: IDotBuilder) => IDotBuilder)): INoteBuilder => {
      makeReference("dots");
      if (frozen["dots"][idx]) {
          throw new Error("Patching dots." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["dots"] && !original["dots"]) {
          // Clone snapshot.
          patches.push({p: ["dots", idx], li: original._snapshot["dots"]});
      }
      if (typeof build === 'function' && reference["dots"][idx]) {
        let patch = (build as any)(new DotBuilder(reference["dots"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["dots", idx].concat(patch.p);
          return patch;
        }));
        frozen["dots"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new DotBuilder(reference["dots"][idx])).build() : build;
      if (original) {
        patches.push({p: ["dots", idx], li: update});
      } else {
        updates["dots"] = reference["dots"]; // TODO: Merge?
      } 
      reference["dots"][idx] = update;
      frozen["dots"][idx] = true;
      return this;
    }

    this.dotsSplice = (start: number, deleteCount: number, ...items: Dot[]): INoteBuilder => {
      makeReference("dots");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["dots"][idx]) {
            throw new Error("Replacing dots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["dots"][idx];
          patches.push({p: ["dots", idx], ld, li: items[idx - start]});
          frozen["dots"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["dots"][idx]) {
            throw new Error("Removing dots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["dots"][idx];
          patches.push({p: ["dots", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["dots", idx], li: items[idx - start]});
          frozen["dots"][idx] = true;
        }
      }
      reference["dots"].splice(start, deleteCount, ...items);
      updates["dots"] = reference["dots"];
      frozen["dots"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.notations = (spec: Notations[]): INoteBuilder => {
        updates["notations"] = spec;
        delete childBuilders["notations;"];
        modifiedKeys["notations"] = true;
        return this;
    }

    this.notationsAt = (idx: number, build: Notations | ((builder: INotationsBuilder) => INotationsBuilder)): INoteBuilder => {
      makeReference("notations");
      if (frozen["notations"][idx]) {
          throw new Error("Patching notations." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["notations"] && !original["notations"]) {
          // Clone snapshot.
          patches.push({p: ["notations", idx], li: original._snapshot["notations"]});
      }
      if (typeof build === 'function' && reference["notations"][idx]) {
        let patch = (build as any)(new NotationsBuilder(reference["notations"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["notations", idx].concat(patch.p);
          return patch;
        }));
        frozen["notations"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new NotationsBuilder(reference["notations"][idx])).build() : build;
      if (original) {
        patches.push({p: ["notations", idx], li: update});
      } else {
        updates["notations"] = reference["notations"]; // TODO: Merge?
      } 
      reference["notations"][idx] = update;
      frozen["notations"][idx] = true;
      return this;
    }

    this.notationsSplice = (start: number, deleteCount: number, ...items: Notations[]): INoteBuilder => {
      makeReference("notations");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["notations"][idx]) {
            throw new Error("Replacing notations." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["notations"][idx];
          patches.push({p: ["notations", idx], ld, li: items[idx - start]});
          frozen["notations"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["notations"][idx]) {
            throw new Error("Removing notations." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["notations"][idx];
          patches.push({p: ["notations", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["notations", idx], li: items[idx - start]});
          frozen["notations"][idx] = true;
        }
      }
      reference["notations"].splice(start, deleteCount, ...items);
      updates["notations"] = reference["notations"];
      frozen["notations"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.stem = (build: Stem | ((builder: IStemBuilder) => IStemBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["stem"]
        const builder = (build as any)(new StemBuilder(original && original["stem"]));
        if (!original) updates["stem"] = builder.build();
        else childBuilders["stem"] = builder;
      } else {
        updates.stem = build as any;
        delete childBuilders["stem;"];
      }
      modifiedKeys["stem"] = true;
      return this;
    }

    this.noteType = (build: Type | ((builder: ITypeBuilder) => ITypeBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["noteType"]
        const builder = (build as any)(new TypeBuilder(original && original["noteType"]));
        if (!original) updates["noteType"] = builder.build();
        else childBuilders["noteType"] = builder;
      } else {
        updates.noteType = build as any;
        delete childBuilders["noteType;"];
      }
      modifiedKeys["noteType"] = true;
      return this;
    }

    this.pizzicato = (spec: boolean): INoteBuilder => {
        updates["pizzicato"] = spec;
        delete childBuilders["pizzicato;"];
        modifiedKeys["pizzicato"] = true;
        return this;
    }

    this.cue = (build: Cue | ((builder: ICueBuilder) => ICueBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["cue"]
        const builder = (build as any)(new CueBuilder(original && original["cue"]));
        if (!original) updates["cue"] = builder.build();
        else childBuilders["cue"] = builder;
      } else {
        updates.cue = build as any;
        delete childBuilders["cue;"];
      }
      modifiedKeys["cue"] = true;
      return this;
    }

    this.duration = (spec: number): INoteBuilder => {
        updates["duration"] = spec;
        delete childBuilders["duration;"];
        modifiedKeys["duration"] = true;
        return this;
    }

    this.ties = (spec: Tie[]): INoteBuilder => {
        updates["ties"] = spec;
        delete childBuilders["ties;"];
        modifiedKeys["ties"] = true;
        return this;
    }

    this.tiesAt = (idx: number, build: Tie | ((builder: ITieBuilder) => ITieBuilder)): INoteBuilder => {
      makeReference("ties");
      if (frozen["ties"][idx]) {
          throw new Error("Patching ties." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["ties"] && !original["ties"]) {
          // Clone snapshot.
          patches.push({p: ["ties", idx], li: original._snapshot["ties"]});
      }
      if (typeof build === 'function' && reference["ties"][idx]) {
        let patch = (build as any)(new TieBuilder(reference["ties"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["ties", idx].concat(patch.p);
          return patch;
        }));
        frozen["ties"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new TieBuilder(reference["ties"][idx])).build() : build;
      if (original) {
        patches.push({p: ["ties", idx], li: update});
      } else {
        updates["ties"] = reference["ties"]; // TODO: Merge?
      } 
      reference["ties"][idx] = update;
      frozen["ties"][idx] = true;
      return this;
    }

    this.tiesSplice = (start: number, deleteCount: number, ...items: Tie[]): INoteBuilder => {
      makeReference("ties");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["ties"][idx]) {
            throw new Error("Replacing ties." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["ties"][idx];
          patches.push({p: ["ties", idx], ld, li: items[idx - start]});
          frozen["ties"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["ties"][idx]) {
            throw new Error("Removing ties." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["ties"][idx];
          patches.push({p: ["ties", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["ties", idx], li: items[idx - start]});
          frozen["ties"][idx] = true;
        }
      }
      reference["ties"].splice(start, deleteCount, ...items);
      updates["ties"] = reference["ties"];
      frozen["ties"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.dynamics = (spec: number): INoteBuilder => {
        updates["dynamics"] = spec;
        delete childBuilders["dynamics;"];
        modifiedKeys["dynamics"] = true;
        return this;
    }

    this.play = (build: Play | ((builder: IPlayBuilder) => IPlayBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["play"]
        const builder = (build as any)(new PlayBuilder(original && original["play"]));
        if (!original) updates["play"] = builder.build();
        else childBuilders["play"] = builder;
      } else {
        updates.play = build as any;
        delete childBuilders["play;"];
      }
      modifiedKeys["play"] = true;
      return this;
    }

    this.staff = (spec: number): INoteBuilder => {
        updates["staff"] = spec;
        delete childBuilders["staff;"];
        modifiedKeys["staff"] = true;
        return this;
    }

    this.grace = (build: Grace | ((builder: IGraceBuilder) => IGraceBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["grace"]
        const builder = (build as any)(new GraceBuilder(original && original["grace"]));
        if (!original) updates["grace"] = builder.build();
        else childBuilders["grace"] = builder;
      } else {
        updates.grace = build as any;
        delete childBuilders["grace;"];
      }
      modifiedKeys["grace"] = true;
      return this;
    }

    this.notehead = (build: Notehead | ((builder: INoteheadBuilder) => INoteheadBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["notehead"]
        const builder = (build as any)(new NoteheadBuilder(original && original["notehead"]));
        if (!original) updates["notehead"] = builder.build();
        else childBuilders["notehead"] = builder;
      } else {
        updates.notehead = build as any;
        delete childBuilders["notehead;"];
      }
      modifiedKeys["notehead"] = true;
      return this;
    }

    this.release = (spec: number): INoteBuilder => {
        updates["release"] = spec;
        delete childBuilders["release;"];
        modifiedKeys["release"] = true;
        return this;
    }

    this.beams = (spec: Beam[]): INoteBuilder => {
        updates["beams"] = spec;
        delete childBuilders["beams;"];
        modifiedKeys["beams"] = true;
        return this;
    }

    this.beamsAt = (idx: number, build: Beam | ((builder: IBeamBuilder) => IBeamBuilder)): INoteBuilder => {
      makeReference("beams");
      if (frozen["beams"][idx]) {
          throw new Error("Patching beams." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["beams"] && !original["beams"]) {
          // Clone snapshot.
          patches.push({p: ["beams", idx], li: original._snapshot["beams"]});
      }
      if (typeof build === 'function' && reference["beams"][idx]) {
        let patch = (build as any)(new BeamBuilder(reference["beams"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["beams", idx].concat(patch.p);
          return patch;
        }));
        frozen["beams"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new BeamBuilder(reference["beams"][idx])).build() : build;
      if (original) {
        patches.push({p: ["beams", idx], li: update});
      } else {
        updates["beams"] = reference["beams"]; // TODO: Merge?
      } 
      reference["beams"][idx] = update;
      frozen["beams"][idx] = true;
      return this;
    }

    this.beamsSplice = (start: number, deleteCount: number, ...items: Beam[]): INoteBuilder => {
      makeReference("beams");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["beams"][idx]) {
            throw new Error("Replacing beams." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["beams"][idx];
          patches.push({p: ["beams", idx], ld, li: items[idx - start]});
          frozen["beams"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["beams"][idx]) {
            throw new Error("Removing beams." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["beams"][idx];
          patches.push({p: ["beams", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["beams", idx], li: items[idx - start]});
          frozen["beams"][idx] = true;
        }
      }
      reference["beams"].splice(start, deleteCount, ...items);
      updates["beams"] = reference["beams"];
      frozen["beams"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.defaultX = (spec: number): INoteBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): INoteBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): INoteBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): INoteBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): INoteBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): INoteBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): INoteBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): INoteBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): INoteBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.timeOnly = (spec: string): INoteBuilder => {
        updates["timeOnly"] = spec;
        delete childBuilders["timeOnly;"];
        modifiedKeys["timeOnly"] = true;
        return this;
    }

    this.voice = (spec: number): INoteBuilder => {
        updates["voice"] = spec;
        delete childBuilders["voice;"];
        modifiedKeys["voice"] = true;
        return this;
    }

    this.footnote = (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["footnote"]
        const builder = (build as any)(new FootnoteBuilder(original && original["footnote"]));
        if (!original) updates["footnote"] = builder.build();
        else childBuilders["footnote"] = builder;
      } else {
        updates.footnote = build as any;
        delete childBuilders["footnote;"];
      }
      modifiedKeys["footnote"] = true;
      return this;
    }

    this.level = (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["level"]
        const builder = (build as any)(new LevelBuilder(original && original["level"]));
        if (!original) updates["level"] = builder.build();
        else childBuilders["level"] = builder;
      } else {
        updates.level = build as any;
        delete childBuilders["level;"];
      }
      modifiedKeys["level"] = true;
      return this;
    }

    this.printDot = (spec: boolean): INoteBuilder => {
        updates["printDot"] = spec;
        delete childBuilders["printDot;"];
        modifiedKeys["printDot"] = true;
        return this;
    }

    this.printLyric = (spec: boolean): INoteBuilder => {
        updates["printLyric"] = spec;
        delete childBuilders["printLyric;"];
        modifiedKeys["printLyric"] = true;
        return this;
    }

    this.printObject = (spec: boolean): INoteBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.printSpacing = (spec: boolean): INoteBuilder => {
        updates["printSpacing"] = spec;
        delete childBuilders["printSpacing;"];
        modifiedKeys["printSpacing"] = true;
        return this;
    }

    this.unpitched = (build: Unpitched | ((builder: IUnpitchedBuilder) => IUnpitchedBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["unpitched"]
        const builder = (build as any)(new UnpitchedBuilder(original && original["unpitched"]));
        if (!original) updates["unpitched"] = builder.build();
        else childBuilders["unpitched"] = builder;
      } else {
        updates.unpitched = build as any;
        delete childBuilders["unpitched;"];
      }
      modifiedKeys["unpitched"] = true;
      return this;
    }

    this.chord = (build: Chord | ((builder: IChordBuilder) => IChordBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["chord"]
        const builder = (build as any)(new ChordBuilder(original && original["chord"]));
        if (!original) updates["chord"] = builder.build();
        else childBuilders["chord"] = builder;
      } else {
        updates.chord = build as any;
        delete childBuilders["chord;"];
      }
      modifiedKeys["chord"] = true;
      return this;
    }

    this.pitch = (build: Pitch | ((builder: IPitchBuilder) => IPitchBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["pitch"]
        const builder = (build as any)(new PitchBuilder(original && original["pitch"]));
        if (!original) updates["pitch"] = builder.build();
        else childBuilders["pitch"] = builder;
      } else {
        updates.pitch = build as any;
        delete childBuilders["pitch;"];
      }
      modifiedKeys["pitch"] = true;
      return this;
    }

    this.rest = (build: Rest | ((builder: IRestBuilder) => IRestBuilder)): INoteBuilder => {
      if (typeof build === 'function') {
        delete updates["rest"]
        const builder = (build as any)(new RestBuilder(original && original["rest"]));
        if (!original) updates["rest"] = builder.build();
        else childBuilders["rest"] = builder;
      } else {
        updates.rest = build as any;
        delete childBuilders["rest;"];
      }
      modifiedKeys["rest"] = true;
      return this;
    }
  }
}
export function patchNote(base: Note, builder: (build: INoteBuilder) => INoteBuilder): IAny[] { return builder(new NoteBuilder(base)).patch(); }
export function buildNote(builder: (build: INoteBuilder) => INoteBuilder): Note { return builder(new NoteBuilder()).build(); }

export interface ITypeBuilder {
  build?: () => Type;
  patch: () => IAny[];
  duration: (duration: Count) => ITypeBuilder;
  size: (size: SymbolSize) => ITypeBuilder;
}

class TypeBuilder implements ITypeBuilder {
  build: () => Type;
  patch: () => IAny[];
  duration: (duration: Count) => ITypeBuilder;
  size: (size: SymbolSize) => ITypeBuilder;
  constructor(original?: Type) {
    let updates: Type = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["duration"]) ||
          childBuilders["duration"] !== undefined ||
          updates.duration !== undefined,
        "duration is a required field");
    }

    if (!original) {
      this.build = (): Type => {
        checkInvariants();
        (updates as any)._class = "Type";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.duration = (spec: Count): ITypeBuilder => {
        updates["duration"] = spec;
        delete childBuilders["duration;"];
        modifiedKeys["duration"] = true;
        return this;
    }

    this.size = (spec: SymbolSize): ITypeBuilder => {
        updates["size"] = spec;
        delete childBuilders["size;"];
        modifiedKeys["size"] = true;
        return this;
    }
  }
}
export function patchType(base: Type, builder: (build: ITypeBuilder) => ITypeBuilder): IAny[] { return builder(new TypeBuilder(base)).patch(); }
export function buildType(builder: (build: ITypeBuilder) => ITypeBuilder): Type { return builder(new TypeBuilder()).build(); }

export interface IDotBuilder {
  build?: () => Dot;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IDotBuilder;
  relativeY: (relativeY: number) => IDotBuilder;
  defaultY: (defaultY: number) => IDotBuilder;
  relativeX: (relativeX: number) => IDotBuilder;
  fontFamily: (fontFamily: string) => IDotBuilder;
  fontWeight: (fontWeight: NormalBold) => IDotBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDotBuilder;
  fontSize: (fontSize: string) => IDotBuilder;
  color: (color: string) => IDotBuilder;
  placement: (placement: AboveBelow) => IDotBuilder;
}

class DotBuilder implements IDotBuilder {
  build: () => Dot;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IDotBuilder;
  relativeY: (relativeY: number) => IDotBuilder;
  defaultY: (defaultY: number) => IDotBuilder;
  relativeX: (relativeX: number) => IDotBuilder;
  fontFamily: (fontFamily: string) => IDotBuilder;
  fontWeight: (fontWeight: NormalBold) => IDotBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDotBuilder;
  fontSize: (fontSize: string) => IDotBuilder;
  color: (color: string) => IDotBuilder;
  placement: (placement: AboveBelow) => IDotBuilder;
  constructor(original?: Dot) {
    let updates: Dot = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Dot => {
        checkInvariants();
        (updates as any)._class = "Dot";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IDotBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDotBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDotBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDotBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDotBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDotBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDotBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDotBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDotBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IDotBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchDot(base: Dot, builder: (build: IDotBuilder) => IDotBuilder): IAny[] { return builder(new DotBuilder(base)).patch(); }
export function buildDot(builder: (build: IDotBuilder) => IDotBuilder): Dot { return builder(new DotBuilder()).build(); }

export interface IAccidentalBuilder {
  build?: () => Accidental;
  patch: () => IAny[];
  cautionary: (cautionary: boolean) => IAccidentalBuilder;
  accidental: (accidental: MxmlAccidental) => IAccidentalBuilder;
  editorial: (editorial: boolean) => IAccidentalBuilder;
  defaultX: (defaultX: number) => IAccidentalBuilder;
  relativeY: (relativeY: number) => IAccidentalBuilder;
  defaultY: (defaultY: number) => IAccidentalBuilder;
  relativeX: (relativeX: number) => IAccidentalBuilder;
  fontFamily: (fontFamily: string) => IAccidentalBuilder;
  fontWeight: (fontWeight: NormalBold) => IAccidentalBuilder;
  fontStyle: (fontStyle: NormalItalic) => IAccidentalBuilder;
  fontSize: (fontSize: string) => IAccidentalBuilder;
  color: (color: string) => IAccidentalBuilder;
  bracket: (bracket: boolean) => IAccidentalBuilder;
  size: (size: SymbolSize) => IAccidentalBuilder;
  parentheses: (parentheses: boolean) => IAccidentalBuilder;
}

class AccidentalBuilder implements IAccidentalBuilder {
  build: () => Accidental;
  patch: () => IAny[];
  cautionary: (cautionary: boolean) => IAccidentalBuilder;
  accidental: (accidental: MxmlAccidental) => IAccidentalBuilder;
  editorial: (editorial: boolean) => IAccidentalBuilder;
  defaultX: (defaultX: number) => IAccidentalBuilder;
  relativeY: (relativeY: number) => IAccidentalBuilder;
  defaultY: (defaultY: number) => IAccidentalBuilder;
  relativeX: (relativeX: number) => IAccidentalBuilder;
  fontFamily: (fontFamily: string) => IAccidentalBuilder;
  fontWeight: (fontWeight: NormalBold) => IAccidentalBuilder;
  fontStyle: (fontStyle: NormalItalic) => IAccidentalBuilder;
  fontSize: (fontSize: string) => IAccidentalBuilder;
  color: (color: string) => IAccidentalBuilder;
  bracket: (bracket: boolean) => IAccidentalBuilder;
  size: (size: SymbolSize) => IAccidentalBuilder;
  parentheses: (parentheses: boolean) => IAccidentalBuilder;
  constructor(original?: Accidental) {
    let updates: Accidental = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["accidental"]) ||
          childBuilders["accidental"] !== undefined ||
          updates.accidental !== undefined,
        "accidental is a required field");
    }

    if (!original) {
      this.build = (): Accidental => {
        checkInvariants();
        (updates as any)._class = "Accidental";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.cautionary = (spec: boolean): IAccidentalBuilder => {
        updates["cautionary"] = spec;
        delete childBuilders["cautionary;"];
        modifiedKeys["cautionary"] = true;
        return this;
    }

    this.accidental = (spec: MxmlAccidental): IAccidentalBuilder => {
        updates["accidental"] = spec;
        delete childBuilders["accidental;"];
        modifiedKeys["accidental"] = true;
        return this;
    }

    this.editorial = (spec: boolean): IAccidentalBuilder => {
        updates["editorial"] = spec;
        delete childBuilders["editorial;"];
        modifiedKeys["editorial"] = true;
        return this;
    }

    this.defaultX = (spec: number): IAccidentalBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IAccidentalBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IAccidentalBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IAccidentalBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IAccidentalBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IAccidentalBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IAccidentalBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IAccidentalBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IAccidentalBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.bracket = (spec: boolean): IAccidentalBuilder => {
        updates["bracket"] = spec;
        delete childBuilders["bracket;"];
        modifiedKeys["bracket"] = true;
        return this;
    }

    this.size = (spec: SymbolSize): IAccidentalBuilder => {
        updates["size"] = spec;
        delete childBuilders["size;"];
        modifiedKeys["size"] = true;
        return this;
    }

    this.parentheses = (spec: boolean): IAccidentalBuilder => {
        updates["parentheses"] = spec;
        delete childBuilders["parentheses;"];
        modifiedKeys["parentheses"] = true;
        return this;
    }
  }
}
export function patchAccidental(base: Accidental, builder: (build: IAccidentalBuilder) => IAccidentalBuilder): IAny[] { return builder(new AccidentalBuilder(base)).patch(); }
export function buildAccidental(builder: (build: IAccidentalBuilder) => IAccidentalBuilder): Accidental { return builder(new AccidentalBuilder()).build(); }

export interface ITimeModificationBuilder {
  build?: () => TimeModification;
  patch: () => IAny[];
  actualNotes: (actualNotes: number) => ITimeModificationBuilder;
  normalType: (normalType: string) => ITimeModificationBuilder;
  normalNotes: (normalNotes: number) => ITimeModificationBuilder;
  normalDotsAt: (idx: number, build: NormalDot | ((builder: INormalDotBuilder) => INormalDotBuilder)) => ITimeModificationBuilder;
  normalDotsSplice: (start: number, deleteCount: number, ...items: NormalDot[]) => ITimeModificationBuilder;
  normalDots: (normalDots: NormalDot[]) => ITimeModificationBuilder;
}

class TimeModificationBuilder implements ITimeModificationBuilder {
  build: () => TimeModification;
  patch: () => IAny[];
  actualNotes: (actualNotes: number) => ITimeModificationBuilder;
  normalType: (normalType: string) => ITimeModificationBuilder;
  normalNotes: (normalNotes: number) => ITimeModificationBuilder;
  normalDotsAt: (idx: number, build: NormalDot | ((builder: INormalDotBuilder) => INormalDotBuilder)) => ITimeModificationBuilder;
  normalDotsSplice: (start: number, deleteCount: number, ...items: NormalDot[]) => ITimeModificationBuilder;
  normalDots: (normalDots: NormalDot[]) => ITimeModificationBuilder;
  constructor(original?: TimeModification) {
    let updates: TimeModification = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["actualNotes"]) ||
          childBuilders["actualNotes"] !== undefined ||
          updates.actualNotes !== undefined,
        "actualNotes is a required field");
      console.assert(
          (original && !modifiedKeys["normalNotes"]) ||
          childBuilders["normalNotes"] !== undefined ||
          updates.normalNotes !== undefined,
        "normalNotes is a required field");
    }

    if (!original) {
      this.build = (): TimeModification => {
        checkInvariants();
        (updates as any)._class = "TimeModification";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.actualNotes = (spec: number): ITimeModificationBuilder => {
        updates["actualNotes"] = spec;
        delete childBuilders["actualNotes;"];
        modifiedKeys["actualNotes"] = true;
        return this;
    }

    this.normalType = (spec: string): ITimeModificationBuilder => {
        updates["normalType"] = spec;
        delete childBuilders["normalType;"];
        modifiedKeys["normalType"] = true;
        return this;
    }

    this.normalNotes = (spec: number): ITimeModificationBuilder => {
        updates["normalNotes"] = spec;
        delete childBuilders["normalNotes;"];
        modifiedKeys["normalNotes"] = true;
        return this;
    }

    this.normalDots = (spec: NormalDot[]): ITimeModificationBuilder => {
        updates["normalDots"] = spec;
        delete childBuilders["normalDots;"];
        modifiedKeys["normalDots"] = true;
        return this;
    }

    this.normalDotsAt = (idx: number, build: NormalDot | ((builder: INormalDotBuilder) => INormalDotBuilder)): ITimeModificationBuilder => {
      makeReference("normalDots");
      if (frozen["normalDots"][idx]) {
          throw new Error("Patching normalDots." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["normalDots"] && !original["normalDots"]) {
          // Clone snapshot.
          patches.push({p: ["normalDots", idx], li: original._snapshot["normalDots"]});
      }
      if (typeof build === 'function' && reference["normalDots"][idx]) {
        let patch = (build as any)(new NormalDotBuilder(reference["normalDots"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["normalDots", idx].concat(patch.p);
          return patch;
        }));
        frozen["normalDots"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new NormalDotBuilder(reference["normalDots"][idx])).build() : build;
      if (original) {
        patches.push({p: ["normalDots", idx], li: update});
      } else {
        updates["normalDots"] = reference["normalDots"]; // TODO: Merge?
      } 
      reference["normalDots"][idx] = update;
      frozen["normalDots"][idx] = true;
      return this;
    }

    this.normalDotsSplice = (start: number, deleteCount: number, ...items: NormalDot[]): ITimeModificationBuilder => {
      makeReference("normalDots");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["normalDots"][idx]) {
            throw new Error("Replacing normalDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["normalDots"][idx];
          patches.push({p: ["normalDots", idx], ld, li: items[idx - start]});
          frozen["normalDots"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["normalDots"][idx]) {
            throw new Error("Removing normalDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["normalDots"][idx];
          patches.push({p: ["normalDots", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["normalDots", idx], li: items[idx - start]});
          frozen["normalDots"][idx] = true;
        }
      }
      reference["normalDots"].splice(start, deleteCount, ...items);
      updates["normalDots"] = reference["normalDots"];
      frozen["normalDots"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }
  }
}
export function patchTimeModification(base: TimeModification, builder: (build: ITimeModificationBuilder) => ITimeModificationBuilder): IAny[] { return builder(new TimeModificationBuilder(base)).patch(); }
export function buildTimeModification(builder: (build: ITimeModificationBuilder) => ITimeModificationBuilder): TimeModification { return builder(new TimeModificationBuilder()).build(); }

export interface IStemBuilder {
  build?: () => Stem;
  patch: () => IAny[];
  type: (type: StemType) => IStemBuilder;
  defaultX: (defaultX: number) => IStemBuilder;
  relativeY: (relativeY: number) => IStemBuilder;
  defaultY: (defaultY: number) => IStemBuilder;
  relativeX: (relativeX: number) => IStemBuilder;
  color: (color: string) => IStemBuilder;
}

class StemBuilder implements IStemBuilder {
  build: () => Stem;
  patch: () => IAny[];
  type: (type: StemType) => IStemBuilder;
  defaultX: (defaultX: number) => IStemBuilder;
  relativeY: (relativeY: number) => IStemBuilder;
  defaultY: (defaultY: number) => IStemBuilder;
  relativeX: (relativeX: number) => IStemBuilder;
  color: (color: string) => IStemBuilder;
  constructor(original?: Stem) {
    let updates: Stem = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Stem => {
        checkInvariants();
        (updates as any)._class = "Stem";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.type = (spec: StemType): IStemBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): IStemBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IStemBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IStemBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IStemBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.color = (spec: string): IStemBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchStem(base: Stem, builder: (build: IStemBuilder) => IStemBuilder): IAny[] { return builder(new StemBuilder(base)).patch(); }
export function buildStem(builder: (build: IStemBuilder) => IStemBuilder): Stem { return builder(new StemBuilder()).build(); }

export interface INoteheadBuilder {
  build?: () => Notehead;
  patch: () => IAny[];
  type: (type: NoteheadType) => INoteheadBuilder;
  filled: (filled: boolean) => INoteheadBuilder;
  parentheses: (parentheses: boolean) => INoteheadBuilder;
  fontFamily: (fontFamily: string) => INoteheadBuilder;
  fontWeight: (fontWeight: NormalBold) => INoteheadBuilder;
  fontStyle: (fontStyle: NormalItalic) => INoteheadBuilder;
  fontSize: (fontSize: string) => INoteheadBuilder;
  color: (color: string) => INoteheadBuilder;
}

class NoteheadBuilder implements INoteheadBuilder {
  build: () => Notehead;
  patch: () => IAny[];
  type: (type: NoteheadType) => INoteheadBuilder;
  filled: (filled: boolean) => INoteheadBuilder;
  parentheses: (parentheses: boolean) => INoteheadBuilder;
  fontFamily: (fontFamily: string) => INoteheadBuilder;
  fontWeight: (fontWeight: NormalBold) => INoteheadBuilder;
  fontStyle: (fontStyle: NormalItalic) => INoteheadBuilder;
  fontSize: (fontSize: string) => INoteheadBuilder;
  color: (color: string) => INoteheadBuilder;
  constructor(original?: Notehead) {
    let updates: Notehead = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Notehead => {
        checkInvariants();
        (updates as any)._class = "Notehead";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.type = (spec: NoteheadType): INoteheadBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.filled = (spec: boolean): INoteheadBuilder => {
        updates["filled"] = spec;
        delete childBuilders["filled;"];
        modifiedKeys["filled"] = true;
        return this;
    }

    this.parentheses = (spec: boolean): INoteheadBuilder => {
        updates["parentheses"] = spec;
        delete childBuilders["parentheses;"];
        modifiedKeys["parentheses"] = true;
        return this;
    }

    this.fontFamily = (spec: string): INoteheadBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): INoteheadBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): INoteheadBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): INoteheadBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): INoteheadBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchNotehead(base: Notehead, builder: (build: INoteheadBuilder) => INoteheadBuilder): IAny[] { return builder(new NoteheadBuilder(base)).patch(); }
export function buildNotehead(builder: (build: INoteheadBuilder) => INoteheadBuilder): Notehead { return builder(new NoteheadBuilder()).build(); }

export interface INoteheadTextBuilder {
  build?: () => NoteheadText;
  patch: () => IAny[];
  textAt: (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)) => INoteheadTextBuilder;
  textSplice: (start: number, deleteCount: number, ...items: TextSegment[]) => INoteheadTextBuilder;
  text: (text: TextSegment[]) => INoteheadTextBuilder;
}

class NoteheadTextBuilder implements INoteheadTextBuilder {
  build: () => NoteheadText;
  patch: () => IAny[];
  textAt: (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)) => INoteheadTextBuilder;
  textSplice: (start: number, deleteCount: number, ...items: TextSegment[]) => INoteheadTextBuilder;
  text: (text: TextSegment[]) => INoteheadTextBuilder;
  constructor(original?: NoteheadText) {
    let updates: NoteheadText = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["text"]) ||
          childBuilders["text"] !== undefined ||
          updates.text !== undefined,
        "text is a required field");
    }

    if (!original) {
      this.build = (): NoteheadText => {
        checkInvariants();
        (updates as any)._class = "NoteheadText";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.text = (spec: TextSegment[]): INoteheadTextBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.textAt = (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)): INoteheadTextBuilder => {
      makeReference("text");
      if (frozen["text"][idx]) {
          throw new Error("Patching text." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["text"] && !original["text"]) {
          // Clone snapshot.
          patches.push({p: ["text", idx], li: original._snapshot["text"]});
      }
      if (typeof build === 'function' && reference["text"][idx]) {
        let patch = (build as any)(new TextSegmentBuilder(reference["text"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["text", idx].concat(patch.p);
          return patch;
        }));
        frozen["text"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new TextSegmentBuilder(reference["text"][idx])).build() : build;
      if (original) {
        patches.push({p: ["text", idx], li: update});
      } else {
        updates["text"] = reference["text"]; // TODO: Merge?
      } 
      reference["text"][idx] = update;
      frozen["text"][idx] = true;
      return this;
    }

    this.textSplice = (start: number, deleteCount: number, ...items: TextSegment[]): INoteheadTextBuilder => {
      makeReference("text");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["text"][idx]) {
            throw new Error("Replacing text." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["text"][idx];
          patches.push({p: ["text", idx], ld, li: items[idx - start]});
          frozen["text"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["text"][idx]) {
            throw new Error("Removing text." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["text"][idx];
          patches.push({p: ["text", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["text", idx], li: items[idx - start]});
          frozen["text"][idx] = true;
        }
      }
      reference["text"].splice(start, deleteCount, ...items);
      updates["text"] = reference["text"];
      frozen["text"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }
  }
}
export function patchNoteheadText(base: NoteheadText, builder: (build: INoteheadTextBuilder) => INoteheadTextBuilder): IAny[] { return builder(new NoteheadTextBuilder(base)).patch(); }
export function buildNoteheadText(builder: (build: INoteheadTextBuilder) => INoteheadTextBuilder): NoteheadText { return builder(new NoteheadTextBuilder()).build(); }

export interface IBeamBuilder {
  build?: () => Beam;
  patch: () => IAny[];
  repeater: (repeater: boolean) => IBeamBuilder;
  number: (number: number) => IBeamBuilder;
  type: (type: BeamType) => IBeamBuilder;
  fan: (fan: AccelRitNone) => IBeamBuilder;
}

class BeamBuilder implements IBeamBuilder {
  build: () => Beam;
  patch: () => IAny[];
  repeater: (repeater: boolean) => IBeamBuilder;
  number: (number: number) => IBeamBuilder;
  type: (type: BeamType) => IBeamBuilder;
  fan: (fan: AccelRitNone) => IBeamBuilder;
  constructor(original?: Beam) {
    let updates: Beam = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["number"]) ||
          childBuilders["number"] !== undefined ||
          updates.number !== undefined,
        "number is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Beam => {
        checkInvariants();
        (updates as any)._class = "Beam";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.repeater = (spec: boolean): IBeamBuilder => {
        updates["repeater"] = spec;
        delete childBuilders["repeater;"];
        modifiedKeys["repeater"] = true;
        return this;
    }

    this.number = (spec: number): IBeamBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.type = (spec: BeamType): IBeamBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.fan = (spec: AccelRitNone): IBeamBuilder => {
        updates["fan"] = spec;
        delete childBuilders["fan;"];
        modifiedKeys["fan"] = true;
        return this;
    }
  }
}
export function patchBeam(base: Beam, builder: (build: IBeamBuilder) => IBeamBuilder): IAny[] { return builder(new BeamBuilder(base)).patch(); }
export function buildBeam(builder: (build: IBeamBuilder) => IBeamBuilder): Beam { return builder(new BeamBuilder()).build(); }

export interface INotationsBuilder {
  build?: () => Notations;
  patch: () => IAny[];
  slursAt: (idx: number, build: Slur | ((builder: ISlurBuilder) => ISlurBuilder)) => INotationsBuilder;
  slursSplice: (start: number, deleteCount: number, ...items: Slur[]) => INotationsBuilder;
  slurs: (slurs: Slur[]) => INotationsBuilder;
  articulationsAt: (idx: number, build: Articulations | ((builder: IArticulationsBuilder) => IArticulationsBuilder)) => INotationsBuilder;
  articulationsSplice: (start: number, deleteCount: number, ...items: Articulations[]) => INotationsBuilder;
  articulations: (articulations: Articulations[]) => INotationsBuilder;
  slidesAt: (idx: number, build: Slide | ((builder: ISlideBuilder) => ISlideBuilder)) => INotationsBuilder;
  slidesSplice: (start: number, deleteCount: number, ...items: Slide[]) => INotationsBuilder;
  slides: (slides: Slide[]) => INotationsBuilder;
  technicalsAt: (idx: number, build: Technical | ((builder: ITechnicalBuilder) => ITechnicalBuilder)) => INotationsBuilder;
  technicalsSplice: (start: number, deleteCount: number, ...items: Technical[]) => INotationsBuilder;
  technicals: (technicals: Technical[]) => INotationsBuilder;
  tiedsAt: (idx: number, build: Tied | ((builder: ITiedBuilder) => ITiedBuilder)) => INotationsBuilder;
  tiedsSplice: (start: number, deleteCount: number, ...items: Tied[]) => INotationsBuilder;
  tieds: (tieds: Tied[]) => INotationsBuilder;
  tupletsAt: (idx: number, build: Tuplet | ((builder: ITupletBuilder) => ITupletBuilder)) => INotationsBuilder;
  tupletsSplice: (start: number, deleteCount: number, ...items: Tuplet[]) => INotationsBuilder;
  tuplets: (tuplets: Tuplet[]) => INotationsBuilder;
  glissandosAt: (idx: number, build: Glissando | ((builder: IGlissandoBuilder) => IGlissandoBuilder)) => INotationsBuilder;
  glissandosSplice: (start: number, deleteCount: number, ...items: Glissando[]) => INotationsBuilder;
  glissandos: (glissandos: Glissando[]) => INotationsBuilder;
  dynamicsAt: (idx: number, build: Dynamics | ((builder: IDynamicsBuilder) => IDynamicsBuilder)) => INotationsBuilder;
  dynamicsSplice: (start: number, deleteCount: number, ...items: Dynamics[]) => INotationsBuilder;
  dynamics: (dynamics: Dynamics[]) => INotationsBuilder;
  fermatasAt: (idx: number, build: Fermata | ((builder: IFermataBuilder) => IFermataBuilder)) => INotationsBuilder;
  fermatasSplice: (start: number, deleteCount: number, ...items: Fermata[]) => INotationsBuilder;
  fermatas: (fermatas: Fermata[]) => INotationsBuilder;
  accidentalMarksAt: (idx: number, build: AccidentalMark | ((builder: IAccidentalMarkBuilder) => IAccidentalMarkBuilder)) => INotationsBuilder;
  accidentalMarksSplice: (start: number, deleteCount: number, ...items: AccidentalMark[]) => INotationsBuilder;
  accidentalMarks: (accidentalMarks: AccidentalMark[]) => INotationsBuilder;
  ornamentsAt: (idx: number, build: Ornaments | ((builder: IOrnamentsBuilder) => IOrnamentsBuilder)) => INotationsBuilder;
  ornamentsSplice: (start: number, deleteCount: number, ...items: Ornaments[]) => INotationsBuilder;
  ornaments: (ornaments: Ornaments[]) => INotationsBuilder;
  arpeggiatesAt: (idx: number, build: Arpeggiate | ((builder: IArpeggiateBuilder) => IArpeggiateBuilder)) => INotationsBuilder;
  arpeggiatesSplice: (start: number, deleteCount: number, ...items: Arpeggiate[]) => INotationsBuilder;
  arpeggiates: (arpeggiates: Arpeggiate[]) => INotationsBuilder;
  nonArpeggiatesAt: (idx: number, build: NonArpeggiate | ((builder: INonArpeggiateBuilder) => INonArpeggiateBuilder)) => INotationsBuilder;
  nonArpeggiatesSplice: (start: number, deleteCount: number, ...items: NonArpeggiate[]) => INotationsBuilder;
  nonArpeggiates: (nonArpeggiates: NonArpeggiate[]) => INotationsBuilder;
  otherNotationsAt: (idx: number, build: OtherNotation | ((builder: IOtherNotationBuilder) => IOtherNotationBuilder)) => INotationsBuilder;
  otherNotationsSplice: (start: number, deleteCount: number, ...items: OtherNotation[]) => INotationsBuilder;
  otherNotations: (otherNotations: OtherNotation[]) => INotationsBuilder;
  printObject: (printObject: boolean) => INotationsBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => INotationsBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => INotationsBuilder;
}

class NotationsBuilder implements INotationsBuilder {
  build: () => Notations;
  patch: () => IAny[];
  slursAt: (idx: number, build: Slur | ((builder: ISlurBuilder) => ISlurBuilder)) => INotationsBuilder;
  slursSplice: (start: number, deleteCount: number, ...items: Slur[]) => INotationsBuilder;
  slurs: (slurs: Slur[]) => INotationsBuilder;
  articulationsAt: (idx: number, build: Articulations | ((builder: IArticulationsBuilder) => IArticulationsBuilder)) => INotationsBuilder;
  articulationsSplice: (start: number, deleteCount: number, ...items: Articulations[]) => INotationsBuilder;
  articulations: (articulations: Articulations[]) => INotationsBuilder;
  slidesAt: (idx: number, build: Slide | ((builder: ISlideBuilder) => ISlideBuilder)) => INotationsBuilder;
  slidesSplice: (start: number, deleteCount: number, ...items: Slide[]) => INotationsBuilder;
  slides: (slides: Slide[]) => INotationsBuilder;
  technicalsAt: (idx: number, build: Technical | ((builder: ITechnicalBuilder) => ITechnicalBuilder)) => INotationsBuilder;
  technicalsSplice: (start: number, deleteCount: number, ...items: Technical[]) => INotationsBuilder;
  technicals: (technicals: Technical[]) => INotationsBuilder;
  tiedsAt: (idx: number, build: Tied | ((builder: ITiedBuilder) => ITiedBuilder)) => INotationsBuilder;
  tiedsSplice: (start: number, deleteCount: number, ...items: Tied[]) => INotationsBuilder;
  tieds: (tieds: Tied[]) => INotationsBuilder;
  tupletsAt: (idx: number, build: Tuplet | ((builder: ITupletBuilder) => ITupletBuilder)) => INotationsBuilder;
  tupletsSplice: (start: number, deleteCount: number, ...items: Tuplet[]) => INotationsBuilder;
  tuplets: (tuplets: Tuplet[]) => INotationsBuilder;
  glissandosAt: (idx: number, build: Glissando | ((builder: IGlissandoBuilder) => IGlissandoBuilder)) => INotationsBuilder;
  glissandosSplice: (start: number, deleteCount: number, ...items: Glissando[]) => INotationsBuilder;
  glissandos: (glissandos: Glissando[]) => INotationsBuilder;
  dynamicsAt: (idx: number, build: Dynamics | ((builder: IDynamicsBuilder) => IDynamicsBuilder)) => INotationsBuilder;
  dynamicsSplice: (start: number, deleteCount: number, ...items: Dynamics[]) => INotationsBuilder;
  dynamics: (dynamics: Dynamics[]) => INotationsBuilder;
  fermatasAt: (idx: number, build: Fermata | ((builder: IFermataBuilder) => IFermataBuilder)) => INotationsBuilder;
  fermatasSplice: (start: number, deleteCount: number, ...items: Fermata[]) => INotationsBuilder;
  fermatas: (fermatas: Fermata[]) => INotationsBuilder;
  accidentalMarksAt: (idx: number, build: AccidentalMark | ((builder: IAccidentalMarkBuilder) => IAccidentalMarkBuilder)) => INotationsBuilder;
  accidentalMarksSplice: (start: number, deleteCount: number, ...items: AccidentalMark[]) => INotationsBuilder;
  accidentalMarks: (accidentalMarks: AccidentalMark[]) => INotationsBuilder;
  ornamentsAt: (idx: number, build: Ornaments | ((builder: IOrnamentsBuilder) => IOrnamentsBuilder)) => INotationsBuilder;
  ornamentsSplice: (start: number, deleteCount: number, ...items: Ornaments[]) => INotationsBuilder;
  ornaments: (ornaments: Ornaments[]) => INotationsBuilder;
  arpeggiatesAt: (idx: number, build: Arpeggiate | ((builder: IArpeggiateBuilder) => IArpeggiateBuilder)) => INotationsBuilder;
  arpeggiatesSplice: (start: number, deleteCount: number, ...items: Arpeggiate[]) => INotationsBuilder;
  arpeggiates: (arpeggiates: Arpeggiate[]) => INotationsBuilder;
  nonArpeggiatesAt: (idx: number, build: NonArpeggiate | ((builder: INonArpeggiateBuilder) => INonArpeggiateBuilder)) => INotationsBuilder;
  nonArpeggiatesSplice: (start: number, deleteCount: number, ...items: NonArpeggiate[]) => INotationsBuilder;
  nonArpeggiates: (nonArpeggiates: NonArpeggiate[]) => INotationsBuilder;
  otherNotationsAt: (idx: number, build: OtherNotation | ((builder: IOtherNotationBuilder) => IOtherNotationBuilder)) => INotationsBuilder;
  otherNotationsSplice: (start: number, deleteCount: number, ...items: OtherNotation[]) => INotationsBuilder;
  otherNotations: (otherNotations: OtherNotation[]) => INotationsBuilder;
  printObject: (printObject: boolean) => INotationsBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => INotationsBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => INotationsBuilder;
  constructor(original?: Notations) {
    let updates: Notations = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Notations => {
        checkInvariants();
        (updates as any)._class = "Notations";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.slurs = (spec: Slur[]): INotationsBuilder => {
        updates["slurs"] = spec;
        delete childBuilders["slurs;"];
        modifiedKeys["slurs"] = true;
        return this;
    }

    this.slursAt = (idx: number, build: Slur | ((builder: ISlurBuilder) => ISlurBuilder)): INotationsBuilder => {
      makeReference("slurs");
      if (frozen["slurs"][idx]) {
          throw new Error("Patching slurs." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["slurs"] && !original["slurs"]) {
          // Clone snapshot.
          patches.push({p: ["slurs", idx], li: original._snapshot["slurs"]});
      }
      if (typeof build === 'function' && reference["slurs"][idx]) {
        let patch = (build as any)(new SlurBuilder(reference["slurs"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["slurs", idx].concat(patch.p);
          return patch;
        }));
        frozen["slurs"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new SlurBuilder(reference["slurs"][idx])).build() : build;
      if (original) {
        patches.push({p: ["slurs", idx], li: update});
      } else {
        updates["slurs"] = reference["slurs"]; // TODO: Merge?
      } 
      reference["slurs"][idx] = update;
      frozen["slurs"][idx] = true;
      return this;
    }

    this.slursSplice = (start: number, deleteCount: number, ...items: Slur[]): INotationsBuilder => {
      makeReference("slurs");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["slurs"][idx]) {
            throw new Error("Replacing slurs." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["slurs"][idx];
          patches.push({p: ["slurs", idx], ld, li: items[idx - start]});
          frozen["slurs"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["slurs"][idx]) {
            throw new Error("Removing slurs." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["slurs"][idx];
          patches.push({p: ["slurs", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["slurs", idx], li: items[idx - start]});
          frozen["slurs"][idx] = true;
        }
      }
      reference["slurs"].splice(start, deleteCount, ...items);
      updates["slurs"] = reference["slurs"];
      frozen["slurs"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.articulations = (spec: Articulations[]): INotationsBuilder => {
        updates["articulations"] = spec;
        delete childBuilders["articulations;"];
        modifiedKeys["articulations"] = true;
        return this;
    }

    this.articulationsAt = (idx: number, build: Articulations | ((builder: IArticulationsBuilder) => IArticulationsBuilder)): INotationsBuilder => {
      makeReference("articulations");
      if (frozen["articulations"][idx]) {
          throw new Error("Patching articulations." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["articulations"] && !original["articulations"]) {
          // Clone snapshot.
          patches.push({p: ["articulations", idx], li: original._snapshot["articulations"]});
      }
      if (typeof build === 'function' && reference["articulations"][idx]) {
        let patch = (build as any)(new ArticulationsBuilder(reference["articulations"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["articulations", idx].concat(patch.p);
          return patch;
        }));
        frozen["articulations"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new ArticulationsBuilder(reference["articulations"][idx])).build() : build;
      if (original) {
        patches.push({p: ["articulations", idx], li: update});
      } else {
        updates["articulations"] = reference["articulations"]; // TODO: Merge?
      } 
      reference["articulations"][idx] = update;
      frozen["articulations"][idx] = true;
      return this;
    }

    this.articulationsSplice = (start: number, deleteCount: number, ...items: Articulations[]): INotationsBuilder => {
      makeReference("articulations");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["articulations"][idx]) {
            throw new Error("Replacing articulations." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["articulations"][idx];
          patches.push({p: ["articulations", idx], ld, li: items[idx - start]});
          frozen["articulations"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["articulations"][idx]) {
            throw new Error("Removing articulations." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["articulations"][idx];
          patches.push({p: ["articulations", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["articulations", idx], li: items[idx - start]});
          frozen["articulations"][idx] = true;
        }
      }
      reference["articulations"].splice(start, deleteCount, ...items);
      updates["articulations"] = reference["articulations"];
      frozen["articulations"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.slides = (spec: Slide[]): INotationsBuilder => {
        updates["slides"] = spec;
        delete childBuilders["slides;"];
        modifiedKeys["slides"] = true;
        return this;
    }

    this.slidesAt = (idx: number, build: Slide | ((builder: ISlideBuilder) => ISlideBuilder)): INotationsBuilder => {
      makeReference("slides");
      if (frozen["slides"][idx]) {
          throw new Error("Patching slides." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["slides"] && !original["slides"]) {
          // Clone snapshot.
          patches.push({p: ["slides", idx], li: original._snapshot["slides"]});
      }
      if (typeof build === 'function' && reference["slides"][idx]) {
        let patch = (build as any)(new SlideBuilder(reference["slides"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["slides", idx].concat(patch.p);
          return patch;
        }));
        frozen["slides"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new SlideBuilder(reference["slides"][idx])).build() : build;
      if (original) {
        patches.push({p: ["slides", idx], li: update});
      } else {
        updates["slides"] = reference["slides"]; // TODO: Merge?
      } 
      reference["slides"][idx] = update;
      frozen["slides"][idx] = true;
      return this;
    }

    this.slidesSplice = (start: number, deleteCount: number, ...items: Slide[]): INotationsBuilder => {
      makeReference("slides");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["slides"][idx]) {
            throw new Error("Replacing slides." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["slides"][idx];
          patches.push({p: ["slides", idx], ld, li: items[idx - start]});
          frozen["slides"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["slides"][idx]) {
            throw new Error("Removing slides." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["slides"][idx];
          patches.push({p: ["slides", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["slides", idx], li: items[idx - start]});
          frozen["slides"][idx] = true;
        }
      }
      reference["slides"].splice(start, deleteCount, ...items);
      updates["slides"] = reference["slides"];
      frozen["slides"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.technicals = (spec: Technical[]): INotationsBuilder => {
        updates["technicals"] = spec;
        delete childBuilders["technicals;"];
        modifiedKeys["technicals"] = true;
        return this;
    }

    this.technicalsAt = (idx: number, build: Technical | ((builder: ITechnicalBuilder) => ITechnicalBuilder)): INotationsBuilder => {
      makeReference("technicals");
      if (frozen["technicals"][idx]) {
          throw new Error("Patching technicals." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["technicals"] && !original["technicals"]) {
          // Clone snapshot.
          patches.push({p: ["technicals", idx], li: original._snapshot["technicals"]});
      }
      if (typeof build === 'function' && reference["technicals"][idx]) {
        let patch = (build as any)(new TechnicalBuilder(reference["technicals"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["technicals", idx].concat(patch.p);
          return patch;
        }));
        frozen["technicals"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new TechnicalBuilder(reference["technicals"][idx])).build() : build;
      if (original) {
        patches.push({p: ["technicals", idx], li: update});
      } else {
        updates["technicals"] = reference["technicals"]; // TODO: Merge?
      } 
      reference["technicals"][idx] = update;
      frozen["technicals"][idx] = true;
      return this;
    }

    this.technicalsSplice = (start: number, deleteCount: number, ...items: Technical[]): INotationsBuilder => {
      makeReference("technicals");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["technicals"][idx]) {
            throw new Error("Replacing technicals." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["technicals"][idx];
          patches.push({p: ["technicals", idx], ld, li: items[idx - start]});
          frozen["technicals"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["technicals"][idx]) {
            throw new Error("Removing technicals." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["technicals"][idx];
          patches.push({p: ["technicals", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["technicals", idx], li: items[idx - start]});
          frozen["technicals"][idx] = true;
        }
      }
      reference["technicals"].splice(start, deleteCount, ...items);
      updates["technicals"] = reference["technicals"];
      frozen["technicals"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.tieds = (spec: Tied[]): INotationsBuilder => {
        updates["tieds"] = spec;
        delete childBuilders["tieds;"];
        modifiedKeys["tieds"] = true;
        return this;
    }

    this.tiedsAt = (idx: number, build: Tied | ((builder: ITiedBuilder) => ITiedBuilder)): INotationsBuilder => {
      makeReference("tieds");
      if (frozen["tieds"][idx]) {
          throw new Error("Patching tieds." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["tieds"] && !original["tieds"]) {
          // Clone snapshot.
          patches.push({p: ["tieds", idx], li: original._snapshot["tieds"]});
      }
      if (typeof build === 'function' && reference["tieds"][idx]) {
        let patch = (build as any)(new TiedBuilder(reference["tieds"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["tieds", idx].concat(patch.p);
          return patch;
        }));
        frozen["tieds"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new TiedBuilder(reference["tieds"][idx])).build() : build;
      if (original) {
        patches.push({p: ["tieds", idx], li: update});
      } else {
        updates["tieds"] = reference["tieds"]; // TODO: Merge?
      } 
      reference["tieds"][idx] = update;
      frozen["tieds"][idx] = true;
      return this;
    }

    this.tiedsSplice = (start: number, deleteCount: number, ...items: Tied[]): INotationsBuilder => {
      makeReference("tieds");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["tieds"][idx]) {
            throw new Error("Replacing tieds." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["tieds"][idx];
          patches.push({p: ["tieds", idx], ld, li: items[idx - start]});
          frozen["tieds"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["tieds"][idx]) {
            throw new Error("Removing tieds." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["tieds"][idx];
          patches.push({p: ["tieds", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["tieds", idx], li: items[idx - start]});
          frozen["tieds"][idx] = true;
        }
      }
      reference["tieds"].splice(start, deleteCount, ...items);
      updates["tieds"] = reference["tieds"];
      frozen["tieds"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.tuplets = (spec: Tuplet[]): INotationsBuilder => {
        updates["tuplets"] = spec;
        delete childBuilders["tuplets;"];
        modifiedKeys["tuplets"] = true;
        return this;
    }

    this.tupletsAt = (idx: number, build: Tuplet | ((builder: ITupletBuilder) => ITupletBuilder)): INotationsBuilder => {
      makeReference("tuplets");
      if (frozen["tuplets"][idx]) {
          throw new Error("Patching tuplets." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["tuplets"] && !original["tuplets"]) {
          // Clone snapshot.
          patches.push({p: ["tuplets", idx], li: original._snapshot["tuplets"]});
      }
      if (typeof build === 'function' && reference["tuplets"][idx]) {
        let patch = (build as any)(new TupletBuilder(reference["tuplets"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["tuplets", idx].concat(patch.p);
          return patch;
        }));
        frozen["tuplets"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new TupletBuilder(reference["tuplets"][idx])).build() : build;
      if (original) {
        patches.push({p: ["tuplets", idx], li: update});
      } else {
        updates["tuplets"] = reference["tuplets"]; // TODO: Merge?
      } 
      reference["tuplets"][idx] = update;
      frozen["tuplets"][idx] = true;
      return this;
    }

    this.tupletsSplice = (start: number, deleteCount: number, ...items: Tuplet[]): INotationsBuilder => {
      makeReference("tuplets");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["tuplets"][idx]) {
            throw new Error("Replacing tuplets." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["tuplets"][idx];
          patches.push({p: ["tuplets", idx], ld, li: items[idx - start]});
          frozen["tuplets"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["tuplets"][idx]) {
            throw new Error("Removing tuplets." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["tuplets"][idx];
          patches.push({p: ["tuplets", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["tuplets", idx], li: items[idx - start]});
          frozen["tuplets"][idx] = true;
        }
      }
      reference["tuplets"].splice(start, deleteCount, ...items);
      updates["tuplets"] = reference["tuplets"];
      frozen["tuplets"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.glissandos = (spec: Glissando[]): INotationsBuilder => {
        updates["glissandos"] = spec;
        delete childBuilders["glissandos;"];
        modifiedKeys["glissandos"] = true;
        return this;
    }

    this.glissandosAt = (idx: number, build: Glissando | ((builder: IGlissandoBuilder) => IGlissandoBuilder)): INotationsBuilder => {
      makeReference("glissandos");
      if (frozen["glissandos"][idx]) {
          throw new Error("Patching glissandos." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["glissandos"] && !original["glissandos"]) {
          // Clone snapshot.
          patches.push({p: ["glissandos", idx], li: original._snapshot["glissandos"]});
      }
      if (typeof build === 'function' && reference["glissandos"][idx]) {
        let patch = (build as any)(new GlissandoBuilder(reference["glissandos"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["glissandos", idx].concat(patch.p);
          return patch;
        }));
        frozen["glissandos"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new GlissandoBuilder(reference["glissandos"][idx])).build() : build;
      if (original) {
        patches.push({p: ["glissandos", idx], li: update});
      } else {
        updates["glissandos"] = reference["glissandos"]; // TODO: Merge?
      } 
      reference["glissandos"][idx] = update;
      frozen["glissandos"][idx] = true;
      return this;
    }

    this.glissandosSplice = (start: number, deleteCount: number, ...items: Glissando[]): INotationsBuilder => {
      makeReference("glissandos");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["glissandos"][idx]) {
            throw new Error("Replacing glissandos." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["glissandos"][idx];
          patches.push({p: ["glissandos", idx], ld, li: items[idx - start]});
          frozen["glissandos"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["glissandos"][idx]) {
            throw new Error("Removing glissandos." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["glissandos"][idx];
          patches.push({p: ["glissandos", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["glissandos", idx], li: items[idx - start]});
          frozen["glissandos"][idx] = true;
        }
      }
      reference["glissandos"].splice(start, deleteCount, ...items);
      updates["glissandos"] = reference["glissandos"];
      frozen["glissandos"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.dynamics = (spec: Dynamics[]): INotationsBuilder => {
        updates["dynamics"] = spec;
        delete childBuilders["dynamics;"];
        modifiedKeys["dynamics"] = true;
        return this;
    }

    this.dynamicsAt = (idx: number, build: Dynamics | ((builder: IDynamicsBuilder) => IDynamicsBuilder)): INotationsBuilder => {
      makeReference("dynamics");
      if (frozen["dynamics"][idx]) {
          throw new Error("Patching dynamics." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["dynamics"] && !original["dynamics"]) {
          // Clone snapshot.
          patches.push({p: ["dynamics", idx], li: original._snapshot["dynamics"]});
      }
      if (typeof build === 'function' && reference["dynamics"][idx]) {
        let patch = (build as any)(new DynamicsBuilder(reference["dynamics"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["dynamics", idx].concat(patch.p);
          return patch;
        }));
        frozen["dynamics"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new DynamicsBuilder(reference["dynamics"][idx])).build() : build;
      if (original) {
        patches.push({p: ["dynamics", idx], li: update});
      } else {
        updates["dynamics"] = reference["dynamics"]; // TODO: Merge?
      } 
      reference["dynamics"][idx] = update;
      frozen["dynamics"][idx] = true;
      return this;
    }

    this.dynamicsSplice = (start: number, deleteCount: number, ...items: Dynamics[]): INotationsBuilder => {
      makeReference("dynamics");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["dynamics"][idx]) {
            throw new Error("Replacing dynamics." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["dynamics"][idx];
          patches.push({p: ["dynamics", idx], ld, li: items[idx - start]});
          frozen["dynamics"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["dynamics"][idx]) {
            throw new Error("Removing dynamics." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["dynamics"][idx];
          patches.push({p: ["dynamics", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["dynamics", idx], li: items[idx - start]});
          frozen["dynamics"][idx] = true;
        }
      }
      reference["dynamics"].splice(start, deleteCount, ...items);
      updates["dynamics"] = reference["dynamics"];
      frozen["dynamics"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.fermatas = (spec: Fermata[]): INotationsBuilder => {
        updates["fermatas"] = spec;
        delete childBuilders["fermatas;"];
        modifiedKeys["fermatas"] = true;
        return this;
    }

    this.fermatasAt = (idx: number, build: Fermata | ((builder: IFermataBuilder) => IFermataBuilder)): INotationsBuilder => {
      makeReference("fermatas");
      if (frozen["fermatas"][idx]) {
          throw new Error("Patching fermatas." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["fermatas"] && !original["fermatas"]) {
          // Clone snapshot.
          patches.push({p: ["fermatas", idx], li: original._snapshot["fermatas"]});
      }
      if (typeof build === 'function' && reference["fermatas"][idx]) {
        let patch = (build as any)(new FermataBuilder(reference["fermatas"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["fermatas", idx].concat(patch.p);
          return patch;
        }));
        frozen["fermatas"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new FermataBuilder(reference["fermatas"][idx])).build() : build;
      if (original) {
        patches.push({p: ["fermatas", idx], li: update});
      } else {
        updates["fermatas"] = reference["fermatas"]; // TODO: Merge?
      } 
      reference["fermatas"][idx] = update;
      frozen["fermatas"][idx] = true;
      return this;
    }

    this.fermatasSplice = (start: number, deleteCount: number, ...items: Fermata[]): INotationsBuilder => {
      makeReference("fermatas");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["fermatas"][idx]) {
            throw new Error("Replacing fermatas." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["fermatas"][idx];
          patches.push({p: ["fermatas", idx], ld, li: items[idx - start]});
          frozen["fermatas"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["fermatas"][idx]) {
            throw new Error("Removing fermatas." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["fermatas"][idx];
          patches.push({p: ["fermatas", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["fermatas", idx], li: items[idx - start]});
          frozen["fermatas"][idx] = true;
        }
      }
      reference["fermatas"].splice(start, deleteCount, ...items);
      updates["fermatas"] = reference["fermatas"];
      frozen["fermatas"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.accidentalMarks = (spec: AccidentalMark[]): INotationsBuilder => {
        updates["accidentalMarks"] = spec;
        delete childBuilders["accidentalMarks;"];
        modifiedKeys["accidentalMarks"] = true;
        return this;
    }

    this.accidentalMarksAt = (idx: number, build: AccidentalMark | ((builder: IAccidentalMarkBuilder) => IAccidentalMarkBuilder)): INotationsBuilder => {
      makeReference("accidentalMarks");
      if (frozen["accidentalMarks"][idx]) {
          throw new Error("Patching accidentalMarks." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["accidentalMarks"] && !original["accidentalMarks"]) {
          // Clone snapshot.
          patches.push({p: ["accidentalMarks", idx], li: original._snapshot["accidentalMarks"]});
      }
      if (typeof build === 'function' && reference["accidentalMarks"][idx]) {
        let patch = (build as any)(new AccidentalMarkBuilder(reference["accidentalMarks"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["accidentalMarks", idx].concat(patch.p);
          return patch;
        }));
        frozen["accidentalMarks"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new AccidentalMarkBuilder(reference["accidentalMarks"][idx])).build() : build;
      if (original) {
        patches.push({p: ["accidentalMarks", idx], li: update});
      } else {
        updates["accidentalMarks"] = reference["accidentalMarks"]; // TODO: Merge?
      } 
      reference["accidentalMarks"][idx] = update;
      frozen["accidentalMarks"][idx] = true;
      return this;
    }

    this.accidentalMarksSplice = (start: number, deleteCount: number, ...items: AccidentalMark[]): INotationsBuilder => {
      makeReference("accidentalMarks");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["accidentalMarks"][idx]) {
            throw new Error("Replacing accidentalMarks." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["accidentalMarks"][idx];
          patches.push({p: ["accidentalMarks", idx], ld, li: items[idx - start]});
          frozen["accidentalMarks"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["accidentalMarks"][idx]) {
            throw new Error("Removing accidentalMarks." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["accidentalMarks"][idx];
          patches.push({p: ["accidentalMarks", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["accidentalMarks", idx], li: items[idx - start]});
          frozen["accidentalMarks"][idx] = true;
        }
      }
      reference["accidentalMarks"].splice(start, deleteCount, ...items);
      updates["accidentalMarks"] = reference["accidentalMarks"];
      frozen["accidentalMarks"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.ornaments = (spec: Ornaments[]): INotationsBuilder => {
        updates["ornaments"] = spec;
        delete childBuilders["ornaments;"];
        modifiedKeys["ornaments"] = true;
        return this;
    }

    this.ornamentsAt = (idx: number, build: Ornaments | ((builder: IOrnamentsBuilder) => IOrnamentsBuilder)): INotationsBuilder => {
      makeReference("ornaments");
      if (frozen["ornaments"][idx]) {
          throw new Error("Patching ornaments." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["ornaments"] && !original["ornaments"]) {
          // Clone snapshot.
          patches.push({p: ["ornaments", idx], li: original._snapshot["ornaments"]});
      }
      if (typeof build === 'function' && reference["ornaments"][idx]) {
        let patch = (build as any)(new OrnamentsBuilder(reference["ornaments"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["ornaments", idx].concat(patch.p);
          return patch;
        }));
        frozen["ornaments"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new OrnamentsBuilder(reference["ornaments"][idx])).build() : build;
      if (original) {
        patches.push({p: ["ornaments", idx], li: update});
      } else {
        updates["ornaments"] = reference["ornaments"]; // TODO: Merge?
      } 
      reference["ornaments"][idx] = update;
      frozen["ornaments"][idx] = true;
      return this;
    }

    this.ornamentsSplice = (start: number, deleteCount: number, ...items: Ornaments[]): INotationsBuilder => {
      makeReference("ornaments");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["ornaments"][idx]) {
            throw new Error("Replacing ornaments." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["ornaments"][idx];
          patches.push({p: ["ornaments", idx], ld, li: items[idx - start]});
          frozen["ornaments"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["ornaments"][idx]) {
            throw new Error("Removing ornaments." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["ornaments"][idx];
          patches.push({p: ["ornaments", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["ornaments", idx], li: items[idx - start]});
          frozen["ornaments"][idx] = true;
        }
      }
      reference["ornaments"].splice(start, deleteCount, ...items);
      updates["ornaments"] = reference["ornaments"];
      frozen["ornaments"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.arpeggiates = (spec: Arpeggiate[]): INotationsBuilder => {
        updates["arpeggiates"] = spec;
        delete childBuilders["arpeggiates;"];
        modifiedKeys["arpeggiates"] = true;
        return this;
    }

    this.arpeggiatesAt = (idx: number, build: Arpeggiate | ((builder: IArpeggiateBuilder) => IArpeggiateBuilder)): INotationsBuilder => {
      makeReference("arpeggiates");
      if (frozen["arpeggiates"][idx]) {
          throw new Error("Patching arpeggiates." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["arpeggiates"] && !original["arpeggiates"]) {
          // Clone snapshot.
          patches.push({p: ["arpeggiates", idx], li: original._snapshot["arpeggiates"]});
      }
      if (typeof build === 'function' && reference["arpeggiates"][idx]) {
        let patch = (build as any)(new ArpeggiateBuilder(reference["arpeggiates"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["arpeggiates", idx].concat(patch.p);
          return patch;
        }));
        frozen["arpeggiates"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new ArpeggiateBuilder(reference["arpeggiates"][idx])).build() : build;
      if (original) {
        patches.push({p: ["arpeggiates", idx], li: update});
      } else {
        updates["arpeggiates"] = reference["arpeggiates"]; // TODO: Merge?
      } 
      reference["arpeggiates"][idx] = update;
      frozen["arpeggiates"][idx] = true;
      return this;
    }

    this.arpeggiatesSplice = (start: number, deleteCount: number, ...items: Arpeggiate[]): INotationsBuilder => {
      makeReference("arpeggiates");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["arpeggiates"][idx]) {
            throw new Error("Replacing arpeggiates." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["arpeggiates"][idx];
          patches.push({p: ["arpeggiates", idx], ld, li: items[idx - start]});
          frozen["arpeggiates"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["arpeggiates"][idx]) {
            throw new Error("Removing arpeggiates." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["arpeggiates"][idx];
          patches.push({p: ["arpeggiates", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["arpeggiates", idx], li: items[idx - start]});
          frozen["arpeggiates"][idx] = true;
        }
      }
      reference["arpeggiates"].splice(start, deleteCount, ...items);
      updates["arpeggiates"] = reference["arpeggiates"];
      frozen["arpeggiates"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.nonArpeggiates = (spec: NonArpeggiate[]): INotationsBuilder => {
        updates["nonArpeggiates"] = spec;
        delete childBuilders["nonArpeggiates;"];
        modifiedKeys["nonArpeggiates"] = true;
        return this;
    }

    this.nonArpeggiatesAt = (idx: number, build: NonArpeggiate | ((builder: INonArpeggiateBuilder) => INonArpeggiateBuilder)): INotationsBuilder => {
      makeReference("nonArpeggiates");
      if (frozen["nonArpeggiates"][idx]) {
          throw new Error("Patching nonArpeggiates." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["nonArpeggiates"] && !original["nonArpeggiates"]) {
          // Clone snapshot.
          patches.push({p: ["nonArpeggiates", idx], li: original._snapshot["nonArpeggiates"]});
      }
      if (typeof build === 'function' && reference["nonArpeggiates"][idx]) {
        let patch = (build as any)(new NonArpeggiateBuilder(reference["nonArpeggiates"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["nonArpeggiates", idx].concat(patch.p);
          return patch;
        }));
        frozen["nonArpeggiates"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new NonArpeggiateBuilder(reference["nonArpeggiates"][idx])).build() : build;
      if (original) {
        patches.push({p: ["nonArpeggiates", idx], li: update});
      } else {
        updates["nonArpeggiates"] = reference["nonArpeggiates"]; // TODO: Merge?
      } 
      reference["nonArpeggiates"][idx] = update;
      frozen["nonArpeggiates"][idx] = true;
      return this;
    }

    this.nonArpeggiatesSplice = (start: number, deleteCount: number, ...items: NonArpeggiate[]): INotationsBuilder => {
      makeReference("nonArpeggiates");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["nonArpeggiates"][idx]) {
            throw new Error("Replacing nonArpeggiates." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["nonArpeggiates"][idx];
          patches.push({p: ["nonArpeggiates", idx], ld, li: items[idx - start]});
          frozen["nonArpeggiates"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["nonArpeggiates"][idx]) {
            throw new Error("Removing nonArpeggiates." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["nonArpeggiates"][idx];
          patches.push({p: ["nonArpeggiates", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["nonArpeggiates", idx], li: items[idx - start]});
          frozen["nonArpeggiates"][idx] = true;
        }
      }
      reference["nonArpeggiates"].splice(start, deleteCount, ...items);
      updates["nonArpeggiates"] = reference["nonArpeggiates"];
      frozen["nonArpeggiates"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.otherNotations = (spec: OtherNotation[]): INotationsBuilder => {
        updates["otherNotations"] = spec;
        delete childBuilders["otherNotations;"];
        modifiedKeys["otherNotations"] = true;
        return this;
    }

    this.otherNotationsAt = (idx: number, build: OtherNotation | ((builder: IOtherNotationBuilder) => IOtherNotationBuilder)): INotationsBuilder => {
      makeReference("otherNotations");
      if (frozen["otherNotations"][idx]) {
          throw new Error("Patching otherNotations." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["otherNotations"] && !original["otherNotations"]) {
          // Clone snapshot.
          patches.push({p: ["otherNotations", idx], li: original._snapshot["otherNotations"]});
      }
      if (typeof build === 'function' && reference["otherNotations"][idx]) {
        let patch = (build as any)(new OtherNotationBuilder(reference["otherNotations"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["otherNotations", idx].concat(patch.p);
          return patch;
        }));
        frozen["otherNotations"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new OtherNotationBuilder(reference["otherNotations"][idx])).build() : build;
      if (original) {
        patches.push({p: ["otherNotations", idx], li: update});
      } else {
        updates["otherNotations"] = reference["otherNotations"]; // TODO: Merge?
      } 
      reference["otherNotations"][idx] = update;
      frozen["otherNotations"][idx] = true;
      return this;
    }

    this.otherNotationsSplice = (start: number, deleteCount: number, ...items: OtherNotation[]): INotationsBuilder => {
      makeReference("otherNotations");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["otherNotations"][idx]) {
            throw new Error("Replacing otherNotations." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["otherNotations"][idx];
          patches.push({p: ["otherNotations", idx], ld, li: items[idx - start]});
          frozen["otherNotations"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["otherNotations"][idx]) {
            throw new Error("Removing otherNotations." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["otherNotations"][idx];
          patches.push({p: ["otherNotations", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["otherNotations", idx], li: items[idx - start]});
          frozen["otherNotations"][idx] = true;
        }
      }
      reference["otherNotations"].splice(start, deleteCount, ...items);
      updates["otherNotations"] = reference["otherNotations"];
      frozen["otherNotations"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.printObject = (spec: boolean): INotationsBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.footnote = (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)): INotationsBuilder => {
      if (typeof build === 'function') {
        delete updates["footnote"]
        const builder = (build as any)(new FootnoteBuilder(original && original["footnote"]));
        if (!original) updates["footnote"] = builder.build();
        else childBuilders["footnote"] = builder;
      } else {
        updates.footnote = build as any;
        delete childBuilders["footnote;"];
      }
      modifiedKeys["footnote"] = true;
      return this;
    }

    this.level = (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)): INotationsBuilder => {
      if (typeof build === 'function') {
        delete updates["level"]
        const builder = (build as any)(new LevelBuilder(original && original["level"]));
        if (!original) updates["level"] = builder.build();
        else childBuilders["level"] = builder;
      } else {
        updates.level = build as any;
        delete childBuilders["level;"];
      }
      modifiedKeys["level"] = true;
      return this;
    }
  }
}
export function patchNotations(base: Notations, builder: (build: INotationsBuilder) => INotationsBuilder): IAny[] { return builder(new NotationsBuilder(base)).patch(); }
export function buildNotations(builder: (build: INotationsBuilder) => INotationsBuilder): Notations { return builder(new NotationsBuilder()).build(); }

export interface ITiedBuilder {
  build?: () => Tied;
  patch: () => IAny[];
  number: (number: number) => ITiedBuilder;
  type: (type: StartStopContinue) => ITiedBuilder;
  defaultX: (defaultX: number) => ITiedBuilder;
  relativeY: (relativeY: number) => ITiedBuilder;
  defaultY: (defaultY: number) => ITiedBuilder;
  relativeX: (relativeX: number) => ITiedBuilder;
  color: (color: string) => ITiedBuilder;
  placement: (placement: AboveBelow) => ITiedBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => ITiedBuilder;
  dashLength: (dashLength: number) => ITiedBuilder;
  spaceLength: (spaceLength: number) => ITiedBuilder;
  orientation: (orientation: OverUnder) => ITiedBuilder;
  bezierX2: (bezierX2: number) => ITiedBuilder;
  bezierOffset: (bezierOffset: number) => ITiedBuilder;
  bezierOffset2: (bezierOffset2: number) => ITiedBuilder;
  bezierX: (bezierX: number) => ITiedBuilder;
  bezierY: (bezierY: number) => ITiedBuilder;
  bezierY2: (bezierY2: number) => ITiedBuilder;
}

class TiedBuilder implements ITiedBuilder {
  build: () => Tied;
  patch: () => IAny[];
  number: (number: number) => ITiedBuilder;
  type: (type: StartStopContinue) => ITiedBuilder;
  defaultX: (defaultX: number) => ITiedBuilder;
  relativeY: (relativeY: number) => ITiedBuilder;
  defaultY: (defaultY: number) => ITiedBuilder;
  relativeX: (relativeX: number) => ITiedBuilder;
  color: (color: string) => ITiedBuilder;
  placement: (placement: AboveBelow) => ITiedBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => ITiedBuilder;
  dashLength: (dashLength: number) => ITiedBuilder;
  spaceLength: (spaceLength: number) => ITiedBuilder;
  orientation: (orientation: OverUnder) => ITiedBuilder;
  bezierX2: (bezierX2: number) => ITiedBuilder;
  bezierOffset: (bezierOffset: number) => ITiedBuilder;
  bezierOffset2: (bezierOffset2: number) => ITiedBuilder;
  bezierX: (bezierX: number) => ITiedBuilder;
  bezierY: (bezierY: number) => ITiedBuilder;
  bezierY2: (bezierY2: number) => ITiedBuilder;
  constructor(original?: Tied) {
    let updates: Tied = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Tied => {
        checkInvariants();
        (updates as any)._class = "Tied";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: number): ITiedBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.type = (spec: StartStopContinue): ITiedBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): ITiedBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ITiedBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ITiedBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ITiedBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.color = (spec: string): ITiedBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): ITiedBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.lineType = (spec: SolidDashedDottedWavy): ITiedBuilder => {
        updates["lineType"] = spec;
        delete childBuilders["lineType;"];
        modifiedKeys["lineType"] = true;
        return this;
    }

    this.dashLength = (spec: number): ITiedBuilder => {
        updates["dashLength"] = spec;
        delete childBuilders["dashLength;"];
        modifiedKeys["dashLength"] = true;
        return this;
    }

    this.spaceLength = (spec: number): ITiedBuilder => {
        updates["spaceLength"] = spec;
        delete childBuilders["spaceLength;"];
        modifiedKeys["spaceLength"] = true;
        return this;
    }

    this.orientation = (spec: OverUnder): ITiedBuilder => {
        updates["orientation"] = spec;
        delete childBuilders["orientation;"];
        modifiedKeys["orientation"] = true;
        return this;
    }

    this.bezierX2 = (spec: number): ITiedBuilder => {
        updates["bezierX2"] = spec;
        delete childBuilders["bezierX2;"];
        modifiedKeys["bezierX2"] = true;
        return this;
    }

    this.bezierOffset = (spec: number): ITiedBuilder => {
        updates["bezierOffset"] = spec;
        delete childBuilders["bezierOffset;"];
        modifiedKeys["bezierOffset"] = true;
        return this;
    }

    this.bezierOffset2 = (spec: number): ITiedBuilder => {
        updates["bezierOffset2"] = spec;
        delete childBuilders["bezierOffset2;"];
        modifiedKeys["bezierOffset2"] = true;
        return this;
    }

    this.bezierX = (spec: number): ITiedBuilder => {
        updates["bezierX"] = spec;
        delete childBuilders["bezierX;"];
        modifiedKeys["bezierX"] = true;
        return this;
    }

    this.bezierY = (spec: number): ITiedBuilder => {
        updates["bezierY"] = spec;
        delete childBuilders["bezierY;"];
        modifiedKeys["bezierY"] = true;
        return this;
    }

    this.bezierY2 = (spec: number): ITiedBuilder => {
        updates["bezierY2"] = spec;
        delete childBuilders["bezierY2;"];
        modifiedKeys["bezierY2"] = true;
        return this;
    }
  }
}
export function patchTied(base: Tied, builder: (build: ITiedBuilder) => ITiedBuilder): IAny[] { return builder(new TiedBuilder(base)).patch(); }
export function buildTied(builder: (build: ITiedBuilder) => ITiedBuilder): Tied { return builder(new TiedBuilder()).build(); }

export interface ISlurBuilder {
  build?: () => Slur;
  patch: () => IAny[];
  number: (number: number) => ISlurBuilder;
  type: (type: StartStopContinue) => ISlurBuilder;
  defaultX: (defaultX: number) => ISlurBuilder;
  relativeY: (relativeY: number) => ISlurBuilder;
  defaultY: (defaultY: number) => ISlurBuilder;
  relativeX: (relativeX: number) => ISlurBuilder;
  color: (color: string) => ISlurBuilder;
  placement: (placement: AboveBelow) => ISlurBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => ISlurBuilder;
  dashLength: (dashLength: number) => ISlurBuilder;
  spaceLength: (spaceLength: number) => ISlurBuilder;
  orientation: (orientation: OverUnder) => ISlurBuilder;
  bezierX2: (bezierX2: number) => ISlurBuilder;
  bezierOffset: (bezierOffset: number) => ISlurBuilder;
  bezierOffset2: (bezierOffset2: number) => ISlurBuilder;
  bezierX: (bezierX: number) => ISlurBuilder;
  bezierY: (bezierY: number) => ISlurBuilder;
  bezierY2: (bezierY2: number) => ISlurBuilder;
}

class SlurBuilder implements ISlurBuilder {
  build: () => Slur;
  patch: () => IAny[];
  number: (number: number) => ISlurBuilder;
  type: (type: StartStopContinue) => ISlurBuilder;
  defaultX: (defaultX: number) => ISlurBuilder;
  relativeY: (relativeY: number) => ISlurBuilder;
  defaultY: (defaultY: number) => ISlurBuilder;
  relativeX: (relativeX: number) => ISlurBuilder;
  color: (color: string) => ISlurBuilder;
  placement: (placement: AboveBelow) => ISlurBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => ISlurBuilder;
  dashLength: (dashLength: number) => ISlurBuilder;
  spaceLength: (spaceLength: number) => ISlurBuilder;
  orientation: (orientation: OverUnder) => ISlurBuilder;
  bezierX2: (bezierX2: number) => ISlurBuilder;
  bezierOffset: (bezierOffset: number) => ISlurBuilder;
  bezierOffset2: (bezierOffset2: number) => ISlurBuilder;
  bezierX: (bezierX: number) => ISlurBuilder;
  bezierY: (bezierY: number) => ISlurBuilder;
  bezierY2: (bezierY2: number) => ISlurBuilder;
  constructor(original?: Slur) {
    let updates: Slur = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Slur => {
        checkInvariants();
        (updates as any)._class = "Slur";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: number): ISlurBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.type = (spec: StartStopContinue): ISlurBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): ISlurBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ISlurBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ISlurBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ISlurBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.color = (spec: string): ISlurBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): ISlurBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.lineType = (spec: SolidDashedDottedWavy): ISlurBuilder => {
        updates["lineType"] = spec;
        delete childBuilders["lineType;"];
        modifiedKeys["lineType"] = true;
        return this;
    }

    this.dashLength = (spec: number): ISlurBuilder => {
        updates["dashLength"] = spec;
        delete childBuilders["dashLength;"];
        modifiedKeys["dashLength"] = true;
        return this;
    }

    this.spaceLength = (spec: number): ISlurBuilder => {
        updates["spaceLength"] = spec;
        delete childBuilders["spaceLength;"];
        modifiedKeys["spaceLength"] = true;
        return this;
    }

    this.orientation = (spec: OverUnder): ISlurBuilder => {
        updates["orientation"] = spec;
        delete childBuilders["orientation;"];
        modifiedKeys["orientation"] = true;
        return this;
    }

    this.bezierX2 = (spec: number): ISlurBuilder => {
        updates["bezierX2"] = spec;
        delete childBuilders["bezierX2;"];
        modifiedKeys["bezierX2"] = true;
        return this;
    }

    this.bezierOffset = (spec: number): ISlurBuilder => {
        updates["bezierOffset"] = spec;
        delete childBuilders["bezierOffset;"];
        modifiedKeys["bezierOffset"] = true;
        return this;
    }

    this.bezierOffset2 = (spec: number): ISlurBuilder => {
        updates["bezierOffset2"] = spec;
        delete childBuilders["bezierOffset2;"];
        modifiedKeys["bezierOffset2"] = true;
        return this;
    }

    this.bezierX = (spec: number): ISlurBuilder => {
        updates["bezierX"] = spec;
        delete childBuilders["bezierX;"];
        modifiedKeys["bezierX"] = true;
        return this;
    }

    this.bezierY = (spec: number): ISlurBuilder => {
        updates["bezierY"] = spec;
        delete childBuilders["bezierY;"];
        modifiedKeys["bezierY"] = true;
        return this;
    }

    this.bezierY2 = (spec: number): ISlurBuilder => {
        updates["bezierY2"] = spec;
        delete childBuilders["bezierY2;"];
        modifiedKeys["bezierY2"] = true;
        return this;
    }
  }
}
export function patchSlur(base: Slur, builder: (build: ISlurBuilder) => ISlurBuilder): IAny[] { return builder(new SlurBuilder(base)).patch(); }
export function buildSlur(builder: (build: ISlurBuilder) => ISlurBuilder): Slur { return builder(new SlurBuilder()).build(); }

export interface ITupletBuilder {
  build?: () => Tuplet;
  patch: () => IAny[];
  bracket: (bracket: boolean) => ITupletBuilder;
  number: (number: number) => ITupletBuilder;
  showNumber: (showNumber: ActualBothNone) => ITupletBuilder;
  tupletNormal: (build: TupletNormal | ((builder: ITupletNormalBuilder) => ITupletNormalBuilder)) => ITupletBuilder;
  type: (type: StartStop) => ITupletBuilder;
  showType: (showType: ActualBothNone) => ITupletBuilder;
  tupletActual: (build: TupletActual | ((builder: ITupletActualBuilder) => ITupletActualBuilder)) => ITupletBuilder;
  defaultX: (defaultX: number) => ITupletBuilder;
  relativeY: (relativeY: number) => ITupletBuilder;
  defaultY: (defaultY: number) => ITupletBuilder;
  relativeX: (relativeX: number) => ITupletBuilder;
  placement: (placement: AboveBelow) => ITupletBuilder;
  lineShape: (lineShape: StraightCurved) => ITupletBuilder;
}

class TupletBuilder implements ITupletBuilder {
  build: () => Tuplet;
  patch: () => IAny[];
  bracket: (bracket: boolean) => ITupletBuilder;
  number: (number: number) => ITupletBuilder;
  showNumber: (showNumber: ActualBothNone) => ITupletBuilder;
  tupletNormal: (build: TupletNormal | ((builder: ITupletNormalBuilder) => ITupletNormalBuilder)) => ITupletBuilder;
  type: (type: StartStop) => ITupletBuilder;
  showType: (showType: ActualBothNone) => ITupletBuilder;
  tupletActual: (build: TupletActual | ((builder: ITupletActualBuilder) => ITupletActualBuilder)) => ITupletBuilder;
  defaultX: (defaultX: number) => ITupletBuilder;
  relativeY: (relativeY: number) => ITupletBuilder;
  defaultY: (defaultY: number) => ITupletBuilder;
  relativeX: (relativeX: number) => ITupletBuilder;
  placement: (placement: AboveBelow) => ITupletBuilder;
  lineShape: (lineShape: StraightCurved) => ITupletBuilder;
  constructor(original?: Tuplet) {
    let updates: Tuplet = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["number"]) ||
          childBuilders["number"] !== undefined ||
          updates.number !== undefined,
        "number is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Tuplet => {
        checkInvariants();
        (updates as any)._class = "Tuplet";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.bracket = (spec: boolean): ITupletBuilder => {
        updates["bracket"] = spec;
        delete childBuilders["bracket;"];
        modifiedKeys["bracket"] = true;
        return this;
    }

    this.number = (spec: number): ITupletBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.showNumber = (spec: ActualBothNone): ITupletBuilder => {
        updates["showNumber"] = spec;
        delete childBuilders["showNumber;"];
        modifiedKeys["showNumber"] = true;
        return this;
    }

    this.tupletNormal = (build: TupletNormal | ((builder: ITupletNormalBuilder) => ITupletNormalBuilder)): ITupletBuilder => {
      if (typeof build === 'function') {
        delete updates["tupletNormal"]
        const builder = (build as any)(new TupletNormalBuilder(original && original["tupletNormal"]));
        if (!original) updates["tupletNormal"] = builder.build();
        else childBuilders["tupletNormal"] = builder;
      } else {
        updates.tupletNormal = build as any;
        delete childBuilders["tupletNormal;"];
      }
      modifiedKeys["tupletNormal"] = true;
      return this;
    }

    this.type = (spec: StartStop): ITupletBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.showType = (spec: ActualBothNone): ITupletBuilder => {
        updates["showType"] = spec;
        delete childBuilders["showType;"];
        modifiedKeys["showType"] = true;
        return this;
    }

    this.tupletActual = (build: TupletActual | ((builder: ITupletActualBuilder) => ITupletActualBuilder)): ITupletBuilder => {
      if (typeof build === 'function') {
        delete updates["tupletActual"]
        const builder = (build as any)(new TupletActualBuilder(original && original["tupletActual"]));
        if (!original) updates["tupletActual"] = builder.build();
        else childBuilders["tupletActual"] = builder;
      } else {
        updates.tupletActual = build as any;
        delete childBuilders["tupletActual;"];
      }
      modifiedKeys["tupletActual"] = true;
      return this;
    }

    this.defaultX = (spec: number): ITupletBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ITupletBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ITupletBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ITupletBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): ITupletBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.lineShape = (spec: StraightCurved): ITupletBuilder => {
        updates["lineShape"] = spec;
        delete childBuilders["lineShape;"];
        modifiedKeys["lineShape"] = true;
        return this;
    }
  }
}
export function patchTuplet(base: Tuplet, builder: (build: ITupletBuilder) => ITupletBuilder): IAny[] { return builder(new TupletBuilder(base)).patch(); }
export function buildTuplet(builder: (build: ITupletBuilder) => ITupletBuilder): Tuplet { return builder(new TupletBuilder()).build(); }

export interface ITupletActualBuilder {
  build?: () => TupletActual;
  patch: () => IAny[];
  tupletNumber: (build: TupletNumber | ((builder: ITupletNumberBuilder) => ITupletNumberBuilder)) => ITupletActualBuilder;
  tupletDotsAt: (idx: number, build: TupletDot | ((builder: ITupletDotBuilder) => ITupletDotBuilder)) => ITupletActualBuilder;
  tupletDotsSplice: (start: number, deleteCount: number, ...items: TupletDot[]) => ITupletActualBuilder;
  tupletDots: (tupletDots: TupletDot[]) => ITupletActualBuilder;
  tupletType: (build: TupletType | ((builder: ITupletTypeBuilder) => ITupletTypeBuilder)) => ITupletActualBuilder;
}

class TupletActualBuilder implements ITupletActualBuilder {
  build: () => TupletActual;
  patch: () => IAny[];
  tupletNumber: (build: TupletNumber | ((builder: ITupletNumberBuilder) => ITupletNumberBuilder)) => ITupletActualBuilder;
  tupletDotsAt: (idx: number, build: TupletDot | ((builder: ITupletDotBuilder) => ITupletDotBuilder)) => ITupletActualBuilder;
  tupletDotsSplice: (start: number, deleteCount: number, ...items: TupletDot[]) => ITupletActualBuilder;
  tupletDots: (tupletDots: TupletDot[]) => ITupletActualBuilder;
  tupletType: (build: TupletType | ((builder: ITupletTypeBuilder) => ITupletTypeBuilder)) => ITupletActualBuilder;
  constructor(original?: TupletActual) {
    let updates: TupletActual = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): TupletActual => {
        checkInvariants();
        (updates as any)._class = "TupletActual";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.tupletNumber = (build: TupletNumber | ((builder: ITupletNumberBuilder) => ITupletNumberBuilder)): ITupletActualBuilder => {
      if (typeof build === 'function') {
        delete updates["tupletNumber"]
        const builder = (build as any)(new TupletNumberBuilder(original && original["tupletNumber"]));
        if (!original) updates["tupletNumber"] = builder.build();
        else childBuilders["tupletNumber"] = builder;
      } else {
        updates.tupletNumber = build as any;
        delete childBuilders["tupletNumber;"];
      }
      modifiedKeys["tupletNumber"] = true;
      return this;
    }

    this.tupletDots = (spec: TupletDot[]): ITupletActualBuilder => {
        updates["tupletDots"] = spec;
        delete childBuilders["tupletDots;"];
        modifiedKeys["tupletDots"] = true;
        return this;
    }

    this.tupletDotsAt = (idx: number, build: TupletDot | ((builder: ITupletDotBuilder) => ITupletDotBuilder)): ITupletActualBuilder => {
      makeReference("tupletDots");
      if (frozen["tupletDots"][idx]) {
          throw new Error("Patching tupletDots." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["tupletDots"] && !original["tupletDots"]) {
          // Clone snapshot.
          patches.push({p: ["tupletDots", idx], li: original._snapshot["tupletDots"]});
      }
      if (typeof build === 'function' && reference["tupletDots"][idx]) {
        let patch = (build as any)(new TupletDotBuilder(reference["tupletDots"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["tupletDots", idx].concat(patch.p);
          return patch;
        }));
        frozen["tupletDots"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new TupletDotBuilder(reference["tupletDots"][idx])).build() : build;
      if (original) {
        patches.push({p: ["tupletDots", idx], li: update});
      } else {
        updates["tupletDots"] = reference["tupletDots"]; // TODO: Merge?
      } 
      reference["tupletDots"][idx] = update;
      frozen["tupletDots"][idx] = true;
      return this;
    }

    this.tupletDotsSplice = (start: number, deleteCount: number, ...items: TupletDot[]): ITupletActualBuilder => {
      makeReference("tupletDots");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["tupletDots"][idx]) {
            throw new Error("Replacing tupletDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["tupletDots"][idx];
          patches.push({p: ["tupletDots", idx], ld, li: items[idx - start]});
          frozen["tupletDots"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["tupletDots"][idx]) {
            throw new Error("Removing tupletDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["tupletDots"][idx];
          patches.push({p: ["tupletDots", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["tupletDots", idx], li: items[idx - start]});
          frozen["tupletDots"][idx] = true;
        }
      }
      reference["tupletDots"].splice(start, deleteCount, ...items);
      updates["tupletDots"] = reference["tupletDots"];
      frozen["tupletDots"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.tupletType = (build: TupletType | ((builder: ITupletTypeBuilder) => ITupletTypeBuilder)): ITupletActualBuilder => {
      if (typeof build === 'function') {
        delete updates["tupletType"]
        const builder = (build as any)(new TupletTypeBuilder(original && original["tupletType"]));
        if (!original) updates["tupletType"] = builder.build();
        else childBuilders["tupletType"] = builder;
      } else {
        updates.tupletType = build as any;
        delete childBuilders["tupletType;"];
      }
      modifiedKeys["tupletType"] = true;
      return this;
    }
  }
}
export function patchTupletActual(base: TupletActual, builder: (build: ITupletActualBuilder) => ITupletActualBuilder): IAny[] { return builder(new TupletActualBuilder(base)).patch(); }
export function buildTupletActual(builder: (build: ITupletActualBuilder) => ITupletActualBuilder): TupletActual { return builder(new TupletActualBuilder()).build(); }

export interface ITupletNormalBuilder {
  build?: () => TupletNormal;
  patch: () => IAny[];
  tupletNumber: (build: TupletNumber | ((builder: ITupletNumberBuilder) => ITupletNumberBuilder)) => ITupletNormalBuilder;
  tupletDotsAt: (idx: number, build: TupletDot | ((builder: ITupletDotBuilder) => ITupletDotBuilder)) => ITupletNormalBuilder;
  tupletDotsSplice: (start: number, deleteCount: number, ...items: TupletDot[]) => ITupletNormalBuilder;
  tupletDots: (tupletDots: TupletDot[]) => ITupletNormalBuilder;
  tupletType: (build: TupletType | ((builder: ITupletTypeBuilder) => ITupletTypeBuilder)) => ITupletNormalBuilder;
}

class TupletNormalBuilder implements ITupletNormalBuilder {
  build: () => TupletNormal;
  patch: () => IAny[];
  tupletNumber: (build: TupletNumber | ((builder: ITupletNumberBuilder) => ITupletNumberBuilder)) => ITupletNormalBuilder;
  tupletDotsAt: (idx: number, build: TupletDot | ((builder: ITupletDotBuilder) => ITupletDotBuilder)) => ITupletNormalBuilder;
  tupletDotsSplice: (start: number, deleteCount: number, ...items: TupletDot[]) => ITupletNormalBuilder;
  tupletDots: (tupletDots: TupletDot[]) => ITupletNormalBuilder;
  tupletType: (build: TupletType | ((builder: ITupletTypeBuilder) => ITupletTypeBuilder)) => ITupletNormalBuilder;
  constructor(original?: TupletNormal) {
    let updates: TupletNormal = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): TupletNormal => {
        checkInvariants();
        (updates as any)._class = "TupletNormal";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.tupletNumber = (build: TupletNumber | ((builder: ITupletNumberBuilder) => ITupletNumberBuilder)): ITupletNormalBuilder => {
      if (typeof build === 'function') {
        delete updates["tupletNumber"]
        const builder = (build as any)(new TupletNumberBuilder(original && original["tupletNumber"]));
        if (!original) updates["tupletNumber"] = builder.build();
        else childBuilders["tupletNumber"] = builder;
      } else {
        updates.tupletNumber = build as any;
        delete childBuilders["tupletNumber;"];
      }
      modifiedKeys["tupletNumber"] = true;
      return this;
    }

    this.tupletDots = (spec: TupletDot[]): ITupletNormalBuilder => {
        updates["tupletDots"] = spec;
        delete childBuilders["tupletDots;"];
        modifiedKeys["tupletDots"] = true;
        return this;
    }

    this.tupletDotsAt = (idx: number, build: TupletDot | ((builder: ITupletDotBuilder) => ITupletDotBuilder)): ITupletNormalBuilder => {
      makeReference("tupletDots");
      if (frozen["tupletDots"][idx]) {
          throw new Error("Patching tupletDots." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["tupletDots"] && !original["tupletDots"]) {
          // Clone snapshot.
          patches.push({p: ["tupletDots", idx], li: original._snapshot["tupletDots"]});
      }
      if (typeof build === 'function' && reference["tupletDots"][idx]) {
        let patch = (build as any)(new TupletDotBuilder(reference["tupletDots"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["tupletDots", idx].concat(patch.p);
          return patch;
        }));
        frozen["tupletDots"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new TupletDotBuilder(reference["tupletDots"][idx])).build() : build;
      if (original) {
        patches.push({p: ["tupletDots", idx], li: update});
      } else {
        updates["tupletDots"] = reference["tupletDots"]; // TODO: Merge?
      } 
      reference["tupletDots"][idx] = update;
      frozen["tupletDots"][idx] = true;
      return this;
    }

    this.tupletDotsSplice = (start: number, deleteCount: number, ...items: TupletDot[]): ITupletNormalBuilder => {
      makeReference("tupletDots");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["tupletDots"][idx]) {
            throw new Error("Replacing tupletDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["tupletDots"][idx];
          patches.push({p: ["tupletDots", idx], ld, li: items[idx - start]});
          frozen["tupletDots"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["tupletDots"][idx]) {
            throw new Error("Removing tupletDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["tupletDots"][idx];
          patches.push({p: ["tupletDots", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["tupletDots", idx], li: items[idx - start]});
          frozen["tupletDots"][idx] = true;
        }
      }
      reference["tupletDots"].splice(start, deleteCount, ...items);
      updates["tupletDots"] = reference["tupletDots"];
      frozen["tupletDots"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.tupletType = (build: TupletType | ((builder: ITupletTypeBuilder) => ITupletTypeBuilder)): ITupletNormalBuilder => {
      if (typeof build === 'function') {
        delete updates["tupletType"]
        const builder = (build as any)(new TupletTypeBuilder(original && original["tupletType"]));
        if (!original) updates["tupletType"] = builder.build();
        else childBuilders["tupletType"] = builder;
      } else {
        updates.tupletType = build as any;
        delete childBuilders["tupletType;"];
      }
      modifiedKeys["tupletType"] = true;
      return this;
    }
  }
}
export function patchTupletNormal(base: TupletNormal, builder: (build: ITupletNormalBuilder) => ITupletNormalBuilder): IAny[] { return builder(new TupletNormalBuilder(base)).patch(); }
export function buildTupletNormal(builder: (build: ITupletNormalBuilder) => ITupletNormalBuilder): TupletNormal { return builder(new TupletNormalBuilder()).build(); }

export interface ITupletNumberBuilder {
  build?: () => TupletNumber;
  patch: () => IAny[];
  text: (text: string) => ITupletNumberBuilder;
  fontFamily: (fontFamily: string) => ITupletNumberBuilder;
  fontWeight: (fontWeight: NormalBold) => ITupletNumberBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITupletNumberBuilder;
  fontSize: (fontSize: string) => ITupletNumberBuilder;
  color: (color: string) => ITupletNumberBuilder;
}

class TupletNumberBuilder implements ITupletNumberBuilder {
  build: () => TupletNumber;
  patch: () => IAny[];
  text: (text: string) => ITupletNumberBuilder;
  fontFamily: (fontFamily: string) => ITupletNumberBuilder;
  fontWeight: (fontWeight: NormalBold) => ITupletNumberBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITupletNumberBuilder;
  fontSize: (fontSize: string) => ITupletNumberBuilder;
  color: (color: string) => ITupletNumberBuilder;
  constructor(original?: TupletNumber) {
    let updates: TupletNumber = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["text"]) ||
          childBuilders["text"] !== undefined ||
          updates.text !== undefined,
        "text is a required field");
    }

    if (!original) {
      this.build = (): TupletNumber => {
        checkInvariants();
        (updates as any)._class = "TupletNumber";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.text = (spec: string): ITupletNumberBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ITupletNumberBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ITupletNumberBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ITupletNumberBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ITupletNumberBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ITupletNumberBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchTupletNumber(base: TupletNumber, builder: (build: ITupletNumberBuilder) => ITupletNumberBuilder): IAny[] { return builder(new TupletNumberBuilder(base)).patch(); }
export function buildTupletNumber(builder: (build: ITupletNumberBuilder) => ITupletNumberBuilder): TupletNumber { return builder(new TupletNumberBuilder()).build(); }

export interface ITupletTypeBuilder {
  build?: () => TupletType;
  patch: () => IAny[];
  text: (text: string) => ITupletTypeBuilder;
  fontFamily: (fontFamily: string) => ITupletTypeBuilder;
  fontWeight: (fontWeight: NormalBold) => ITupletTypeBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITupletTypeBuilder;
  fontSize: (fontSize: string) => ITupletTypeBuilder;
  color: (color: string) => ITupletTypeBuilder;
}

class TupletTypeBuilder implements ITupletTypeBuilder {
  build: () => TupletType;
  patch: () => IAny[];
  text: (text: string) => ITupletTypeBuilder;
  fontFamily: (fontFamily: string) => ITupletTypeBuilder;
  fontWeight: (fontWeight: NormalBold) => ITupletTypeBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITupletTypeBuilder;
  fontSize: (fontSize: string) => ITupletTypeBuilder;
  color: (color: string) => ITupletTypeBuilder;
  constructor(original?: TupletType) {
    let updates: TupletType = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["text"]) ||
          childBuilders["text"] !== undefined ||
          updates.text !== undefined,
        "text is a required field");
    }

    if (!original) {
      this.build = (): TupletType => {
        checkInvariants();
        (updates as any)._class = "TupletType";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.text = (spec: string): ITupletTypeBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ITupletTypeBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ITupletTypeBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ITupletTypeBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ITupletTypeBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ITupletTypeBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchTupletType(base: TupletType, builder: (build: ITupletTypeBuilder) => ITupletTypeBuilder): IAny[] { return builder(new TupletTypeBuilder(base)).patch(); }
export function buildTupletType(builder: (build: ITupletTypeBuilder) => ITupletTypeBuilder): TupletType { return builder(new TupletTypeBuilder()).build(); }

export interface ITupletDotBuilder {
  build?: () => TupletDot;
  patch: () => IAny[];
  fontFamily: (fontFamily: string) => ITupletDotBuilder;
  fontWeight: (fontWeight: NormalBold) => ITupletDotBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITupletDotBuilder;
  fontSize: (fontSize: string) => ITupletDotBuilder;
  color: (color: string) => ITupletDotBuilder;
}

class TupletDotBuilder implements ITupletDotBuilder {
  build: () => TupletDot;
  patch: () => IAny[];
  fontFamily: (fontFamily: string) => ITupletDotBuilder;
  fontWeight: (fontWeight: NormalBold) => ITupletDotBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITupletDotBuilder;
  fontSize: (fontSize: string) => ITupletDotBuilder;
  color: (color: string) => ITupletDotBuilder;
  constructor(original?: TupletDot) {
    let updates: TupletDot = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): TupletDot => {
        checkInvariants();
        (updates as any)._class = "TupletDot";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.fontFamily = (spec: string): ITupletDotBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ITupletDotBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ITupletDotBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ITupletDotBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ITupletDotBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchTupletDot(base: TupletDot, builder: (build: ITupletDotBuilder) => ITupletDotBuilder): IAny[] { return builder(new TupletDotBuilder(base)).patch(); }
export function buildTupletDot(builder: (build: ITupletDotBuilder) => ITupletDotBuilder): TupletDot { return builder(new TupletDotBuilder()).build(); }

export interface IGlissandoBuilder {
  build?: () => Glissando;
  patch: () => IAny[];
  text: (text: string) => IGlissandoBuilder;
  type: (type: StartStop) => IGlissandoBuilder;
  normal: (normal: number) => IGlissandoBuilder;
  defaultX: (defaultX: number) => IGlissandoBuilder;
  relativeY: (relativeY: number) => IGlissandoBuilder;
  defaultY: (defaultY: number) => IGlissandoBuilder;
  relativeX: (relativeX: number) => IGlissandoBuilder;
  fontFamily: (fontFamily: string) => IGlissandoBuilder;
  fontWeight: (fontWeight: NormalBold) => IGlissandoBuilder;
  fontStyle: (fontStyle: NormalItalic) => IGlissandoBuilder;
  fontSize: (fontSize: string) => IGlissandoBuilder;
  color: (color: string) => IGlissandoBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IGlissandoBuilder;
  dashLength: (dashLength: number) => IGlissandoBuilder;
  spaceLength: (spaceLength: number) => IGlissandoBuilder;
}

class GlissandoBuilder implements IGlissandoBuilder {
  build: () => Glissando;
  patch: () => IAny[];
  text: (text: string) => IGlissandoBuilder;
  type: (type: StartStop) => IGlissandoBuilder;
  normal: (normal: number) => IGlissandoBuilder;
  defaultX: (defaultX: number) => IGlissandoBuilder;
  relativeY: (relativeY: number) => IGlissandoBuilder;
  defaultY: (defaultY: number) => IGlissandoBuilder;
  relativeX: (relativeX: number) => IGlissandoBuilder;
  fontFamily: (fontFamily: string) => IGlissandoBuilder;
  fontWeight: (fontWeight: NormalBold) => IGlissandoBuilder;
  fontStyle: (fontStyle: NormalItalic) => IGlissandoBuilder;
  fontSize: (fontSize: string) => IGlissandoBuilder;
  color: (color: string) => IGlissandoBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IGlissandoBuilder;
  dashLength: (dashLength: number) => IGlissandoBuilder;
  spaceLength: (spaceLength: number) => IGlissandoBuilder;
  constructor(original?: Glissando) {
    let updates: Glissando = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Glissando => {
        checkInvariants();
        (updates as any)._class = "Glissando";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.text = (spec: string): IGlissandoBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.type = (spec: StartStop): IGlissandoBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.normal = (spec: number): IGlissandoBuilder => {
        updates["normal"] = spec;
        delete childBuilders["normal;"];
        modifiedKeys["normal"] = true;
        return this;
    }

    this.defaultX = (spec: number): IGlissandoBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IGlissandoBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IGlissandoBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IGlissandoBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IGlissandoBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IGlissandoBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IGlissandoBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IGlissandoBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IGlissandoBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.lineType = (spec: SolidDashedDottedWavy): IGlissandoBuilder => {
        updates["lineType"] = spec;
        delete childBuilders["lineType;"];
        modifiedKeys["lineType"] = true;
        return this;
    }

    this.dashLength = (spec: number): IGlissandoBuilder => {
        updates["dashLength"] = spec;
        delete childBuilders["dashLength;"];
        modifiedKeys["dashLength"] = true;
        return this;
    }

    this.spaceLength = (spec: number): IGlissandoBuilder => {
        updates["spaceLength"] = spec;
        delete childBuilders["spaceLength;"];
        modifiedKeys["spaceLength"] = true;
        return this;
    }
  }
}
export function patchGlissando(base: Glissando, builder: (build: IGlissandoBuilder) => IGlissandoBuilder): IAny[] { return builder(new GlissandoBuilder(base)).patch(); }
export function buildGlissando(builder: (build: IGlissandoBuilder) => IGlissandoBuilder): Glissando { return builder(new GlissandoBuilder()).build(); }

export interface ISlideBuilder {
  build?: () => Slide;
  patch: () => IAny[];
  text: (text: string) => ISlideBuilder;
  type: (type: StartStop) => ISlideBuilder;
  normal: (normal: number) => ISlideBuilder;
  defaultX: (defaultX: number) => ISlideBuilder;
  relativeY: (relativeY: number) => ISlideBuilder;
  defaultY: (defaultY: number) => ISlideBuilder;
  relativeX: (relativeX: number) => ISlideBuilder;
  fontFamily: (fontFamily: string) => ISlideBuilder;
  fontWeight: (fontWeight: NormalBold) => ISlideBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISlideBuilder;
  fontSize: (fontSize: string) => ISlideBuilder;
  color: (color: string) => ISlideBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => ISlideBuilder;
  dashLength: (dashLength: number) => ISlideBuilder;
  spaceLength: (spaceLength: number) => ISlideBuilder;
  accelerate: (accelerate: boolean) => ISlideBuilder;
  beats: (beats: number) => ISlideBuilder;
  firstBeat: (firstBeat: number) => ISlideBuilder;
  lastBeat: (lastBeat: number) => ISlideBuilder;
}

class SlideBuilder implements ISlideBuilder {
  build: () => Slide;
  patch: () => IAny[];
  text: (text: string) => ISlideBuilder;
  type: (type: StartStop) => ISlideBuilder;
  normal: (normal: number) => ISlideBuilder;
  defaultX: (defaultX: number) => ISlideBuilder;
  relativeY: (relativeY: number) => ISlideBuilder;
  defaultY: (defaultY: number) => ISlideBuilder;
  relativeX: (relativeX: number) => ISlideBuilder;
  fontFamily: (fontFamily: string) => ISlideBuilder;
  fontWeight: (fontWeight: NormalBold) => ISlideBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISlideBuilder;
  fontSize: (fontSize: string) => ISlideBuilder;
  color: (color: string) => ISlideBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => ISlideBuilder;
  dashLength: (dashLength: number) => ISlideBuilder;
  spaceLength: (spaceLength: number) => ISlideBuilder;
  accelerate: (accelerate: boolean) => ISlideBuilder;
  beats: (beats: number) => ISlideBuilder;
  firstBeat: (firstBeat: number) => ISlideBuilder;
  lastBeat: (lastBeat: number) => ISlideBuilder;
  constructor(original?: Slide) {
    let updates: Slide = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Slide => {
        checkInvariants();
        (updates as any)._class = "Slide";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.text = (spec: string): ISlideBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.type = (spec: StartStop): ISlideBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.normal = (spec: number): ISlideBuilder => {
        updates["normal"] = spec;
        delete childBuilders["normal;"];
        modifiedKeys["normal"] = true;
        return this;
    }

    this.defaultX = (spec: number): ISlideBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ISlideBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ISlideBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ISlideBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ISlideBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ISlideBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ISlideBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ISlideBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ISlideBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.lineType = (spec: SolidDashedDottedWavy): ISlideBuilder => {
        updates["lineType"] = spec;
        delete childBuilders["lineType;"];
        modifiedKeys["lineType"] = true;
        return this;
    }

    this.dashLength = (spec: number): ISlideBuilder => {
        updates["dashLength"] = spec;
        delete childBuilders["dashLength;"];
        modifiedKeys["dashLength"] = true;
        return this;
    }

    this.spaceLength = (spec: number): ISlideBuilder => {
        updates["spaceLength"] = spec;
        delete childBuilders["spaceLength;"];
        modifiedKeys["spaceLength"] = true;
        return this;
    }

    this.accelerate = (spec: boolean): ISlideBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): ISlideBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.firstBeat = (spec: number): ISlideBuilder => {
        updates["firstBeat"] = spec;
        delete childBuilders["firstBeat;"];
        modifiedKeys["firstBeat"] = true;
        return this;
    }

    this.lastBeat = (spec: number): ISlideBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }
  }
}
export function patchSlide(base: Slide, builder: (build: ISlideBuilder) => ISlideBuilder): IAny[] { return builder(new SlideBuilder(base)).patch(); }
export function buildSlide(builder: (build: ISlideBuilder) => ISlideBuilder): Slide { return builder(new SlideBuilder()).build(); }

export interface IOtherNotationBuilder {
  build?: () => OtherNotation;
  patch: () => IAny[];
  type: (type: StartStopSingle) => IOtherNotationBuilder;
  data: (data: string) => IOtherNotationBuilder;
  defaultX: (defaultX: number) => IOtherNotationBuilder;
  relativeY: (relativeY: number) => IOtherNotationBuilder;
  defaultY: (defaultY: number) => IOtherNotationBuilder;
  relativeX: (relativeX: number) => IOtherNotationBuilder;
  fontFamily: (fontFamily: string) => IOtherNotationBuilder;
  fontWeight: (fontWeight: NormalBold) => IOtherNotationBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOtherNotationBuilder;
  fontSize: (fontSize: string) => IOtherNotationBuilder;
  color: (color: string) => IOtherNotationBuilder;
  printObject: (printObject: boolean) => IOtherNotationBuilder;
  placement: (placement: AboveBelow) => IOtherNotationBuilder;
}

class OtherNotationBuilder implements IOtherNotationBuilder {
  build: () => OtherNotation;
  patch: () => IAny[];
  type: (type: StartStopSingle) => IOtherNotationBuilder;
  data: (data: string) => IOtherNotationBuilder;
  defaultX: (defaultX: number) => IOtherNotationBuilder;
  relativeY: (relativeY: number) => IOtherNotationBuilder;
  defaultY: (defaultY: number) => IOtherNotationBuilder;
  relativeX: (relativeX: number) => IOtherNotationBuilder;
  fontFamily: (fontFamily: string) => IOtherNotationBuilder;
  fontWeight: (fontWeight: NormalBold) => IOtherNotationBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOtherNotationBuilder;
  fontSize: (fontSize: string) => IOtherNotationBuilder;
  color: (color: string) => IOtherNotationBuilder;
  printObject: (printObject: boolean) => IOtherNotationBuilder;
  placement: (placement: AboveBelow) => IOtherNotationBuilder;
  constructor(original?: OtherNotation) {
    let updates: OtherNotation = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): OtherNotation => {
        checkInvariants();
        (updates as any)._class = "OtherNotation";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.type = (spec: StartStopSingle): IOtherNotationBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.data = (spec: string): IOtherNotationBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IOtherNotationBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IOtherNotationBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IOtherNotationBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IOtherNotationBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IOtherNotationBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IOtherNotationBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IOtherNotationBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IOtherNotationBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IOtherNotationBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.printObject = (spec: boolean): IOtherNotationBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IOtherNotationBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchOtherNotation(base: OtherNotation, builder: (build: IOtherNotationBuilder) => IOtherNotationBuilder): IAny[] { return builder(new OtherNotationBuilder(base)).patch(); }
export function buildOtherNotation(builder: (build: IOtherNotationBuilder) => IOtherNotationBuilder): OtherNotation { return builder(new OtherNotationBuilder()).build(); }

export interface IOtherDirectionBuilder {
  build?: () => OtherDirection;
  patch: () => IAny[];
  data: (data: string) => IOtherDirectionBuilder;
  printObject: (printObject: boolean) => IOtherDirectionBuilder;
  defaultX: (defaultX: number) => IOtherDirectionBuilder;
  relativeY: (relativeY: number) => IOtherDirectionBuilder;
  defaultY: (defaultY: number) => IOtherDirectionBuilder;
  relativeX: (relativeX: number) => IOtherDirectionBuilder;
  fontFamily: (fontFamily: string) => IOtherDirectionBuilder;
  fontWeight: (fontWeight: NormalBold) => IOtherDirectionBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOtherDirectionBuilder;
  fontSize: (fontSize: string) => IOtherDirectionBuilder;
  color: (color: string) => IOtherDirectionBuilder;
  halign: (halign: LeftCenterRight) => IOtherDirectionBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IOtherDirectionBuilder;
}

class OtherDirectionBuilder implements IOtherDirectionBuilder {
  build: () => OtherDirection;
  patch: () => IAny[];
  data: (data: string) => IOtherDirectionBuilder;
  printObject: (printObject: boolean) => IOtherDirectionBuilder;
  defaultX: (defaultX: number) => IOtherDirectionBuilder;
  relativeY: (relativeY: number) => IOtherDirectionBuilder;
  defaultY: (defaultY: number) => IOtherDirectionBuilder;
  relativeX: (relativeX: number) => IOtherDirectionBuilder;
  fontFamily: (fontFamily: string) => IOtherDirectionBuilder;
  fontWeight: (fontWeight: NormalBold) => IOtherDirectionBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOtherDirectionBuilder;
  fontSize: (fontSize: string) => IOtherDirectionBuilder;
  color: (color: string) => IOtherDirectionBuilder;
  halign: (halign: LeftCenterRight) => IOtherDirectionBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IOtherDirectionBuilder;
  constructor(original?: OtherDirection) {
    let updates: OtherDirection = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): OtherDirection => {
        checkInvariants();
        (updates as any)._class = "OtherDirection";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IOtherDirectionBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.printObject = (spec: boolean): IOtherDirectionBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.defaultX = (spec: number): IOtherDirectionBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IOtherDirectionBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IOtherDirectionBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IOtherDirectionBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IOtherDirectionBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IOtherDirectionBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IOtherDirectionBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IOtherDirectionBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IOtherDirectionBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IOtherDirectionBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IOtherDirectionBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchOtherDirection(base: OtherDirection, builder: (build: IOtherDirectionBuilder) => IOtherDirectionBuilder): IAny[] { return builder(new OtherDirectionBuilder(base)).patch(); }
export function buildOtherDirection(builder: (build: IOtherDirectionBuilder) => IOtherDirectionBuilder): OtherDirection { return builder(new OtherDirectionBuilder()).build(); }

export interface IOrnamentsBuilder {
  build?: () => Ornaments;
  patch: () => IAny[];
  delayedInvertedTurn: (build: DelayedInvertedTurn | ((builder: IDelayedInvertedTurnBuilder) => IDelayedInvertedTurnBuilder)) => IOrnamentsBuilder;
  shake: (build: Shake | ((builder: IShakeBuilder) => IShakeBuilder)) => IOrnamentsBuilder;
  turn: (build: Turn | ((builder: ITurnBuilder) => ITurnBuilder)) => IOrnamentsBuilder;
  invertedTurn: (build: InvertedTurn | ((builder: IInvertedTurnBuilder) => IInvertedTurnBuilder)) => IOrnamentsBuilder;
  otherOrnament: (build: OtherOrnament | ((builder: IOtherOrnamentBuilder) => IOtherOrnamentBuilder)) => IOrnamentsBuilder;
  delayedTurn: (build: DelayedTurn | ((builder: IDelayedTurnBuilder) => IDelayedTurnBuilder)) => IOrnamentsBuilder;
  verticalTurn: (build: VerticalTurn | ((builder: IVerticalTurnBuilder) => IVerticalTurnBuilder)) => IOrnamentsBuilder;
  wavyLine: (build: WavyLine | ((builder: IWavyLineBuilder) => IWavyLineBuilder)) => IOrnamentsBuilder;
  tremolo: (build: Tremolo | ((builder: ITremoloBuilder) => ITremoloBuilder)) => IOrnamentsBuilder;
  accidentalMarksAt: (idx: number, build: AccidentalMark | ((builder: IAccidentalMarkBuilder) => IAccidentalMarkBuilder)) => IOrnamentsBuilder;
  accidentalMarksSplice: (start: number, deleteCount: number, ...items: AccidentalMark[]) => IOrnamentsBuilder;
  accidentalMarks: (accidentalMarks: AccidentalMark[]) => IOrnamentsBuilder;
  trillMark: (build: TrillMark | ((builder: ITrillMarkBuilder) => ITrillMarkBuilder)) => IOrnamentsBuilder;
  mordent: (build: Mordent | ((builder: IMordentBuilder) => IMordentBuilder)) => IOrnamentsBuilder;
  invertedMordent: (build: InvertedMordent | ((builder: IInvertedMordentBuilder) => IInvertedMordentBuilder)) => IOrnamentsBuilder;
  schleifer: (build: Schleifer | ((builder: ISchleiferBuilder) => ISchleiferBuilder)) => IOrnamentsBuilder;
  defaultX: (defaultX: number) => IOrnamentsBuilder;
  relativeY: (relativeY: number) => IOrnamentsBuilder;
  defaultY: (defaultY: number) => IOrnamentsBuilder;
  relativeX: (relativeX: number) => IOrnamentsBuilder;
  fontFamily: (fontFamily: string) => IOrnamentsBuilder;
  fontWeight: (fontWeight: NormalBold) => IOrnamentsBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOrnamentsBuilder;
  fontSize: (fontSize: string) => IOrnamentsBuilder;
  color: (color: string) => IOrnamentsBuilder;
  placement: (placement: AboveBelow) => IOrnamentsBuilder;
  startNote: (startNote: UpperMainBelow) => IOrnamentsBuilder;
  accelerate: (accelerate: boolean) => IOrnamentsBuilder;
  beats: (beats: number) => IOrnamentsBuilder;
  lastBeat: (lastBeat: number) => IOrnamentsBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IOrnamentsBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IOrnamentsBuilder;
  secondBeat: (secondBeat: number) => IOrnamentsBuilder;
}

class OrnamentsBuilder implements IOrnamentsBuilder {
  build: () => Ornaments;
  patch: () => IAny[];
  delayedInvertedTurn: (build: DelayedInvertedTurn | ((builder: IDelayedInvertedTurnBuilder) => IDelayedInvertedTurnBuilder)) => IOrnamentsBuilder;
  shake: (build: Shake | ((builder: IShakeBuilder) => IShakeBuilder)) => IOrnamentsBuilder;
  turn: (build: Turn | ((builder: ITurnBuilder) => ITurnBuilder)) => IOrnamentsBuilder;
  invertedTurn: (build: InvertedTurn | ((builder: IInvertedTurnBuilder) => IInvertedTurnBuilder)) => IOrnamentsBuilder;
  otherOrnament: (build: OtherOrnament | ((builder: IOtherOrnamentBuilder) => IOtherOrnamentBuilder)) => IOrnamentsBuilder;
  delayedTurn: (build: DelayedTurn | ((builder: IDelayedTurnBuilder) => IDelayedTurnBuilder)) => IOrnamentsBuilder;
  verticalTurn: (build: VerticalTurn | ((builder: IVerticalTurnBuilder) => IVerticalTurnBuilder)) => IOrnamentsBuilder;
  wavyLine: (build: WavyLine | ((builder: IWavyLineBuilder) => IWavyLineBuilder)) => IOrnamentsBuilder;
  tremolo: (build: Tremolo | ((builder: ITremoloBuilder) => ITremoloBuilder)) => IOrnamentsBuilder;
  accidentalMarksAt: (idx: number, build: AccidentalMark | ((builder: IAccidentalMarkBuilder) => IAccidentalMarkBuilder)) => IOrnamentsBuilder;
  accidentalMarksSplice: (start: number, deleteCount: number, ...items: AccidentalMark[]) => IOrnamentsBuilder;
  accidentalMarks: (accidentalMarks: AccidentalMark[]) => IOrnamentsBuilder;
  trillMark: (build: TrillMark | ((builder: ITrillMarkBuilder) => ITrillMarkBuilder)) => IOrnamentsBuilder;
  mordent: (build: Mordent | ((builder: IMordentBuilder) => IMordentBuilder)) => IOrnamentsBuilder;
  invertedMordent: (build: InvertedMordent | ((builder: IInvertedMordentBuilder) => IInvertedMordentBuilder)) => IOrnamentsBuilder;
  schleifer: (build: Schleifer | ((builder: ISchleiferBuilder) => ISchleiferBuilder)) => IOrnamentsBuilder;
  defaultX: (defaultX: number) => IOrnamentsBuilder;
  relativeY: (relativeY: number) => IOrnamentsBuilder;
  defaultY: (defaultY: number) => IOrnamentsBuilder;
  relativeX: (relativeX: number) => IOrnamentsBuilder;
  fontFamily: (fontFamily: string) => IOrnamentsBuilder;
  fontWeight: (fontWeight: NormalBold) => IOrnamentsBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOrnamentsBuilder;
  fontSize: (fontSize: string) => IOrnamentsBuilder;
  color: (color: string) => IOrnamentsBuilder;
  placement: (placement: AboveBelow) => IOrnamentsBuilder;
  startNote: (startNote: UpperMainBelow) => IOrnamentsBuilder;
  accelerate: (accelerate: boolean) => IOrnamentsBuilder;
  beats: (beats: number) => IOrnamentsBuilder;
  lastBeat: (lastBeat: number) => IOrnamentsBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IOrnamentsBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IOrnamentsBuilder;
  secondBeat: (secondBeat: number) => IOrnamentsBuilder;
  constructor(original?: Ornaments) {
    let updates: Ornaments = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Ornaments => {
        checkInvariants();
        (updates as any)._class = "Ornaments";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.delayedInvertedTurn = (build: DelayedInvertedTurn | ((builder: IDelayedInvertedTurnBuilder) => IDelayedInvertedTurnBuilder)): IOrnamentsBuilder => {
      if (typeof build === 'function') {
        delete updates["delayedInvertedTurn"]
        const builder = (build as any)(new DelayedInvertedTurnBuilder(original && original["delayedInvertedTurn"]));
        if (!original) updates["delayedInvertedTurn"] = builder.build();
        else childBuilders["delayedInvertedTurn"] = builder;
      } else {
        updates.delayedInvertedTurn = build as any;
        delete childBuilders["delayedInvertedTurn;"];
      }
      modifiedKeys["delayedInvertedTurn"] = true;
      return this;
    }

    this.shake = (build: Shake | ((builder: IShakeBuilder) => IShakeBuilder)): IOrnamentsBuilder => {
      if (typeof build === 'function') {
        delete updates["shake"]
        const builder = (build as any)(new ShakeBuilder(original && original["shake"]));
        if (!original) updates["shake"] = builder.build();
        else childBuilders["shake"] = builder;
      } else {
        updates.shake = build as any;
        delete childBuilders["shake;"];
      }
      modifiedKeys["shake"] = true;
      return this;
    }

    this.turn = (build: Turn | ((builder: ITurnBuilder) => ITurnBuilder)): IOrnamentsBuilder => {
      if (typeof build === 'function') {
        delete updates["turn"]
        const builder = (build as any)(new TurnBuilder(original && original["turn"]));
        if (!original) updates["turn"] = builder.build();
        else childBuilders["turn"] = builder;
      } else {
        updates.turn = build as any;
        delete childBuilders["turn;"];
      }
      modifiedKeys["turn"] = true;
      return this;
    }

    this.invertedTurn = (build: InvertedTurn | ((builder: IInvertedTurnBuilder) => IInvertedTurnBuilder)): IOrnamentsBuilder => {
      if (typeof build === 'function') {
        delete updates["invertedTurn"]
        const builder = (build as any)(new InvertedTurnBuilder(original && original["invertedTurn"]));
        if (!original) updates["invertedTurn"] = builder.build();
        else childBuilders["invertedTurn"] = builder;
      } else {
        updates.invertedTurn = build as any;
        delete childBuilders["invertedTurn;"];
      }
      modifiedKeys["invertedTurn"] = true;
      return this;
    }

    this.otherOrnament = (build: OtherOrnament | ((builder: IOtherOrnamentBuilder) => IOtherOrnamentBuilder)): IOrnamentsBuilder => {
      if (typeof build === 'function') {
        delete updates["otherOrnament"]
        const builder = (build as any)(new OtherOrnamentBuilder(original && original["otherOrnament"]));
        if (!original) updates["otherOrnament"] = builder.build();
        else childBuilders["otherOrnament"] = builder;
      } else {
        updates.otherOrnament = build as any;
        delete childBuilders["otherOrnament;"];
      }
      modifiedKeys["otherOrnament"] = true;
      return this;
    }

    this.delayedTurn = (build: DelayedTurn | ((builder: IDelayedTurnBuilder) => IDelayedTurnBuilder)): IOrnamentsBuilder => {
      if (typeof build === 'function') {
        delete updates["delayedTurn"]
        const builder = (build as any)(new DelayedTurnBuilder(original && original["delayedTurn"]));
        if (!original) updates["delayedTurn"] = builder.build();
        else childBuilders["delayedTurn"] = builder;
      } else {
        updates.delayedTurn = build as any;
        delete childBuilders["delayedTurn;"];
      }
      modifiedKeys["delayedTurn"] = true;
      return this;
    }

    this.verticalTurn = (build: VerticalTurn | ((builder: IVerticalTurnBuilder) => IVerticalTurnBuilder)): IOrnamentsBuilder => {
      if (typeof build === 'function') {
        delete updates["verticalTurn"]
        const builder = (build as any)(new VerticalTurnBuilder(original && original["verticalTurn"]));
        if (!original) updates["verticalTurn"] = builder.build();
        else childBuilders["verticalTurn"] = builder;
      } else {
        updates.verticalTurn = build as any;
        delete childBuilders["verticalTurn;"];
      }
      modifiedKeys["verticalTurn"] = true;
      return this;
    }

    this.wavyLine = (build: WavyLine | ((builder: IWavyLineBuilder) => IWavyLineBuilder)): IOrnamentsBuilder => {
      if (typeof build === 'function') {
        delete updates["wavyLine"]
        const builder = (build as any)(new WavyLineBuilder(original && original["wavyLine"]));
        if (!original) updates["wavyLine"] = builder.build();
        else childBuilders["wavyLine"] = builder;
      } else {
        updates.wavyLine = build as any;
        delete childBuilders["wavyLine;"];
      }
      modifiedKeys["wavyLine"] = true;
      return this;
    }

    this.tremolo = (build: Tremolo | ((builder: ITremoloBuilder) => ITremoloBuilder)): IOrnamentsBuilder => {
      if (typeof build === 'function') {
        delete updates["tremolo"]
        const builder = (build as any)(new TremoloBuilder(original && original["tremolo"]));
        if (!original) updates["tremolo"] = builder.build();
        else childBuilders["tremolo"] = builder;
      } else {
        updates.tremolo = build as any;
        delete childBuilders["tremolo;"];
      }
      modifiedKeys["tremolo"] = true;
      return this;
    }

    this.accidentalMarks = (spec: AccidentalMark[]): IOrnamentsBuilder => {
        updates["accidentalMarks"] = spec;
        delete childBuilders["accidentalMarks;"];
        modifiedKeys["accidentalMarks"] = true;
        return this;
    }

    this.accidentalMarksAt = (idx: number, build: AccidentalMark | ((builder: IAccidentalMarkBuilder) => IAccidentalMarkBuilder)): IOrnamentsBuilder => {
      makeReference("accidentalMarks");
      if (frozen["accidentalMarks"][idx]) {
          throw new Error("Patching accidentalMarks." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["accidentalMarks"] && !original["accidentalMarks"]) {
          // Clone snapshot.
          patches.push({p: ["accidentalMarks", idx], li: original._snapshot["accidentalMarks"]});
      }
      if (typeof build === 'function' && reference["accidentalMarks"][idx]) {
        let patch = (build as any)(new AccidentalMarkBuilder(reference["accidentalMarks"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["accidentalMarks", idx].concat(patch.p);
          return patch;
        }));
        frozen["accidentalMarks"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new AccidentalMarkBuilder(reference["accidentalMarks"][idx])).build() : build;
      if (original) {
        patches.push({p: ["accidentalMarks", idx], li: update});
      } else {
        updates["accidentalMarks"] = reference["accidentalMarks"]; // TODO: Merge?
      } 
      reference["accidentalMarks"][idx] = update;
      frozen["accidentalMarks"][idx] = true;
      return this;
    }

    this.accidentalMarksSplice = (start: number, deleteCount: number, ...items: AccidentalMark[]): IOrnamentsBuilder => {
      makeReference("accidentalMarks");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["accidentalMarks"][idx]) {
            throw new Error("Replacing accidentalMarks." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["accidentalMarks"][idx];
          patches.push({p: ["accidentalMarks", idx], ld, li: items[idx - start]});
          frozen["accidentalMarks"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["accidentalMarks"][idx]) {
            throw new Error("Removing accidentalMarks." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["accidentalMarks"][idx];
          patches.push({p: ["accidentalMarks", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["accidentalMarks", idx], li: items[idx - start]});
          frozen["accidentalMarks"][idx] = true;
        }
      }
      reference["accidentalMarks"].splice(start, deleteCount, ...items);
      updates["accidentalMarks"] = reference["accidentalMarks"];
      frozen["accidentalMarks"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.trillMark = (build: TrillMark | ((builder: ITrillMarkBuilder) => ITrillMarkBuilder)): IOrnamentsBuilder => {
      if (typeof build === 'function') {
        delete updates["trillMark"]
        const builder = (build as any)(new TrillMarkBuilder(original && original["trillMark"]));
        if (!original) updates["trillMark"] = builder.build();
        else childBuilders["trillMark"] = builder;
      } else {
        updates.trillMark = build as any;
        delete childBuilders["trillMark;"];
      }
      modifiedKeys["trillMark"] = true;
      return this;
    }

    this.mordent = (build: Mordent | ((builder: IMordentBuilder) => IMordentBuilder)): IOrnamentsBuilder => {
      if (typeof build === 'function') {
        delete updates["mordent"]
        const builder = (build as any)(new MordentBuilder(original && original["mordent"]));
        if (!original) updates["mordent"] = builder.build();
        else childBuilders["mordent"] = builder;
      } else {
        updates.mordent = build as any;
        delete childBuilders["mordent;"];
      }
      modifiedKeys["mordent"] = true;
      return this;
    }

    this.invertedMordent = (build: InvertedMordent | ((builder: IInvertedMordentBuilder) => IInvertedMordentBuilder)): IOrnamentsBuilder => {
      if (typeof build === 'function') {
        delete updates["invertedMordent"]
        const builder = (build as any)(new InvertedMordentBuilder(original && original["invertedMordent"]));
        if (!original) updates["invertedMordent"] = builder.build();
        else childBuilders["invertedMordent"] = builder;
      } else {
        updates.invertedMordent = build as any;
        delete childBuilders["invertedMordent;"];
      }
      modifiedKeys["invertedMordent"] = true;
      return this;
    }

    this.schleifer = (build: Schleifer | ((builder: ISchleiferBuilder) => ISchleiferBuilder)): IOrnamentsBuilder => {
      if (typeof build === 'function') {
        delete updates["schleifer"]
        const builder = (build as any)(new SchleiferBuilder(original && original["schleifer"]));
        if (!original) updates["schleifer"] = builder.build();
        else childBuilders["schleifer"] = builder;
      } else {
        updates.schleifer = build as any;
        delete childBuilders["schleifer;"];
      }
      modifiedKeys["schleifer"] = true;
      return this;
    }

    this.defaultX = (spec: number): IOrnamentsBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IOrnamentsBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IOrnamentsBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IOrnamentsBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IOrnamentsBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IOrnamentsBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IOrnamentsBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IOrnamentsBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IOrnamentsBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IOrnamentsBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.startNote = (spec: UpperMainBelow): IOrnamentsBuilder => {
        updates["startNote"] = spec;
        delete childBuilders["startNote;"];
        modifiedKeys["startNote"] = true;
        return this;
    }

    this.accelerate = (spec: boolean): IOrnamentsBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): IOrnamentsBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.lastBeat = (spec: number): IOrnamentsBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }

    this.trillStep = (spec: WholeHalfUnison): IOrnamentsBuilder => {
        updates["trillStep"] = spec;
        delete childBuilders["trillStep;"];
        modifiedKeys["trillStep"] = true;
        return this;
    }

    this.twoNoteTurn = (spec: WholeHalfNone): IOrnamentsBuilder => {
        updates["twoNoteTurn"] = spec;
        delete childBuilders["twoNoteTurn;"];
        modifiedKeys["twoNoteTurn"] = true;
        return this;
    }

    this.secondBeat = (spec: number): IOrnamentsBuilder => {
        updates["secondBeat"] = spec;
        delete childBuilders["secondBeat;"];
        modifiedKeys["secondBeat"] = true;
        return this;
    }
  }
}
export function patchOrnaments(base: Ornaments, builder: (build: IOrnamentsBuilder) => IOrnamentsBuilder): IAny[] { return builder(new OrnamentsBuilder(base)).patch(); }
export function buildOrnaments(builder: (build: IOrnamentsBuilder) => IOrnamentsBuilder): Ornaments { return builder(new OrnamentsBuilder()).build(); }

export interface ITrillMarkBuilder {
  build?: () => TrillMark;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ITrillMarkBuilder;
  relativeY: (relativeY: number) => ITrillMarkBuilder;
  defaultY: (defaultY: number) => ITrillMarkBuilder;
  relativeX: (relativeX: number) => ITrillMarkBuilder;
  fontFamily: (fontFamily: string) => ITrillMarkBuilder;
  fontWeight: (fontWeight: NormalBold) => ITrillMarkBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITrillMarkBuilder;
  fontSize: (fontSize: string) => ITrillMarkBuilder;
  color: (color: string) => ITrillMarkBuilder;
  placement: (placement: AboveBelow) => ITrillMarkBuilder;
  startNote: (startNote: UpperMainBelow) => ITrillMarkBuilder;
  accelerate: (accelerate: boolean) => ITrillMarkBuilder;
  beats: (beats: number) => ITrillMarkBuilder;
  lastBeat: (lastBeat: number) => ITrillMarkBuilder;
  trillStep: (trillStep: WholeHalfUnison) => ITrillMarkBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => ITrillMarkBuilder;
  secondBeat: (secondBeat: number) => ITrillMarkBuilder;
}

class TrillMarkBuilder implements ITrillMarkBuilder {
  build: () => TrillMark;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ITrillMarkBuilder;
  relativeY: (relativeY: number) => ITrillMarkBuilder;
  defaultY: (defaultY: number) => ITrillMarkBuilder;
  relativeX: (relativeX: number) => ITrillMarkBuilder;
  fontFamily: (fontFamily: string) => ITrillMarkBuilder;
  fontWeight: (fontWeight: NormalBold) => ITrillMarkBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITrillMarkBuilder;
  fontSize: (fontSize: string) => ITrillMarkBuilder;
  color: (color: string) => ITrillMarkBuilder;
  placement: (placement: AboveBelow) => ITrillMarkBuilder;
  startNote: (startNote: UpperMainBelow) => ITrillMarkBuilder;
  accelerate: (accelerate: boolean) => ITrillMarkBuilder;
  beats: (beats: number) => ITrillMarkBuilder;
  lastBeat: (lastBeat: number) => ITrillMarkBuilder;
  trillStep: (trillStep: WholeHalfUnison) => ITrillMarkBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => ITrillMarkBuilder;
  secondBeat: (secondBeat: number) => ITrillMarkBuilder;
  constructor(original?: TrillMark) {
    let updates: TrillMark = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): TrillMark => {
        checkInvariants();
        (updates as any)._class = "TrillMark";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): ITrillMarkBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ITrillMarkBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ITrillMarkBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ITrillMarkBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ITrillMarkBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ITrillMarkBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ITrillMarkBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ITrillMarkBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ITrillMarkBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): ITrillMarkBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.startNote = (spec: UpperMainBelow): ITrillMarkBuilder => {
        updates["startNote"] = spec;
        delete childBuilders["startNote;"];
        modifiedKeys["startNote"] = true;
        return this;
    }

    this.accelerate = (spec: boolean): ITrillMarkBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): ITrillMarkBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.lastBeat = (spec: number): ITrillMarkBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }

    this.trillStep = (spec: WholeHalfUnison): ITrillMarkBuilder => {
        updates["trillStep"] = spec;
        delete childBuilders["trillStep;"];
        modifiedKeys["trillStep"] = true;
        return this;
    }

    this.twoNoteTurn = (spec: WholeHalfNone): ITrillMarkBuilder => {
        updates["twoNoteTurn"] = spec;
        delete childBuilders["twoNoteTurn;"];
        modifiedKeys["twoNoteTurn"] = true;
        return this;
    }

    this.secondBeat = (spec: number): ITrillMarkBuilder => {
        updates["secondBeat"] = spec;
        delete childBuilders["secondBeat;"];
        modifiedKeys["secondBeat"] = true;
        return this;
    }
  }
}
export function patchTrillMark(base: TrillMark, builder: (build: ITrillMarkBuilder) => ITrillMarkBuilder): IAny[] { return builder(new TrillMarkBuilder(base)).patch(); }
export function buildTrillMark(builder: (build: ITrillMarkBuilder) => ITrillMarkBuilder): TrillMark { return builder(new TrillMarkBuilder()).build(); }

export interface ITurnBuilder {
  build?: () => Turn;
  patch: () => IAny[];
  slash: (slash: boolean) => ITurnBuilder;
  defaultX: (defaultX: number) => ITurnBuilder;
  relativeY: (relativeY: number) => ITurnBuilder;
  defaultY: (defaultY: number) => ITurnBuilder;
  relativeX: (relativeX: number) => ITurnBuilder;
  fontFamily: (fontFamily: string) => ITurnBuilder;
  fontWeight: (fontWeight: NormalBold) => ITurnBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITurnBuilder;
  fontSize: (fontSize: string) => ITurnBuilder;
  color: (color: string) => ITurnBuilder;
  placement: (placement: AboveBelow) => ITurnBuilder;
  startNote: (startNote: UpperMainBelow) => ITurnBuilder;
  accelerate: (accelerate: boolean) => ITurnBuilder;
  beats: (beats: number) => ITurnBuilder;
  lastBeat: (lastBeat: number) => ITurnBuilder;
  trillStep: (trillStep: WholeHalfUnison) => ITurnBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => ITurnBuilder;
  secondBeat: (secondBeat: number) => ITurnBuilder;
}

class TurnBuilder implements ITurnBuilder {
  build: () => Turn;
  patch: () => IAny[];
  slash: (slash: boolean) => ITurnBuilder;
  defaultX: (defaultX: number) => ITurnBuilder;
  relativeY: (relativeY: number) => ITurnBuilder;
  defaultY: (defaultY: number) => ITurnBuilder;
  relativeX: (relativeX: number) => ITurnBuilder;
  fontFamily: (fontFamily: string) => ITurnBuilder;
  fontWeight: (fontWeight: NormalBold) => ITurnBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITurnBuilder;
  fontSize: (fontSize: string) => ITurnBuilder;
  color: (color: string) => ITurnBuilder;
  placement: (placement: AboveBelow) => ITurnBuilder;
  startNote: (startNote: UpperMainBelow) => ITurnBuilder;
  accelerate: (accelerate: boolean) => ITurnBuilder;
  beats: (beats: number) => ITurnBuilder;
  lastBeat: (lastBeat: number) => ITurnBuilder;
  trillStep: (trillStep: WholeHalfUnison) => ITurnBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => ITurnBuilder;
  secondBeat: (secondBeat: number) => ITurnBuilder;
  constructor(original?: Turn) {
    let updates: Turn = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Turn => {
        checkInvariants();
        (updates as any)._class = "Turn";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.slash = (spec: boolean): ITurnBuilder => {
        updates["slash"] = spec;
        delete childBuilders["slash;"];
        modifiedKeys["slash"] = true;
        return this;
    }

    this.defaultX = (spec: number): ITurnBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ITurnBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ITurnBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ITurnBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ITurnBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ITurnBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ITurnBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ITurnBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ITurnBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): ITurnBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.startNote = (spec: UpperMainBelow): ITurnBuilder => {
        updates["startNote"] = spec;
        delete childBuilders["startNote;"];
        modifiedKeys["startNote"] = true;
        return this;
    }

    this.accelerate = (spec: boolean): ITurnBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): ITurnBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.lastBeat = (spec: number): ITurnBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }

    this.trillStep = (spec: WholeHalfUnison): ITurnBuilder => {
        updates["trillStep"] = spec;
        delete childBuilders["trillStep;"];
        modifiedKeys["trillStep"] = true;
        return this;
    }

    this.twoNoteTurn = (spec: WholeHalfNone): ITurnBuilder => {
        updates["twoNoteTurn"] = spec;
        delete childBuilders["twoNoteTurn;"];
        modifiedKeys["twoNoteTurn"] = true;
        return this;
    }

    this.secondBeat = (spec: number): ITurnBuilder => {
        updates["secondBeat"] = spec;
        delete childBuilders["secondBeat;"];
        modifiedKeys["secondBeat"] = true;
        return this;
    }
  }
}
export function patchTurn(base: Turn, builder: (build: ITurnBuilder) => ITurnBuilder): IAny[] { return builder(new TurnBuilder(base)).patch(); }
export function buildTurn(builder: (build: ITurnBuilder) => ITurnBuilder): Turn { return builder(new TurnBuilder()).build(); }

export interface IDelayedTurnBuilder {
  build?: () => DelayedTurn;
  patch: () => IAny[];
  slash: (slash: boolean) => IDelayedTurnBuilder;
  defaultX: (defaultX: number) => IDelayedTurnBuilder;
  relativeY: (relativeY: number) => IDelayedTurnBuilder;
  defaultY: (defaultY: number) => IDelayedTurnBuilder;
  relativeX: (relativeX: number) => IDelayedTurnBuilder;
  fontFamily: (fontFamily: string) => IDelayedTurnBuilder;
  fontWeight: (fontWeight: NormalBold) => IDelayedTurnBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDelayedTurnBuilder;
  fontSize: (fontSize: string) => IDelayedTurnBuilder;
  color: (color: string) => IDelayedTurnBuilder;
  placement: (placement: AboveBelow) => IDelayedTurnBuilder;
  startNote: (startNote: UpperMainBelow) => IDelayedTurnBuilder;
  accelerate: (accelerate: boolean) => IDelayedTurnBuilder;
  beats: (beats: number) => IDelayedTurnBuilder;
  lastBeat: (lastBeat: number) => IDelayedTurnBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IDelayedTurnBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IDelayedTurnBuilder;
  secondBeat: (secondBeat: number) => IDelayedTurnBuilder;
}

class DelayedTurnBuilder implements IDelayedTurnBuilder {
  build: () => DelayedTurn;
  patch: () => IAny[];
  slash: (slash: boolean) => IDelayedTurnBuilder;
  defaultX: (defaultX: number) => IDelayedTurnBuilder;
  relativeY: (relativeY: number) => IDelayedTurnBuilder;
  defaultY: (defaultY: number) => IDelayedTurnBuilder;
  relativeX: (relativeX: number) => IDelayedTurnBuilder;
  fontFamily: (fontFamily: string) => IDelayedTurnBuilder;
  fontWeight: (fontWeight: NormalBold) => IDelayedTurnBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDelayedTurnBuilder;
  fontSize: (fontSize: string) => IDelayedTurnBuilder;
  color: (color: string) => IDelayedTurnBuilder;
  placement: (placement: AboveBelow) => IDelayedTurnBuilder;
  startNote: (startNote: UpperMainBelow) => IDelayedTurnBuilder;
  accelerate: (accelerate: boolean) => IDelayedTurnBuilder;
  beats: (beats: number) => IDelayedTurnBuilder;
  lastBeat: (lastBeat: number) => IDelayedTurnBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IDelayedTurnBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IDelayedTurnBuilder;
  secondBeat: (secondBeat: number) => IDelayedTurnBuilder;
  constructor(original?: DelayedTurn) {
    let updates: DelayedTurn = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): DelayedTurn => {
        checkInvariants();
        (updates as any)._class = "DelayedTurn";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.slash = (spec: boolean): IDelayedTurnBuilder => {
        updates["slash"] = spec;
        delete childBuilders["slash;"];
        modifiedKeys["slash"] = true;
        return this;
    }

    this.defaultX = (spec: number): IDelayedTurnBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDelayedTurnBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDelayedTurnBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDelayedTurnBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDelayedTurnBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDelayedTurnBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDelayedTurnBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDelayedTurnBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDelayedTurnBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IDelayedTurnBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.startNote = (spec: UpperMainBelow): IDelayedTurnBuilder => {
        updates["startNote"] = spec;
        delete childBuilders["startNote;"];
        modifiedKeys["startNote"] = true;
        return this;
    }

    this.accelerate = (spec: boolean): IDelayedTurnBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): IDelayedTurnBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.lastBeat = (spec: number): IDelayedTurnBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }

    this.trillStep = (spec: WholeHalfUnison): IDelayedTurnBuilder => {
        updates["trillStep"] = spec;
        delete childBuilders["trillStep;"];
        modifiedKeys["trillStep"] = true;
        return this;
    }

    this.twoNoteTurn = (spec: WholeHalfNone): IDelayedTurnBuilder => {
        updates["twoNoteTurn"] = spec;
        delete childBuilders["twoNoteTurn;"];
        modifiedKeys["twoNoteTurn"] = true;
        return this;
    }

    this.secondBeat = (spec: number): IDelayedTurnBuilder => {
        updates["secondBeat"] = spec;
        delete childBuilders["secondBeat;"];
        modifiedKeys["secondBeat"] = true;
        return this;
    }
  }
}
export function patchDelayedTurn(base: DelayedTurn, builder: (build: IDelayedTurnBuilder) => IDelayedTurnBuilder): IAny[] { return builder(new DelayedTurnBuilder(base)).patch(); }
export function buildDelayedTurn(builder: (build: IDelayedTurnBuilder) => IDelayedTurnBuilder): DelayedTurn { return builder(new DelayedTurnBuilder()).build(); }

export interface IInvertedTurnBuilder {
  build?: () => InvertedTurn;
  patch: () => IAny[];
  slash: (slash: boolean) => IInvertedTurnBuilder;
  defaultX: (defaultX: number) => IInvertedTurnBuilder;
  relativeY: (relativeY: number) => IInvertedTurnBuilder;
  defaultY: (defaultY: number) => IInvertedTurnBuilder;
  relativeX: (relativeX: number) => IInvertedTurnBuilder;
  fontFamily: (fontFamily: string) => IInvertedTurnBuilder;
  fontWeight: (fontWeight: NormalBold) => IInvertedTurnBuilder;
  fontStyle: (fontStyle: NormalItalic) => IInvertedTurnBuilder;
  fontSize: (fontSize: string) => IInvertedTurnBuilder;
  color: (color: string) => IInvertedTurnBuilder;
  placement: (placement: AboveBelow) => IInvertedTurnBuilder;
  startNote: (startNote: UpperMainBelow) => IInvertedTurnBuilder;
  accelerate: (accelerate: boolean) => IInvertedTurnBuilder;
  beats: (beats: number) => IInvertedTurnBuilder;
  lastBeat: (lastBeat: number) => IInvertedTurnBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IInvertedTurnBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IInvertedTurnBuilder;
  secondBeat: (secondBeat: number) => IInvertedTurnBuilder;
}

class InvertedTurnBuilder implements IInvertedTurnBuilder {
  build: () => InvertedTurn;
  patch: () => IAny[];
  slash: (slash: boolean) => IInvertedTurnBuilder;
  defaultX: (defaultX: number) => IInvertedTurnBuilder;
  relativeY: (relativeY: number) => IInvertedTurnBuilder;
  defaultY: (defaultY: number) => IInvertedTurnBuilder;
  relativeX: (relativeX: number) => IInvertedTurnBuilder;
  fontFamily: (fontFamily: string) => IInvertedTurnBuilder;
  fontWeight: (fontWeight: NormalBold) => IInvertedTurnBuilder;
  fontStyle: (fontStyle: NormalItalic) => IInvertedTurnBuilder;
  fontSize: (fontSize: string) => IInvertedTurnBuilder;
  color: (color: string) => IInvertedTurnBuilder;
  placement: (placement: AboveBelow) => IInvertedTurnBuilder;
  startNote: (startNote: UpperMainBelow) => IInvertedTurnBuilder;
  accelerate: (accelerate: boolean) => IInvertedTurnBuilder;
  beats: (beats: number) => IInvertedTurnBuilder;
  lastBeat: (lastBeat: number) => IInvertedTurnBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IInvertedTurnBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IInvertedTurnBuilder;
  secondBeat: (secondBeat: number) => IInvertedTurnBuilder;
  constructor(original?: InvertedTurn) {
    let updates: InvertedTurn = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): InvertedTurn => {
        checkInvariants();
        (updates as any)._class = "InvertedTurn";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.slash = (spec: boolean): IInvertedTurnBuilder => {
        updates["slash"] = spec;
        delete childBuilders["slash;"];
        modifiedKeys["slash"] = true;
        return this;
    }

    this.defaultX = (spec: number): IInvertedTurnBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IInvertedTurnBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IInvertedTurnBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IInvertedTurnBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IInvertedTurnBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IInvertedTurnBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IInvertedTurnBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IInvertedTurnBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IInvertedTurnBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IInvertedTurnBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.startNote = (spec: UpperMainBelow): IInvertedTurnBuilder => {
        updates["startNote"] = spec;
        delete childBuilders["startNote;"];
        modifiedKeys["startNote"] = true;
        return this;
    }

    this.accelerate = (spec: boolean): IInvertedTurnBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): IInvertedTurnBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.lastBeat = (spec: number): IInvertedTurnBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }

    this.trillStep = (spec: WholeHalfUnison): IInvertedTurnBuilder => {
        updates["trillStep"] = spec;
        delete childBuilders["trillStep;"];
        modifiedKeys["trillStep"] = true;
        return this;
    }

    this.twoNoteTurn = (spec: WholeHalfNone): IInvertedTurnBuilder => {
        updates["twoNoteTurn"] = spec;
        delete childBuilders["twoNoteTurn;"];
        modifiedKeys["twoNoteTurn"] = true;
        return this;
    }

    this.secondBeat = (spec: number): IInvertedTurnBuilder => {
        updates["secondBeat"] = spec;
        delete childBuilders["secondBeat;"];
        modifiedKeys["secondBeat"] = true;
        return this;
    }
  }
}
export function patchInvertedTurn(base: InvertedTurn, builder: (build: IInvertedTurnBuilder) => IInvertedTurnBuilder): IAny[] { return builder(new InvertedTurnBuilder(base)).patch(); }
export function buildInvertedTurn(builder: (build: IInvertedTurnBuilder) => IInvertedTurnBuilder): InvertedTurn { return builder(new InvertedTurnBuilder()).build(); }

export interface IDelayedInvertedTurnBuilder {
  build?: () => DelayedInvertedTurn;
  patch: () => IAny[];
  slash: (slash: boolean) => IDelayedInvertedTurnBuilder;
  defaultX: (defaultX: number) => IDelayedInvertedTurnBuilder;
  relativeY: (relativeY: number) => IDelayedInvertedTurnBuilder;
  defaultY: (defaultY: number) => IDelayedInvertedTurnBuilder;
  relativeX: (relativeX: number) => IDelayedInvertedTurnBuilder;
  fontFamily: (fontFamily: string) => IDelayedInvertedTurnBuilder;
  fontWeight: (fontWeight: NormalBold) => IDelayedInvertedTurnBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDelayedInvertedTurnBuilder;
  fontSize: (fontSize: string) => IDelayedInvertedTurnBuilder;
  color: (color: string) => IDelayedInvertedTurnBuilder;
  placement: (placement: AboveBelow) => IDelayedInvertedTurnBuilder;
  startNote: (startNote: UpperMainBelow) => IDelayedInvertedTurnBuilder;
  accelerate: (accelerate: boolean) => IDelayedInvertedTurnBuilder;
  beats: (beats: number) => IDelayedInvertedTurnBuilder;
  lastBeat: (lastBeat: number) => IDelayedInvertedTurnBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IDelayedInvertedTurnBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IDelayedInvertedTurnBuilder;
  secondBeat: (secondBeat: number) => IDelayedInvertedTurnBuilder;
}

class DelayedInvertedTurnBuilder implements IDelayedInvertedTurnBuilder {
  build: () => DelayedInvertedTurn;
  patch: () => IAny[];
  slash: (slash: boolean) => IDelayedInvertedTurnBuilder;
  defaultX: (defaultX: number) => IDelayedInvertedTurnBuilder;
  relativeY: (relativeY: number) => IDelayedInvertedTurnBuilder;
  defaultY: (defaultY: number) => IDelayedInvertedTurnBuilder;
  relativeX: (relativeX: number) => IDelayedInvertedTurnBuilder;
  fontFamily: (fontFamily: string) => IDelayedInvertedTurnBuilder;
  fontWeight: (fontWeight: NormalBold) => IDelayedInvertedTurnBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDelayedInvertedTurnBuilder;
  fontSize: (fontSize: string) => IDelayedInvertedTurnBuilder;
  color: (color: string) => IDelayedInvertedTurnBuilder;
  placement: (placement: AboveBelow) => IDelayedInvertedTurnBuilder;
  startNote: (startNote: UpperMainBelow) => IDelayedInvertedTurnBuilder;
  accelerate: (accelerate: boolean) => IDelayedInvertedTurnBuilder;
  beats: (beats: number) => IDelayedInvertedTurnBuilder;
  lastBeat: (lastBeat: number) => IDelayedInvertedTurnBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IDelayedInvertedTurnBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IDelayedInvertedTurnBuilder;
  secondBeat: (secondBeat: number) => IDelayedInvertedTurnBuilder;
  constructor(original?: DelayedInvertedTurn) {
    let updates: DelayedInvertedTurn = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): DelayedInvertedTurn => {
        checkInvariants();
        (updates as any)._class = "DelayedInvertedTurn";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.slash = (spec: boolean): IDelayedInvertedTurnBuilder => {
        updates["slash"] = spec;
        delete childBuilders["slash;"];
        modifiedKeys["slash"] = true;
        return this;
    }

    this.defaultX = (spec: number): IDelayedInvertedTurnBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDelayedInvertedTurnBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDelayedInvertedTurnBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDelayedInvertedTurnBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDelayedInvertedTurnBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDelayedInvertedTurnBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDelayedInvertedTurnBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDelayedInvertedTurnBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDelayedInvertedTurnBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IDelayedInvertedTurnBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.startNote = (spec: UpperMainBelow): IDelayedInvertedTurnBuilder => {
        updates["startNote"] = spec;
        delete childBuilders["startNote;"];
        modifiedKeys["startNote"] = true;
        return this;
    }

    this.accelerate = (spec: boolean): IDelayedInvertedTurnBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): IDelayedInvertedTurnBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.lastBeat = (spec: number): IDelayedInvertedTurnBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }

    this.trillStep = (spec: WholeHalfUnison): IDelayedInvertedTurnBuilder => {
        updates["trillStep"] = spec;
        delete childBuilders["trillStep;"];
        modifiedKeys["trillStep"] = true;
        return this;
    }

    this.twoNoteTurn = (spec: WholeHalfNone): IDelayedInvertedTurnBuilder => {
        updates["twoNoteTurn"] = spec;
        delete childBuilders["twoNoteTurn;"];
        modifiedKeys["twoNoteTurn"] = true;
        return this;
    }

    this.secondBeat = (spec: number): IDelayedInvertedTurnBuilder => {
        updates["secondBeat"] = spec;
        delete childBuilders["secondBeat;"];
        modifiedKeys["secondBeat"] = true;
        return this;
    }
  }
}
export function patchDelayedInvertedTurn(base: DelayedInvertedTurn, builder: (build: IDelayedInvertedTurnBuilder) => IDelayedInvertedTurnBuilder): IAny[] { return builder(new DelayedInvertedTurnBuilder(base)).patch(); }
export function buildDelayedInvertedTurn(builder: (build: IDelayedInvertedTurnBuilder) => IDelayedInvertedTurnBuilder): DelayedInvertedTurn { return builder(new DelayedInvertedTurnBuilder()).build(); }

export interface IVerticalTurnBuilder {
  build?: () => VerticalTurn;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IVerticalTurnBuilder;
  relativeY: (relativeY: number) => IVerticalTurnBuilder;
  defaultY: (defaultY: number) => IVerticalTurnBuilder;
  relativeX: (relativeX: number) => IVerticalTurnBuilder;
  fontFamily: (fontFamily: string) => IVerticalTurnBuilder;
  fontWeight: (fontWeight: NormalBold) => IVerticalTurnBuilder;
  fontStyle: (fontStyle: NormalItalic) => IVerticalTurnBuilder;
  fontSize: (fontSize: string) => IVerticalTurnBuilder;
  color: (color: string) => IVerticalTurnBuilder;
  placement: (placement: AboveBelow) => IVerticalTurnBuilder;
  startNote: (startNote: UpperMainBelow) => IVerticalTurnBuilder;
  accelerate: (accelerate: boolean) => IVerticalTurnBuilder;
  beats: (beats: number) => IVerticalTurnBuilder;
  lastBeat: (lastBeat: number) => IVerticalTurnBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IVerticalTurnBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IVerticalTurnBuilder;
  secondBeat: (secondBeat: number) => IVerticalTurnBuilder;
}

class VerticalTurnBuilder implements IVerticalTurnBuilder {
  build: () => VerticalTurn;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IVerticalTurnBuilder;
  relativeY: (relativeY: number) => IVerticalTurnBuilder;
  defaultY: (defaultY: number) => IVerticalTurnBuilder;
  relativeX: (relativeX: number) => IVerticalTurnBuilder;
  fontFamily: (fontFamily: string) => IVerticalTurnBuilder;
  fontWeight: (fontWeight: NormalBold) => IVerticalTurnBuilder;
  fontStyle: (fontStyle: NormalItalic) => IVerticalTurnBuilder;
  fontSize: (fontSize: string) => IVerticalTurnBuilder;
  color: (color: string) => IVerticalTurnBuilder;
  placement: (placement: AboveBelow) => IVerticalTurnBuilder;
  startNote: (startNote: UpperMainBelow) => IVerticalTurnBuilder;
  accelerate: (accelerate: boolean) => IVerticalTurnBuilder;
  beats: (beats: number) => IVerticalTurnBuilder;
  lastBeat: (lastBeat: number) => IVerticalTurnBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IVerticalTurnBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IVerticalTurnBuilder;
  secondBeat: (secondBeat: number) => IVerticalTurnBuilder;
  constructor(original?: VerticalTurn) {
    let updates: VerticalTurn = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): VerticalTurn => {
        checkInvariants();
        (updates as any)._class = "VerticalTurn";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IVerticalTurnBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IVerticalTurnBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IVerticalTurnBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IVerticalTurnBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IVerticalTurnBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IVerticalTurnBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IVerticalTurnBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IVerticalTurnBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IVerticalTurnBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IVerticalTurnBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.startNote = (spec: UpperMainBelow): IVerticalTurnBuilder => {
        updates["startNote"] = spec;
        delete childBuilders["startNote;"];
        modifiedKeys["startNote"] = true;
        return this;
    }

    this.accelerate = (spec: boolean): IVerticalTurnBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): IVerticalTurnBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.lastBeat = (spec: number): IVerticalTurnBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }

    this.trillStep = (spec: WholeHalfUnison): IVerticalTurnBuilder => {
        updates["trillStep"] = spec;
        delete childBuilders["trillStep;"];
        modifiedKeys["trillStep"] = true;
        return this;
    }

    this.twoNoteTurn = (spec: WholeHalfNone): IVerticalTurnBuilder => {
        updates["twoNoteTurn"] = spec;
        delete childBuilders["twoNoteTurn;"];
        modifiedKeys["twoNoteTurn"] = true;
        return this;
    }

    this.secondBeat = (spec: number): IVerticalTurnBuilder => {
        updates["secondBeat"] = spec;
        delete childBuilders["secondBeat;"];
        modifiedKeys["secondBeat"] = true;
        return this;
    }
  }
}
export function patchVerticalTurn(base: VerticalTurn, builder: (build: IVerticalTurnBuilder) => IVerticalTurnBuilder): IAny[] { return builder(new VerticalTurnBuilder(base)).patch(); }
export function buildVerticalTurn(builder: (build: IVerticalTurnBuilder) => IVerticalTurnBuilder): VerticalTurn { return builder(new VerticalTurnBuilder()).build(); }

export interface IShakeBuilder {
  build?: () => Shake;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IShakeBuilder;
  relativeY: (relativeY: number) => IShakeBuilder;
  defaultY: (defaultY: number) => IShakeBuilder;
  relativeX: (relativeX: number) => IShakeBuilder;
  fontFamily: (fontFamily: string) => IShakeBuilder;
  fontWeight: (fontWeight: NormalBold) => IShakeBuilder;
  fontStyle: (fontStyle: NormalItalic) => IShakeBuilder;
  fontSize: (fontSize: string) => IShakeBuilder;
  color: (color: string) => IShakeBuilder;
  placement: (placement: AboveBelow) => IShakeBuilder;
  startNote: (startNote: UpperMainBelow) => IShakeBuilder;
  accelerate: (accelerate: boolean) => IShakeBuilder;
  beats: (beats: number) => IShakeBuilder;
  lastBeat: (lastBeat: number) => IShakeBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IShakeBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IShakeBuilder;
  secondBeat: (secondBeat: number) => IShakeBuilder;
}

class ShakeBuilder implements IShakeBuilder {
  build: () => Shake;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IShakeBuilder;
  relativeY: (relativeY: number) => IShakeBuilder;
  defaultY: (defaultY: number) => IShakeBuilder;
  relativeX: (relativeX: number) => IShakeBuilder;
  fontFamily: (fontFamily: string) => IShakeBuilder;
  fontWeight: (fontWeight: NormalBold) => IShakeBuilder;
  fontStyle: (fontStyle: NormalItalic) => IShakeBuilder;
  fontSize: (fontSize: string) => IShakeBuilder;
  color: (color: string) => IShakeBuilder;
  placement: (placement: AboveBelow) => IShakeBuilder;
  startNote: (startNote: UpperMainBelow) => IShakeBuilder;
  accelerate: (accelerate: boolean) => IShakeBuilder;
  beats: (beats: number) => IShakeBuilder;
  lastBeat: (lastBeat: number) => IShakeBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IShakeBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IShakeBuilder;
  secondBeat: (secondBeat: number) => IShakeBuilder;
  constructor(original?: Shake) {
    let updates: Shake = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Shake => {
        checkInvariants();
        (updates as any)._class = "Shake";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IShakeBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IShakeBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IShakeBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IShakeBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IShakeBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IShakeBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IShakeBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IShakeBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IShakeBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IShakeBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.startNote = (spec: UpperMainBelow): IShakeBuilder => {
        updates["startNote"] = spec;
        delete childBuilders["startNote;"];
        modifiedKeys["startNote"] = true;
        return this;
    }

    this.accelerate = (spec: boolean): IShakeBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): IShakeBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.lastBeat = (spec: number): IShakeBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }

    this.trillStep = (spec: WholeHalfUnison): IShakeBuilder => {
        updates["trillStep"] = spec;
        delete childBuilders["trillStep;"];
        modifiedKeys["trillStep"] = true;
        return this;
    }

    this.twoNoteTurn = (spec: WholeHalfNone): IShakeBuilder => {
        updates["twoNoteTurn"] = spec;
        delete childBuilders["twoNoteTurn;"];
        modifiedKeys["twoNoteTurn"] = true;
        return this;
    }

    this.secondBeat = (spec: number): IShakeBuilder => {
        updates["secondBeat"] = spec;
        delete childBuilders["secondBeat;"];
        modifiedKeys["secondBeat"] = true;
        return this;
    }
  }
}
export function patchShake(base: Shake, builder: (build: IShakeBuilder) => IShakeBuilder): IAny[] { return builder(new ShakeBuilder(base)).patch(); }
export function buildShake(builder: (build: IShakeBuilder) => IShakeBuilder): Shake { return builder(new ShakeBuilder()).build(); }

export interface IMordentBuilder {
  build?: () => Mordent;
  patch: () => IAny[];
  long: (long: boolean) => IMordentBuilder;
  approach: (approach: AboveBelow) => IMordentBuilder;
  departure: (departure: AboveBelow) => IMordentBuilder;
  defaultX: (defaultX: number) => IMordentBuilder;
  relativeY: (relativeY: number) => IMordentBuilder;
  defaultY: (defaultY: number) => IMordentBuilder;
  relativeX: (relativeX: number) => IMordentBuilder;
  fontFamily: (fontFamily: string) => IMordentBuilder;
  fontWeight: (fontWeight: NormalBold) => IMordentBuilder;
  fontStyle: (fontStyle: NormalItalic) => IMordentBuilder;
  fontSize: (fontSize: string) => IMordentBuilder;
  color: (color: string) => IMordentBuilder;
  placement: (placement: AboveBelow) => IMordentBuilder;
  startNote: (startNote: UpperMainBelow) => IMordentBuilder;
  accelerate: (accelerate: boolean) => IMordentBuilder;
  beats: (beats: number) => IMordentBuilder;
  lastBeat: (lastBeat: number) => IMordentBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IMordentBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IMordentBuilder;
  secondBeat: (secondBeat: number) => IMordentBuilder;
}

class MordentBuilder implements IMordentBuilder {
  build: () => Mordent;
  patch: () => IAny[];
  long: (long: boolean) => IMordentBuilder;
  approach: (approach: AboveBelow) => IMordentBuilder;
  departure: (departure: AboveBelow) => IMordentBuilder;
  defaultX: (defaultX: number) => IMordentBuilder;
  relativeY: (relativeY: number) => IMordentBuilder;
  defaultY: (defaultY: number) => IMordentBuilder;
  relativeX: (relativeX: number) => IMordentBuilder;
  fontFamily: (fontFamily: string) => IMordentBuilder;
  fontWeight: (fontWeight: NormalBold) => IMordentBuilder;
  fontStyle: (fontStyle: NormalItalic) => IMordentBuilder;
  fontSize: (fontSize: string) => IMordentBuilder;
  color: (color: string) => IMordentBuilder;
  placement: (placement: AboveBelow) => IMordentBuilder;
  startNote: (startNote: UpperMainBelow) => IMordentBuilder;
  accelerate: (accelerate: boolean) => IMordentBuilder;
  beats: (beats: number) => IMordentBuilder;
  lastBeat: (lastBeat: number) => IMordentBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IMordentBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IMordentBuilder;
  secondBeat: (secondBeat: number) => IMordentBuilder;
  constructor(original?: Mordent) {
    let updates: Mordent = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Mordent => {
        checkInvariants();
        (updates as any)._class = "Mordent";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.long = (spec: boolean): IMordentBuilder => {
        updates["long"] = spec;
        delete childBuilders["long;"];
        modifiedKeys["long"] = true;
        return this;
    }

    this.approach = (spec: AboveBelow): IMordentBuilder => {
        updates["approach"] = spec;
        delete childBuilders["approach;"];
        modifiedKeys["approach"] = true;
        return this;
    }

    this.departure = (spec: AboveBelow): IMordentBuilder => {
        updates["departure"] = spec;
        delete childBuilders["departure;"];
        modifiedKeys["departure"] = true;
        return this;
    }

    this.defaultX = (spec: number): IMordentBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IMordentBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IMordentBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IMordentBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IMordentBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IMordentBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IMordentBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IMordentBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IMordentBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IMordentBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.startNote = (spec: UpperMainBelow): IMordentBuilder => {
        updates["startNote"] = spec;
        delete childBuilders["startNote;"];
        modifiedKeys["startNote"] = true;
        return this;
    }

    this.accelerate = (spec: boolean): IMordentBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): IMordentBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.lastBeat = (spec: number): IMordentBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }

    this.trillStep = (spec: WholeHalfUnison): IMordentBuilder => {
        updates["trillStep"] = spec;
        delete childBuilders["trillStep;"];
        modifiedKeys["trillStep"] = true;
        return this;
    }

    this.twoNoteTurn = (spec: WholeHalfNone): IMordentBuilder => {
        updates["twoNoteTurn"] = spec;
        delete childBuilders["twoNoteTurn;"];
        modifiedKeys["twoNoteTurn"] = true;
        return this;
    }

    this.secondBeat = (spec: number): IMordentBuilder => {
        updates["secondBeat"] = spec;
        delete childBuilders["secondBeat;"];
        modifiedKeys["secondBeat"] = true;
        return this;
    }
  }
}
export function patchMordent(base: Mordent, builder: (build: IMordentBuilder) => IMordentBuilder): IAny[] { return builder(new MordentBuilder(base)).patch(); }
export function buildMordent(builder: (build: IMordentBuilder) => IMordentBuilder): Mordent { return builder(new MordentBuilder()).build(); }

export interface IInvertedMordentBuilder {
  build?: () => InvertedMordent;
  patch: () => IAny[];
  long: (long: boolean) => IInvertedMordentBuilder;
  approach: (approach: AboveBelow) => IInvertedMordentBuilder;
  departure: (departure: AboveBelow) => IInvertedMordentBuilder;
  defaultX: (defaultX: number) => IInvertedMordentBuilder;
  relativeY: (relativeY: number) => IInvertedMordentBuilder;
  defaultY: (defaultY: number) => IInvertedMordentBuilder;
  relativeX: (relativeX: number) => IInvertedMordentBuilder;
  fontFamily: (fontFamily: string) => IInvertedMordentBuilder;
  fontWeight: (fontWeight: NormalBold) => IInvertedMordentBuilder;
  fontStyle: (fontStyle: NormalItalic) => IInvertedMordentBuilder;
  fontSize: (fontSize: string) => IInvertedMordentBuilder;
  color: (color: string) => IInvertedMordentBuilder;
  placement: (placement: AboveBelow) => IInvertedMordentBuilder;
  startNote: (startNote: UpperMainBelow) => IInvertedMordentBuilder;
  accelerate: (accelerate: boolean) => IInvertedMordentBuilder;
  beats: (beats: number) => IInvertedMordentBuilder;
  lastBeat: (lastBeat: number) => IInvertedMordentBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IInvertedMordentBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IInvertedMordentBuilder;
  secondBeat: (secondBeat: number) => IInvertedMordentBuilder;
}

class InvertedMordentBuilder implements IInvertedMordentBuilder {
  build: () => InvertedMordent;
  patch: () => IAny[];
  long: (long: boolean) => IInvertedMordentBuilder;
  approach: (approach: AboveBelow) => IInvertedMordentBuilder;
  departure: (departure: AboveBelow) => IInvertedMordentBuilder;
  defaultX: (defaultX: number) => IInvertedMordentBuilder;
  relativeY: (relativeY: number) => IInvertedMordentBuilder;
  defaultY: (defaultY: number) => IInvertedMordentBuilder;
  relativeX: (relativeX: number) => IInvertedMordentBuilder;
  fontFamily: (fontFamily: string) => IInvertedMordentBuilder;
  fontWeight: (fontWeight: NormalBold) => IInvertedMordentBuilder;
  fontStyle: (fontStyle: NormalItalic) => IInvertedMordentBuilder;
  fontSize: (fontSize: string) => IInvertedMordentBuilder;
  color: (color: string) => IInvertedMordentBuilder;
  placement: (placement: AboveBelow) => IInvertedMordentBuilder;
  startNote: (startNote: UpperMainBelow) => IInvertedMordentBuilder;
  accelerate: (accelerate: boolean) => IInvertedMordentBuilder;
  beats: (beats: number) => IInvertedMordentBuilder;
  lastBeat: (lastBeat: number) => IInvertedMordentBuilder;
  trillStep: (trillStep: WholeHalfUnison) => IInvertedMordentBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => IInvertedMordentBuilder;
  secondBeat: (secondBeat: number) => IInvertedMordentBuilder;
  constructor(original?: InvertedMordent) {
    let updates: InvertedMordent = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): InvertedMordent => {
        checkInvariants();
        (updates as any)._class = "InvertedMordent";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.long = (spec: boolean): IInvertedMordentBuilder => {
        updates["long"] = spec;
        delete childBuilders["long;"];
        modifiedKeys["long"] = true;
        return this;
    }

    this.approach = (spec: AboveBelow): IInvertedMordentBuilder => {
        updates["approach"] = spec;
        delete childBuilders["approach;"];
        modifiedKeys["approach"] = true;
        return this;
    }

    this.departure = (spec: AboveBelow): IInvertedMordentBuilder => {
        updates["departure"] = spec;
        delete childBuilders["departure;"];
        modifiedKeys["departure"] = true;
        return this;
    }

    this.defaultX = (spec: number): IInvertedMordentBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IInvertedMordentBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IInvertedMordentBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IInvertedMordentBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IInvertedMordentBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IInvertedMordentBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IInvertedMordentBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IInvertedMordentBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IInvertedMordentBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IInvertedMordentBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.startNote = (spec: UpperMainBelow): IInvertedMordentBuilder => {
        updates["startNote"] = spec;
        delete childBuilders["startNote;"];
        modifiedKeys["startNote"] = true;
        return this;
    }

    this.accelerate = (spec: boolean): IInvertedMordentBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): IInvertedMordentBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.lastBeat = (spec: number): IInvertedMordentBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }

    this.trillStep = (spec: WholeHalfUnison): IInvertedMordentBuilder => {
        updates["trillStep"] = spec;
        delete childBuilders["trillStep;"];
        modifiedKeys["trillStep"] = true;
        return this;
    }

    this.twoNoteTurn = (spec: WholeHalfNone): IInvertedMordentBuilder => {
        updates["twoNoteTurn"] = spec;
        delete childBuilders["twoNoteTurn;"];
        modifiedKeys["twoNoteTurn"] = true;
        return this;
    }

    this.secondBeat = (spec: number): IInvertedMordentBuilder => {
        updates["secondBeat"] = spec;
        delete childBuilders["secondBeat;"];
        modifiedKeys["secondBeat"] = true;
        return this;
    }
  }
}
export function patchInvertedMordent(base: InvertedMordent, builder: (build: IInvertedMordentBuilder) => IInvertedMordentBuilder): IAny[] { return builder(new InvertedMordentBuilder(base)).patch(); }
export function buildInvertedMordent(builder: (build: IInvertedMordentBuilder) => IInvertedMordentBuilder): InvertedMordent { return builder(new InvertedMordentBuilder()).build(); }

export interface ISchleiferBuilder {
  build?: () => Schleifer;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ISchleiferBuilder;
  relativeY: (relativeY: number) => ISchleiferBuilder;
  defaultY: (defaultY: number) => ISchleiferBuilder;
  relativeX: (relativeX: number) => ISchleiferBuilder;
  fontFamily: (fontFamily: string) => ISchleiferBuilder;
  fontWeight: (fontWeight: NormalBold) => ISchleiferBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISchleiferBuilder;
  fontSize: (fontSize: string) => ISchleiferBuilder;
  color: (color: string) => ISchleiferBuilder;
  placement: (placement: AboveBelow) => ISchleiferBuilder;
}

class SchleiferBuilder implements ISchleiferBuilder {
  build: () => Schleifer;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ISchleiferBuilder;
  relativeY: (relativeY: number) => ISchleiferBuilder;
  defaultY: (defaultY: number) => ISchleiferBuilder;
  relativeX: (relativeX: number) => ISchleiferBuilder;
  fontFamily: (fontFamily: string) => ISchleiferBuilder;
  fontWeight: (fontWeight: NormalBold) => ISchleiferBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISchleiferBuilder;
  fontSize: (fontSize: string) => ISchleiferBuilder;
  color: (color: string) => ISchleiferBuilder;
  placement: (placement: AboveBelow) => ISchleiferBuilder;
  constructor(original?: Schleifer) {
    let updates: Schleifer = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Schleifer => {
        checkInvariants();
        (updates as any)._class = "Schleifer";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): ISchleiferBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ISchleiferBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ISchleiferBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ISchleiferBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ISchleiferBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ISchleiferBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ISchleiferBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ISchleiferBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ISchleiferBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): ISchleiferBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchSchleifer(base: Schleifer, builder: (build: ISchleiferBuilder) => ISchleiferBuilder): IAny[] { return builder(new SchleiferBuilder(base)).patch(); }
export function buildSchleifer(builder: (build: ISchleiferBuilder) => ISchleiferBuilder): Schleifer { return builder(new SchleiferBuilder()).build(); }

export interface ITremoloBuilder {
  build?: () => Tremolo;
  patch: () => IAny[];
  data: (data: string) => ITremoloBuilder;
  type: (type: StartStopSingle) => ITremoloBuilder;
  defaultX: (defaultX: number) => ITremoloBuilder;
  relativeY: (relativeY: number) => ITremoloBuilder;
  defaultY: (defaultY: number) => ITremoloBuilder;
  relativeX: (relativeX: number) => ITremoloBuilder;
  fontFamily: (fontFamily: string) => ITremoloBuilder;
  fontWeight: (fontWeight: NormalBold) => ITremoloBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITremoloBuilder;
  fontSize: (fontSize: string) => ITremoloBuilder;
  color: (color: string) => ITremoloBuilder;
  placement: (placement: AboveBelow) => ITremoloBuilder;
}

class TremoloBuilder implements ITremoloBuilder {
  build: () => Tremolo;
  patch: () => IAny[];
  data: (data: string) => ITremoloBuilder;
  type: (type: StartStopSingle) => ITremoloBuilder;
  defaultX: (defaultX: number) => ITremoloBuilder;
  relativeY: (relativeY: number) => ITremoloBuilder;
  defaultY: (defaultY: number) => ITremoloBuilder;
  relativeX: (relativeX: number) => ITremoloBuilder;
  fontFamily: (fontFamily: string) => ITremoloBuilder;
  fontWeight: (fontWeight: NormalBold) => ITremoloBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITremoloBuilder;
  fontSize: (fontSize: string) => ITremoloBuilder;
  color: (color: string) => ITremoloBuilder;
  placement: (placement: AboveBelow) => ITremoloBuilder;
  constructor(original?: Tremolo) {
    let updates: Tremolo = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Tremolo => {
        checkInvariants();
        (updates as any)._class = "Tremolo";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): ITremoloBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.type = (spec: StartStopSingle): ITremoloBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): ITremoloBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ITremoloBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ITremoloBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ITremoloBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ITremoloBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ITremoloBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ITremoloBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ITremoloBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ITremoloBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): ITremoloBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchTremolo(base: Tremolo, builder: (build: ITremoloBuilder) => ITremoloBuilder): IAny[] { return builder(new TremoloBuilder(base)).patch(); }
export function buildTremolo(builder: (build: ITremoloBuilder) => ITremoloBuilder): Tremolo { return builder(new TremoloBuilder()).build(); }

export interface IOtherOrnamentBuilder {
  build?: () => OtherOrnament;
  patch: () => IAny[];
  type: (type: StartStopSingle) => IOtherOrnamentBuilder;
  data: (data: string) => IOtherOrnamentBuilder;
  defaultX: (defaultX: number) => IOtherOrnamentBuilder;
  relativeY: (relativeY: number) => IOtherOrnamentBuilder;
  defaultY: (defaultY: number) => IOtherOrnamentBuilder;
  relativeX: (relativeX: number) => IOtherOrnamentBuilder;
  fontFamily: (fontFamily: string) => IOtherOrnamentBuilder;
  fontWeight: (fontWeight: NormalBold) => IOtherOrnamentBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOtherOrnamentBuilder;
  fontSize: (fontSize: string) => IOtherOrnamentBuilder;
  color: (color: string) => IOtherOrnamentBuilder;
  placement: (placement: AboveBelow) => IOtherOrnamentBuilder;
}

class OtherOrnamentBuilder implements IOtherOrnamentBuilder {
  build: () => OtherOrnament;
  patch: () => IAny[];
  type: (type: StartStopSingle) => IOtherOrnamentBuilder;
  data: (data: string) => IOtherOrnamentBuilder;
  defaultX: (defaultX: number) => IOtherOrnamentBuilder;
  relativeY: (relativeY: number) => IOtherOrnamentBuilder;
  defaultY: (defaultY: number) => IOtherOrnamentBuilder;
  relativeX: (relativeX: number) => IOtherOrnamentBuilder;
  fontFamily: (fontFamily: string) => IOtherOrnamentBuilder;
  fontWeight: (fontWeight: NormalBold) => IOtherOrnamentBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOtherOrnamentBuilder;
  fontSize: (fontSize: string) => IOtherOrnamentBuilder;
  color: (color: string) => IOtherOrnamentBuilder;
  placement: (placement: AboveBelow) => IOtherOrnamentBuilder;
  constructor(original?: OtherOrnament) {
    let updates: OtherOrnament = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): OtherOrnament => {
        checkInvariants();
        (updates as any)._class = "OtherOrnament";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.type = (spec: StartStopSingle): IOtherOrnamentBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.data = (spec: string): IOtherOrnamentBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IOtherOrnamentBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IOtherOrnamentBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IOtherOrnamentBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IOtherOrnamentBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IOtherOrnamentBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IOtherOrnamentBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IOtherOrnamentBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IOtherOrnamentBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IOtherOrnamentBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IOtherOrnamentBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchOtherOrnament(base: OtherOrnament, builder: (build: IOtherOrnamentBuilder) => IOtherOrnamentBuilder): IAny[] { return builder(new OtherOrnamentBuilder(base)).patch(); }
export function buildOtherOrnament(builder: (build: IOtherOrnamentBuilder) => IOtherOrnamentBuilder): OtherOrnament { return builder(new OtherOrnamentBuilder()).build(); }

export interface IAccidentalMarkBuilder {
  build?: () => AccidentalMark;
  patch: () => IAny[];
  mark: (mark: string) => IAccidentalMarkBuilder;
  defaultX: (defaultX: number) => IAccidentalMarkBuilder;
  relativeY: (relativeY: number) => IAccidentalMarkBuilder;
  defaultY: (defaultY: number) => IAccidentalMarkBuilder;
  relativeX: (relativeX: number) => IAccidentalMarkBuilder;
  fontFamily: (fontFamily: string) => IAccidentalMarkBuilder;
  fontWeight: (fontWeight: NormalBold) => IAccidentalMarkBuilder;
  fontStyle: (fontStyle: NormalItalic) => IAccidentalMarkBuilder;
  fontSize: (fontSize: string) => IAccidentalMarkBuilder;
  color: (color: string) => IAccidentalMarkBuilder;
  placement: (placement: AboveBelow) => IAccidentalMarkBuilder;
}

class AccidentalMarkBuilder implements IAccidentalMarkBuilder {
  build: () => AccidentalMark;
  patch: () => IAny[];
  mark: (mark: string) => IAccidentalMarkBuilder;
  defaultX: (defaultX: number) => IAccidentalMarkBuilder;
  relativeY: (relativeY: number) => IAccidentalMarkBuilder;
  defaultY: (defaultY: number) => IAccidentalMarkBuilder;
  relativeX: (relativeX: number) => IAccidentalMarkBuilder;
  fontFamily: (fontFamily: string) => IAccidentalMarkBuilder;
  fontWeight: (fontWeight: NormalBold) => IAccidentalMarkBuilder;
  fontStyle: (fontStyle: NormalItalic) => IAccidentalMarkBuilder;
  fontSize: (fontSize: string) => IAccidentalMarkBuilder;
  color: (color: string) => IAccidentalMarkBuilder;
  placement: (placement: AboveBelow) => IAccidentalMarkBuilder;
  constructor(original?: AccidentalMark) {
    let updates: AccidentalMark = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["mark"]) ||
          childBuilders["mark"] !== undefined ||
          updates.mark !== undefined,
        "mark is a required field");
    }

    if (!original) {
      this.build = (): AccidentalMark => {
        checkInvariants();
        (updates as any)._class = "AccidentalMark";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.mark = (spec: string): IAccidentalMarkBuilder => {
        updates["mark"] = spec;
        delete childBuilders["mark;"];
        modifiedKeys["mark"] = true;
        return this;
    }

    this.defaultX = (spec: number): IAccidentalMarkBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IAccidentalMarkBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IAccidentalMarkBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IAccidentalMarkBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IAccidentalMarkBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IAccidentalMarkBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IAccidentalMarkBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IAccidentalMarkBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IAccidentalMarkBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IAccidentalMarkBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchAccidentalMark(base: AccidentalMark, builder: (build: IAccidentalMarkBuilder) => IAccidentalMarkBuilder): IAny[] { return builder(new AccidentalMarkBuilder(base)).patch(); }
export function buildAccidentalMark(builder: (build: IAccidentalMarkBuilder) => IAccidentalMarkBuilder): AccidentalMark { return builder(new AccidentalMarkBuilder()).build(); }

export interface ITechnicalBuilder {
  build?: () => Technical;
  patch: () => IAny[];
  tripleTongue: (build: TripleTongue | ((builder: ITripleTongueBuilder) => ITripleTongueBuilder)) => ITechnicalBuilder;
  toe: (build: Toe | ((builder: IToeBuilder) => IToeBuilder)) => ITechnicalBuilder;
  hole: (build: Hole | ((builder: IHoleBuilder) => IHoleBuilder)) => ITechnicalBuilder;
  hammerOn: (build: HammerOn | ((builder: IHammerOnBuilder) => IHammerOnBuilder)) => ITechnicalBuilder;
  upBow: (build: UpBow | ((builder: IUpBowBuilder) => IUpBowBuilder)) => ITechnicalBuilder;
  downBow: (build: DownBow | ((builder: IDownBowBuilder) => IDownBowBuilder)) => ITechnicalBuilder;
  fret: (build: Fret | ((builder: IFretBuilder) => IFretBuilder)) => ITechnicalBuilder;
  tap: (build: Tap | ((builder: ITapBuilder) => ITapBuilder)) => ITechnicalBuilder;
  pullOff: (build: PullOff | ((builder: IPullOffBuilder) => IPullOffBuilder)) => ITechnicalBuilder;
  handbell: (build: Handbell | ((builder: IHandbellBuilder) => IHandbellBuilder)) => ITechnicalBuilder;
  bend: (build: Bend | ((builder: IBendBuilder) => IBendBuilder)) => ITechnicalBuilder;
  thumbPosition: (build: ThumbPosition | ((builder: IThumbPositionBuilder) => IThumbPositionBuilder)) => ITechnicalBuilder;
  stopped: (build: Stopped | ((builder: IStoppedBuilder) => IStoppedBuilder)) => ITechnicalBuilder;
  pluck: (build: Pluck | ((builder: IPluckBuilder) => IPluckBuilder)) => ITechnicalBuilder;
  doubleTongue: (build: DoubleTongue | ((builder: IDoubleTongueBuilder) => IDoubleTongueBuilder)) => ITechnicalBuilder;
  string: (build: String | ((builder: IStringBuilder) => IStringBuilder)) => ITechnicalBuilder;
  openString: (build: OpenString | ((builder: IOpenStringBuilder) => IOpenStringBuilder)) => ITechnicalBuilder;
  fingernails: (build: Fingernails | ((builder: IFingernailsBuilder) => IFingernailsBuilder)) => ITechnicalBuilder;
  arrow: (build: Arrow | ((builder: IArrowBuilder) => IArrowBuilder)) => ITechnicalBuilder;
  harmonic: (build: Harmonic | ((builder: IHarmonicBuilder) => IHarmonicBuilder)) => ITechnicalBuilder;
  heel: (build: Heel | ((builder: IHeelBuilder) => IHeelBuilder)) => ITechnicalBuilder;
  otherTechnical: (build: OtherTechnical | ((builder: IOtherTechnicalBuilder) => IOtherTechnicalBuilder)) => ITechnicalBuilder;
  snapPizzicato: (build: SnapPizzicato | ((builder: ISnapPizzicatoBuilder) => ISnapPizzicatoBuilder)) => ITechnicalBuilder;
  fingering: (build: Fingering | ((builder: IFingeringBuilder) => IFingeringBuilder)) => ITechnicalBuilder;
}

class TechnicalBuilder implements ITechnicalBuilder {
  build: () => Technical;
  patch: () => IAny[];
  tripleTongue: (build: TripleTongue | ((builder: ITripleTongueBuilder) => ITripleTongueBuilder)) => ITechnicalBuilder;
  toe: (build: Toe | ((builder: IToeBuilder) => IToeBuilder)) => ITechnicalBuilder;
  hole: (build: Hole | ((builder: IHoleBuilder) => IHoleBuilder)) => ITechnicalBuilder;
  hammerOn: (build: HammerOn | ((builder: IHammerOnBuilder) => IHammerOnBuilder)) => ITechnicalBuilder;
  upBow: (build: UpBow | ((builder: IUpBowBuilder) => IUpBowBuilder)) => ITechnicalBuilder;
  downBow: (build: DownBow | ((builder: IDownBowBuilder) => IDownBowBuilder)) => ITechnicalBuilder;
  fret: (build: Fret | ((builder: IFretBuilder) => IFretBuilder)) => ITechnicalBuilder;
  tap: (build: Tap | ((builder: ITapBuilder) => ITapBuilder)) => ITechnicalBuilder;
  pullOff: (build: PullOff | ((builder: IPullOffBuilder) => IPullOffBuilder)) => ITechnicalBuilder;
  handbell: (build: Handbell | ((builder: IHandbellBuilder) => IHandbellBuilder)) => ITechnicalBuilder;
  bend: (build: Bend | ((builder: IBendBuilder) => IBendBuilder)) => ITechnicalBuilder;
  thumbPosition: (build: ThumbPosition | ((builder: IThumbPositionBuilder) => IThumbPositionBuilder)) => ITechnicalBuilder;
  stopped: (build: Stopped | ((builder: IStoppedBuilder) => IStoppedBuilder)) => ITechnicalBuilder;
  pluck: (build: Pluck | ((builder: IPluckBuilder) => IPluckBuilder)) => ITechnicalBuilder;
  doubleTongue: (build: DoubleTongue | ((builder: IDoubleTongueBuilder) => IDoubleTongueBuilder)) => ITechnicalBuilder;
  string: (build: String | ((builder: IStringBuilder) => IStringBuilder)) => ITechnicalBuilder;
  openString: (build: OpenString | ((builder: IOpenStringBuilder) => IOpenStringBuilder)) => ITechnicalBuilder;
  fingernails: (build: Fingernails | ((builder: IFingernailsBuilder) => IFingernailsBuilder)) => ITechnicalBuilder;
  arrow: (build: Arrow | ((builder: IArrowBuilder) => IArrowBuilder)) => ITechnicalBuilder;
  harmonic: (build: Harmonic | ((builder: IHarmonicBuilder) => IHarmonicBuilder)) => ITechnicalBuilder;
  heel: (build: Heel | ((builder: IHeelBuilder) => IHeelBuilder)) => ITechnicalBuilder;
  otherTechnical: (build: OtherTechnical | ((builder: IOtherTechnicalBuilder) => IOtherTechnicalBuilder)) => ITechnicalBuilder;
  snapPizzicato: (build: SnapPizzicato | ((builder: ISnapPizzicatoBuilder) => ISnapPizzicatoBuilder)) => ITechnicalBuilder;
  fingering: (build: Fingering | ((builder: IFingeringBuilder) => IFingeringBuilder)) => ITechnicalBuilder;
  constructor(original?: Technical) {
    let updates: Technical = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Technical => {
        checkInvariants();
        (updates as any)._class = "Technical";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.tripleTongue = (build: TripleTongue | ((builder: ITripleTongueBuilder) => ITripleTongueBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["tripleTongue"]
        const builder = (build as any)(new TripleTongueBuilder(original && original["tripleTongue"]));
        if (!original) updates["tripleTongue"] = builder.build();
        else childBuilders["tripleTongue"] = builder;
      } else {
        updates.tripleTongue = build as any;
        delete childBuilders["tripleTongue;"];
      }
      modifiedKeys["tripleTongue"] = true;
      return this;
    }

    this.toe = (build: Toe | ((builder: IToeBuilder) => IToeBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["toe"]
        const builder = (build as any)(new ToeBuilder(original && original["toe"]));
        if (!original) updates["toe"] = builder.build();
        else childBuilders["toe"] = builder;
      } else {
        updates.toe = build as any;
        delete childBuilders["toe;"];
      }
      modifiedKeys["toe"] = true;
      return this;
    }

    this.hole = (build: Hole | ((builder: IHoleBuilder) => IHoleBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["hole"]
        const builder = (build as any)(new HoleBuilder(original && original["hole"]));
        if (!original) updates["hole"] = builder.build();
        else childBuilders["hole"] = builder;
      } else {
        updates.hole = build as any;
        delete childBuilders["hole;"];
      }
      modifiedKeys["hole"] = true;
      return this;
    }

    this.hammerOn = (build: HammerOn | ((builder: IHammerOnBuilder) => IHammerOnBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["hammerOn"]
        const builder = (build as any)(new HammerOnBuilder(original && original["hammerOn"]));
        if (!original) updates["hammerOn"] = builder.build();
        else childBuilders["hammerOn"] = builder;
      } else {
        updates.hammerOn = build as any;
        delete childBuilders["hammerOn;"];
      }
      modifiedKeys["hammerOn"] = true;
      return this;
    }

    this.upBow = (build: UpBow | ((builder: IUpBowBuilder) => IUpBowBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["upBow"]
        const builder = (build as any)(new UpBowBuilder(original && original["upBow"]));
        if (!original) updates["upBow"] = builder.build();
        else childBuilders["upBow"] = builder;
      } else {
        updates.upBow = build as any;
        delete childBuilders["upBow;"];
      }
      modifiedKeys["upBow"] = true;
      return this;
    }

    this.downBow = (build: DownBow | ((builder: IDownBowBuilder) => IDownBowBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["downBow"]
        const builder = (build as any)(new DownBowBuilder(original && original["downBow"]));
        if (!original) updates["downBow"] = builder.build();
        else childBuilders["downBow"] = builder;
      } else {
        updates.downBow = build as any;
        delete childBuilders["downBow;"];
      }
      modifiedKeys["downBow"] = true;
      return this;
    }

    this.fret = (build: Fret | ((builder: IFretBuilder) => IFretBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["fret"]
        const builder = (build as any)(new FretBuilder(original && original["fret"]));
        if (!original) updates["fret"] = builder.build();
        else childBuilders["fret"] = builder;
      } else {
        updates.fret = build as any;
        delete childBuilders["fret;"];
      }
      modifiedKeys["fret"] = true;
      return this;
    }

    this.tap = (build: Tap | ((builder: ITapBuilder) => ITapBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["tap"]
        const builder = (build as any)(new TapBuilder(original && original["tap"]));
        if (!original) updates["tap"] = builder.build();
        else childBuilders["tap"] = builder;
      } else {
        updates.tap = build as any;
        delete childBuilders["tap;"];
      }
      modifiedKeys["tap"] = true;
      return this;
    }

    this.pullOff = (build: PullOff | ((builder: IPullOffBuilder) => IPullOffBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["pullOff"]
        const builder = (build as any)(new PullOffBuilder(original && original["pullOff"]));
        if (!original) updates["pullOff"] = builder.build();
        else childBuilders["pullOff"] = builder;
      } else {
        updates.pullOff = build as any;
        delete childBuilders["pullOff;"];
      }
      modifiedKeys["pullOff"] = true;
      return this;
    }

    this.handbell = (build: Handbell | ((builder: IHandbellBuilder) => IHandbellBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["handbell"]
        const builder = (build as any)(new HandbellBuilder(original && original["handbell"]));
        if (!original) updates["handbell"] = builder.build();
        else childBuilders["handbell"] = builder;
      } else {
        updates.handbell = build as any;
        delete childBuilders["handbell;"];
      }
      modifiedKeys["handbell"] = true;
      return this;
    }

    this.bend = (build: Bend | ((builder: IBendBuilder) => IBendBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["bend"]
        const builder = (build as any)(new BendBuilder(original && original["bend"]));
        if (!original) updates["bend"] = builder.build();
        else childBuilders["bend"] = builder;
      } else {
        updates.bend = build as any;
        delete childBuilders["bend;"];
      }
      modifiedKeys["bend"] = true;
      return this;
    }

    this.thumbPosition = (build: ThumbPosition | ((builder: IThumbPositionBuilder) => IThumbPositionBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["thumbPosition"]
        const builder = (build as any)(new ThumbPositionBuilder(original && original["thumbPosition"]));
        if (!original) updates["thumbPosition"] = builder.build();
        else childBuilders["thumbPosition"] = builder;
      } else {
        updates.thumbPosition = build as any;
        delete childBuilders["thumbPosition;"];
      }
      modifiedKeys["thumbPosition"] = true;
      return this;
    }

    this.stopped = (build: Stopped | ((builder: IStoppedBuilder) => IStoppedBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["stopped"]
        const builder = (build as any)(new StoppedBuilder(original && original["stopped"]));
        if (!original) updates["stopped"] = builder.build();
        else childBuilders["stopped"] = builder;
      } else {
        updates.stopped = build as any;
        delete childBuilders["stopped;"];
      }
      modifiedKeys["stopped"] = true;
      return this;
    }

    this.pluck = (build: Pluck | ((builder: IPluckBuilder) => IPluckBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["pluck"]
        const builder = (build as any)(new PluckBuilder(original && original["pluck"]));
        if (!original) updates["pluck"] = builder.build();
        else childBuilders["pluck"] = builder;
      } else {
        updates.pluck = build as any;
        delete childBuilders["pluck;"];
      }
      modifiedKeys["pluck"] = true;
      return this;
    }

    this.doubleTongue = (build: DoubleTongue | ((builder: IDoubleTongueBuilder) => IDoubleTongueBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["doubleTongue"]
        const builder = (build as any)(new DoubleTongueBuilder(original && original["doubleTongue"]));
        if (!original) updates["doubleTongue"] = builder.build();
        else childBuilders["doubleTongue"] = builder;
      } else {
        updates.doubleTongue = build as any;
        delete childBuilders["doubleTongue;"];
      }
      modifiedKeys["doubleTongue"] = true;
      return this;
    }

    this.string = (build: String | ((builder: IStringBuilder) => IStringBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["string"]
        const builder = (build as any)(new StringBuilder(original && original["string"]));
        if (!original) updates["string"] = builder.build();
        else childBuilders["string"] = builder;
      } else {
        updates.string = build as any;
        delete childBuilders["string;"];
      }
      modifiedKeys["string"] = true;
      return this;
    }

    this.openString = (build: OpenString | ((builder: IOpenStringBuilder) => IOpenStringBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["openString"]
        const builder = (build as any)(new OpenStringBuilder(original && original["openString"]));
        if (!original) updates["openString"] = builder.build();
        else childBuilders["openString"] = builder;
      } else {
        updates.openString = build as any;
        delete childBuilders["openString;"];
      }
      modifiedKeys["openString"] = true;
      return this;
    }

    this.fingernails = (build: Fingernails | ((builder: IFingernailsBuilder) => IFingernailsBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["fingernails"]
        const builder = (build as any)(new FingernailsBuilder(original && original["fingernails"]));
        if (!original) updates["fingernails"] = builder.build();
        else childBuilders["fingernails"] = builder;
      } else {
        updates.fingernails = build as any;
        delete childBuilders["fingernails;"];
      }
      modifiedKeys["fingernails"] = true;
      return this;
    }

    this.arrow = (build: Arrow | ((builder: IArrowBuilder) => IArrowBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["arrow"]
        const builder = (build as any)(new ArrowBuilder(original && original["arrow"]));
        if (!original) updates["arrow"] = builder.build();
        else childBuilders["arrow"] = builder;
      } else {
        updates.arrow = build as any;
        delete childBuilders["arrow;"];
      }
      modifiedKeys["arrow"] = true;
      return this;
    }

    this.harmonic = (build: Harmonic | ((builder: IHarmonicBuilder) => IHarmonicBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["harmonic"]
        const builder = (build as any)(new HarmonicBuilder(original && original["harmonic"]));
        if (!original) updates["harmonic"] = builder.build();
        else childBuilders["harmonic"] = builder;
      } else {
        updates.harmonic = build as any;
        delete childBuilders["harmonic;"];
      }
      modifiedKeys["harmonic"] = true;
      return this;
    }

    this.heel = (build: Heel | ((builder: IHeelBuilder) => IHeelBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["heel"]
        const builder = (build as any)(new HeelBuilder(original && original["heel"]));
        if (!original) updates["heel"] = builder.build();
        else childBuilders["heel"] = builder;
      } else {
        updates.heel = build as any;
        delete childBuilders["heel;"];
      }
      modifiedKeys["heel"] = true;
      return this;
    }

    this.otherTechnical = (build: OtherTechnical | ((builder: IOtherTechnicalBuilder) => IOtherTechnicalBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["otherTechnical"]
        const builder = (build as any)(new OtherTechnicalBuilder(original && original["otherTechnical"]));
        if (!original) updates["otherTechnical"] = builder.build();
        else childBuilders["otherTechnical"] = builder;
      } else {
        updates.otherTechnical = build as any;
        delete childBuilders["otherTechnical;"];
      }
      modifiedKeys["otherTechnical"] = true;
      return this;
    }

    this.snapPizzicato = (build: SnapPizzicato | ((builder: ISnapPizzicatoBuilder) => ISnapPizzicatoBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["snapPizzicato"]
        const builder = (build as any)(new SnapPizzicatoBuilder(original && original["snapPizzicato"]));
        if (!original) updates["snapPizzicato"] = builder.build();
        else childBuilders["snapPizzicato"] = builder;
      } else {
        updates.snapPizzicato = build as any;
        delete childBuilders["snapPizzicato;"];
      }
      modifiedKeys["snapPizzicato"] = true;
      return this;
    }

    this.fingering = (build: Fingering | ((builder: IFingeringBuilder) => IFingeringBuilder)): ITechnicalBuilder => {
      if (typeof build === 'function') {
        delete updates["fingering"]
        const builder = (build as any)(new FingeringBuilder(original && original["fingering"]));
        if (!original) updates["fingering"] = builder.build();
        else childBuilders["fingering"] = builder;
      } else {
        updates.fingering = build as any;
        delete childBuilders["fingering;"];
      }
      modifiedKeys["fingering"] = true;
      return this;
    }
  }
}
export function patchTechnical(base: Technical, builder: (build: ITechnicalBuilder) => ITechnicalBuilder): IAny[] { return builder(new TechnicalBuilder(base)).patch(); }
export function buildTechnical(builder: (build: ITechnicalBuilder) => ITechnicalBuilder): Technical { return builder(new TechnicalBuilder()).build(); }

export interface IUpBowBuilder {
  build?: () => UpBow;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IUpBowBuilder;
  relativeY: (relativeY: number) => IUpBowBuilder;
  defaultY: (defaultY: number) => IUpBowBuilder;
  relativeX: (relativeX: number) => IUpBowBuilder;
  fontFamily: (fontFamily: string) => IUpBowBuilder;
  fontWeight: (fontWeight: NormalBold) => IUpBowBuilder;
  fontStyle: (fontStyle: NormalItalic) => IUpBowBuilder;
  fontSize: (fontSize: string) => IUpBowBuilder;
  color: (color: string) => IUpBowBuilder;
  placement: (placement: AboveBelow) => IUpBowBuilder;
}

class UpBowBuilder implements IUpBowBuilder {
  build: () => UpBow;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IUpBowBuilder;
  relativeY: (relativeY: number) => IUpBowBuilder;
  defaultY: (defaultY: number) => IUpBowBuilder;
  relativeX: (relativeX: number) => IUpBowBuilder;
  fontFamily: (fontFamily: string) => IUpBowBuilder;
  fontWeight: (fontWeight: NormalBold) => IUpBowBuilder;
  fontStyle: (fontStyle: NormalItalic) => IUpBowBuilder;
  fontSize: (fontSize: string) => IUpBowBuilder;
  color: (color: string) => IUpBowBuilder;
  placement: (placement: AboveBelow) => IUpBowBuilder;
  constructor(original?: UpBow) {
    let updates: UpBow = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): UpBow => {
        checkInvariants();
        (updates as any)._class = "UpBow";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IUpBowBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IUpBowBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IUpBowBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IUpBowBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IUpBowBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IUpBowBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IUpBowBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IUpBowBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IUpBowBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IUpBowBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchUpBow(base: UpBow, builder: (build: IUpBowBuilder) => IUpBowBuilder): IAny[] { return builder(new UpBowBuilder(base)).patch(); }
export function buildUpBow(builder: (build: IUpBowBuilder) => IUpBowBuilder): UpBow { return builder(new UpBowBuilder()).build(); }

export interface IDownBowBuilder {
  build?: () => DownBow;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IDownBowBuilder;
  relativeY: (relativeY: number) => IDownBowBuilder;
  defaultY: (defaultY: number) => IDownBowBuilder;
  relativeX: (relativeX: number) => IDownBowBuilder;
  fontFamily: (fontFamily: string) => IDownBowBuilder;
  fontWeight: (fontWeight: NormalBold) => IDownBowBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDownBowBuilder;
  fontSize: (fontSize: string) => IDownBowBuilder;
  color: (color: string) => IDownBowBuilder;
  placement: (placement: AboveBelow) => IDownBowBuilder;
}

class DownBowBuilder implements IDownBowBuilder {
  build: () => DownBow;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IDownBowBuilder;
  relativeY: (relativeY: number) => IDownBowBuilder;
  defaultY: (defaultY: number) => IDownBowBuilder;
  relativeX: (relativeX: number) => IDownBowBuilder;
  fontFamily: (fontFamily: string) => IDownBowBuilder;
  fontWeight: (fontWeight: NormalBold) => IDownBowBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDownBowBuilder;
  fontSize: (fontSize: string) => IDownBowBuilder;
  color: (color: string) => IDownBowBuilder;
  placement: (placement: AboveBelow) => IDownBowBuilder;
  constructor(original?: DownBow) {
    let updates: DownBow = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): DownBow => {
        checkInvariants();
        (updates as any)._class = "DownBow";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IDownBowBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDownBowBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDownBowBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDownBowBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDownBowBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDownBowBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDownBowBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDownBowBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDownBowBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IDownBowBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchDownBow(base: DownBow, builder: (build: IDownBowBuilder) => IDownBowBuilder): IAny[] { return builder(new DownBowBuilder(base)).patch(); }
export function buildDownBow(builder: (build: IDownBowBuilder) => IDownBowBuilder): DownBow { return builder(new DownBowBuilder()).build(); }

export interface IHarmonicBuilder {
  build?: () => Harmonic;
  patch: () => IAny[];
  artificial: (artificial: boolean) => IHarmonicBuilder;
  touchingPitch: (touchingPitch: boolean) => IHarmonicBuilder;
  soundingPitch: (soundingPitch: boolean) => IHarmonicBuilder;
  natural: (natural: boolean) => IHarmonicBuilder;
  basePitch: (basePitch: boolean) => IHarmonicBuilder;
  defaultX: (defaultX: number) => IHarmonicBuilder;
  relativeY: (relativeY: number) => IHarmonicBuilder;
  defaultY: (defaultY: number) => IHarmonicBuilder;
  relativeX: (relativeX: number) => IHarmonicBuilder;
  fontFamily: (fontFamily: string) => IHarmonicBuilder;
  fontWeight: (fontWeight: NormalBold) => IHarmonicBuilder;
  fontStyle: (fontStyle: NormalItalic) => IHarmonicBuilder;
  fontSize: (fontSize: string) => IHarmonicBuilder;
  color: (color: string) => IHarmonicBuilder;
  printObject: (printObject: boolean) => IHarmonicBuilder;
  placement: (placement: AboveBelow) => IHarmonicBuilder;
}

class HarmonicBuilder implements IHarmonicBuilder {
  build: () => Harmonic;
  patch: () => IAny[];
  artificial: (artificial: boolean) => IHarmonicBuilder;
  touchingPitch: (touchingPitch: boolean) => IHarmonicBuilder;
  soundingPitch: (soundingPitch: boolean) => IHarmonicBuilder;
  natural: (natural: boolean) => IHarmonicBuilder;
  basePitch: (basePitch: boolean) => IHarmonicBuilder;
  defaultX: (defaultX: number) => IHarmonicBuilder;
  relativeY: (relativeY: number) => IHarmonicBuilder;
  defaultY: (defaultY: number) => IHarmonicBuilder;
  relativeX: (relativeX: number) => IHarmonicBuilder;
  fontFamily: (fontFamily: string) => IHarmonicBuilder;
  fontWeight: (fontWeight: NormalBold) => IHarmonicBuilder;
  fontStyle: (fontStyle: NormalItalic) => IHarmonicBuilder;
  fontSize: (fontSize: string) => IHarmonicBuilder;
  color: (color: string) => IHarmonicBuilder;
  printObject: (printObject: boolean) => IHarmonicBuilder;
  placement: (placement: AboveBelow) => IHarmonicBuilder;
  constructor(original?: Harmonic) {
    let updates: Harmonic = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["artificial"]) ||
          childBuilders["artificial"] !== undefined ||
          updates.artificial !== undefined,
        "artificial is a required field");
      console.assert(
          (original && !modifiedKeys["touchingPitch"]) ||
          childBuilders["touchingPitch"] !== undefined ||
          updates.touchingPitch !== undefined,
        "touchingPitch is a required field");
      console.assert(
          (original && !modifiedKeys["soundingPitch"]) ||
          childBuilders["soundingPitch"] !== undefined ||
          updates.soundingPitch !== undefined,
        "soundingPitch is a required field");
      console.assert(
          (original && !modifiedKeys["natural"]) ||
          childBuilders["natural"] !== undefined ||
          updates.natural !== undefined,
        "natural is a required field");
      console.assert(
          (original && !modifiedKeys["basePitch"]) ||
          childBuilders["basePitch"] !== undefined ||
          updates.basePitch !== undefined,
        "basePitch is a required field");
    }

    if (!original) {
      this.build = (): Harmonic => {
        checkInvariants();
        (updates as any)._class = "Harmonic";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.artificial = (spec: boolean): IHarmonicBuilder => {
        updates["artificial"] = spec;
        delete childBuilders["artificial;"];
        modifiedKeys["artificial"] = true;
        return this;
    }

    this.touchingPitch = (spec: boolean): IHarmonicBuilder => {
        updates["touchingPitch"] = spec;
        delete childBuilders["touchingPitch;"];
        modifiedKeys["touchingPitch"] = true;
        return this;
    }

    this.soundingPitch = (spec: boolean): IHarmonicBuilder => {
        updates["soundingPitch"] = spec;
        delete childBuilders["soundingPitch;"];
        modifiedKeys["soundingPitch"] = true;
        return this;
    }

    this.natural = (spec: boolean): IHarmonicBuilder => {
        updates["natural"] = spec;
        delete childBuilders["natural;"];
        modifiedKeys["natural"] = true;
        return this;
    }

    this.basePitch = (spec: boolean): IHarmonicBuilder => {
        updates["basePitch"] = spec;
        delete childBuilders["basePitch;"];
        modifiedKeys["basePitch"] = true;
        return this;
    }

    this.defaultX = (spec: number): IHarmonicBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IHarmonicBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IHarmonicBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IHarmonicBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IHarmonicBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IHarmonicBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IHarmonicBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IHarmonicBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IHarmonicBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.printObject = (spec: boolean): IHarmonicBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IHarmonicBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchHarmonic(base: Harmonic, builder: (build: IHarmonicBuilder) => IHarmonicBuilder): IAny[] { return builder(new HarmonicBuilder(base)).patch(); }
export function buildHarmonic(builder: (build: IHarmonicBuilder) => IHarmonicBuilder): Harmonic { return builder(new HarmonicBuilder()).build(); }

export interface IOpenStringBuilder {
  build?: () => OpenString;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IOpenStringBuilder;
  relativeY: (relativeY: number) => IOpenStringBuilder;
  defaultY: (defaultY: number) => IOpenStringBuilder;
  relativeX: (relativeX: number) => IOpenStringBuilder;
  fontFamily: (fontFamily: string) => IOpenStringBuilder;
  fontWeight: (fontWeight: NormalBold) => IOpenStringBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOpenStringBuilder;
  fontSize: (fontSize: string) => IOpenStringBuilder;
  color: (color: string) => IOpenStringBuilder;
  placement: (placement: AboveBelow) => IOpenStringBuilder;
}

class OpenStringBuilder implements IOpenStringBuilder {
  build: () => OpenString;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IOpenStringBuilder;
  relativeY: (relativeY: number) => IOpenStringBuilder;
  defaultY: (defaultY: number) => IOpenStringBuilder;
  relativeX: (relativeX: number) => IOpenStringBuilder;
  fontFamily: (fontFamily: string) => IOpenStringBuilder;
  fontWeight: (fontWeight: NormalBold) => IOpenStringBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOpenStringBuilder;
  fontSize: (fontSize: string) => IOpenStringBuilder;
  color: (color: string) => IOpenStringBuilder;
  placement: (placement: AboveBelow) => IOpenStringBuilder;
  constructor(original?: OpenString) {
    let updates: OpenString = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): OpenString => {
        checkInvariants();
        (updates as any)._class = "OpenString";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IOpenStringBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IOpenStringBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IOpenStringBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IOpenStringBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IOpenStringBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IOpenStringBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IOpenStringBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IOpenStringBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IOpenStringBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IOpenStringBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchOpenString(base: OpenString, builder: (build: IOpenStringBuilder) => IOpenStringBuilder): IAny[] { return builder(new OpenStringBuilder(base)).patch(); }
export function buildOpenString(builder: (build: IOpenStringBuilder) => IOpenStringBuilder): OpenString { return builder(new OpenStringBuilder()).build(); }

export interface IThumbPositionBuilder {
  build?: () => ThumbPosition;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IThumbPositionBuilder;
  relativeY: (relativeY: number) => IThumbPositionBuilder;
  defaultY: (defaultY: number) => IThumbPositionBuilder;
  relativeX: (relativeX: number) => IThumbPositionBuilder;
  fontFamily: (fontFamily: string) => IThumbPositionBuilder;
  fontWeight: (fontWeight: NormalBold) => IThumbPositionBuilder;
  fontStyle: (fontStyle: NormalItalic) => IThumbPositionBuilder;
  fontSize: (fontSize: string) => IThumbPositionBuilder;
  color: (color: string) => IThumbPositionBuilder;
  placement: (placement: AboveBelow) => IThumbPositionBuilder;
}

class ThumbPositionBuilder implements IThumbPositionBuilder {
  build: () => ThumbPosition;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IThumbPositionBuilder;
  relativeY: (relativeY: number) => IThumbPositionBuilder;
  defaultY: (defaultY: number) => IThumbPositionBuilder;
  relativeX: (relativeX: number) => IThumbPositionBuilder;
  fontFamily: (fontFamily: string) => IThumbPositionBuilder;
  fontWeight: (fontWeight: NormalBold) => IThumbPositionBuilder;
  fontStyle: (fontStyle: NormalItalic) => IThumbPositionBuilder;
  fontSize: (fontSize: string) => IThumbPositionBuilder;
  color: (color: string) => IThumbPositionBuilder;
  placement: (placement: AboveBelow) => IThumbPositionBuilder;
  constructor(original?: ThumbPosition) {
    let updates: ThumbPosition = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): ThumbPosition => {
        checkInvariants();
        (updates as any)._class = "ThumbPosition";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IThumbPositionBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IThumbPositionBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IThumbPositionBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IThumbPositionBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IThumbPositionBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IThumbPositionBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IThumbPositionBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IThumbPositionBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IThumbPositionBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IThumbPositionBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchThumbPosition(base: ThumbPosition, builder: (build: IThumbPositionBuilder) => IThumbPositionBuilder): IAny[] { return builder(new ThumbPositionBuilder(base)).patch(); }
export function buildThumbPosition(builder: (build: IThumbPositionBuilder) => IThumbPositionBuilder): ThumbPosition { return builder(new ThumbPositionBuilder()).build(); }

export interface IPluckBuilder {
  build?: () => Pluck;
  patch: () => IAny[];
  data: (data: string) => IPluckBuilder;
  defaultX: (defaultX: number) => IPluckBuilder;
  relativeY: (relativeY: number) => IPluckBuilder;
  defaultY: (defaultY: number) => IPluckBuilder;
  relativeX: (relativeX: number) => IPluckBuilder;
  fontFamily: (fontFamily: string) => IPluckBuilder;
  fontWeight: (fontWeight: NormalBold) => IPluckBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPluckBuilder;
  fontSize: (fontSize: string) => IPluckBuilder;
  color: (color: string) => IPluckBuilder;
  placement: (placement: AboveBelow) => IPluckBuilder;
}

class PluckBuilder implements IPluckBuilder {
  build: () => Pluck;
  patch: () => IAny[];
  data: (data: string) => IPluckBuilder;
  defaultX: (defaultX: number) => IPluckBuilder;
  relativeY: (relativeY: number) => IPluckBuilder;
  defaultY: (defaultY: number) => IPluckBuilder;
  relativeX: (relativeX: number) => IPluckBuilder;
  fontFamily: (fontFamily: string) => IPluckBuilder;
  fontWeight: (fontWeight: NormalBold) => IPluckBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPluckBuilder;
  fontSize: (fontSize: string) => IPluckBuilder;
  color: (color: string) => IPluckBuilder;
  placement: (placement: AboveBelow) => IPluckBuilder;
  constructor(original?: Pluck) {
    let updates: Pluck = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): Pluck => {
        checkInvariants();
        (updates as any)._class = "Pluck";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IPluckBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IPluckBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IPluckBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IPluckBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IPluckBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IPluckBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IPluckBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IPluckBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IPluckBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IPluckBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IPluckBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchPluck(base: Pluck, builder: (build: IPluckBuilder) => IPluckBuilder): IAny[] { return builder(new PluckBuilder(base)).patch(); }
export function buildPluck(builder: (build: IPluckBuilder) => IPluckBuilder): Pluck { return builder(new PluckBuilder()).build(); }

export interface IDoubleTongueBuilder {
  build?: () => DoubleTongue;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IDoubleTongueBuilder;
  relativeY: (relativeY: number) => IDoubleTongueBuilder;
  defaultY: (defaultY: number) => IDoubleTongueBuilder;
  relativeX: (relativeX: number) => IDoubleTongueBuilder;
  fontFamily: (fontFamily: string) => IDoubleTongueBuilder;
  fontWeight: (fontWeight: NormalBold) => IDoubleTongueBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDoubleTongueBuilder;
  fontSize: (fontSize: string) => IDoubleTongueBuilder;
  color: (color: string) => IDoubleTongueBuilder;
  placement: (placement: AboveBelow) => IDoubleTongueBuilder;
}

class DoubleTongueBuilder implements IDoubleTongueBuilder {
  build: () => DoubleTongue;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IDoubleTongueBuilder;
  relativeY: (relativeY: number) => IDoubleTongueBuilder;
  defaultY: (defaultY: number) => IDoubleTongueBuilder;
  relativeX: (relativeX: number) => IDoubleTongueBuilder;
  fontFamily: (fontFamily: string) => IDoubleTongueBuilder;
  fontWeight: (fontWeight: NormalBold) => IDoubleTongueBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDoubleTongueBuilder;
  fontSize: (fontSize: string) => IDoubleTongueBuilder;
  color: (color: string) => IDoubleTongueBuilder;
  placement: (placement: AboveBelow) => IDoubleTongueBuilder;
  constructor(original?: DoubleTongue) {
    let updates: DoubleTongue = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): DoubleTongue => {
        checkInvariants();
        (updates as any)._class = "DoubleTongue";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IDoubleTongueBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDoubleTongueBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDoubleTongueBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDoubleTongueBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDoubleTongueBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDoubleTongueBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDoubleTongueBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDoubleTongueBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDoubleTongueBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IDoubleTongueBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchDoubleTongue(base: DoubleTongue, builder: (build: IDoubleTongueBuilder) => IDoubleTongueBuilder): IAny[] { return builder(new DoubleTongueBuilder(base)).patch(); }
export function buildDoubleTongue(builder: (build: IDoubleTongueBuilder) => IDoubleTongueBuilder): DoubleTongue { return builder(new DoubleTongueBuilder()).build(); }

export interface ITripleTongueBuilder {
  build?: () => TripleTongue;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ITripleTongueBuilder;
  relativeY: (relativeY: number) => ITripleTongueBuilder;
  defaultY: (defaultY: number) => ITripleTongueBuilder;
  relativeX: (relativeX: number) => ITripleTongueBuilder;
  fontFamily: (fontFamily: string) => ITripleTongueBuilder;
  fontWeight: (fontWeight: NormalBold) => ITripleTongueBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITripleTongueBuilder;
  fontSize: (fontSize: string) => ITripleTongueBuilder;
  color: (color: string) => ITripleTongueBuilder;
  placement: (placement: AboveBelow) => ITripleTongueBuilder;
}

class TripleTongueBuilder implements ITripleTongueBuilder {
  build: () => TripleTongue;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ITripleTongueBuilder;
  relativeY: (relativeY: number) => ITripleTongueBuilder;
  defaultY: (defaultY: number) => ITripleTongueBuilder;
  relativeX: (relativeX: number) => ITripleTongueBuilder;
  fontFamily: (fontFamily: string) => ITripleTongueBuilder;
  fontWeight: (fontWeight: NormalBold) => ITripleTongueBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITripleTongueBuilder;
  fontSize: (fontSize: string) => ITripleTongueBuilder;
  color: (color: string) => ITripleTongueBuilder;
  placement: (placement: AboveBelow) => ITripleTongueBuilder;
  constructor(original?: TripleTongue) {
    let updates: TripleTongue = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): TripleTongue => {
        checkInvariants();
        (updates as any)._class = "TripleTongue";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): ITripleTongueBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ITripleTongueBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ITripleTongueBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ITripleTongueBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ITripleTongueBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ITripleTongueBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ITripleTongueBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ITripleTongueBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ITripleTongueBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): ITripleTongueBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchTripleTongue(base: TripleTongue, builder: (build: ITripleTongueBuilder) => ITripleTongueBuilder): IAny[] { return builder(new TripleTongueBuilder(base)).patch(); }
export function buildTripleTongue(builder: (build: ITripleTongueBuilder) => ITripleTongueBuilder): TripleTongue { return builder(new TripleTongueBuilder()).build(); }

export interface IStoppedBuilder {
  build?: () => Stopped;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IStoppedBuilder;
  relativeY: (relativeY: number) => IStoppedBuilder;
  defaultY: (defaultY: number) => IStoppedBuilder;
  relativeX: (relativeX: number) => IStoppedBuilder;
  fontFamily: (fontFamily: string) => IStoppedBuilder;
  fontWeight: (fontWeight: NormalBold) => IStoppedBuilder;
  fontStyle: (fontStyle: NormalItalic) => IStoppedBuilder;
  fontSize: (fontSize: string) => IStoppedBuilder;
  color: (color: string) => IStoppedBuilder;
  placement: (placement: AboveBelow) => IStoppedBuilder;
}

class StoppedBuilder implements IStoppedBuilder {
  build: () => Stopped;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IStoppedBuilder;
  relativeY: (relativeY: number) => IStoppedBuilder;
  defaultY: (defaultY: number) => IStoppedBuilder;
  relativeX: (relativeX: number) => IStoppedBuilder;
  fontFamily: (fontFamily: string) => IStoppedBuilder;
  fontWeight: (fontWeight: NormalBold) => IStoppedBuilder;
  fontStyle: (fontStyle: NormalItalic) => IStoppedBuilder;
  fontSize: (fontSize: string) => IStoppedBuilder;
  color: (color: string) => IStoppedBuilder;
  placement: (placement: AboveBelow) => IStoppedBuilder;
  constructor(original?: Stopped) {
    let updates: Stopped = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Stopped => {
        checkInvariants();
        (updates as any)._class = "Stopped";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IStoppedBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IStoppedBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IStoppedBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IStoppedBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IStoppedBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IStoppedBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IStoppedBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IStoppedBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IStoppedBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IStoppedBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchStopped(base: Stopped, builder: (build: IStoppedBuilder) => IStoppedBuilder): IAny[] { return builder(new StoppedBuilder(base)).patch(); }
export function buildStopped(builder: (build: IStoppedBuilder) => IStoppedBuilder): Stopped { return builder(new StoppedBuilder()).build(); }

export interface ISnapPizzicatoBuilder {
  build?: () => SnapPizzicato;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ISnapPizzicatoBuilder;
  relativeY: (relativeY: number) => ISnapPizzicatoBuilder;
  defaultY: (defaultY: number) => ISnapPizzicatoBuilder;
  relativeX: (relativeX: number) => ISnapPizzicatoBuilder;
  fontFamily: (fontFamily: string) => ISnapPizzicatoBuilder;
  fontWeight: (fontWeight: NormalBold) => ISnapPizzicatoBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISnapPizzicatoBuilder;
  fontSize: (fontSize: string) => ISnapPizzicatoBuilder;
  color: (color: string) => ISnapPizzicatoBuilder;
  placement: (placement: AboveBelow) => ISnapPizzicatoBuilder;
}

class SnapPizzicatoBuilder implements ISnapPizzicatoBuilder {
  build: () => SnapPizzicato;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ISnapPizzicatoBuilder;
  relativeY: (relativeY: number) => ISnapPizzicatoBuilder;
  defaultY: (defaultY: number) => ISnapPizzicatoBuilder;
  relativeX: (relativeX: number) => ISnapPizzicatoBuilder;
  fontFamily: (fontFamily: string) => ISnapPizzicatoBuilder;
  fontWeight: (fontWeight: NormalBold) => ISnapPizzicatoBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISnapPizzicatoBuilder;
  fontSize: (fontSize: string) => ISnapPizzicatoBuilder;
  color: (color: string) => ISnapPizzicatoBuilder;
  placement: (placement: AboveBelow) => ISnapPizzicatoBuilder;
  constructor(original?: SnapPizzicato) {
    let updates: SnapPizzicato = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): SnapPizzicato => {
        checkInvariants();
        (updates as any)._class = "SnapPizzicato";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): ISnapPizzicatoBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ISnapPizzicatoBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ISnapPizzicatoBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ISnapPizzicatoBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ISnapPizzicatoBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ISnapPizzicatoBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ISnapPizzicatoBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ISnapPizzicatoBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ISnapPizzicatoBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): ISnapPizzicatoBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchSnapPizzicato(base: SnapPizzicato, builder: (build: ISnapPizzicatoBuilder) => ISnapPizzicatoBuilder): IAny[] { return builder(new SnapPizzicatoBuilder(base)).patch(); }
export function buildSnapPizzicato(builder: (build: ISnapPizzicatoBuilder) => ISnapPizzicatoBuilder): SnapPizzicato { return builder(new SnapPizzicatoBuilder()).build(); }

export interface IHammerOnBuilder {
  build?: () => HammerOn;
  patch: () => IAny[];
  number: (number: number) => IHammerOnBuilder;
  type: (type: StartStop) => IHammerOnBuilder;
  data: (data: string) => IHammerOnBuilder;
  defaultX: (defaultX: number) => IHammerOnBuilder;
  relativeY: (relativeY: number) => IHammerOnBuilder;
  defaultY: (defaultY: number) => IHammerOnBuilder;
  relativeX: (relativeX: number) => IHammerOnBuilder;
  fontFamily: (fontFamily: string) => IHammerOnBuilder;
  fontWeight: (fontWeight: NormalBold) => IHammerOnBuilder;
  fontStyle: (fontStyle: NormalItalic) => IHammerOnBuilder;
  fontSize: (fontSize: string) => IHammerOnBuilder;
  color: (color: string) => IHammerOnBuilder;
  placement: (placement: AboveBelow) => IHammerOnBuilder;
}

class HammerOnBuilder implements IHammerOnBuilder {
  build: () => HammerOn;
  patch: () => IAny[];
  number: (number: number) => IHammerOnBuilder;
  type: (type: StartStop) => IHammerOnBuilder;
  data: (data: string) => IHammerOnBuilder;
  defaultX: (defaultX: number) => IHammerOnBuilder;
  relativeY: (relativeY: number) => IHammerOnBuilder;
  defaultY: (defaultY: number) => IHammerOnBuilder;
  relativeX: (relativeX: number) => IHammerOnBuilder;
  fontFamily: (fontFamily: string) => IHammerOnBuilder;
  fontWeight: (fontWeight: NormalBold) => IHammerOnBuilder;
  fontStyle: (fontStyle: NormalItalic) => IHammerOnBuilder;
  fontSize: (fontSize: string) => IHammerOnBuilder;
  color: (color: string) => IHammerOnBuilder;
  placement: (placement: AboveBelow) => IHammerOnBuilder;
  constructor(original?: HammerOn) {
    let updates: HammerOn = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): HammerOn => {
        checkInvariants();
        (updates as any)._class = "HammerOn";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: number): IHammerOnBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.type = (spec: StartStop): IHammerOnBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.data = (spec: string): IHammerOnBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IHammerOnBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IHammerOnBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IHammerOnBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IHammerOnBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IHammerOnBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IHammerOnBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IHammerOnBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IHammerOnBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IHammerOnBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IHammerOnBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchHammerOn(base: HammerOn, builder: (build: IHammerOnBuilder) => IHammerOnBuilder): IAny[] { return builder(new HammerOnBuilder(base)).patch(); }
export function buildHammerOn(builder: (build: IHammerOnBuilder) => IHammerOnBuilder): HammerOn { return builder(new HammerOnBuilder()).build(); }

export interface IPullOffBuilder {
  build?: () => PullOff;
  patch: () => IAny[];
  number: (number: number) => IPullOffBuilder;
  type: (type: StartStop) => IPullOffBuilder;
  data: (data: string) => IPullOffBuilder;
  defaultX: (defaultX: number) => IPullOffBuilder;
  relativeY: (relativeY: number) => IPullOffBuilder;
  defaultY: (defaultY: number) => IPullOffBuilder;
  relativeX: (relativeX: number) => IPullOffBuilder;
  fontFamily: (fontFamily: string) => IPullOffBuilder;
  fontWeight: (fontWeight: NormalBold) => IPullOffBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPullOffBuilder;
  fontSize: (fontSize: string) => IPullOffBuilder;
  color: (color: string) => IPullOffBuilder;
  placement: (placement: AboveBelow) => IPullOffBuilder;
}

class PullOffBuilder implements IPullOffBuilder {
  build: () => PullOff;
  patch: () => IAny[];
  number: (number: number) => IPullOffBuilder;
  type: (type: StartStop) => IPullOffBuilder;
  data: (data: string) => IPullOffBuilder;
  defaultX: (defaultX: number) => IPullOffBuilder;
  relativeY: (relativeY: number) => IPullOffBuilder;
  defaultY: (defaultY: number) => IPullOffBuilder;
  relativeX: (relativeX: number) => IPullOffBuilder;
  fontFamily: (fontFamily: string) => IPullOffBuilder;
  fontWeight: (fontWeight: NormalBold) => IPullOffBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPullOffBuilder;
  fontSize: (fontSize: string) => IPullOffBuilder;
  color: (color: string) => IPullOffBuilder;
  placement: (placement: AboveBelow) => IPullOffBuilder;
  constructor(original?: PullOff) {
    let updates: PullOff = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): PullOff => {
        checkInvariants();
        (updates as any)._class = "PullOff";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: number): IPullOffBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.type = (spec: StartStop): IPullOffBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.data = (spec: string): IPullOffBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IPullOffBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IPullOffBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IPullOffBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IPullOffBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IPullOffBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IPullOffBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IPullOffBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IPullOffBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IPullOffBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IPullOffBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchPullOff(base: PullOff, builder: (build: IPullOffBuilder) => IPullOffBuilder): IAny[] { return builder(new PullOffBuilder(base)).patch(); }
export function buildPullOff(builder: (build: IPullOffBuilder) => IPullOffBuilder): PullOff { return builder(new PullOffBuilder()).build(); }

export interface IBendBuilder {
  build?: () => Bend;
  patch: () => IAny[];
  bendAlter: (bendAlter: string) => IBendBuilder;
  withBar: (build: WithBar | ((builder: IWithBarBuilder) => IWithBarBuilder)) => IBendBuilder;
  preBend: (preBend: boolean) => IBendBuilder;
  release: (release: boolean) => IBendBuilder;
  defaultX: (defaultX: number) => IBendBuilder;
  relativeY: (relativeY: number) => IBendBuilder;
  defaultY: (defaultY: number) => IBendBuilder;
  relativeX: (relativeX: number) => IBendBuilder;
  fontFamily: (fontFamily: string) => IBendBuilder;
  fontWeight: (fontWeight: NormalBold) => IBendBuilder;
  fontStyle: (fontStyle: NormalItalic) => IBendBuilder;
  fontSize: (fontSize: string) => IBendBuilder;
  color: (color: string) => IBendBuilder;
  accelerate: (accelerate: boolean) => IBendBuilder;
  beats: (beats: number) => IBendBuilder;
  firstBeat: (firstBeat: number) => IBendBuilder;
  lastBeat: (lastBeat: number) => IBendBuilder;
}

class BendBuilder implements IBendBuilder {
  build: () => Bend;
  patch: () => IAny[];
  bendAlter: (bendAlter: string) => IBendBuilder;
  withBar: (build: WithBar | ((builder: IWithBarBuilder) => IWithBarBuilder)) => IBendBuilder;
  preBend: (preBend: boolean) => IBendBuilder;
  release: (release: boolean) => IBendBuilder;
  defaultX: (defaultX: number) => IBendBuilder;
  relativeY: (relativeY: number) => IBendBuilder;
  defaultY: (defaultY: number) => IBendBuilder;
  relativeX: (relativeX: number) => IBendBuilder;
  fontFamily: (fontFamily: string) => IBendBuilder;
  fontWeight: (fontWeight: NormalBold) => IBendBuilder;
  fontStyle: (fontStyle: NormalItalic) => IBendBuilder;
  fontSize: (fontSize: string) => IBendBuilder;
  color: (color: string) => IBendBuilder;
  accelerate: (accelerate: boolean) => IBendBuilder;
  beats: (beats: number) => IBendBuilder;
  firstBeat: (firstBeat: number) => IBendBuilder;
  lastBeat: (lastBeat: number) => IBendBuilder;
  constructor(original?: Bend) {
    let updates: Bend = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["bendAlter"]) ||
          childBuilders["bendAlter"] !== undefined ||
          updates.bendAlter !== undefined,
        "bendAlter is a required field");
      console.assert(
          (original && !modifiedKeys["preBend"]) ||
          childBuilders["preBend"] !== undefined ||
          updates.preBend !== undefined,
        "preBend is a required field");
      console.assert(
          (original && !modifiedKeys["release"]) ||
          childBuilders["release"] !== undefined ||
          updates.release !== undefined,
        "release is a required field");
    }

    if (!original) {
      this.build = (): Bend => {
        checkInvariants();
        (updates as any)._class = "Bend";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.bendAlter = (spec: string): IBendBuilder => {
        updates["bendAlter"] = spec;
        delete childBuilders["bendAlter;"];
        modifiedKeys["bendAlter"] = true;
        return this;
    }

    this.withBar = (build: WithBar | ((builder: IWithBarBuilder) => IWithBarBuilder)): IBendBuilder => {
      if (typeof build === 'function') {
        delete updates["withBar"]
        const builder = (build as any)(new WithBarBuilder(original && original["withBar"]));
        if (!original) updates["withBar"] = builder.build();
        else childBuilders["withBar"] = builder;
      } else {
        updates.withBar = build as any;
        delete childBuilders["withBar;"];
      }
      modifiedKeys["withBar"] = true;
      return this;
    }

    this.preBend = (spec: boolean): IBendBuilder => {
        updates["preBend"] = spec;
        delete childBuilders["preBend;"];
        modifiedKeys["preBend"] = true;
        return this;
    }

    this.release = (spec: boolean): IBendBuilder => {
        updates["release"] = spec;
        delete childBuilders["release;"];
        modifiedKeys["release"] = true;
        return this;
    }

    this.defaultX = (spec: number): IBendBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IBendBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IBendBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IBendBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IBendBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IBendBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IBendBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IBendBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IBendBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.accelerate = (spec: boolean): IBendBuilder => {
        updates["accelerate"] = spec;
        delete childBuilders["accelerate;"];
        modifiedKeys["accelerate"] = true;
        return this;
    }

    this.beats = (spec: number): IBendBuilder => {
        updates["beats"] = spec;
        delete childBuilders["beats;"];
        modifiedKeys["beats"] = true;
        return this;
    }

    this.firstBeat = (spec: number): IBendBuilder => {
        updates["firstBeat"] = spec;
        delete childBuilders["firstBeat;"];
        modifiedKeys["firstBeat"] = true;
        return this;
    }

    this.lastBeat = (spec: number): IBendBuilder => {
        updates["lastBeat"] = spec;
        delete childBuilders["lastBeat;"];
        modifiedKeys["lastBeat"] = true;
        return this;
    }
  }
}
export function patchBend(base: Bend, builder: (build: IBendBuilder) => IBendBuilder): IAny[] { return builder(new BendBuilder(base)).patch(); }
export function buildBend(builder: (build: IBendBuilder) => IBendBuilder): Bend { return builder(new BendBuilder()).build(); }

export interface IWithBarBuilder {
  build?: () => WithBar;
  patch: () => IAny[];
  data: (data: string) => IWithBarBuilder;
  defaultX: (defaultX: number) => IWithBarBuilder;
  relativeY: (relativeY: number) => IWithBarBuilder;
  defaultY: (defaultY: number) => IWithBarBuilder;
  relativeX: (relativeX: number) => IWithBarBuilder;
  fontFamily: (fontFamily: string) => IWithBarBuilder;
  fontWeight: (fontWeight: NormalBold) => IWithBarBuilder;
  fontStyle: (fontStyle: NormalItalic) => IWithBarBuilder;
  fontSize: (fontSize: string) => IWithBarBuilder;
  color: (color: string) => IWithBarBuilder;
  placement: (placement: AboveBelow) => IWithBarBuilder;
}

class WithBarBuilder implements IWithBarBuilder {
  build: () => WithBar;
  patch: () => IAny[];
  data: (data: string) => IWithBarBuilder;
  defaultX: (defaultX: number) => IWithBarBuilder;
  relativeY: (relativeY: number) => IWithBarBuilder;
  defaultY: (defaultY: number) => IWithBarBuilder;
  relativeX: (relativeX: number) => IWithBarBuilder;
  fontFamily: (fontFamily: string) => IWithBarBuilder;
  fontWeight: (fontWeight: NormalBold) => IWithBarBuilder;
  fontStyle: (fontStyle: NormalItalic) => IWithBarBuilder;
  fontSize: (fontSize: string) => IWithBarBuilder;
  color: (color: string) => IWithBarBuilder;
  placement: (placement: AboveBelow) => IWithBarBuilder;
  constructor(original?: WithBar) {
    let updates: WithBar = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): WithBar => {
        checkInvariants();
        (updates as any)._class = "WithBar";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IWithBarBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IWithBarBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IWithBarBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IWithBarBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IWithBarBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IWithBarBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IWithBarBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IWithBarBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IWithBarBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IWithBarBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IWithBarBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchWithBar(base: WithBar, builder: (build: IWithBarBuilder) => IWithBarBuilder): IAny[] { return builder(new WithBarBuilder(base)).patch(); }
export function buildWithBar(builder: (build: IWithBarBuilder) => IWithBarBuilder): WithBar { return builder(new WithBarBuilder()).build(); }

export interface ITapBuilder {
  build?: () => Tap;
  patch: () => IAny[];
  data: (data: string) => ITapBuilder;
  defaultX: (defaultX: number) => ITapBuilder;
  relativeY: (relativeY: number) => ITapBuilder;
  defaultY: (defaultY: number) => ITapBuilder;
  relativeX: (relativeX: number) => ITapBuilder;
  fontFamily: (fontFamily: string) => ITapBuilder;
  fontWeight: (fontWeight: NormalBold) => ITapBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITapBuilder;
  fontSize: (fontSize: string) => ITapBuilder;
  color: (color: string) => ITapBuilder;
  placement: (placement: AboveBelow) => ITapBuilder;
}

class TapBuilder implements ITapBuilder {
  build: () => Tap;
  patch: () => IAny[];
  data: (data: string) => ITapBuilder;
  defaultX: (defaultX: number) => ITapBuilder;
  relativeY: (relativeY: number) => ITapBuilder;
  defaultY: (defaultY: number) => ITapBuilder;
  relativeX: (relativeX: number) => ITapBuilder;
  fontFamily: (fontFamily: string) => ITapBuilder;
  fontWeight: (fontWeight: NormalBold) => ITapBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITapBuilder;
  fontSize: (fontSize: string) => ITapBuilder;
  color: (color: string) => ITapBuilder;
  placement: (placement: AboveBelow) => ITapBuilder;
  constructor(original?: Tap) {
    let updates: Tap = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): Tap => {
        checkInvariants();
        (updates as any)._class = "Tap";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): ITapBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): ITapBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ITapBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ITapBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ITapBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ITapBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ITapBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ITapBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ITapBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ITapBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): ITapBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchTap(base: Tap, builder: (build: ITapBuilder) => ITapBuilder): IAny[] { return builder(new TapBuilder(base)).patch(); }
export function buildTap(builder: (build: ITapBuilder) => ITapBuilder): Tap { return builder(new TapBuilder()).build(); }

export interface IHeelBuilder {
  build?: () => Heel;
  patch: () => IAny[];
  substitution: (substitution: boolean) => IHeelBuilder;
  defaultX: (defaultX: number) => IHeelBuilder;
  relativeY: (relativeY: number) => IHeelBuilder;
  defaultY: (defaultY: number) => IHeelBuilder;
  relativeX: (relativeX: number) => IHeelBuilder;
  fontFamily: (fontFamily: string) => IHeelBuilder;
  fontWeight: (fontWeight: NormalBold) => IHeelBuilder;
  fontStyle: (fontStyle: NormalItalic) => IHeelBuilder;
  fontSize: (fontSize: string) => IHeelBuilder;
  color: (color: string) => IHeelBuilder;
  placement: (placement: AboveBelow) => IHeelBuilder;
}

class HeelBuilder implements IHeelBuilder {
  build: () => Heel;
  patch: () => IAny[];
  substitution: (substitution: boolean) => IHeelBuilder;
  defaultX: (defaultX: number) => IHeelBuilder;
  relativeY: (relativeY: number) => IHeelBuilder;
  defaultY: (defaultY: number) => IHeelBuilder;
  relativeX: (relativeX: number) => IHeelBuilder;
  fontFamily: (fontFamily: string) => IHeelBuilder;
  fontWeight: (fontWeight: NormalBold) => IHeelBuilder;
  fontStyle: (fontStyle: NormalItalic) => IHeelBuilder;
  fontSize: (fontSize: string) => IHeelBuilder;
  color: (color: string) => IHeelBuilder;
  placement: (placement: AboveBelow) => IHeelBuilder;
  constructor(original?: Heel) {
    let updates: Heel = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Heel => {
        checkInvariants();
        (updates as any)._class = "Heel";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.substitution = (spec: boolean): IHeelBuilder => {
        updates["substitution"] = spec;
        delete childBuilders["substitution;"];
        modifiedKeys["substitution"] = true;
        return this;
    }

    this.defaultX = (spec: number): IHeelBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IHeelBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IHeelBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IHeelBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IHeelBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IHeelBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IHeelBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IHeelBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IHeelBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IHeelBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchHeel(base: Heel, builder: (build: IHeelBuilder) => IHeelBuilder): IAny[] { return builder(new HeelBuilder(base)).patch(); }
export function buildHeel(builder: (build: IHeelBuilder) => IHeelBuilder): Heel { return builder(new HeelBuilder()).build(); }

export interface IToeBuilder {
  build?: () => Toe;
  patch: () => IAny[];
  substitution: (substitution: boolean) => IToeBuilder;
  defaultX: (defaultX: number) => IToeBuilder;
  relativeY: (relativeY: number) => IToeBuilder;
  defaultY: (defaultY: number) => IToeBuilder;
  relativeX: (relativeX: number) => IToeBuilder;
  fontFamily: (fontFamily: string) => IToeBuilder;
  fontWeight: (fontWeight: NormalBold) => IToeBuilder;
  fontStyle: (fontStyle: NormalItalic) => IToeBuilder;
  fontSize: (fontSize: string) => IToeBuilder;
  color: (color: string) => IToeBuilder;
  placement: (placement: AboveBelow) => IToeBuilder;
}

class ToeBuilder implements IToeBuilder {
  build: () => Toe;
  patch: () => IAny[];
  substitution: (substitution: boolean) => IToeBuilder;
  defaultX: (defaultX: number) => IToeBuilder;
  relativeY: (relativeY: number) => IToeBuilder;
  defaultY: (defaultY: number) => IToeBuilder;
  relativeX: (relativeX: number) => IToeBuilder;
  fontFamily: (fontFamily: string) => IToeBuilder;
  fontWeight: (fontWeight: NormalBold) => IToeBuilder;
  fontStyle: (fontStyle: NormalItalic) => IToeBuilder;
  fontSize: (fontSize: string) => IToeBuilder;
  color: (color: string) => IToeBuilder;
  placement: (placement: AboveBelow) => IToeBuilder;
  constructor(original?: Toe) {
    let updates: Toe = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Toe => {
        checkInvariants();
        (updates as any)._class = "Toe";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.substitution = (spec: boolean): IToeBuilder => {
        updates["substitution"] = spec;
        delete childBuilders["substitution;"];
        modifiedKeys["substitution"] = true;
        return this;
    }

    this.defaultX = (spec: number): IToeBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IToeBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IToeBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IToeBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IToeBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IToeBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IToeBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IToeBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IToeBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IToeBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchToe(base: Toe, builder: (build: IToeBuilder) => IToeBuilder): IAny[] { return builder(new ToeBuilder(base)).patch(); }
export function buildToe(builder: (build: IToeBuilder) => IToeBuilder): Toe { return builder(new ToeBuilder()).build(); }

export interface IFingernailsBuilder {
  build?: () => Fingernails;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IFingernailsBuilder;
  relativeY: (relativeY: number) => IFingernailsBuilder;
  defaultY: (defaultY: number) => IFingernailsBuilder;
  relativeX: (relativeX: number) => IFingernailsBuilder;
  fontFamily: (fontFamily: string) => IFingernailsBuilder;
  fontWeight: (fontWeight: NormalBold) => IFingernailsBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFingernailsBuilder;
  fontSize: (fontSize: string) => IFingernailsBuilder;
  color: (color: string) => IFingernailsBuilder;
  placement: (placement: AboveBelow) => IFingernailsBuilder;
}

class FingernailsBuilder implements IFingernailsBuilder {
  build: () => Fingernails;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IFingernailsBuilder;
  relativeY: (relativeY: number) => IFingernailsBuilder;
  defaultY: (defaultY: number) => IFingernailsBuilder;
  relativeX: (relativeX: number) => IFingernailsBuilder;
  fontFamily: (fontFamily: string) => IFingernailsBuilder;
  fontWeight: (fontWeight: NormalBold) => IFingernailsBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFingernailsBuilder;
  fontSize: (fontSize: string) => IFingernailsBuilder;
  color: (color: string) => IFingernailsBuilder;
  placement: (placement: AboveBelow) => IFingernailsBuilder;
  constructor(original?: Fingernails) {
    let updates: Fingernails = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Fingernails => {
        checkInvariants();
        (updates as any)._class = "Fingernails";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IFingernailsBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IFingernailsBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IFingernailsBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IFingernailsBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IFingernailsBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IFingernailsBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IFingernailsBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IFingernailsBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IFingernailsBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IFingernailsBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchFingernails(base: Fingernails, builder: (build: IFingernailsBuilder) => IFingernailsBuilder): IAny[] { return builder(new FingernailsBuilder(base)).patch(); }
export function buildFingernails(builder: (build: IFingernailsBuilder) => IFingernailsBuilder): Fingernails { return builder(new FingernailsBuilder()).build(); }

export interface IHoleBuilder {
  build?: () => Hole;
  patch: () => IAny[];
  holeClosed: (build: HoleClosed | ((builder: IHoleClosedBuilder) => IHoleClosedBuilder)) => IHoleBuilder;
  holeShape: (holeShape: string) => IHoleBuilder;
  holeType: (holeType: string) => IHoleBuilder;
  defaultX: (defaultX: number) => IHoleBuilder;
  relativeY: (relativeY: number) => IHoleBuilder;
  defaultY: (defaultY: number) => IHoleBuilder;
  relativeX: (relativeX: number) => IHoleBuilder;
  fontFamily: (fontFamily: string) => IHoleBuilder;
  fontWeight: (fontWeight: NormalBold) => IHoleBuilder;
  fontStyle: (fontStyle: NormalItalic) => IHoleBuilder;
  fontSize: (fontSize: string) => IHoleBuilder;
  color: (color: string) => IHoleBuilder;
  placement: (placement: AboveBelow) => IHoleBuilder;
}

class HoleBuilder implements IHoleBuilder {
  build: () => Hole;
  patch: () => IAny[];
  holeClosed: (build: HoleClosed | ((builder: IHoleClosedBuilder) => IHoleClosedBuilder)) => IHoleBuilder;
  holeShape: (holeShape: string) => IHoleBuilder;
  holeType: (holeType: string) => IHoleBuilder;
  defaultX: (defaultX: number) => IHoleBuilder;
  relativeY: (relativeY: number) => IHoleBuilder;
  defaultY: (defaultY: number) => IHoleBuilder;
  relativeX: (relativeX: number) => IHoleBuilder;
  fontFamily: (fontFamily: string) => IHoleBuilder;
  fontWeight: (fontWeight: NormalBold) => IHoleBuilder;
  fontStyle: (fontStyle: NormalItalic) => IHoleBuilder;
  fontSize: (fontSize: string) => IHoleBuilder;
  color: (color: string) => IHoleBuilder;
  placement: (placement: AboveBelow) => IHoleBuilder;
  constructor(original?: Hole) {
    let updates: Hole = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["holeClosed"]) ||
          childBuilders["holeClosed"] !== undefined ||
          updates.holeClosed !== undefined,
        "holeClosed is a required field");
      console.assert(
          (original && !modifiedKeys["holeShape"]) ||
          childBuilders["holeShape"] !== undefined ||
          updates.holeShape !== undefined,
        "holeShape is a required field");
    }

    if (!original) {
      this.build = (): Hole => {
        checkInvariants();
        (updates as any)._class = "Hole";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.holeClosed = (build: HoleClosed | ((builder: IHoleClosedBuilder) => IHoleClosedBuilder)): IHoleBuilder => {
      if (typeof build === 'function') {
        delete updates["holeClosed"]
        const builder = (build as any)(new HoleClosedBuilder(original && original["holeClosed"]));
        if (!original) updates["holeClosed"] = builder.build();
        else childBuilders["holeClosed"] = builder;
      } else {
        updates.holeClosed = build as any;
        delete childBuilders["holeClosed;"];
      }
      modifiedKeys["holeClosed"] = true;
      return this;
    }

    this.holeShape = (spec: string): IHoleBuilder => {
        updates["holeShape"] = spec;
        delete childBuilders["holeShape;"];
        modifiedKeys["holeShape"] = true;
        return this;
    }

    this.holeType = (spec: string): IHoleBuilder => {
        updates["holeType"] = spec;
        delete childBuilders["holeType;"];
        modifiedKeys["holeType"] = true;
        return this;
    }

    this.defaultX = (spec: number): IHoleBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IHoleBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IHoleBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IHoleBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IHoleBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IHoleBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IHoleBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IHoleBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IHoleBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IHoleBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchHole(base: Hole, builder: (build: IHoleBuilder) => IHoleBuilder): IAny[] { return builder(new HoleBuilder(base)).patch(); }
export function buildHole(builder: (build: IHoleBuilder) => IHoleBuilder): Hole { return builder(new HoleBuilder()).build(); }

export interface IHoleClosedBuilder {
  build?: () => HoleClosed;
  patch: () => IAny[];
  location: (location: HoleLocation) => IHoleClosedBuilder;
  data: (data: HoleClosedType) => IHoleClosedBuilder;
}

class HoleClosedBuilder implements IHoleClosedBuilder {
  build: () => HoleClosed;
  patch: () => IAny[];
  location: (location: HoleLocation) => IHoleClosedBuilder;
  data: (data: HoleClosedType) => IHoleClosedBuilder;
  constructor(original?: HoleClosed) {
    let updates: HoleClosed = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): HoleClosed => {
        checkInvariants();
        (updates as any)._class = "HoleClosed";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.location = (spec: HoleLocation): IHoleClosedBuilder => {
        updates["location"] = spec;
        delete childBuilders["location;"];
        modifiedKeys["location"] = true;
        return this;
    }

    this.data = (spec: HoleClosedType): IHoleClosedBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }
  }
}
export function patchHoleClosed(base: HoleClosed, builder: (build: IHoleClosedBuilder) => IHoleClosedBuilder): IAny[] { return builder(new HoleClosedBuilder(base)).patch(); }
export function buildHoleClosed(builder: (build: IHoleClosedBuilder) => IHoleClosedBuilder): HoleClosed { return builder(new HoleClosedBuilder()).build(); }

export interface IArrowBuilder {
  build?: () => Arrow;
  patch: () => IAny[];
  arrowStyle: (arrowStyle: string) => IArrowBuilder;
  arrowDirection: (arrowDirection: string) => IArrowBuilder;
  circularArrow: (circularArrow: string) => IArrowBuilder;
  defaultX: (defaultX: number) => IArrowBuilder;
  relativeY: (relativeY: number) => IArrowBuilder;
  defaultY: (defaultY: number) => IArrowBuilder;
  relativeX: (relativeX: number) => IArrowBuilder;
  fontFamily: (fontFamily: string) => IArrowBuilder;
  fontWeight: (fontWeight: NormalBold) => IArrowBuilder;
  fontStyle: (fontStyle: NormalItalic) => IArrowBuilder;
  fontSize: (fontSize: string) => IArrowBuilder;
  color: (color: string) => IArrowBuilder;
  placement: (placement: AboveBelow) => IArrowBuilder;
}

class ArrowBuilder implements IArrowBuilder {
  build: () => Arrow;
  patch: () => IAny[];
  arrowStyle: (arrowStyle: string) => IArrowBuilder;
  arrowDirection: (arrowDirection: string) => IArrowBuilder;
  circularArrow: (circularArrow: string) => IArrowBuilder;
  defaultX: (defaultX: number) => IArrowBuilder;
  relativeY: (relativeY: number) => IArrowBuilder;
  defaultY: (defaultY: number) => IArrowBuilder;
  relativeX: (relativeX: number) => IArrowBuilder;
  fontFamily: (fontFamily: string) => IArrowBuilder;
  fontWeight: (fontWeight: NormalBold) => IArrowBuilder;
  fontStyle: (fontStyle: NormalItalic) => IArrowBuilder;
  fontSize: (fontSize: string) => IArrowBuilder;
  color: (color: string) => IArrowBuilder;
  placement: (placement: AboveBelow) => IArrowBuilder;
  constructor(original?: Arrow) {
    let updates: Arrow = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Arrow => {
        checkInvariants();
        (updates as any)._class = "Arrow";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.arrowStyle = (spec: string): IArrowBuilder => {
        updates["arrowStyle"] = spec;
        delete childBuilders["arrowStyle;"];
        modifiedKeys["arrowStyle"] = true;
        return this;
    }

    this.arrowDirection = (spec: string): IArrowBuilder => {
        updates["arrowDirection"] = spec;
        delete childBuilders["arrowDirection;"];
        modifiedKeys["arrowDirection"] = true;
        return this;
    }

    this.circularArrow = (spec: string): IArrowBuilder => {
        updates["circularArrow"] = spec;
        delete childBuilders["circularArrow;"];
        modifiedKeys["circularArrow"] = true;
        return this;
    }

    this.defaultX = (spec: number): IArrowBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IArrowBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IArrowBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IArrowBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IArrowBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IArrowBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IArrowBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IArrowBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IArrowBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IArrowBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchArrow(base: Arrow, builder: (build: IArrowBuilder) => IArrowBuilder): IAny[] { return builder(new ArrowBuilder(base)).patch(); }
export function buildArrow(builder: (build: IArrowBuilder) => IArrowBuilder): Arrow { return builder(new ArrowBuilder()).build(); }

export interface IHandbellBuilder {
  build?: () => Handbell;
  patch: () => IAny[];
  data: (data: string) => IHandbellBuilder;
  defaultX: (defaultX: number) => IHandbellBuilder;
  relativeY: (relativeY: number) => IHandbellBuilder;
  defaultY: (defaultY: number) => IHandbellBuilder;
  relativeX: (relativeX: number) => IHandbellBuilder;
  fontFamily: (fontFamily: string) => IHandbellBuilder;
  fontWeight: (fontWeight: NormalBold) => IHandbellBuilder;
  fontStyle: (fontStyle: NormalItalic) => IHandbellBuilder;
  fontSize: (fontSize: string) => IHandbellBuilder;
  color: (color: string) => IHandbellBuilder;
  placement: (placement: AboveBelow) => IHandbellBuilder;
}

class HandbellBuilder implements IHandbellBuilder {
  build: () => Handbell;
  patch: () => IAny[];
  data: (data: string) => IHandbellBuilder;
  defaultX: (defaultX: number) => IHandbellBuilder;
  relativeY: (relativeY: number) => IHandbellBuilder;
  defaultY: (defaultY: number) => IHandbellBuilder;
  relativeX: (relativeX: number) => IHandbellBuilder;
  fontFamily: (fontFamily: string) => IHandbellBuilder;
  fontWeight: (fontWeight: NormalBold) => IHandbellBuilder;
  fontStyle: (fontStyle: NormalItalic) => IHandbellBuilder;
  fontSize: (fontSize: string) => IHandbellBuilder;
  color: (color: string) => IHandbellBuilder;
  placement: (placement: AboveBelow) => IHandbellBuilder;
  constructor(original?: Handbell) {
    let updates: Handbell = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): Handbell => {
        checkInvariants();
        (updates as any)._class = "Handbell";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IHandbellBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IHandbellBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IHandbellBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IHandbellBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IHandbellBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IHandbellBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IHandbellBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IHandbellBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IHandbellBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IHandbellBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IHandbellBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchHandbell(base: Handbell, builder: (build: IHandbellBuilder) => IHandbellBuilder): IAny[] { return builder(new HandbellBuilder(base)).patch(); }
export function buildHandbell(builder: (build: IHandbellBuilder) => IHandbellBuilder): Handbell { return builder(new HandbellBuilder()).build(); }

export interface IOtherTechnicalBuilder {
  build?: () => OtherTechnical;
  patch: () => IAny[];
  data: (data: string) => IOtherTechnicalBuilder;
  defaultX: (defaultX: number) => IOtherTechnicalBuilder;
  relativeY: (relativeY: number) => IOtherTechnicalBuilder;
  defaultY: (defaultY: number) => IOtherTechnicalBuilder;
  relativeX: (relativeX: number) => IOtherTechnicalBuilder;
  fontFamily: (fontFamily: string) => IOtherTechnicalBuilder;
  fontWeight: (fontWeight: NormalBold) => IOtherTechnicalBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOtherTechnicalBuilder;
  fontSize: (fontSize: string) => IOtherTechnicalBuilder;
  color: (color: string) => IOtherTechnicalBuilder;
  placement: (placement: AboveBelow) => IOtherTechnicalBuilder;
}

class OtherTechnicalBuilder implements IOtherTechnicalBuilder {
  build: () => OtherTechnical;
  patch: () => IAny[];
  data: (data: string) => IOtherTechnicalBuilder;
  defaultX: (defaultX: number) => IOtherTechnicalBuilder;
  relativeY: (relativeY: number) => IOtherTechnicalBuilder;
  defaultY: (defaultY: number) => IOtherTechnicalBuilder;
  relativeX: (relativeX: number) => IOtherTechnicalBuilder;
  fontFamily: (fontFamily: string) => IOtherTechnicalBuilder;
  fontWeight: (fontWeight: NormalBold) => IOtherTechnicalBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOtherTechnicalBuilder;
  fontSize: (fontSize: string) => IOtherTechnicalBuilder;
  color: (color: string) => IOtherTechnicalBuilder;
  placement: (placement: AboveBelow) => IOtherTechnicalBuilder;
  constructor(original?: OtherTechnical) {
    let updates: OtherTechnical = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): OtherTechnical => {
        checkInvariants();
        (updates as any)._class = "OtherTechnical";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IOtherTechnicalBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IOtherTechnicalBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IOtherTechnicalBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IOtherTechnicalBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IOtherTechnicalBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IOtherTechnicalBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IOtherTechnicalBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IOtherTechnicalBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IOtherTechnicalBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IOtherTechnicalBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IOtherTechnicalBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchOtherTechnical(base: OtherTechnical, builder: (build: IOtherTechnicalBuilder) => IOtherTechnicalBuilder): IAny[] { return builder(new OtherTechnicalBuilder(base)).patch(); }
export function buildOtherTechnical(builder: (build: IOtherTechnicalBuilder) => IOtherTechnicalBuilder): OtherTechnical { return builder(new OtherTechnicalBuilder()).build(); }

export interface IArticulationsBuilder {
  build?: () => Articulations;
  patch: () => IAny[];
  accent: (build: Accent | ((builder: IAccentBuilder) => IAccentBuilder)) => IArticulationsBuilder;
  doit: (build: Doit | ((builder: IDoitBuilder) => IDoitBuilder)) => IArticulationsBuilder;
  breathMark: (build: BreathMark | ((builder: IBreathMarkBuilder) => IBreathMarkBuilder)) => IArticulationsBuilder;
  otherArticulationsAt: (idx: number, build: OtherArticulation | ((builder: IOtherArticulationBuilder) => IOtherArticulationBuilder)) => IArticulationsBuilder;
  otherArticulationsSplice: (start: number, deleteCount: number, ...items: OtherArticulation[]) => IArticulationsBuilder;
  otherArticulations: (otherArticulations: OtherArticulation[]) => IArticulationsBuilder;
  detachedLegato: (build: DetachedLegato | ((builder: IDetachedLegatoBuilder) => IDetachedLegatoBuilder)) => IArticulationsBuilder;
  staccatissimo: (build: Staccatissimo | ((builder: IStaccatissimoBuilder) => IStaccatissimoBuilder)) => IArticulationsBuilder;
  plop: (build: Plop | ((builder: IPlopBuilder) => IPlopBuilder)) => IArticulationsBuilder;
  unstress: (build: Unstress | ((builder: IUnstressBuilder) => IUnstressBuilder)) => IArticulationsBuilder;
  strongAccent: (build: StrongAccent | ((builder: IStrongAccentBuilder) => IStrongAccentBuilder)) => IArticulationsBuilder;
  staccato: (build: Staccato | ((builder: IStaccatoBuilder) => IStaccatoBuilder)) => IArticulationsBuilder;
  spiccato: (build: Spiccato | ((builder: ISpiccatoBuilder) => ISpiccatoBuilder)) => IArticulationsBuilder;
  scoop: (build: Scoop | ((builder: IScoopBuilder) => IScoopBuilder)) => IArticulationsBuilder;
  falloff: (build: Falloff | ((builder: IFalloffBuilder) => IFalloffBuilder)) => IArticulationsBuilder;
  caesura: (build: Caesura | ((builder: ICaesuraBuilder) => ICaesuraBuilder)) => IArticulationsBuilder;
  stress: (build: Stress | ((builder: IStressBuilder) => IStressBuilder)) => IArticulationsBuilder;
  tenuto: (build: Tenuto | ((builder: ITenutoBuilder) => ITenutoBuilder)) => IArticulationsBuilder;
}

class ArticulationsBuilder implements IArticulationsBuilder {
  build: () => Articulations;
  patch: () => IAny[];
  accent: (build: Accent | ((builder: IAccentBuilder) => IAccentBuilder)) => IArticulationsBuilder;
  doit: (build: Doit | ((builder: IDoitBuilder) => IDoitBuilder)) => IArticulationsBuilder;
  breathMark: (build: BreathMark | ((builder: IBreathMarkBuilder) => IBreathMarkBuilder)) => IArticulationsBuilder;
  otherArticulationsAt: (idx: number, build: OtherArticulation | ((builder: IOtherArticulationBuilder) => IOtherArticulationBuilder)) => IArticulationsBuilder;
  otherArticulationsSplice: (start: number, deleteCount: number, ...items: OtherArticulation[]) => IArticulationsBuilder;
  otherArticulations: (otherArticulations: OtherArticulation[]) => IArticulationsBuilder;
  detachedLegato: (build: DetachedLegato | ((builder: IDetachedLegatoBuilder) => IDetachedLegatoBuilder)) => IArticulationsBuilder;
  staccatissimo: (build: Staccatissimo | ((builder: IStaccatissimoBuilder) => IStaccatissimoBuilder)) => IArticulationsBuilder;
  plop: (build: Plop | ((builder: IPlopBuilder) => IPlopBuilder)) => IArticulationsBuilder;
  unstress: (build: Unstress | ((builder: IUnstressBuilder) => IUnstressBuilder)) => IArticulationsBuilder;
  strongAccent: (build: StrongAccent | ((builder: IStrongAccentBuilder) => IStrongAccentBuilder)) => IArticulationsBuilder;
  staccato: (build: Staccato | ((builder: IStaccatoBuilder) => IStaccatoBuilder)) => IArticulationsBuilder;
  spiccato: (build: Spiccato | ((builder: ISpiccatoBuilder) => ISpiccatoBuilder)) => IArticulationsBuilder;
  scoop: (build: Scoop | ((builder: IScoopBuilder) => IScoopBuilder)) => IArticulationsBuilder;
  falloff: (build: Falloff | ((builder: IFalloffBuilder) => IFalloffBuilder)) => IArticulationsBuilder;
  caesura: (build: Caesura | ((builder: ICaesuraBuilder) => ICaesuraBuilder)) => IArticulationsBuilder;
  stress: (build: Stress | ((builder: IStressBuilder) => IStressBuilder)) => IArticulationsBuilder;
  tenuto: (build: Tenuto | ((builder: ITenutoBuilder) => ITenutoBuilder)) => IArticulationsBuilder;
  constructor(original?: Articulations) {
    let updates: Articulations = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Articulations => {
        checkInvariants();
        (updates as any)._class = "Articulations";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.accent = (build: Accent | ((builder: IAccentBuilder) => IAccentBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["accent"]
        const builder = (build as any)(new AccentBuilder(original && original["accent"]));
        if (!original) updates["accent"] = builder.build();
        else childBuilders["accent"] = builder;
      } else {
        updates.accent = build as any;
        delete childBuilders["accent;"];
      }
      modifiedKeys["accent"] = true;
      return this;
    }

    this.doit = (build: Doit | ((builder: IDoitBuilder) => IDoitBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["doit"]
        const builder = (build as any)(new DoitBuilder(original && original["doit"]));
        if (!original) updates["doit"] = builder.build();
        else childBuilders["doit"] = builder;
      } else {
        updates.doit = build as any;
        delete childBuilders["doit;"];
      }
      modifiedKeys["doit"] = true;
      return this;
    }

    this.breathMark = (build: BreathMark | ((builder: IBreathMarkBuilder) => IBreathMarkBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["breathMark"]
        const builder = (build as any)(new BreathMarkBuilder(original && original["breathMark"]));
        if (!original) updates["breathMark"] = builder.build();
        else childBuilders["breathMark"] = builder;
      } else {
        updates.breathMark = build as any;
        delete childBuilders["breathMark;"];
      }
      modifiedKeys["breathMark"] = true;
      return this;
    }

    this.otherArticulations = (spec: OtherArticulation[]): IArticulationsBuilder => {
        updates["otherArticulations"] = spec;
        delete childBuilders["otherArticulations;"];
        modifiedKeys["otherArticulations"] = true;
        return this;
    }

    this.otherArticulationsAt = (idx: number, build: OtherArticulation | ((builder: IOtherArticulationBuilder) => IOtherArticulationBuilder)): IArticulationsBuilder => {
      makeReference("otherArticulations");
      if (frozen["otherArticulations"][idx]) {
          throw new Error("Patching otherArticulations." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["otherArticulations"] && !original["otherArticulations"]) {
          // Clone snapshot.
          patches.push({p: ["otherArticulations", idx], li: original._snapshot["otherArticulations"]});
      }
      if (typeof build === 'function' && reference["otherArticulations"][idx]) {
        let patch = (build as any)(new OtherArticulationBuilder(reference["otherArticulations"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["otherArticulations", idx].concat(patch.p);
          return patch;
        }));
        frozen["otherArticulations"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new OtherArticulationBuilder(reference["otherArticulations"][idx])).build() : build;
      if (original) {
        patches.push({p: ["otherArticulations", idx], li: update});
      } else {
        updates["otherArticulations"] = reference["otherArticulations"]; // TODO: Merge?
      } 
      reference["otherArticulations"][idx] = update;
      frozen["otherArticulations"][idx] = true;
      return this;
    }

    this.otherArticulationsSplice = (start: number, deleteCount: number, ...items: OtherArticulation[]): IArticulationsBuilder => {
      makeReference("otherArticulations");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["otherArticulations"][idx]) {
            throw new Error("Replacing otherArticulations." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["otherArticulations"][idx];
          patches.push({p: ["otherArticulations", idx], ld, li: items[idx - start]});
          frozen["otherArticulations"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["otherArticulations"][idx]) {
            throw new Error("Removing otherArticulations." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["otherArticulations"][idx];
          patches.push({p: ["otherArticulations", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["otherArticulations", idx], li: items[idx - start]});
          frozen["otherArticulations"][idx] = true;
        }
      }
      reference["otherArticulations"].splice(start, deleteCount, ...items);
      updates["otherArticulations"] = reference["otherArticulations"];
      frozen["otherArticulations"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.detachedLegato = (build: DetachedLegato | ((builder: IDetachedLegatoBuilder) => IDetachedLegatoBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["detachedLegato"]
        const builder = (build as any)(new DetachedLegatoBuilder(original && original["detachedLegato"]));
        if (!original) updates["detachedLegato"] = builder.build();
        else childBuilders["detachedLegato"] = builder;
      } else {
        updates.detachedLegato = build as any;
        delete childBuilders["detachedLegato;"];
      }
      modifiedKeys["detachedLegato"] = true;
      return this;
    }

    this.staccatissimo = (build: Staccatissimo | ((builder: IStaccatissimoBuilder) => IStaccatissimoBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["staccatissimo"]
        const builder = (build as any)(new StaccatissimoBuilder(original && original["staccatissimo"]));
        if (!original) updates["staccatissimo"] = builder.build();
        else childBuilders["staccatissimo"] = builder;
      } else {
        updates.staccatissimo = build as any;
        delete childBuilders["staccatissimo;"];
      }
      modifiedKeys["staccatissimo"] = true;
      return this;
    }

    this.plop = (build: Plop | ((builder: IPlopBuilder) => IPlopBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["plop"]
        const builder = (build as any)(new PlopBuilder(original && original["plop"]));
        if (!original) updates["plop"] = builder.build();
        else childBuilders["plop"] = builder;
      } else {
        updates.plop = build as any;
        delete childBuilders["plop;"];
      }
      modifiedKeys["plop"] = true;
      return this;
    }

    this.unstress = (build: Unstress | ((builder: IUnstressBuilder) => IUnstressBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["unstress"]
        const builder = (build as any)(new UnstressBuilder(original && original["unstress"]));
        if (!original) updates["unstress"] = builder.build();
        else childBuilders["unstress"] = builder;
      } else {
        updates.unstress = build as any;
        delete childBuilders["unstress;"];
      }
      modifiedKeys["unstress"] = true;
      return this;
    }

    this.strongAccent = (build: StrongAccent | ((builder: IStrongAccentBuilder) => IStrongAccentBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["strongAccent"]
        const builder = (build as any)(new StrongAccentBuilder(original && original["strongAccent"]));
        if (!original) updates["strongAccent"] = builder.build();
        else childBuilders["strongAccent"] = builder;
      } else {
        updates.strongAccent = build as any;
        delete childBuilders["strongAccent;"];
      }
      modifiedKeys["strongAccent"] = true;
      return this;
    }

    this.staccato = (build: Staccato | ((builder: IStaccatoBuilder) => IStaccatoBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["staccato"]
        const builder = (build as any)(new StaccatoBuilder(original && original["staccato"]));
        if (!original) updates["staccato"] = builder.build();
        else childBuilders["staccato"] = builder;
      } else {
        updates.staccato = build as any;
        delete childBuilders["staccato;"];
      }
      modifiedKeys["staccato"] = true;
      return this;
    }

    this.spiccato = (build: Spiccato | ((builder: ISpiccatoBuilder) => ISpiccatoBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["spiccato"]
        const builder = (build as any)(new SpiccatoBuilder(original && original["spiccato"]));
        if (!original) updates["spiccato"] = builder.build();
        else childBuilders["spiccato"] = builder;
      } else {
        updates.spiccato = build as any;
        delete childBuilders["spiccato;"];
      }
      modifiedKeys["spiccato"] = true;
      return this;
    }

    this.scoop = (build: Scoop | ((builder: IScoopBuilder) => IScoopBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["scoop"]
        const builder = (build as any)(new ScoopBuilder(original && original["scoop"]));
        if (!original) updates["scoop"] = builder.build();
        else childBuilders["scoop"] = builder;
      } else {
        updates.scoop = build as any;
        delete childBuilders["scoop;"];
      }
      modifiedKeys["scoop"] = true;
      return this;
    }

    this.falloff = (build: Falloff | ((builder: IFalloffBuilder) => IFalloffBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["falloff"]
        const builder = (build as any)(new FalloffBuilder(original && original["falloff"]));
        if (!original) updates["falloff"] = builder.build();
        else childBuilders["falloff"] = builder;
      } else {
        updates.falloff = build as any;
        delete childBuilders["falloff;"];
      }
      modifiedKeys["falloff"] = true;
      return this;
    }

    this.caesura = (build: Caesura | ((builder: ICaesuraBuilder) => ICaesuraBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["caesura"]
        const builder = (build as any)(new CaesuraBuilder(original && original["caesura"]));
        if (!original) updates["caesura"] = builder.build();
        else childBuilders["caesura"] = builder;
      } else {
        updates.caesura = build as any;
        delete childBuilders["caesura;"];
      }
      modifiedKeys["caesura"] = true;
      return this;
    }

    this.stress = (build: Stress | ((builder: IStressBuilder) => IStressBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["stress"]
        const builder = (build as any)(new StressBuilder(original && original["stress"]));
        if (!original) updates["stress"] = builder.build();
        else childBuilders["stress"] = builder;
      } else {
        updates.stress = build as any;
        delete childBuilders["stress;"];
      }
      modifiedKeys["stress"] = true;
      return this;
    }

    this.tenuto = (build: Tenuto | ((builder: ITenutoBuilder) => ITenutoBuilder)): IArticulationsBuilder => {
      if (typeof build === 'function') {
        delete updates["tenuto"]
        const builder = (build as any)(new TenutoBuilder(original && original["tenuto"]));
        if (!original) updates["tenuto"] = builder.build();
        else childBuilders["tenuto"] = builder;
      } else {
        updates.tenuto = build as any;
        delete childBuilders["tenuto;"];
      }
      modifiedKeys["tenuto"] = true;
      return this;
    }
  }
}
export function patchArticulations(base: Articulations, builder: (build: IArticulationsBuilder) => IArticulationsBuilder): IAny[] { return builder(new ArticulationsBuilder(base)).patch(); }
export function buildArticulations(builder: (build: IArticulationsBuilder) => IArticulationsBuilder): Articulations { return builder(new ArticulationsBuilder()).build(); }

export interface IAccentBuilder {
  build?: () => Accent;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IAccentBuilder;
  relativeY: (relativeY: number) => IAccentBuilder;
  defaultY: (defaultY: number) => IAccentBuilder;
  relativeX: (relativeX: number) => IAccentBuilder;
  fontFamily: (fontFamily: string) => IAccentBuilder;
  fontWeight: (fontWeight: NormalBold) => IAccentBuilder;
  fontStyle: (fontStyle: NormalItalic) => IAccentBuilder;
  fontSize: (fontSize: string) => IAccentBuilder;
  color: (color: string) => IAccentBuilder;
  placement: (placement: AboveBelow) => IAccentBuilder;
}

class AccentBuilder implements IAccentBuilder {
  build: () => Accent;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IAccentBuilder;
  relativeY: (relativeY: number) => IAccentBuilder;
  defaultY: (defaultY: number) => IAccentBuilder;
  relativeX: (relativeX: number) => IAccentBuilder;
  fontFamily: (fontFamily: string) => IAccentBuilder;
  fontWeight: (fontWeight: NormalBold) => IAccentBuilder;
  fontStyle: (fontStyle: NormalItalic) => IAccentBuilder;
  fontSize: (fontSize: string) => IAccentBuilder;
  color: (color: string) => IAccentBuilder;
  placement: (placement: AboveBelow) => IAccentBuilder;
  constructor(original?: Accent) {
    let updates: Accent = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Accent => {
        checkInvariants();
        (updates as any)._class = "Accent";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IAccentBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IAccentBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IAccentBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IAccentBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IAccentBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IAccentBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IAccentBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IAccentBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IAccentBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IAccentBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchAccent(base: Accent, builder: (build: IAccentBuilder) => IAccentBuilder): IAny[] { return builder(new AccentBuilder(base)).patch(); }
export function buildAccent(builder: (build: IAccentBuilder) => IAccentBuilder): Accent { return builder(new AccentBuilder()).build(); }

export interface IStrongAccentBuilder {
  build?: () => StrongAccent;
  patch: () => IAny[];
  type: (type: UpDown) => IStrongAccentBuilder;
  defaultX: (defaultX: number) => IStrongAccentBuilder;
  relativeY: (relativeY: number) => IStrongAccentBuilder;
  defaultY: (defaultY: number) => IStrongAccentBuilder;
  relativeX: (relativeX: number) => IStrongAccentBuilder;
  fontFamily: (fontFamily: string) => IStrongAccentBuilder;
  fontWeight: (fontWeight: NormalBold) => IStrongAccentBuilder;
  fontStyle: (fontStyle: NormalItalic) => IStrongAccentBuilder;
  fontSize: (fontSize: string) => IStrongAccentBuilder;
  color: (color: string) => IStrongAccentBuilder;
  placement: (placement: AboveBelow) => IStrongAccentBuilder;
}

class StrongAccentBuilder implements IStrongAccentBuilder {
  build: () => StrongAccent;
  patch: () => IAny[];
  type: (type: UpDown) => IStrongAccentBuilder;
  defaultX: (defaultX: number) => IStrongAccentBuilder;
  relativeY: (relativeY: number) => IStrongAccentBuilder;
  defaultY: (defaultY: number) => IStrongAccentBuilder;
  relativeX: (relativeX: number) => IStrongAccentBuilder;
  fontFamily: (fontFamily: string) => IStrongAccentBuilder;
  fontWeight: (fontWeight: NormalBold) => IStrongAccentBuilder;
  fontStyle: (fontStyle: NormalItalic) => IStrongAccentBuilder;
  fontSize: (fontSize: string) => IStrongAccentBuilder;
  color: (color: string) => IStrongAccentBuilder;
  placement: (placement: AboveBelow) => IStrongAccentBuilder;
  constructor(original?: StrongAccent) {
    let updates: StrongAccent = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): StrongAccent => {
        checkInvariants();
        (updates as any)._class = "StrongAccent";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.type = (spec: UpDown): IStrongAccentBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): IStrongAccentBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IStrongAccentBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IStrongAccentBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IStrongAccentBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IStrongAccentBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IStrongAccentBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IStrongAccentBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IStrongAccentBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IStrongAccentBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IStrongAccentBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchStrongAccent(base: StrongAccent, builder: (build: IStrongAccentBuilder) => IStrongAccentBuilder): IAny[] { return builder(new StrongAccentBuilder(base)).patch(); }
export function buildStrongAccent(builder: (build: IStrongAccentBuilder) => IStrongAccentBuilder): StrongAccent { return builder(new StrongAccentBuilder()).build(); }

export interface IStaccatoBuilder {
  build?: () => Staccato;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IStaccatoBuilder;
  relativeY: (relativeY: number) => IStaccatoBuilder;
  defaultY: (defaultY: number) => IStaccatoBuilder;
  relativeX: (relativeX: number) => IStaccatoBuilder;
  fontFamily: (fontFamily: string) => IStaccatoBuilder;
  fontWeight: (fontWeight: NormalBold) => IStaccatoBuilder;
  fontStyle: (fontStyle: NormalItalic) => IStaccatoBuilder;
  fontSize: (fontSize: string) => IStaccatoBuilder;
  color: (color: string) => IStaccatoBuilder;
  placement: (placement: AboveBelow) => IStaccatoBuilder;
}

class StaccatoBuilder implements IStaccatoBuilder {
  build: () => Staccato;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IStaccatoBuilder;
  relativeY: (relativeY: number) => IStaccatoBuilder;
  defaultY: (defaultY: number) => IStaccatoBuilder;
  relativeX: (relativeX: number) => IStaccatoBuilder;
  fontFamily: (fontFamily: string) => IStaccatoBuilder;
  fontWeight: (fontWeight: NormalBold) => IStaccatoBuilder;
  fontStyle: (fontStyle: NormalItalic) => IStaccatoBuilder;
  fontSize: (fontSize: string) => IStaccatoBuilder;
  color: (color: string) => IStaccatoBuilder;
  placement: (placement: AboveBelow) => IStaccatoBuilder;
  constructor(original?: Staccato) {
    let updates: Staccato = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Staccato => {
        checkInvariants();
        (updates as any)._class = "Staccato";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IStaccatoBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IStaccatoBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IStaccatoBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IStaccatoBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IStaccatoBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IStaccatoBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IStaccatoBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IStaccatoBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IStaccatoBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IStaccatoBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchStaccato(base: Staccato, builder: (build: IStaccatoBuilder) => IStaccatoBuilder): IAny[] { return builder(new StaccatoBuilder(base)).patch(); }
export function buildStaccato(builder: (build: IStaccatoBuilder) => IStaccatoBuilder): Staccato { return builder(new StaccatoBuilder()).build(); }

export interface ITenutoBuilder {
  build?: () => Tenuto;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ITenutoBuilder;
  relativeY: (relativeY: number) => ITenutoBuilder;
  defaultY: (defaultY: number) => ITenutoBuilder;
  relativeX: (relativeX: number) => ITenutoBuilder;
  fontFamily: (fontFamily: string) => ITenutoBuilder;
  fontWeight: (fontWeight: NormalBold) => ITenutoBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITenutoBuilder;
  fontSize: (fontSize: string) => ITenutoBuilder;
  color: (color: string) => ITenutoBuilder;
  placement: (placement: AboveBelow) => ITenutoBuilder;
}

class TenutoBuilder implements ITenutoBuilder {
  build: () => Tenuto;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ITenutoBuilder;
  relativeY: (relativeY: number) => ITenutoBuilder;
  defaultY: (defaultY: number) => ITenutoBuilder;
  relativeX: (relativeX: number) => ITenutoBuilder;
  fontFamily: (fontFamily: string) => ITenutoBuilder;
  fontWeight: (fontWeight: NormalBold) => ITenutoBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITenutoBuilder;
  fontSize: (fontSize: string) => ITenutoBuilder;
  color: (color: string) => ITenutoBuilder;
  placement: (placement: AboveBelow) => ITenutoBuilder;
  constructor(original?: Tenuto) {
    let updates: Tenuto = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Tenuto => {
        checkInvariants();
        (updates as any)._class = "Tenuto";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): ITenutoBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ITenutoBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ITenutoBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ITenutoBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ITenutoBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ITenutoBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ITenutoBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ITenutoBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ITenutoBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): ITenutoBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchTenuto(base: Tenuto, builder: (build: ITenutoBuilder) => ITenutoBuilder): IAny[] { return builder(new TenutoBuilder(base)).patch(); }
export function buildTenuto(builder: (build: ITenutoBuilder) => ITenutoBuilder): Tenuto { return builder(new TenutoBuilder()).build(); }

export interface IDetachedLegatoBuilder {
  build?: () => DetachedLegato;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IDetachedLegatoBuilder;
  relativeY: (relativeY: number) => IDetachedLegatoBuilder;
  defaultY: (defaultY: number) => IDetachedLegatoBuilder;
  relativeX: (relativeX: number) => IDetachedLegatoBuilder;
  fontFamily: (fontFamily: string) => IDetachedLegatoBuilder;
  fontWeight: (fontWeight: NormalBold) => IDetachedLegatoBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDetachedLegatoBuilder;
  fontSize: (fontSize: string) => IDetachedLegatoBuilder;
  color: (color: string) => IDetachedLegatoBuilder;
  placement: (placement: AboveBelow) => IDetachedLegatoBuilder;
}

class DetachedLegatoBuilder implements IDetachedLegatoBuilder {
  build: () => DetachedLegato;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IDetachedLegatoBuilder;
  relativeY: (relativeY: number) => IDetachedLegatoBuilder;
  defaultY: (defaultY: number) => IDetachedLegatoBuilder;
  relativeX: (relativeX: number) => IDetachedLegatoBuilder;
  fontFamily: (fontFamily: string) => IDetachedLegatoBuilder;
  fontWeight: (fontWeight: NormalBold) => IDetachedLegatoBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDetachedLegatoBuilder;
  fontSize: (fontSize: string) => IDetachedLegatoBuilder;
  color: (color: string) => IDetachedLegatoBuilder;
  placement: (placement: AboveBelow) => IDetachedLegatoBuilder;
  constructor(original?: DetachedLegato) {
    let updates: DetachedLegato = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): DetachedLegato => {
        checkInvariants();
        (updates as any)._class = "DetachedLegato";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IDetachedLegatoBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDetachedLegatoBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDetachedLegatoBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDetachedLegatoBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDetachedLegatoBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDetachedLegatoBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDetachedLegatoBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDetachedLegatoBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDetachedLegatoBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IDetachedLegatoBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchDetachedLegato(base: DetachedLegato, builder: (build: IDetachedLegatoBuilder) => IDetachedLegatoBuilder): IAny[] { return builder(new DetachedLegatoBuilder(base)).patch(); }
export function buildDetachedLegato(builder: (build: IDetachedLegatoBuilder) => IDetachedLegatoBuilder): DetachedLegato { return builder(new DetachedLegatoBuilder()).build(); }

export interface IStaccatissimoBuilder {
  build?: () => Staccatissimo;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IStaccatissimoBuilder;
  relativeY: (relativeY: number) => IStaccatissimoBuilder;
  defaultY: (defaultY: number) => IStaccatissimoBuilder;
  relativeX: (relativeX: number) => IStaccatissimoBuilder;
  fontFamily: (fontFamily: string) => IStaccatissimoBuilder;
  fontWeight: (fontWeight: NormalBold) => IStaccatissimoBuilder;
  fontStyle: (fontStyle: NormalItalic) => IStaccatissimoBuilder;
  fontSize: (fontSize: string) => IStaccatissimoBuilder;
  color: (color: string) => IStaccatissimoBuilder;
  placement: (placement: AboveBelow) => IStaccatissimoBuilder;
}

class StaccatissimoBuilder implements IStaccatissimoBuilder {
  build: () => Staccatissimo;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IStaccatissimoBuilder;
  relativeY: (relativeY: number) => IStaccatissimoBuilder;
  defaultY: (defaultY: number) => IStaccatissimoBuilder;
  relativeX: (relativeX: number) => IStaccatissimoBuilder;
  fontFamily: (fontFamily: string) => IStaccatissimoBuilder;
  fontWeight: (fontWeight: NormalBold) => IStaccatissimoBuilder;
  fontStyle: (fontStyle: NormalItalic) => IStaccatissimoBuilder;
  fontSize: (fontSize: string) => IStaccatissimoBuilder;
  color: (color: string) => IStaccatissimoBuilder;
  placement: (placement: AboveBelow) => IStaccatissimoBuilder;
  constructor(original?: Staccatissimo) {
    let updates: Staccatissimo = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Staccatissimo => {
        checkInvariants();
        (updates as any)._class = "Staccatissimo";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IStaccatissimoBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IStaccatissimoBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IStaccatissimoBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IStaccatissimoBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IStaccatissimoBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IStaccatissimoBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IStaccatissimoBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IStaccatissimoBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IStaccatissimoBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IStaccatissimoBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchStaccatissimo(base: Staccatissimo, builder: (build: IStaccatissimoBuilder) => IStaccatissimoBuilder): IAny[] { return builder(new StaccatissimoBuilder(base)).patch(); }
export function buildStaccatissimo(builder: (build: IStaccatissimoBuilder) => IStaccatissimoBuilder): Staccatissimo { return builder(new StaccatissimoBuilder()).build(); }

export interface ISpiccatoBuilder {
  build?: () => Spiccato;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ISpiccatoBuilder;
  relativeY: (relativeY: number) => ISpiccatoBuilder;
  defaultY: (defaultY: number) => ISpiccatoBuilder;
  relativeX: (relativeX: number) => ISpiccatoBuilder;
  fontFamily: (fontFamily: string) => ISpiccatoBuilder;
  fontWeight: (fontWeight: NormalBold) => ISpiccatoBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISpiccatoBuilder;
  fontSize: (fontSize: string) => ISpiccatoBuilder;
  color: (color: string) => ISpiccatoBuilder;
  placement: (placement: AboveBelow) => ISpiccatoBuilder;
}

class SpiccatoBuilder implements ISpiccatoBuilder {
  build: () => Spiccato;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ISpiccatoBuilder;
  relativeY: (relativeY: number) => ISpiccatoBuilder;
  defaultY: (defaultY: number) => ISpiccatoBuilder;
  relativeX: (relativeX: number) => ISpiccatoBuilder;
  fontFamily: (fontFamily: string) => ISpiccatoBuilder;
  fontWeight: (fontWeight: NormalBold) => ISpiccatoBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISpiccatoBuilder;
  fontSize: (fontSize: string) => ISpiccatoBuilder;
  color: (color: string) => ISpiccatoBuilder;
  placement: (placement: AboveBelow) => ISpiccatoBuilder;
  constructor(original?: Spiccato) {
    let updates: Spiccato = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Spiccato => {
        checkInvariants();
        (updates as any)._class = "Spiccato";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): ISpiccatoBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ISpiccatoBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ISpiccatoBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ISpiccatoBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ISpiccatoBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ISpiccatoBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ISpiccatoBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ISpiccatoBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ISpiccatoBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): ISpiccatoBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchSpiccato(base: Spiccato, builder: (build: ISpiccatoBuilder) => ISpiccatoBuilder): IAny[] { return builder(new SpiccatoBuilder(base)).patch(); }
export function buildSpiccato(builder: (build: ISpiccatoBuilder) => ISpiccatoBuilder): Spiccato { return builder(new SpiccatoBuilder()).build(); }

export interface IScoopBuilder {
  build?: () => Scoop;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IScoopBuilder;
  relativeY: (relativeY: number) => IScoopBuilder;
  defaultY: (defaultY: number) => IScoopBuilder;
  relativeX: (relativeX: number) => IScoopBuilder;
  fontFamily: (fontFamily: string) => IScoopBuilder;
  fontWeight: (fontWeight: NormalBold) => IScoopBuilder;
  fontStyle: (fontStyle: NormalItalic) => IScoopBuilder;
  fontSize: (fontSize: string) => IScoopBuilder;
  color: (color: string) => IScoopBuilder;
  placement: (placement: AboveBelow) => IScoopBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IScoopBuilder;
  dashLength: (dashLength: number) => IScoopBuilder;
  spaceLength: (spaceLength: number) => IScoopBuilder;
  lineShape: (lineShape: StraightCurved) => IScoopBuilder;
}

class ScoopBuilder implements IScoopBuilder {
  build: () => Scoop;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IScoopBuilder;
  relativeY: (relativeY: number) => IScoopBuilder;
  defaultY: (defaultY: number) => IScoopBuilder;
  relativeX: (relativeX: number) => IScoopBuilder;
  fontFamily: (fontFamily: string) => IScoopBuilder;
  fontWeight: (fontWeight: NormalBold) => IScoopBuilder;
  fontStyle: (fontStyle: NormalItalic) => IScoopBuilder;
  fontSize: (fontSize: string) => IScoopBuilder;
  color: (color: string) => IScoopBuilder;
  placement: (placement: AboveBelow) => IScoopBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IScoopBuilder;
  dashLength: (dashLength: number) => IScoopBuilder;
  spaceLength: (spaceLength: number) => IScoopBuilder;
  lineShape: (lineShape: StraightCurved) => IScoopBuilder;
  constructor(original?: Scoop) {
    let updates: Scoop = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Scoop => {
        checkInvariants();
        (updates as any)._class = "Scoop";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IScoopBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IScoopBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IScoopBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IScoopBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IScoopBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IScoopBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IScoopBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IScoopBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IScoopBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IScoopBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.lineType = (spec: SolidDashedDottedWavy): IScoopBuilder => {
        updates["lineType"] = spec;
        delete childBuilders["lineType;"];
        modifiedKeys["lineType"] = true;
        return this;
    }

    this.dashLength = (spec: number): IScoopBuilder => {
        updates["dashLength"] = spec;
        delete childBuilders["dashLength;"];
        modifiedKeys["dashLength"] = true;
        return this;
    }

    this.spaceLength = (spec: number): IScoopBuilder => {
        updates["spaceLength"] = spec;
        delete childBuilders["spaceLength;"];
        modifiedKeys["spaceLength"] = true;
        return this;
    }

    this.lineShape = (spec: StraightCurved): IScoopBuilder => {
        updates["lineShape"] = spec;
        delete childBuilders["lineShape;"];
        modifiedKeys["lineShape"] = true;
        return this;
    }
  }
}
export function patchScoop(base: Scoop, builder: (build: IScoopBuilder) => IScoopBuilder): IAny[] { return builder(new ScoopBuilder(base)).patch(); }
export function buildScoop(builder: (build: IScoopBuilder) => IScoopBuilder): Scoop { return builder(new ScoopBuilder()).build(); }

export interface IPlopBuilder {
  build?: () => Plop;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IPlopBuilder;
  relativeY: (relativeY: number) => IPlopBuilder;
  defaultY: (defaultY: number) => IPlopBuilder;
  relativeX: (relativeX: number) => IPlopBuilder;
  fontFamily: (fontFamily: string) => IPlopBuilder;
  fontWeight: (fontWeight: NormalBold) => IPlopBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPlopBuilder;
  fontSize: (fontSize: string) => IPlopBuilder;
  color: (color: string) => IPlopBuilder;
  placement: (placement: AboveBelow) => IPlopBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IPlopBuilder;
  dashLength: (dashLength: number) => IPlopBuilder;
  spaceLength: (spaceLength: number) => IPlopBuilder;
  lineShape: (lineShape: StraightCurved) => IPlopBuilder;
}

class PlopBuilder implements IPlopBuilder {
  build: () => Plop;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IPlopBuilder;
  relativeY: (relativeY: number) => IPlopBuilder;
  defaultY: (defaultY: number) => IPlopBuilder;
  relativeX: (relativeX: number) => IPlopBuilder;
  fontFamily: (fontFamily: string) => IPlopBuilder;
  fontWeight: (fontWeight: NormalBold) => IPlopBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPlopBuilder;
  fontSize: (fontSize: string) => IPlopBuilder;
  color: (color: string) => IPlopBuilder;
  placement: (placement: AboveBelow) => IPlopBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IPlopBuilder;
  dashLength: (dashLength: number) => IPlopBuilder;
  spaceLength: (spaceLength: number) => IPlopBuilder;
  lineShape: (lineShape: StraightCurved) => IPlopBuilder;
  constructor(original?: Plop) {
    let updates: Plop = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Plop => {
        checkInvariants();
        (updates as any)._class = "Plop";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IPlopBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IPlopBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IPlopBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IPlopBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IPlopBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IPlopBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IPlopBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IPlopBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IPlopBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IPlopBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.lineType = (spec: SolidDashedDottedWavy): IPlopBuilder => {
        updates["lineType"] = spec;
        delete childBuilders["lineType;"];
        modifiedKeys["lineType"] = true;
        return this;
    }

    this.dashLength = (spec: number): IPlopBuilder => {
        updates["dashLength"] = spec;
        delete childBuilders["dashLength;"];
        modifiedKeys["dashLength"] = true;
        return this;
    }

    this.spaceLength = (spec: number): IPlopBuilder => {
        updates["spaceLength"] = spec;
        delete childBuilders["spaceLength;"];
        modifiedKeys["spaceLength"] = true;
        return this;
    }

    this.lineShape = (spec: StraightCurved): IPlopBuilder => {
        updates["lineShape"] = spec;
        delete childBuilders["lineShape;"];
        modifiedKeys["lineShape"] = true;
        return this;
    }
  }
}
export function patchPlop(base: Plop, builder: (build: IPlopBuilder) => IPlopBuilder): IAny[] { return builder(new PlopBuilder(base)).patch(); }
export function buildPlop(builder: (build: IPlopBuilder) => IPlopBuilder): Plop { return builder(new PlopBuilder()).build(); }

export interface IDoitBuilder {
  build?: () => Doit;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IDoitBuilder;
  relativeY: (relativeY: number) => IDoitBuilder;
  defaultY: (defaultY: number) => IDoitBuilder;
  relativeX: (relativeX: number) => IDoitBuilder;
  fontFamily: (fontFamily: string) => IDoitBuilder;
  fontWeight: (fontWeight: NormalBold) => IDoitBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDoitBuilder;
  fontSize: (fontSize: string) => IDoitBuilder;
  color: (color: string) => IDoitBuilder;
  placement: (placement: AboveBelow) => IDoitBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IDoitBuilder;
  dashLength: (dashLength: number) => IDoitBuilder;
  spaceLength: (spaceLength: number) => IDoitBuilder;
  lineShape: (lineShape: StraightCurved) => IDoitBuilder;
}

class DoitBuilder implements IDoitBuilder {
  build: () => Doit;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IDoitBuilder;
  relativeY: (relativeY: number) => IDoitBuilder;
  defaultY: (defaultY: number) => IDoitBuilder;
  relativeX: (relativeX: number) => IDoitBuilder;
  fontFamily: (fontFamily: string) => IDoitBuilder;
  fontWeight: (fontWeight: NormalBold) => IDoitBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDoitBuilder;
  fontSize: (fontSize: string) => IDoitBuilder;
  color: (color: string) => IDoitBuilder;
  placement: (placement: AboveBelow) => IDoitBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IDoitBuilder;
  dashLength: (dashLength: number) => IDoitBuilder;
  spaceLength: (spaceLength: number) => IDoitBuilder;
  lineShape: (lineShape: StraightCurved) => IDoitBuilder;
  constructor(original?: Doit) {
    let updates: Doit = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Doit => {
        checkInvariants();
        (updates as any)._class = "Doit";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IDoitBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDoitBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDoitBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDoitBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDoitBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDoitBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDoitBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDoitBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDoitBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IDoitBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.lineType = (spec: SolidDashedDottedWavy): IDoitBuilder => {
        updates["lineType"] = spec;
        delete childBuilders["lineType;"];
        modifiedKeys["lineType"] = true;
        return this;
    }

    this.dashLength = (spec: number): IDoitBuilder => {
        updates["dashLength"] = spec;
        delete childBuilders["dashLength;"];
        modifiedKeys["dashLength"] = true;
        return this;
    }

    this.spaceLength = (spec: number): IDoitBuilder => {
        updates["spaceLength"] = spec;
        delete childBuilders["spaceLength;"];
        modifiedKeys["spaceLength"] = true;
        return this;
    }

    this.lineShape = (spec: StraightCurved): IDoitBuilder => {
        updates["lineShape"] = spec;
        delete childBuilders["lineShape;"];
        modifiedKeys["lineShape"] = true;
        return this;
    }
  }
}
export function patchDoit(base: Doit, builder: (build: IDoitBuilder) => IDoitBuilder): IAny[] { return builder(new DoitBuilder(base)).patch(); }
export function buildDoit(builder: (build: IDoitBuilder) => IDoitBuilder): Doit { return builder(new DoitBuilder()).build(); }

export interface IFalloffBuilder {
  build?: () => Falloff;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IFalloffBuilder;
  relativeY: (relativeY: number) => IFalloffBuilder;
  defaultY: (defaultY: number) => IFalloffBuilder;
  relativeX: (relativeX: number) => IFalloffBuilder;
  fontFamily: (fontFamily: string) => IFalloffBuilder;
  fontWeight: (fontWeight: NormalBold) => IFalloffBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFalloffBuilder;
  fontSize: (fontSize: string) => IFalloffBuilder;
  color: (color: string) => IFalloffBuilder;
  placement: (placement: AboveBelow) => IFalloffBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IFalloffBuilder;
  dashLength: (dashLength: number) => IFalloffBuilder;
  spaceLength: (spaceLength: number) => IFalloffBuilder;
  lineShape: (lineShape: StraightCurved) => IFalloffBuilder;
}

class FalloffBuilder implements IFalloffBuilder {
  build: () => Falloff;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IFalloffBuilder;
  relativeY: (relativeY: number) => IFalloffBuilder;
  defaultY: (defaultY: number) => IFalloffBuilder;
  relativeX: (relativeX: number) => IFalloffBuilder;
  fontFamily: (fontFamily: string) => IFalloffBuilder;
  fontWeight: (fontWeight: NormalBold) => IFalloffBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFalloffBuilder;
  fontSize: (fontSize: string) => IFalloffBuilder;
  color: (color: string) => IFalloffBuilder;
  placement: (placement: AboveBelow) => IFalloffBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IFalloffBuilder;
  dashLength: (dashLength: number) => IFalloffBuilder;
  spaceLength: (spaceLength: number) => IFalloffBuilder;
  lineShape: (lineShape: StraightCurved) => IFalloffBuilder;
  constructor(original?: Falloff) {
    let updates: Falloff = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Falloff => {
        checkInvariants();
        (updates as any)._class = "Falloff";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IFalloffBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IFalloffBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IFalloffBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IFalloffBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IFalloffBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IFalloffBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IFalloffBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IFalloffBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IFalloffBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IFalloffBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.lineType = (spec: SolidDashedDottedWavy): IFalloffBuilder => {
        updates["lineType"] = spec;
        delete childBuilders["lineType;"];
        modifiedKeys["lineType"] = true;
        return this;
    }

    this.dashLength = (spec: number): IFalloffBuilder => {
        updates["dashLength"] = spec;
        delete childBuilders["dashLength;"];
        modifiedKeys["dashLength"] = true;
        return this;
    }

    this.spaceLength = (spec: number): IFalloffBuilder => {
        updates["spaceLength"] = spec;
        delete childBuilders["spaceLength;"];
        modifiedKeys["spaceLength"] = true;
        return this;
    }

    this.lineShape = (spec: StraightCurved): IFalloffBuilder => {
        updates["lineShape"] = spec;
        delete childBuilders["lineShape;"];
        modifiedKeys["lineShape"] = true;
        return this;
    }
  }
}
export function patchFalloff(base: Falloff, builder: (build: IFalloffBuilder) => IFalloffBuilder): IAny[] { return builder(new FalloffBuilder(base)).patch(); }
export function buildFalloff(builder: (build: IFalloffBuilder) => IFalloffBuilder): Falloff { return builder(new FalloffBuilder()).build(); }

export interface IBreathMarkBuilder {
  build?: () => BreathMark;
  patch: () => IAny[];
  type: (type: BreathMarkType) => IBreathMarkBuilder;
  defaultX: (defaultX: number) => IBreathMarkBuilder;
  relativeY: (relativeY: number) => IBreathMarkBuilder;
  defaultY: (defaultY: number) => IBreathMarkBuilder;
  relativeX: (relativeX: number) => IBreathMarkBuilder;
  fontFamily: (fontFamily: string) => IBreathMarkBuilder;
  fontWeight: (fontWeight: NormalBold) => IBreathMarkBuilder;
  fontStyle: (fontStyle: NormalItalic) => IBreathMarkBuilder;
  fontSize: (fontSize: string) => IBreathMarkBuilder;
  color: (color: string) => IBreathMarkBuilder;
  placement: (placement: AboveBelow) => IBreathMarkBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IBreathMarkBuilder;
  dashLength: (dashLength: number) => IBreathMarkBuilder;
  spaceLength: (spaceLength: number) => IBreathMarkBuilder;
  lineShape: (lineShape: StraightCurved) => IBreathMarkBuilder;
}

class BreathMarkBuilder implements IBreathMarkBuilder {
  build: () => BreathMark;
  patch: () => IAny[];
  type: (type: BreathMarkType) => IBreathMarkBuilder;
  defaultX: (defaultX: number) => IBreathMarkBuilder;
  relativeY: (relativeY: number) => IBreathMarkBuilder;
  defaultY: (defaultY: number) => IBreathMarkBuilder;
  relativeX: (relativeX: number) => IBreathMarkBuilder;
  fontFamily: (fontFamily: string) => IBreathMarkBuilder;
  fontWeight: (fontWeight: NormalBold) => IBreathMarkBuilder;
  fontStyle: (fontStyle: NormalItalic) => IBreathMarkBuilder;
  fontSize: (fontSize: string) => IBreathMarkBuilder;
  color: (color: string) => IBreathMarkBuilder;
  placement: (placement: AboveBelow) => IBreathMarkBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IBreathMarkBuilder;
  dashLength: (dashLength: number) => IBreathMarkBuilder;
  spaceLength: (spaceLength: number) => IBreathMarkBuilder;
  lineShape: (lineShape: StraightCurved) => IBreathMarkBuilder;
  constructor(original?: BreathMark) {
    let updates: BreathMark = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): BreathMark => {
        checkInvariants();
        (updates as any)._class = "BreathMark";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.type = (spec: BreathMarkType): IBreathMarkBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): IBreathMarkBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IBreathMarkBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IBreathMarkBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IBreathMarkBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IBreathMarkBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IBreathMarkBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IBreathMarkBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IBreathMarkBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IBreathMarkBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IBreathMarkBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.lineType = (spec: SolidDashedDottedWavy): IBreathMarkBuilder => {
        updates["lineType"] = spec;
        delete childBuilders["lineType;"];
        modifiedKeys["lineType"] = true;
        return this;
    }

    this.dashLength = (spec: number): IBreathMarkBuilder => {
        updates["dashLength"] = spec;
        delete childBuilders["dashLength;"];
        modifiedKeys["dashLength"] = true;
        return this;
    }

    this.spaceLength = (spec: number): IBreathMarkBuilder => {
        updates["spaceLength"] = spec;
        delete childBuilders["spaceLength;"];
        modifiedKeys["spaceLength"] = true;
        return this;
    }

    this.lineShape = (spec: StraightCurved): IBreathMarkBuilder => {
        updates["lineShape"] = spec;
        delete childBuilders["lineShape;"];
        modifiedKeys["lineShape"] = true;
        return this;
    }
  }
}
export function patchBreathMark(base: BreathMark, builder: (build: IBreathMarkBuilder) => IBreathMarkBuilder): IAny[] { return builder(new BreathMarkBuilder(base)).patch(); }
export function buildBreathMark(builder: (build: IBreathMarkBuilder) => IBreathMarkBuilder): BreathMark { return builder(new BreathMarkBuilder()).build(); }

export interface ICaesuraBuilder {
  build?: () => Caesura;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ICaesuraBuilder;
  relativeY: (relativeY: number) => ICaesuraBuilder;
  defaultY: (defaultY: number) => ICaesuraBuilder;
  relativeX: (relativeX: number) => ICaesuraBuilder;
  fontFamily: (fontFamily: string) => ICaesuraBuilder;
  fontWeight: (fontWeight: NormalBold) => ICaesuraBuilder;
  fontStyle: (fontStyle: NormalItalic) => ICaesuraBuilder;
  fontSize: (fontSize: string) => ICaesuraBuilder;
  color: (color: string) => ICaesuraBuilder;
  placement: (placement: AboveBelow) => ICaesuraBuilder;
}

class CaesuraBuilder implements ICaesuraBuilder {
  build: () => Caesura;
  patch: () => IAny[];
  defaultX: (defaultX: number) => ICaesuraBuilder;
  relativeY: (relativeY: number) => ICaesuraBuilder;
  defaultY: (defaultY: number) => ICaesuraBuilder;
  relativeX: (relativeX: number) => ICaesuraBuilder;
  fontFamily: (fontFamily: string) => ICaesuraBuilder;
  fontWeight: (fontWeight: NormalBold) => ICaesuraBuilder;
  fontStyle: (fontStyle: NormalItalic) => ICaesuraBuilder;
  fontSize: (fontSize: string) => ICaesuraBuilder;
  color: (color: string) => ICaesuraBuilder;
  placement: (placement: AboveBelow) => ICaesuraBuilder;
  constructor(original?: Caesura) {
    let updates: Caesura = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Caesura => {
        checkInvariants();
        (updates as any)._class = "Caesura";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): ICaesuraBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ICaesuraBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ICaesuraBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ICaesuraBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ICaesuraBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ICaesuraBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ICaesuraBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ICaesuraBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ICaesuraBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): ICaesuraBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchCaesura(base: Caesura, builder: (build: ICaesuraBuilder) => ICaesuraBuilder): IAny[] { return builder(new CaesuraBuilder(base)).patch(); }
export function buildCaesura(builder: (build: ICaesuraBuilder) => ICaesuraBuilder): Caesura { return builder(new CaesuraBuilder()).build(); }

export interface IStressBuilder {
  build?: () => Stress;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IStressBuilder;
  relativeY: (relativeY: number) => IStressBuilder;
  defaultY: (defaultY: number) => IStressBuilder;
  relativeX: (relativeX: number) => IStressBuilder;
  fontFamily: (fontFamily: string) => IStressBuilder;
  fontWeight: (fontWeight: NormalBold) => IStressBuilder;
  fontStyle: (fontStyle: NormalItalic) => IStressBuilder;
  fontSize: (fontSize: string) => IStressBuilder;
  color: (color: string) => IStressBuilder;
  placement: (placement: AboveBelow) => IStressBuilder;
}

class StressBuilder implements IStressBuilder {
  build: () => Stress;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IStressBuilder;
  relativeY: (relativeY: number) => IStressBuilder;
  defaultY: (defaultY: number) => IStressBuilder;
  relativeX: (relativeX: number) => IStressBuilder;
  fontFamily: (fontFamily: string) => IStressBuilder;
  fontWeight: (fontWeight: NormalBold) => IStressBuilder;
  fontStyle: (fontStyle: NormalItalic) => IStressBuilder;
  fontSize: (fontSize: string) => IStressBuilder;
  color: (color: string) => IStressBuilder;
  placement: (placement: AboveBelow) => IStressBuilder;
  constructor(original?: Stress) {
    let updates: Stress = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Stress => {
        checkInvariants();
        (updates as any)._class = "Stress";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IStressBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IStressBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IStressBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IStressBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IStressBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IStressBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IStressBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IStressBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IStressBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IStressBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchStress(base: Stress, builder: (build: IStressBuilder) => IStressBuilder): IAny[] { return builder(new StressBuilder(base)).patch(); }
export function buildStress(builder: (build: IStressBuilder) => IStressBuilder): Stress { return builder(new StressBuilder()).build(); }

export interface IUnstressBuilder {
  build?: () => Unstress;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IUnstressBuilder;
  relativeY: (relativeY: number) => IUnstressBuilder;
  defaultY: (defaultY: number) => IUnstressBuilder;
  relativeX: (relativeX: number) => IUnstressBuilder;
  fontFamily: (fontFamily: string) => IUnstressBuilder;
  fontWeight: (fontWeight: NormalBold) => IUnstressBuilder;
  fontStyle: (fontStyle: NormalItalic) => IUnstressBuilder;
  fontSize: (fontSize: string) => IUnstressBuilder;
  color: (color: string) => IUnstressBuilder;
  placement: (placement: AboveBelow) => IUnstressBuilder;
}

class UnstressBuilder implements IUnstressBuilder {
  build: () => Unstress;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IUnstressBuilder;
  relativeY: (relativeY: number) => IUnstressBuilder;
  defaultY: (defaultY: number) => IUnstressBuilder;
  relativeX: (relativeX: number) => IUnstressBuilder;
  fontFamily: (fontFamily: string) => IUnstressBuilder;
  fontWeight: (fontWeight: NormalBold) => IUnstressBuilder;
  fontStyle: (fontStyle: NormalItalic) => IUnstressBuilder;
  fontSize: (fontSize: string) => IUnstressBuilder;
  color: (color: string) => IUnstressBuilder;
  placement: (placement: AboveBelow) => IUnstressBuilder;
  constructor(original?: Unstress) {
    let updates: Unstress = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Unstress => {
        checkInvariants();
        (updates as any)._class = "Unstress";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IUnstressBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IUnstressBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IUnstressBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IUnstressBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IUnstressBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IUnstressBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IUnstressBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IUnstressBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IUnstressBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IUnstressBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchUnstress(base: Unstress, builder: (build: IUnstressBuilder) => IUnstressBuilder): IAny[] { return builder(new UnstressBuilder(base)).patch(); }
export function buildUnstress(builder: (build: IUnstressBuilder) => IUnstressBuilder): Unstress { return builder(new UnstressBuilder()).build(); }

export interface IOtherArticulationBuilder {
  build?: () => OtherArticulation;
  patch: () => IAny[];
  data: (data: string) => IOtherArticulationBuilder;
  defaultX: (defaultX: number) => IOtherArticulationBuilder;
  relativeY: (relativeY: number) => IOtherArticulationBuilder;
  defaultY: (defaultY: number) => IOtherArticulationBuilder;
  relativeX: (relativeX: number) => IOtherArticulationBuilder;
  fontFamily: (fontFamily: string) => IOtherArticulationBuilder;
  fontWeight: (fontWeight: NormalBold) => IOtherArticulationBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOtherArticulationBuilder;
  fontSize: (fontSize: string) => IOtherArticulationBuilder;
  color: (color: string) => IOtherArticulationBuilder;
  placement: (placement: AboveBelow) => IOtherArticulationBuilder;
}

class OtherArticulationBuilder implements IOtherArticulationBuilder {
  build: () => OtherArticulation;
  patch: () => IAny[];
  data: (data: string) => IOtherArticulationBuilder;
  defaultX: (defaultX: number) => IOtherArticulationBuilder;
  relativeY: (relativeY: number) => IOtherArticulationBuilder;
  defaultY: (defaultY: number) => IOtherArticulationBuilder;
  relativeX: (relativeX: number) => IOtherArticulationBuilder;
  fontFamily: (fontFamily: string) => IOtherArticulationBuilder;
  fontWeight: (fontWeight: NormalBold) => IOtherArticulationBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOtherArticulationBuilder;
  fontSize: (fontSize: string) => IOtherArticulationBuilder;
  color: (color: string) => IOtherArticulationBuilder;
  placement: (placement: AboveBelow) => IOtherArticulationBuilder;
  constructor(original?: OtherArticulation) {
    let updates: OtherArticulation = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): OtherArticulation => {
        checkInvariants();
        (updates as any)._class = "OtherArticulation";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IOtherArticulationBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IOtherArticulationBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IOtherArticulationBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IOtherArticulationBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IOtherArticulationBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IOtherArticulationBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IOtherArticulationBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IOtherArticulationBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IOtherArticulationBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IOtherArticulationBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IOtherArticulationBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchOtherArticulation(base: OtherArticulation, builder: (build: IOtherArticulationBuilder) => IOtherArticulationBuilder): IAny[] { return builder(new OtherArticulationBuilder(base)).patch(); }
export function buildOtherArticulation(builder: (build: IOtherArticulationBuilder) => IOtherArticulationBuilder): OtherArticulation { return builder(new OtherArticulationBuilder()).build(); }

export interface IArpeggiateBuilder {
  build?: () => Arpeggiate;
  patch: () => IAny[];
  number: (number: number) => IArpeggiateBuilder;
  direction: (direction: UpDown) => IArpeggiateBuilder;
  defaultX: (defaultX: number) => IArpeggiateBuilder;
  relativeY: (relativeY: number) => IArpeggiateBuilder;
  defaultY: (defaultY: number) => IArpeggiateBuilder;
  relativeX: (relativeX: number) => IArpeggiateBuilder;
  color: (color: string) => IArpeggiateBuilder;
  placement: (placement: AboveBelow) => IArpeggiateBuilder;
}

class ArpeggiateBuilder implements IArpeggiateBuilder {
  build: () => Arpeggiate;
  patch: () => IAny[];
  number: (number: number) => IArpeggiateBuilder;
  direction: (direction: UpDown) => IArpeggiateBuilder;
  defaultX: (defaultX: number) => IArpeggiateBuilder;
  relativeY: (relativeY: number) => IArpeggiateBuilder;
  defaultY: (defaultY: number) => IArpeggiateBuilder;
  relativeX: (relativeX: number) => IArpeggiateBuilder;
  color: (color: string) => IArpeggiateBuilder;
  placement: (placement: AboveBelow) => IArpeggiateBuilder;
  constructor(original?: Arpeggiate) {
    let updates: Arpeggiate = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Arpeggiate => {
        checkInvariants();
        (updates as any)._class = "Arpeggiate";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: number): IArpeggiateBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.direction = (spec: UpDown): IArpeggiateBuilder => {
        updates["direction"] = spec;
        delete childBuilders["direction;"];
        modifiedKeys["direction"] = true;
        return this;
    }

    this.defaultX = (spec: number): IArpeggiateBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IArpeggiateBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IArpeggiateBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IArpeggiateBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.color = (spec: string): IArpeggiateBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IArpeggiateBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchArpeggiate(base: Arpeggiate, builder: (build: IArpeggiateBuilder) => IArpeggiateBuilder): IAny[] { return builder(new ArpeggiateBuilder(base)).patch(); }
export function buildArpeggiate(builder: (build: IArpeggiateBuilder) => IArpeggiateBuilder): Arpeggiate { return builder(new ArpeggiateBuilder()).build(); }

export interface INonArpeggiateBuilder {
  build?: () => NonArpeggiate;
  patch: () => IAny[];
  number: (number: number) => INonArpeggiateBuilder;
  type: (type: TopBottom) => INonArpeggiateBuilder;
  defaultX: (defaultX: number) => INonArpeggiateBuilder;
  relativeY: (relativeY: number) => INonArpeggiateBuilder;
  defaultY: (defaultY: number) => INonArpeggiateBuilder;
  relativeX: (relativeX: number) => INonArpeggiateBuilder;
  color: (color: string) => INonArpeggiateBuilder;
  placement: (placement: AboveBelow) => INonArpeggiateBuilder;
}

class NonArpeggiateBuilder implements INonArpeggiateBuilder {
  build: () => NonArpeggiate;
  patch: () => IAny[];
  number: (number: number) => INonArpeggiateBuilder;
  type: (type: TopBottom) => INonArpeggiateBuilder;
  defaultX: (defaultX: number) => INonArpeggiateBuilder;
  relativeY: (relativeY: number) => INonArpeggiateBuilder;
  defaultY: (defaultY: number) => INonArpeggiateBuilder;
  relativeX: (relativeX: number) => INonArpeggiateBuilder;
  color: (color: string) => INonArpeggiateBuilder;
  placement: (placement: AboveBelow) => INonArpeggiateBuilder;
  constructor(original?: NonArpeggiate) {
    let updates: NonArpeggiate = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): NonArpeggiate => {
        checkInvariants();
        (updates as any)._class = "NonArpeggiate";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: number): INonArpeggiateBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.type = (spec: TopBottom): INonArpeggiateBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): INonArpeggiateBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): INonArpeggiateBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): INonArpeggiateBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): INonArpeggiateBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.color = (spec: string): INonArpeggiateBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): INonArpeggiateBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }
  }
}
export function patchNonArpeggiate(base: NonArpeggiate, builder: (build: INonArpeggiateBuilder) => INonArpeggiateBuilder): IAny[] { return builder(new NonArpeggiateBuilder(base)).patch(); }
export function buildNonArpeggiate(builder: (build: INonArpeggiateBuilder) => INonArpeggiateBuilder): NonArpeggiate { return builder(new NonArpeggiateBuilder()).build(); }

export interface ILaughingBuilder {
  build?: () => Laughing;
  patch: () => IAny[];
}

class LaughingBuilder implements ILaughingBuilder {
  build: () => Laughing;
  patch: () => IAny[];
  constructor(original?: Laughing) {
    let updates: Laughing = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Laughing => {
        checkInvariants();
        (updates as any)._class = "Laughing";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchLaughing(base: Laughing, builder: (build: ILaughingBuilder) => ILaughingBuilder): IAny[] { return builder(new LaughingBuilder(base)).patch(); }
export function buildLaughing(builder: (build: ILaughingBuilder) => ILaughingBuilder): Laughing { return builder(new LaughingBuilder()).build(); }

export interface IHummingBuilder {
  build?: () => Humming;
  patch: () => IAny[];
}

class HummingBuilder implements IHummingBuilder {
  build: () => Humming;
  patch: () => IAny[];
  constructor(original?: Humming) {
    let updates: Humming = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Humming => {
        checkInvariants();
        (updates as any)._class = "Humming";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchHumming(base: Humming, builder: (build: IHummingBuilder) => IHummingBuilder): IAny[] { return builder(new HummingBuilder(base)).patch(); }
export function buildHumming(builder: (build: IHummingBuilder) => IHummingBuilder): Humming { return builder(new HummingBuilder()).build(); }

export interface IEndLineBuilder {
  build?: () => EndLine;
  patch: () => IAny[];
}

class EndLineBuilder implements IEndLineBuilder {
  build: () => EndLine;
  patch: () => IAny[];
  constructor(original?: EndLine) {
    let updates: EndLine = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): EndLine => {
        checkInvariants();
        (updates as any)._class = "EndLine";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchEndLine(base: EndLine, builder: (build: IEndLineBuilder) => IEndLineBuilder): IAny[] { return builder(new EndLineBuilder(base)).patch(); }
export function buildEndLine(builder: (build: IEndLineBuilder) => IEndLineBuilder): EndLine { return builder(new EndLineBuilder()).build(); }

export interface IEndParagraphBuilder {
  build?: () => EndParagraph;
  patch: () => IAny[];
}

class EndParagraphBuilder implements IEndParagraphBuilder {
  build: () => EndParagraph;
  patch: () => IAny[];
  constructor(original?: EndParagraph) {
    let updates: EndParagraph = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): EndParagraph => {
        checkInvariants();
        (updates as any)._class = "EndParagraph";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchEndParagraph(base: EndParagraph, builder: (build: IEndParagraphBuilder) => IEndParagraphBuilder): IAny[] { return builder(new EndParagraphBuilder(base)).patch(); }
export function buildEndParagraph(builder: (build: IEndParagraphBuilder) => IEndParagraphBuilder): EndParagraph { return builder(new EndParagraphBuilder()).build(); }

export interface ILyricPartsBuilder {
  build?: () => LyricParts;
  patch: () => IAny[];
}

class LyricPartsBuilder implements ILyricPartsBuilder {
  build: () => LyricParts;
  patch: () => IAny[];
  constructor(original?: LyricParts) {
    let updates: LyricParts = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): LyricParts => {
        checkInvariants();
        (updates as any)._class = "LyricParts";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchLyricParts(base: LyricParts, builder: (build: ILyricPartsBuilder) => ILyricPartsBuilder): IAny[] { return builder(new LyricPartsBuilder(base)).patch(); }
export function buildLyricParts(builder: (build: ILyricPartsBuilder) => ILyricPartsBuilder): LyricParts { return builder(new LyricPartsBuilder()).build(); }

export interface ILyricBuilder {
  build?: () => Lyric;
  patch: () => IAny[];
  lyricParts: (lyricParts: boolean[]) => ILyricBuilder;
  number: (number: number) => ILyricBuilder;
  name: (name: string) => ILyricBuilder;
  defaultX: (defaultX: number) => ILyricBuilder;
  relativeY: (relativeY: number) => ILyricBuilder;
  defaultY: (defaultY: number) => ILyricBuilder;
  relativeX: (relativeX: number) => ILyricBuilder;
  color: (color: string) => ILyricBuilder;
  printObject: (printObject: boolean) => ILyricBuilder;
  justify: (justify: LeftCenterRight) => ILyricBuilder;
  placement: (placement: AboveBelow) => ILyricBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => ILyricBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => ILyricBuilder;
}

class LyricBuilder implements ILyricBuilder {
  build: () => Lyric;
  patch: () => IAny[];
  lyricParts: (lyricParts: boolean[]) => ILyricBuilder;
  number: (number: number) => ILyricBuilder;
  name: (name: string) => ILyricBuilder;
  defaultX: (defaultX: number) => ILyricBuilder;
  relativeY: (relativeY: number) => ILyricBuilder;
  defaultY: (defaultY: number) => ILyricBuilder;
  relativeX: (relativeX: number) => ILyricBuilder;
  color: (color: string) => ILyricBuilder;
  printObject: (printObject: boolean) => ILyricBuilder;
  justify: (justify: LeftCenterRight) => ILyricBuilder;
  placement: (placement: AboveBelow) => ILyricBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => ILyricBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => ILyricBuilder;
  constructor(original?: Lyric) {
    let updates: Lyric = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["lyricParts"]) ||
          childBuilders["lyricParts"] !== undefined ||
          updates.lyricParts !== undefined,
        "lyricParts is a required field");
    }

    if (!original) {
      this.build = (): Lyric => {
        checkInvariants();
        (updates as any)._class = "Lyric";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.lyricParts = (spec: boolean[]): ILyricBuilder => {
        updates["lyricParts"] = spec;
        delete childBuilders["lyricParts;"];
        modifiedKeys["lyricParts"] = true;
        return this;
    }

    this.number = (spec: number): ILyricBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.name = (spec: string): ILyricBuilder => {
        updates["name"] = spec;
        delete childBuilders["name;"];
        modifiedKeys["name"] = true;
        return this;
    }

    this.defaultX = (spec: number): ILyricBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ILyricBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ILyricBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ILyricBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.color = (spec: string): ILyricBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.printObject = (spec: boolean): ILyricBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.justify = (spec: LeftCenterRight): ILyricBuilder => {
        updates["justify"] = spec;
        delete childBuilders["justify;"];
        modifiedKeys["justify"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): ILyricBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.footnote = (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)): ILyricBuilder => {
      if (typeof build === 'function') {
        delete updates["footnote"]
        const builder = (build as any)(new FootnoteBuilder(original && original["footnote"]));
        if (!original) updates["footnote"] = builder.build();
        else childBuilders["footnote"] = builder;
      } else {
        updates.footnote = build as any;
        delete childBuilders["footnote;"];
      }
      modifiedKeys["footnote"] = true;
      return this;
    }

    this.level = (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)): ILyricBuilder => {
      if (typeof build === 'function') {
        delete updates["level"]
        const builder = (build as any)(new LevelBuilder(original && original["level"]));
        if (!original) updates["level"] = builder.build();
        else childBuilders["level"] = builder;
      } else {
        updates.level = build as any;
        delete childBuilders["level;"];
      }
      modifiedKeys["level"] = true;
      return this;
    }
  }
}
export function patchLyric(base: Lyric, builder: (build: ILyricBuilder) => ILyricBuilder): IAny[] { return builder(new LyricBuilder(base)).patch(); }
export function buildLyric(builder: (build: ILyricBuilder) => ILyricBuilder): Lyric { return builder(new LyricBuilder()).build(); }

export interface ITextBuilder {
  build?: () => Text;
  patch: () => IAny[];
  data: (data: string) => ITextBuilder;
  fontFamily: (fontFamily: string) => ITextBuilder;
  fontWeight: (fontWeight: NormalBold) => ITextBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITextBuilder;
  fontSize: (fontSize: string) => ITextBuilder;
  color: (color: string) => ITextBuilder;
  underline: (underline: number) => ITextBuilder;
  overline: (overline: number) => ITextBuilder;
  lineThrough: (lineThrough: number) => ITextBuilder;
  rotation: (rotation: number) => ITextBuilder;
  letterSpacing: (letterSpacing: string) => ITextBuilder;
  dir: (dir: DirectionMode) => ITextBuilder;
}

class TextBuilder implements ITextBuilder {
  build: () => Text;
  patch: () => IAny[];
  data: (data: string) => ITextBuilder;
  fontFamily: (fontFamily: string) => ITextBuilder;
  fontWeight: (fontWeight: NormalBold) => ITextBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITextBuilder;
  fontSize: (fontSize: string) => ITextBuilder;
  color: (color: string) => ITextBuilder;
  underline: (underline: number) => ITextBuilder;
  overline: (overline: number) => ITextBuilder;
  lineThrough: (lineThrough: number) => ITextBuilder;
  rotation: (rotation: number) => ITextBuilder;
  letterSpacing: (letterSpacing: string) => ITextBuilder;
  dir: (dir: DirectionMode) => ITextBuilder;
  constructor(original?: Text) {
    let updates: Text = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): Text => {
        checkInvariants();
        (updates as any)._class = "Text";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): ITextBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ITextBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ITextBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ITextBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ITextBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ITextBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.underline = (spec: number): ITextBuilder => {
        updates["underline"] = spec;
        delete childBuilders["underline;"];
        modifiedKeys["underline"] = true;
        return this;
    }

    this.overline = (spec: number): ITextBuilder => {
        updates["overline"] = spec;
        delete childBuilders["overline;"];
        modifiedKeys["overline"] = true;
        return this;
    }

    this.lineThrough = (spec: number): ITextBuilder => {
        updates["lineThrough"] = spec;
        delete childBuilders["lineThrough;"];
        modifiedKeys["lineThrough"] = true;
        return this;
    }

    this.rotation = (spec: number): ITextBuilder => {
        updates["rotation"] = spec;
        delete childBuilders["rotation;"];
        modifiedKeys["rotation"] = true;
        return this;
    }

    this.letterSpacing = (spec: string): ITextBuilder => {
        updates["letterSpacing"] = spec;
        delete childBuilders["letterSpacing;"];
        modifiedKeys["letterSpacing"] = true;
        return this;
    }

    this.dir = (spec: DirectionMode): ITextBuilder => {
        updates["dir"] = spec;
        delete childBuilders["dir;"];
        modifiedKeys["dir"] = true;
        return this;
    }
  }
}
export function patchText(base: Text, builder: (build: ITextBuilder) => ITextBuilder): IAny[] { return builder(new TextBuilder(base)).patch(); }
export function buildText(builder: (build: ITextBuilder) => ITextBuilder): Text { return builder(new TextBuilder()).build(); }

export interface ISyllabicBuilder {
  build?: () => Syllabic;
  patch: () => IAny[];
  data: (data: SyllabicType) => ISyllabicBuilder;
  fontFamily: (fontFamily: string) => ISyllabicBuilder;
  fontWeight: (fontWeight: NormalBold) => ISyllabicBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISyllabicBuilder;
  fontSize: (fontSize: string) => ISyllabicBuilder;
  color: (color: string) => ISyllabicBuilder;
}

class SyllabicBuilder implements ISyllabicBuilder {
  build: () => Syllabic;
  patch: () => IAny[];
  data: (data: SyllabicType) => ISyllabicBuilder;
  fontFamily: (fontFamily: string) => ISyllabicBuilder;
  fontWeight: (fontWeight: NormalBold) => ISyllabicBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISyllabicBuilder;
  fontSize: (fontSize: string) => ISyllabicBuilder;
  color: (color: string) => ISyllabicBuilder;
  constructor(original?: Syllabic) {
    let updates: Syllabic = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): Syllabic => {
        checkInvariants();
        (updates as any)._class = "Syllabic";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: SyllabicType): ISyllabicBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ISyllabicBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ISyllabicBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ISyllabicBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ISyllabicBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ISyllabicBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchSyllabic(base: Syllabic, builder: (build: ISyllabicBuilder) => ISyllabicBuilder): IAny[] { return builder(new SyllabicBuilder(base)).patch(); }
export function buildSyllabic(builder: (build: ISyllabicBuilder) => ISyllabicBuilder): Syllabic { return builder(new SyllabicBuilder()).build(); }

export interface IElisionBuilder {
  build?: () => Elision;
  patch: () => IAny[];
  data: (data: string) => IElisionBuilder;
  fontFamily: (fontFamily: string) => IElisionBuilder;
  fontWeight: (fontWeight: NormalBold) => IElisionBuilder;
  fontStyle: (fontStyle: NormalItalic) => IElisionBuilder;
  fontSize: (fontSize: string) => IElisionBuilder;
  color: (color: string) => IElisionBuilder;
}

class ElisionBuilder implements IElisionBuilder {
  build: () => Elision;
  patch: () => IAny[];
  data: (data: string) => IElisionBuilder;
  fontFamily: (fontFamily: string) => IElisionBuilder;
  fontWeight: (fontWeight: NormalBold) => IElisionBuilder;
  fontStyle: (fontStyle: NormalItalic) => IElisionBuilder;
  fontSize: (fontSize: string) => IElisionBuilder;
  color: (color: string) => IElisionBuilder;
  constructor(original?: Elision) {
    let updates: Elision = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): Elision => {
        checkInvariants();
        (updates as any)._class = "Elision";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IElisionBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IElisionBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IElisionBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IElisionBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IElisionBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IElisionBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchElision(base: Elision, builder: (build: IElisionBuilder) => IElisionBuilder): IAny[] { return builder(new ElisionBuilder(base)).patch(); }
export function buildElision(builder: (build: IElisionBuilder) => IElisionBuilder): Elision { return builder(new ElisionBuilder()).build(); }

export interface IExtendBuilder {
  build?: () => Extend;
  patch: () => IAny[];
  type: (type: StartStopContinue) => IExtendBuilder;
  defaultX: (defaultX: number) => IExtendBuilder;
  relativeY: (relativeY: number) => IExtendBuilder;
  defaultY: (defaultY: number) => IExtendBuilder;
  relativeX: (relativeX: number) => IExtendBuilder;
  fontFamily: (fontFamily: string) => IExtendBuilder;
  fontWeight: (fontWeight: NormalBold) => IExtendBuilder;
  fontStyle: (fontStyle: NormalItalic) => IExtendBuilder;
  fontSize: (fontSize: string) => IExtendBuilder;
  color: (color: string) => IExtendBuilder;
}

class ExtendBuilder implements IExtendBuilder {
  build: () => Extend;
  patch: () => IAny[];
  type: (type: StartStopContinue) => IExtendBuilder;
  defaultX: (defaultX: number) => IExtendBuilder;
  relativeY: (relativeY: number) => IExtendBuilder;
  defaultY: (defaultY: number) => IExtendBuilder;
  relativeX: (relativeX: number) => IExtendBuilder;
  fontFamily: (fontFamily: string) => IExtendBuilder;
  fontWeight: (fontWeight: NormalBold) => IExtendBuilder;
  fontStyle: (fontStyle: NormalItalic) => IExtendBuilder;
  fontSize: (fontSize: string) => IExtendBuilder;
  color: (color: string) => IExtendBuilder;
  constructor(original?: Extend) {
    let updates: Extend = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Extend => {
        checkInvariants();
        (updates as any)._class = "Extend";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.type = (spec: StartStopContinue): IExtendBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): IExtendBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IExtendBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IExtendBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IExtendBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IExtendBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IExtendBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IExtendBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IExtendBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IExtendBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchExtend(base: Extend, builder: (build: IExtendBuilder) => IExtendBuilder): IAny[] { return builder(new ExtendBuilder(base)).patch(); }
export function buildExtend(builder: (build: IExtendBuilder) => IExtendBuilder): Extend { return builder(new ExtendBuilder()).build(); }

export interface IFiguredBassBuilder {
  build?: () => FiguredBass;
  patch: () => IAny[];
  figuresAt: (idx: number, build: Figure | ((builder: IFigureBuilder) => IFigureBuilder)) => IFiguredBassBuilder;
  figuresSplice: (start: number, deleteCount: number, ...items: Figure[]) => IFiguredBassBuilder;
  figures: (figures: Figure[]) => IFiguredBassBuilder;
  duration: (duration: number) => IFiguredBassBuilder;
  parentheses: (parentheses: boolean) => IFiguredBassBuilder;
  defaultX: (defaultX: number) => IFiguredBassBuilder;
  relativeY: (relativeY: number) => IFiguredBassBuilder;
  defaultY: (defaultY: number) => IFiguredBassBuilder;
  relativeX: (relativeX: number) => IFiguredBassBuilder;
  fontFamily: (fontFamily: string) => IFiguredBassBuilder;
  fontWeight: (fontWeight: NormalBold) => IFiguredBassBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFiguredBassBuilder;
  fontSize: (fontSize: string) => IFiguredBassBuilder;
  color: (color: string) => IFiguredBassBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IFiguredBassBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IFiguredBassBuilder;
  printDot: (printDot: boolean) => IFiguredBassBuilder;
  printLyric: (printLyric: boolean) => IFiguredBassBuilder;
  printObject: (printObject: boolean) => IFiguredBassBuilder;
  printSpacing: (printSpacing: boolean) => IFiguredBassBuilder;
}

class FiguredBassBuilder implements IFiguredBassBuilder {
  build: () => FiguredBass;
  patch: () => IAny[];
  figuresAt: (idx: number, build: Figure | ((builder: IFigureBuilder) => IFigureBuilder)) => IFiguredBassBuilder;
  figuresSplice: (start: number, deleteCount: number, ...items: Figure[]) => IFiguredBassBuilder;
  figures: (figures: Figure[]) => IFiguredBassBuilder;
  duration: (duration: number) => IFiguredBassBuilder;
  parentheses: (parentheses: boolean) => IFiguredBassBuilder;
  defaultX: (defaultX: number) => IFiguredBassBuilder;
  relativeY: (relativeY: number) => IFiguredBassBuilder;
  defaultY: (defaultY: number) => IFiguredBassBuilder;
  relativeX: (relativeX: number) => IFiguredBassBuilder;
  fontFamily: (fontFamily: string) => IFiguredBassBuilder;
  fontWeight: (fontWeight: NormalBold) => IFiguredBassBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFiguredBassBuilder;
  fontSize: (fontSize: string) => IFiguredBassBuilder;
  color: (color: string) => IFiguredBassBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IFiguredBassBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IFiguredBassBuilder;
  printDot: (printDot: boolean) => IFiguredBassBuilder;
  printLyric: (printLyric: boolean) => IFiguredBassBuilder;
  printObject: (printObject: boolean) => IFiguredBassBuilder;
  printSpacing: (printSpacing: boolean) => IFiguredBassBuilder;
  constructor(original?: FiguredBass) {
    let updates: FiguredBass = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["figures"]) ||
          childBuilders["figures"] !== undefined ||
          updates.figures !== undefined,
        "figures is a required field");
    }

    if (!original) {
      this.build = (): FiguredBass => {
        checkInvariants();
        (updates as any)._class = "FiguredBass";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.figures = (spec: Figure[]): IFiguredBassBuilder => {
        updates["figures"] = spec;
        delete childBuilders["figures;"];
        modifiedKeys["figures"] = true;
        return this;
    }

    this.figuresAt = (idx: number, build: Figure | ((builder: IFigureBuilder) => IFigureBuilder)): IFiguredBassBuilder => {
      makeReference("figures");
      if (frozen["figures"][idx]) {
          throw new Error("Patching figures." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["figures"] && !original["figures"]) {
          // Clone snapshot.
          patches.push({p: ["figures", idx], li: original._snapshot["figures"]});
      }
      if (typeof build === 'function' && reference["figures"][idx]) {
        let patch = (build as any)(new FigureBuilder(reference["figures"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["figures", idx].concat(patch.p);
          return patch;
        }));
        frozen["figures"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new FigureBuilder(reference["figures"][idx])).build() : build;
      if (original) {
        patches.push({p: ["figures", idx], li: update});
      } else {
        updates["figures"] = reference["figures"]; // TODO: Merge?
      } 
      reference["figures"][idx] = update;
      frozen["figures"][idx] = true;
      return this;
    }

    this.figuresSplice = (start: number, deleteCount: number, ...items: Figure[]): IFiguredBassBuilder => {
      makeReference("figures");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["figures"][idx]) {
            throw new Error("Replacing figures." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["figures"][idx];
          patches.push({p: ["figures", idx], ld, li: items[idx - start]});
          frozen["figures"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["figures"][idx]) {
            throw new Error("Removing figures." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["figures"][idx];
          patches.push({p: ["figures", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["figures", idx], li: items[idx - start]});
          frozen["figures"][idx] = true;
        }
      }
      reference["figures"].splice(start, deleteCount, ...items);
      updates["figures"] = reference["figures"];
      frozen["figures"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.duration = (spec: number): IFiguredBassBuilder => {
        updates["duration"] = spec;
        delete childBuilders["duration;"];
        modifiedKeys["duration"] = true;
        return this;
    }

    this.parentheses = (spec: boolean): IFiguredBassBuilder => {
        updates["parentheses"] = spec;
        delete childBuilders["parentheses;"];
        modifiedKeys["parentheses"] = true;
        return this;
    }

    this.defaultX = (spec: number): IFiguredBassBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IFiguredBassBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IFiguredBassBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IFiguredBassBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IFiguredBassBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IFiguredBassBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IFiguredBassBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IFiguredBassBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IFiguredBassBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.footnote = (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)): IFiguredBassBuilder => {
      if (typeof build === 'function') {
        delete updates["footnote"]
        const builder = (build as any)(new FootnoteBuilder(original && original["footnote"]));
        if (!original) updates["footnote"] = builder.build();
        else childBuilders["footnote"] = builder;
      } else {
        updates.footnote = build as any;
        delete childBuilders["footnote;"];
      }
      modifiedKeys["footnote"] = true;
      return this;
    }

    this.level = (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)): IFiguredBassBuilder => {
      if (typeof build === 'function') {
        delete updates["level"]
        const builder = (build as any)(new LevelBuilder(original && original["level"]));
        if (!original) updates["level"] = builder.build();
        else childBuilders["level"] = builder;
      } else {
        updates.level = build as any;
        delete childBuilders["level;"];
      }
      modifiedKeys["level"] = true;
      return this;
    }

    this.printDot = (spec: boolean): IFiguredBassBuilder => {
        updates["printDot"] = spec;
        delete childBuilders["printDot;"];
        modifiedKeys["printDot"] = true;
        return this;
    }

    this.printLyric = (spec: boolean): IFiguredBassBuilder => {
        updates["printLyric"] = spec;
        delete childBuilders["printLyric;"];
        modifiedKeys["printLyric"] = true;
        return this;
    }

    this.printObject = (spec: boolean): IFiguredBassBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.printSpacing = (spec: boolean): IFiguredBassBuilder => {
        updates["printSpacing"] = spec;
        delete childBuilders["printSpacing;"];
        modifiedKeys["printSpacing"] = true;
        return this;
    }
  }
}
export function patchFiguredBass(base: FiguredBass, builder: (build: IFiguredBassBuilder) => IFiguredBassBuilder): IAny[] { return builder(new FiguredBassBuilder(base)).patch(); }
export function buildFiguredBass(builder: (build: IFiguredBassBuilder) => IFiguredBassBuilder): FiguredBass { return builder(new FiguredBassBuilder()).build(); }

export interface IFigureBuilder {
  build?: () => Figure;
  patch: () => IAny[];
  prefix: (build: Prefix | ((builder: IPrefixBuilder) => IPrefixBuilder)) => IFigureBuilder;
  figureNumber: (build: FigureNumber | ((builder: IFigureNumberBuilder) => IFigureNumberBuilder)) => IFigureBuilder;
  extend: (build: Extend | ((builder: IExtendBuilder) => IExtendBuilder)) => IFigureBuilder;
  suffix: (build: Suffix | ((builder: ISuffixBuilder) => ISuffixBuilder)) => IFigureBuilder;
  defaultX: (defaultX: number) => IFigureBuilder;
  relativeY: (relativeY: number) => IFigureBuilder;
  defaultY: (defaultY: number) => IFigureBuilder;
  relativeX: (relativeX: number) => IFigureBuilder;
  fontFamily: (fontFamily: string) => IFigureBuilder;
  fontWeight: (fontWeight: NormalBold) => IFigureBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFigureBuilder;
  fontSize: (fontSize: string) => IFigureBuilder;
  color: (color: string) => IFigureBuilder;
}

class FigureBuilder implements IFigureBuilder {
  build: () => Figure;
  patch: () => IAny[];
  prefix: (build: Prefix | ((builder: IPrefixBuilder) => IPrefixBuilder)) => IFigureBuilder;
  figureNumber: (build: FigureNumber | ((builder: IFigureNumberBuilder) => IFigureNumberBuilder)) => IFigureBuilder;
  extend: (build: Extend | ((builder: IExtendBuilder) => IExtendBuilder)) => IFigureBuilder;
  suffix: (build: Suffix | ((builder: ISuffixBuilder) => ISuffixBuilder)) => IFigureBuilder;
  defaultX: (defaultX: number) => IFigureBuilder;
  relativeY: (relativeY: number) => IFigureBuilder;
  defaultY: (defaultY: number) => IFigureBuilder;
  relativeX: (relativeX: number) => IFigureBuilder;
  fontFamily: (fontFamily: string) => IFigureBuilder;
  fontWeight: (fontWeight: NormalBold) => IFigureBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFigureBuilder;
  fontSize: (fontSize: string) => IFigureBuilder;
  color: (color: string) => IFigureBuilder;
  constructor(original?: Figure) {
    let updates: Figure = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Figure => {
        checkInvariants();
        (updates as any)._class = "Figure";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.prefix = (build: Prefix | ((builder: IPrefixBuilder) => IPrefixBuilder)): IFigureBuilder => {
      if (typeof build === 'function') {
        delete updates["prefix"]
        const builder = (build as any)(new PrefixBuilder(original && original["prefix"]));
        if (!original) updates["prefix"] = builder.build();
        else childBuilders["prefix"] = builder;
      } else {
        updates.prefix = build as any;
        delete childBuilders["prefix;"];
      }
      modifiedKeys["prefix"] = true;
      return this;
    }

    this.figureNumber = (build: FigureNumber | ((builder: IFigureNumberBuilder) => IFigureNumberBuilder)): IFigureBuilder => {
      if (typeof build === 'function') {
        delete updates["figureNumber"]
        const builder = (build as any)(new FigureNumberBuilder(original && original["figureNumber"]));
        if (!original) updates["figureNumber"] = builder.build();
        else childBuilders["figureNumber"] = builder;
      } else {
        updates.figureNumber = build as any;
        delete childBuilders["figureNumber;"];
      }
      modifiedKeys["figureNumber"] = true;
      return this;
    }

    this.extend = (build: Extend | ((builder: IExtendBuilder) => IExtendBuilder)): IFigureBuilder => {
      if (typeof build === 'function') {
        delete updates["extend"]
        const builder = (build as any)(new ExtendBuilder(original && original["extend"]));
        if (!original) updates["extend"] = builder.build();
        else childBuilders["extend"] = builder;
      } else {
        updates.extend = build as any;
        delete childBuilders["extend;"];
      }
      modifiedKeys["extend"] = true;
      return this;
    }

    this.suffix = (build: Suffix | ((builder: ISuffixBuilder) => ISuffixBuilder)): IFigureBuilder => {
      if (typeof build === 'function') {
        delete updates["suffix"]
        const builder = (build as any)(new SuffixBuilder(original && original["suffix"]));
        if (!original) updates["suffix"] = builder.build();
        else childBuilders["suffix"] = builder;
      } else {
        updates.suffix = build as any;
        delete childBuilders["suffix;"];
      }
      modifiedKeys["suffix"] = true;
      return this;
    }

    this.defaultX = (spec: number): IFigureBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IFigureBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IFigureBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IFigureBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IFigureBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IFigureBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IFigureBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IFigureBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IFigureBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchFigure(base: Figure, builder: (build: IFigureBuilder) => IFigureBuilder): IAny[] { return builder(new FigureBuilder(base)).patch(); }
export function buildFigure(builder: (build: IFigureBuilder) => IFigureBuilder): Figure { return builder(new FigureBuilder()).build(); }

export interface IPrefixBuilder {
  build?: () => Prefix;
  patch: () => IAny[];
  data: (data: string) => IPrefixBuilder;
  defaultX: (defaultX: number) => IPrefixBuilder;
  relativeY: (relativeY: number) => IPrefixBuilder;
  defaultY: (defaultY: number) => IPrefixBuilder;
  relativeX: (relativeX: number) => IPrefixBuilder;
  fontFamily: (fontFamily: string) => IPrefixBuilder;
  fontWeight: (fontWeight: NormalBold) => IPrefixBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPrefixBuilder;
  fontSize: (fontSize: string) => IPrefixBuilder;
  color: (color: string) => IPrefixBuilder;
}

class PrefixBuilder implements IPrefixBuilder {
  build: () => Prefix;
  patch: () => IAny[];
  data: (data: string) => IPrefixBuilder;
  defaultX: (defaultX: number) => IPrefixBuilder;
  relativeY: (relativeY: number) => IPrefixBuilder;
  defaultY: (defaultY: number) => IPrefixBuilder;
  relativeX: (relativeX: number) => IPrefixBuilder;
  fontFamily: (fontFamily: string) => IPrefixBuilder;
  fontWeight: (fontWeight: NormalBold) => IPrefixBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPrefixBuilder;
  fontSize: (fontSize: string) => IPrefixBuilder;
  color: (color: string) => IPrefixBuilder;
  constructor(original?: Prefix) {
    let updates: Prefix = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): Prefix => {
        checkInvariants();
        (updates as any)._class = "Prefix";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IPrefixBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IPrefixBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IPrefixBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IPrefixBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IPrefixBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IPrefixBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IPrefixBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IPrefixBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IPrefixBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IPrefixBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchPrefix(base: Prefix, builder: (build: IPrefixBuilder) => IPrefixBuilder): IAny[] { return builder(new PrefixBuilder(base)).patch(); }
export function buildPrefix(builder: (build: IPrefixBuilder) => IPrefixBuilder): Prefix { return builder(new PrefixBuilder()).build(); }

export interface IFigureNumberBuilder {
  build?: () => FigureNumber;
  patch: () => IAny[];
  data: (data: string) => IFigureNumberBuilder;
  defaultX: (defaultX: number) => IFigureNumberBuilder;
  relativeY: (relativeY: number) => IFigureNumberBuilder;
  defaultY: (defaultY: number) => IFigureNumberBuilder;
  relativeX: (relativeX: number) => IFigureNumberBuilder;
  fontFamily: (fontFamily: string) => IFigureNumberBuilder;
  fontWeight: (fontWeight: NormalBold) => IFigureNumberBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFigureNumberBuilder;
  fontSize: (fontSize: string) => IFigureNumberBuilder;
  color: (color: string) => IFigureNumberBuilder;
}

class FigureNumberBuilder implements IFigureNumberBuilder {
  build: () => FigureNumber;
  patch: () => IAny[];
  data: (data: string) => IFigureNumberBuilder;
  defaultX: (defaultX: number) => IFigureNumberBuilder;
  relativeY: (relativeY: number) => IFigureNumberBuilder;
  defaultY: (defaultY: number) => IFigureNumberBuilder;
  relativeX: (relativeX: number) => IFigureNumberBuilder;
  fontFamily: (fontFamily: string) => IFigureNumberBuilder;
  fontWeight: (fontWeight: NormalBold) => IFigureNumberBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFigureNumberBuilder;
  fontSize: (fontSize: string) => IFigureNumberBuilder;
  color: (color: string) => IFigureNumberBuilder;
  constructor(original?: FigureNumber) {
    let updates: FigureNumber = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): FigureNumber => {
        checkInvariants();
        (updates as any)._class = "FigureNumber";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IFigureNumberBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IFigureNumberBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IFigureNumberBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IFigureNumberBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IFigureNumberBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IFigureNumberBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IFigureNumberBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IFigureNumberBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IFigureNumberBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IFigureNumberBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchFigureNumber(base: FigureNumber, builder: (build: IFigureNumberBuilder) => IFigureNumberBuilder): IAny[] { return builder(new FigureNumberBuilder(base)).patch(); }
export function buildFigureNumber(builder: (build: IFigureNumberBuilder) => IFigureNumberBuilder): FigureNumber { return builder(new FigureNumberBuilder()).build(); }

export interface ISuffixBuilder {
  build?: () => Suffix;
  patch: () => IAny[];
  data: (data: string) => ISuffixBuilder;
  defaultX: (defaultX: number) => ISuffixBuilder;
  relativeY: (relativeY: number) => ISuffixBuilder;
  defaultY: (defaultY: number) => ISuffixBuilder;
  relativeX: (relativeX: number) => ISuffixBuilder;
  fontFamily: (fontFamily: string) => ISuffixBuilder;
  fontWeight: (fontWeight: NormalBold) => ISuffixBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISuffixBuilder;
  fontSize: (fontSize: string) => ISuffixBuilder;
  color: (color: string) => ISuffixBuilder;
}

class SuffixBuilder implements ISuffixBuilder {
  build: () => Suffix;
  patch: () => IAny[];
  data: (data: string) => ISuffixBuilder;
  defaultX: (defaultX: number) => ISuffixBuilder;
  relativeY: (relativeY: number) => ISuffixBuilder;
  defaultY: (defaultY: number) => ISuffixBuilder;
  relativeX: (relativeX: number) => ISuffixBuilder;
  fontFamily: (fontFamily: string) => ISuffixBuilder;
  fontWeight: (fontWeight: NormalBold) => ISuffixBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISuffixBuilder;
  fontSize: (fontSize: string) => ISuffixBuilder;
  color: (color: string) => ISuffixBuilder;
  constructor(original?: Suffix) {
    let updates: Suffix = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): Suffix => {
        checkInvariants();
        (updates as any)._class = "Suffix";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): ISuffixBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): ISuffixBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ISuffixBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ISuffixBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ISuffixBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ISuffixBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ISuffixBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ISuffixBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ISuffixBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ISuffixBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchSuffix(base: Suffix, builder: (build: ISuffixBuilder) => ISuffixBuilder): IAny[] { return builder(new SuffixBuilder(base)).patch(); }
export function buildSuffix(builder: (build: ISuffixBuilder) => ISuffixBuilder): Suffix { return builder(new SuffixBuilder()).build(); }

export interface IBackupBuilder {
  build?: () => Backup;
  patch: () => IAny[];
  duration: (duration: number) => IBackupBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IBackupBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IBackupBuilder;
}

class BackupBuilder implements IBackupBuilder {
  build: () => Backup;
  patch: () => IAny[];
  duration: (duration: number) => IBackupBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IBackupBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IBackupBuilder;
  constructor(original?: Backup) {
    let updates: Backup = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["duration"]) ||
          childBuilders["duration"] !== undefined ||
          updates.duration !== undefined,
        "duration is a required field");
    }

    if (!original) {
      this.build = (): Backup => {
        checkInvariants();
        (updates as any)._class = "Backup";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.duration = (spec: number): IBackupBuilder => {
        updates["duration"] = spec;
        delete childBuilders["duration;"];
        modifiedKeys["duration"] = true;
        return this;
    }

    this.footnote = (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)): IBackupBuilder => {
      if (typeof build === 'function') {
        delete updates["footnote"]
        const builder = (build as any)(new FootnoteBuilder(original && original["footnote"]));
        if (!original) updates["footnote"] = builder.build();
        else childBuilders["footnote"] = builder;
      } else {
        updates.footnote = build as any;
        delete childBuilders["footnote;"];
      }
      modifiedKeys["footnote"] = true;
      return this;
    }

    this.level = (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)): IBackupBuilder => {
      if (typeof build === 'function') {
        delete updates["level"]
        const builder = (build as any)(new LevelBuilder(original && original["level"]));
        if (!original) updates["level"] = builder.build();
        else childBuilders["level"] = builder;
      } else {
        updates.level = build as any;
        delete childBuilders["level;"];
      }
      modifiedKeys["level"] = true;
      return this;
    }
  }
}
export function patchBackup(base: Backup, builder: (build: IBackupBuilder) => IBackupBuilder): IAny[] { return builder(new BackupBuilder(base)).patch(); }
export function buildBackup(builder: (build: IBackupBuilder) => IBackupBuilder): Backup { return builder(new BackupBuilder()).build(); }

export interface IForwardBuilder {
  build?: () => Forward;
  patch: () => IAny[];
  duration: (duration: number) => IForwardBuilder;
  staff: (staff: number) => IForwardBuilder;
  voice: (voice: number) => IForwardBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IForwardBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IForwardBuilder;
}

class ForwardBuilder implements IForwardBuilder {
  build: () => Forward;
  patch: () => IAny[];
  duration: (duration: number) => IForwardBuilder;
  staff: (staff: number) => IForwardBuilder;
  voice: (voice: number) => IForwardBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IForwardBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IForwardBuilder;
  constructor(original?: Forward) {
    let updates: Forward = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["duration"]) ||
          childBuilders["duration"] !== undefined ||
          updates.duration !== undefined,
        "duration is a required field");
    }

    if (!original) {
      this.build = (): Forward => {
        checkInvariants();
        (updates as any)._class = "Forward";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.duration = (spec: number): IForwardBuilder => {
        updates["duration"] = spec;
        delete childBuilders["duration;"];
        modifiedKeys["duration"] = true;
        return this;
    }

    this.staff = (spec: number): IForwardBuilder => {
        updates["staff"] = spec;
        delete childBuilders["staff;"];
        modifiedKeys["staff"] = true;
        return this;
    }

    this.voice = (spec: number): IForwardBuilder => {
        updates["voice"] = spec;
        delete childBuilders["voice;"];
        modifiedKeys["voice"] = true;
        return this;
    }

    this.footnote = (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)): IForwardBuilder => {
      if (typeof build === 'function') {
        delete updates["footnote"]
        const builder = (build as any)(new FootnoteBuilder(original && original["footnote"]));
        if (!original) updates["footnote"] = builder.build();
        else childBuilders["footnote"] = builder;
      } else {
        updates.footnote = build as any;
        delete childBuilders["footnote;"];
      }
      modifiedKeys["footnote"] = true;
      return this;
    }

    this.level = (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)): IForwardBuilder => {
      if (typeof build === 'function') {
        delete updates["level"]
        const builder = (build as any)(new LevelBuilder(original && original["level"]));
        if (!original) updates["level"] = builder.build();
        else childBuilders["level"] = builder;
      } else {
        updates.level = build as any;
        delete childBuilders["level;"];
      }
      modifiedKeys["level"] = true;
      return this;
    }
  }
}
export function patchForward(base: Forward, builder: (build: IForwardBuilder) => IForwardBuilder): IAny[] { return builder(new ForwardBuilder(base)).patch(); }
export function buildForward(builder: (build: IForwardBuilder) => IForwardBuilder): Forward { return builder(new ForwardBuilder()).build(); }

export interface IBarlineBuilder {
  build?: () => Barline;
  patch: () => IAny[];
  segno: (build: Segno | ((builder: ISegnoBuilder) => ISegnoBuilder)) => IBarlineBuilder;
  coda: (build: Coda | ((builder: ICodaBuilder) => ICodaBuilder)) => IBarlineBuilder;
  location: (location: BarlineLocation) => IBarlineBuilder;
  codaAttrib: (codaAttrib: string) => IBarlineBuilder;
  wavyLine: (build: WavyLine | ((builder: IWavyLineBuilder) => IWavyLineBuilder)) => IBarlineBuilder;
  fermatasAt: (idx: number, build: Fermata | ((builder: IFermataBuilder) => IFermataBuilder)) => IBarlineBuilder;
  fermatasSplice: (start: number, deleteCount: number, ...items: Fermata[]) => IBarlineBuilder;
  fermatas: (fermatas: Fermata[]) => IBarlineBuilder;
  segnoAttrib: (segnoAttrib: string) => IBarlineBuilder;
  divisions: (divisions: number) => IBarlineBuilder;
  barStyle: (build: BarStyle | ((builder: IBarStyleBuilder) => IBarStyleBuilder)) => IBarlineBuilder;
  ending: (build: Ending | ((builder: IEndingBuilder) => IEndingBuilder)) => IBarlineBuilder;
  repeat: (build: Repeat | ((builder: IRepeatBuilder) => IRepeatBuilder)) => IBarlineBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IBarlineBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IBarlineBuilder;
}

class BarlineBuilder implements IBarlineBuilder {
  build: () => Barline;
  patch: () => IAny[];
  segno: (build: Segno | ((builder: ISegnoBuilder) => ISegnoBuilder)) => IBarlineBuilder;
  coda: (build: Coda | ((builder: ICodaBuilder) => ICodaBuilder)) => IBarlineBuilder;
  location: (location: BarlineLocation) => IBarlineBuilder;
  codaAttrib: (codaAttrib: string) => IBarlineBuilder;
  wavyLine: (build: WavyLine | ((builder: IWavyLineBuilder) => IWavyLineBuilder)) => IBarlineBuilder;
  fermatasAt: (idx: number, build: Fermata | ((builder: IFermataBuilder) => IFermataBuilder)) => IBarlineBuilder;
  fermatasSplice: (start: number, deleteCount: number, ...items: Fermata[]) => IBarlineBuilder;
  fermatas: (fermatas: Fermata[]) => IBarlineBuilder;
  segnoAttrib: (segnoAttrib: string) => IBarlineBuilder;
  divisions: (divisions: number) => IBarlineBuilder;
  barStyle: (build: BarStyle | ((builder: IBarStyleBuilder) => IBarStyleBuilder)) => IBarlineBuilder;
  ending: (build: Ending | ((builder: IEndingBuilder) => IEndingBuilder)) => IBarlineBuilder;
  repeat: (build: Repeat | ((builder: IRepeatBuilder) => IRepeatBuilder)) => IBarlineBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IBarlineBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IBarlineBuilder;
  constructor(original?: Barline) {
    let updates: Barline = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Barline => {
        checkInvariants();
        (updates as any)._class = "Barline";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.segno = (build: Segno | ((builder: ISegnoBuilder) => ISegnoBuilder)): IBarlineBuilder => {
      if (typeof build === 'function') {
        delete updates["segno"]
        const builder = (build as any)(new SegnoBuilder(original && original["segno"]));
        if (!original) updates["segno"] = builder.build();
        else childBuilders["segno"] = builder;
      } else {
        updates.segno = build as any;
        delete childBuilders["segno;"];
      }
      modifiedKeys["segno"] = true;
      return this;
    }

    this.coda = (build: Coda | ((builder: ICodaBuilder) => ICodaBuilder)): IBarlineBuilder => {
      if (typeof build === 'function') {
        delete updates["coda"]
        const builder = (build as any)(new CodaBuilder(original && original["coda"]));
        if (!original) updates["coda"] = builder.build();
        else childBuilders["coda"] = builder;
      } else {
        updates.coda = build as any;
        delete childBuilders["coda;"];
      }
      modifiedKeys["coda"] = true;
      return this;
    }

    this.location = (spec: BarlineLocation): IBarlineBuilder => {
        updates["location"] = spec;
        delete childBuilders["location;"];
        modifiedKeys["location"] = true;
        return this;
    }

    this.codaAttrib = (spec: string): IBarlineBuilder => {
        updates["codaAttrib"] = spec;
        delete childBuilders["codaAttrib;"];
        modifiedKeys["codaAttrib"] = true;
        return this;
    }

    this.wavyLine = (build: WavyLine | ((builder: IWavyLineBuilder) => IWavyLineBuilder)): IBarlineBuilder => {
      if (typeof build === 'function') {
        delete updates["wavyLine"]
        const builder = (build as any)(new WavyLineBuilder(original && original["wavyLine"]));
        if (!original) updates["wavyLine"] = builder.build();
        else childBuilders["wavyLine"] = builder;
      } else {
        updates.wavyLine = build as any;
        delete childBuilders["wavyLine;"];
      }
      modifiedKeys["wavyLine"] = true;
      return this;
    }

    this.fermatas = (spec: Fermata[]): IBarlineBuilder => {
        updates["fermatas"] = spec;
        delete childBuilders["fermatas;"];
        modifiedKeys["fermatas"] = true;
        return this;
    }

    this.fermatasAt = (idx: number, build: Fermata | ((builder: IFermataBuilder) => IFermataBuilder)): IBarlineBuilder => {
      makeReference("fermatas");
      if (frozen["fermatas"][idx]) {
          throw new Error("Patching fermatas." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["fermatas"] && !original["fermatas"]) {
          // Clone snapshot.
          patches.push({p: ["fermatas", idx], li: original._snapshot["fermatas"]});
      }
      if (typeof build === 'function' && reference["fermatas"][idx]) {
        let patch = (build as any)(new FermataBuilder(reference["fermatas"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["fermatas", idx].concat(patch.p);
          return patch;
        }));
        frozen["fermatas"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new FermataBuilder(reference["fermatas"][idx])).build() : build;
      if (original) {
        patches.push({p: ["fermatas", idx], li: update});
      } else {
        updates["fermatas"] = reference["fermatas"]; // TODO: Merge?
      } 
      reference["fermatas"][idx] = update;
      frozen["fermatas"][idx] = true;
      return this;
    }

    this.fermatasSplice = (start: number, deleteCount: number, ...items: Fermata[]): IBarlineBuilder => {
      makeReference("fermatas");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["fermatas"][idx]) {
            throw new Error("Replacing fermatas." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["fermatas"][idx];
          patches.push({p: ["fermatas", idx], ld, li: items[idx - start]});
          frozen["fermatas"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["fermatas"][idx]) {
            throw new Error("Removing fermatas." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["fermatas"][idx];
          patches.push({p: ["fermatas", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["fermatas", idx], li: items[idx - start]});
          frozen["fermatas"][idx] = true;
        }
      }
      reference["fermatas"].splice(start, deleteCount, ...items);
      updates["fermatas"] = reference["fermatas"];
      frozen["fermatas"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.segnoAttrib = (spec: string): IBarlineBuilder => {
        updates["segnoAttrib"] = spec;
        delete childBuilders["segnoAttrib;"];
        modifiedKeys["segnoAttrib"] = true;
        return this;
    }

    this.divisions = (spec: number): IBarlineBuilder => {
        updates["divisions"] = spec;
        delete childBuilders["divisions;"];
        modifiedKeys["divisions"] = true;
        return this;
    }

    this.barStyle = (build: BarStyle | ((builder: IBarStyleBuilder) => IBarStyleBuilder)): IBarlineBuilder => {
      if (typeof build === 'function') {
        delete updates["barStyle"]
        const builder = (build as any)(new BarStyleBuilder(original && original["barStyle"]));
        if (!original) updates["barStyle"] = builder.build();
        else childBuilders["barStyle"] = builder;
      } else {
        updates.barStyle = build as any;
        delete childBuilders["barStyle;"];
      }
      modifiedKeys["barStyle"] = true;
      return this;
    }

    this.ending = (build: Ending | ((builder: IEndingBuilder) => IEndingBuilder)): IBarlineBuilder => {
      if (typeof build === 'function') {
        delete updates["ending"]
        const builder = (build as any)(new EndingBuilder(original && original["ending"]));
        if (!original) updates["ending"] = builder.build();
        else childBuilders["ending"] = builder;
      } else {
        updates.ending = build as any;
        delete childBuilders["ending;"];
      }
      modifiedKeys["ending"] = true;
      return this;
    }

    this.repeat = (build: Repeat | ((builder: IRepeatBuilder) => IRepeatBuilder)): IBarlineBuilder => {
      if (typeof build === 'function') {
        delete updates["repeat"]
        const builder = (build as any)(new RepeatBuilder(original && original["repeat"]));
        if (!original) updates["repeat"] = builder.build();
        else childBuilders["repeat"] = builder;
      } else {
        updates.repeat = build as any;
        delete childBuilders["repeat;"];
      }
      modifiedKeys["repeat"] = true;
      return this;
    }

    this.footnote = (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)): IBarlineBuilder => {
      if (typeof build === 'function') {
        delete updates["footnote"]
        const builder = (build as any)(new FootnoteBuilder(original && original["footnote"]));
        if (!original) updates["footnote"] = builder.build();
        else childBuilders["footnote"] = builder;
      } else {
        updates.footnote = build as any;
        delete childBuilders["footnote;"];
      }
      modifiedKeys["footnote"] = true;
      return this;
    }

    this.level = (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)): IBarlineBuilder => {
      if (typeof build === 'function') {
        delete updates["level"]
        const builder = (build as any)(new LevelBuilder(original && original["level"]));
        if (!original) updates["level"] = builder.build();
        else childBuilders["level"] = builder;
      } else {
        updates.level = build as any;
        delete childBuilders["level;"];
      }
      modifiedKeys["level"] = true;
      return this;
    }
  }
}
export function patchBarline(base: Barline, builder: (build: IBarlineBuilder) => IBarlineBuilder): IAny[] { return builder(new BarlineBuilder(base)).patch(); }
export function buildBarline(builder: (build: IBarlineBuilder) => IBarlineBuilder): Barline { return builder(new BarlineBuilder()).build(); }

export interface IBarStyleBuilder {
  build?: () => BarStyle;
  patch: () => IAny[];
  data: (data: BarStyleType) => IBarStyleBuilder;
  color: (color: string) => IBarStyleBuilder;
}

class BarStyleBuilder implements IBarStyleBuilder {
  build: () => BarStyle;
  patch: () => IAny[];
  data: (data: BarStyleType) => IBarStyleBuilder;
  color: (color: string) => IBarStyleBuilder;
  constructor(original?: BarStyle) {
    let updates: BarStyle = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): BarStyle => {
        checkInvariants();
        (updates as any)._class = "BarStyle";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: BarStyleType): IBarStyleBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.color = (spec: string): IBarStyleBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchBarStyle(base: BarStyle, builder: (build: IBarStyleBuilder) => IBarStyleBuilder): IAny[] { return builder(new BarStyleBuilder(base)).patch(); }
export function buildBarStyle(builder: (build: IBarStyleBuilder) => IBarStyleBuilder): BarStyle { return builder(new BarStyleBuilder()).build(); }

export interface IEndingBuilder {
  build?: () => Ending;
  patch: () => IAny[];
  endLength: (endLength: number) => IEndingBuilder;
  textX: (textX: number) => IEndingBuilder;
  number: (number: number) => IEndingBuilder;
  textY: (textY: number) => IEndingBuilder;
  type: (type: StartStopDiscontinue) => IEndingBuilder;
  ending: (ending: string) => IEndingBuilder;
  defaultX: (defaultX: number) => IEndingBuilder;
  relativeY: (relativeY: number) => IEndingBuilder;
  defaultY: (defaultY: number) => IEndingBuilder;
  relativeX: (relativeX: number) => IEndingBuilder;
  fontFamily: (fontFamily: string) => IEndingBuilder;
  fontWeight: (fontWeight: NormalBold) => IEndingBuilder;
  fontStyle: (fontStyle: NormalItalic) => IEndingBuilder;
  fontSize: (fontSize: string) => IEndingBuilder;
  color: (color: string) => IEndingBuilder;
  printObject: (printObject: boolean) => IEndingBuilder;
}

class EndingBuilder implements IEndingBuilder {
  build: () => Ending;
  patch: () => IAny[];
  endLength: (endLength: number) => IEndingBuilder;
  textX: (textX: number) => IEndingBuilder;
  number: (number: number) => IEndingBuilder;
  textY: (textY: number) => IEndingBuilder;
  type: (type: StartStopDiscontinue) => IEndingBuilder;
  ending: (ending: string) => IEndingBuilder;
  defaultX: (defaultX: number) => IEndingBuilder;
  relativeY: (relativeY: number) => IEndingBuilder;
  defaultY: (defaultY: number) => IEndingBuilder;
  relativeX: (relativeX: number) => IEndingBuilder;
  fontFamily: (fontFamily: string) => IEndingBuilder;
  fontWeight: (fontWeight: NormalBold) => IEndingBuilder;
  fontStyle: (fontStyle: NormalItalic) => IEndingBuilder;
  fontSize: (fontSize: string) => IEndingBuilder;
  color: (color: string) => IEndingBuilder;
  printObject: (printObject: boolean) => IEndingBuilder;
  constructor(original?: Ending) {
    let updates: Ending = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["endLength"]) ||
          childBuilders["endLength"] !== undefined ||
          updates.endLength !== undefined,
        "endLength is a required field");
      console.assert(
          (original && !modifiedKeys["textX"]) ||
          childBuilders["textX"] !== undefined ||
          updates.textX !== undefined,
        "textX is a required field");
      console.assert(
          (original && !modifiedKeys["number"]) ||
          childBuilders["number"] !== undefined ||
          updates.number !== undefined,
        "number is a required field");
      console.assert(
          (original && !modifiedKeys["textY"]) ||
          childBuilders["textY"] !== undefined ||
          updates.textY !== undefined,
        "textY is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Ending => {
        checkInvariants();
        (updates as any)._class = "Ending";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.endLength = (spec: number): IEndingBuilder => {
        updates["endLength"] = spec;
        delete childBuilders["endLength;"];
        modifiedKeys["endLength"] = true;
        return this;
    }

    this.textX = (spec: number): IEndingBuilder => {
        updates["textX"] = spec;
        delete childBuilders["textX;"];
        modifiedKeys["textX"] = true;
        return this;
    }

    this.number = (spec: number): IEndingBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.textY = (spec: number): IEndingBuilder => {
        updates["textY"] = spec;
        delete childBuilders["textY;"];
        modifiedKeys["textY"] = true;
        return this;
    }

    this.type = (spec: StartStopDiscontinue): IEndingBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.ending = (spec: string): IEndingBuilder => {
        updates["ending"] = spec;
        delete childBuilders["ending;"];
        modifiedKeys["ending"] = true;
        return this;
    }

    this.defaultX = (spec: number): IEndingBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IEndingBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IEndingBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IEndingBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IEndingBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IEndingBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IEndingBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IEndingBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IEndingBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.printObject = (spec: boolean): IEndingBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }
  }
}
export function patchEnding(base: Ending, builder: (build: IEndingBuilder) => IEndingBuilder): IAny[] { return builder(new EndingBuilder(base)).patch(); }
export function buildEnding(builder: (build: IEndingBuilder) => IEndingBuilder): Ending { return builder(new EndingBuilder()).build(); }

export interface IRepeatBuilder {
  build?: () => Repeat;
  patch: () => IAny[];
  times: (times: string) => IRepeatBuilder;
  winged: (winged: WingedType) => IRepeatBuilder;
  direction: (direction: DirectionTypeBg) => IRepeatBuilder;
}

class RepeatBuilder implements IRepeatBuilder {
  build: () => Repeat;
  patch: () => IAny[];
  times: (times: string) => IRepeatBuilder;
  winged: (winged: WingedType) => IRepeatBuilder;
  direction: (direction: DirectionTypeBg) => IRepeatBuilder;
  constructor(original?: Repeat) {
    let updates: Repeat = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["times"]) ||
          childBuilders["times"] !== undefined ||
          updates.times !== undefined,
        "times is a required field");
      console.assert(
          (original && !modifiedKeys["winged"]) ||
          childBuilders["winged"] !== undefined ||
          updates.winged !== undefined,
        "winged is a required field");
      console.assert(
          (original && !modifiedKeys["direction"]) ||
          childBuilders["direction"] !== undefined ||
          updates.direction !== undefined,
        "direction is a required field");
    }

    if (!original) {
      this.build = (): Repeat => {
        checkInvariants();
        (updates as any)._class = "Repeat";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.times = (spec: string): IRepeatBuilder => {
        updates["times"] = spec;
        delete childBuilders["times;"];
        modifiedKeys["times"] = true;
        return this;
    }

    this.winged = (spec: WingedType): IRepeatBuilder => {
        updates["winged"] = spec;
        delete childBuilders["winged;"];
        modifiedKeys["winged"] = true;
        return this;
    }

    this.direction = (spec: DirectionTypeBg): IRepeatBuilder => {
        updates["direction"] = spec;
        delete childBuilders["direction;"];
        modifiedKeys["direction"] = true;
        return this;
    }
  }
}
export function patchRepeat(base: Repeat, builder: (build: IRepeatBuilder) => IRepeatBuilder): IAny[] { return builder(new RepeatBuilder(base)).patch(); }
export function buildRepeat(builder: (build: IRepeatBuilder) => IRepeatBuilder): Repeat { return builder(new RepeatBuilder()).build(); }

export interface IDirectionBuilder {
  build?: () => Direction;
  patch: () => IAny[];
  directionTypesAt: (idx: number, build: DirectionType | ((builder: IDirectionTypeBuilder) => IDirectionTypeBuilder)) => IDirectionBuilder;
  directionTypesSplice: (start: number, deleteCount: number, ...items: DirectionType[]) => IDirectionBuilder;
  directionTypes: (directionTypes: DirectionType[]) => IDirectionBuilder;
  staff: (staff: number) => IDirectionBuilder;
  offset: (build: Offset | ((builder: IOffsetBuilder) => IOffsetBuilder)) => IDirectionBuilder;
  sound: (build: Sound | ((builder: ISoundBuilder) => ISoundBuilder)) => IDirectionBuilder;
  placement: (placement: AboveBelow) => IDirectionBuilder;
  voice: (voice: number) => IDirectionBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IDirectionBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IDirectionBuilder;
  directive: (directive: boolean) => IDirectionBuilder;
}

class DirectionBuilder implements IDirectionBuilder {
  build: () => Direction;
  patch: () => IAny[];
  directionTypesAt: (idx: number, build: DirectionType | ((builder: IDirectionTypeBuilder) => IDirectionTypeBuilder)) => IDirectionBuilder;
  directionTypesSplice: (start: number, deleteCount: number, ...items: DirectionType[]) => IDirectionBuilder;
  directionTypes: (directionTypes: DirectionType[]) => IDirectionBuilder;
  staff: (staff: number) => IDirectionBuilder;
  offset: (build: Offset | ((builder: IOffsetBuilder) => IOffsetBuilder)) => IDirectionBuilder;
  sound: (build: Sound | ((builder: ISoundBuilder) => ISoundBuilder)) => IDirectionBuilder;
  placement: (placement: AboveBelow) => IDirectionBuilder;
  voice: (voice: number) => IDirectionBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IDirectionBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IDirectionBuilder;
  directive: (directive: boolean) => IDirectionBuilder;
  constructor(original?: Direction) {
    let updates: Direction = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["directionTypes"]) ||
          childBuilders["directionTypes"] !== undefined ||
          updates.directionTypes !== undefined,
        "directionTypes is a required field");
    }

    if (!original) {
      this.build = (): Direction => {
        checkInvariants();
        (updates as any)._class = "Direction";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.directionTypes = (spec: DirectionType[]): IDirectionBuilder => {
        updates["directionTypes"] = spec;
        delete childBuilders["directionTypes;"];
        modifiedKeys["directionTypes"] = true;
        return this;
    }

    this.directionTypesAt = (idx: number, build: DirectionType | ((builder: IDirectionTypeBuilder) => IDirectionTypeBuilder)): IDirectionBuilder => {
      makeReference("directionTypes");
      if (frozen["directionTypes"][idx]) {
          throw new Error("Patching directionTypes." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["directionTypes"] && !original["directionTypes"]) {
          // Clone snapshot.
          patches.push({p: ["directionTypes", idx], li: original._snapshot["directionTypes"]});
      }
      if (typeof build === 'function' && reference["directionTypes"][idx]) {
        let patch = (build as any)(new DirectionTypeBuilder(reference["directionTypes"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["directionTypes", idx].concat(patch.p);
          return patch;
        }));
        frozen["directionTypes"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new DirectionTypeBuilder(reference["directionTypes"][idx])).build() : build;
      if (original) {
        patches.push({p: ["directionTypes", idx], li: update});
      } else {
        updates["directionTypes"] = reference["directionTypes"]; // TODO: Merge?
      } 
      reference["directionTypes"][idx] = update;
      frozen["directionTypes"][idx] = true;
      return this;
    }

    this.directionTypesSplice = (start: number, deleteCount: number, ...items: DirectionType[]): IDirectionBuilder => {
      makeReference("directionTypes");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["directionTypes"][idx]) {
            throw new Error("Replacing directionTypes." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["directionTypes"][idx];
          patches.push({p: ["directionTypes", idx], ld, li: items[idx - start]});
          frozen["directionTypes"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["directionTypes"][idx]) {
            throw new Error("Removing directionTypes." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["directionTypes"][idx];
          patches.push({p: ["directionTypes", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["directionTypes", idx], li: items[idx - start]});
          frozen["directionTypes"][idx] = true;
        }
      }
      reference["directionTypes"].splice(start, deleteCount, ...items);
      updates["directionTypes"] = reference["directionTypes"];
      frozen["directionTypes"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.staff = (spec: number): IDirectionBuilder => {
        updates["staff"] = spec;
        delete childBuilders["staff;"];
        modifiedKeys["staff"] = true;
        return this;
    }

    this.offset = (build: Offset | ((builder: IOffsetBuilder) => IOffsetBuilder)): IDirectionBuilder => {
      if (typeof build === 'function') {
        delete updates["offset"]
        const builder = (build as any)(new OffsetBuilder(original && original["offset"]));
        if (!original) updates["offset"] = builder.build();
        else childBuilders["offset"] = builder;
      } else {
        updates.offset = build as any;
        delete childBuilders["offset;"];
      }
      modifiedKeys["offset"] = true;
      return this;
    }

    this.sound = (build: Sound | ((builder: ISoundBuilder) => ISoundBuilder)): IDirectionBuilder => {
      if (typeof build === 'function') {
        delete updates["sound"]
        const builder = (build as any)(new SoundBuilder(original && original["sound"]));
        if (!original) updates["sound"] = builder.build();
        else childBuilders["sound"] = builder;
      } else {
        updates.sound = build as any;
        delete childBuilders["sound;"];
      }
      modifiedKeys["sound"] = true;
      return this;
    }

    this.placement = (spec: AboveBelow): IDirectionBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.voice = (spec: number): IDirectionBuilder => {
        updates["voice"] = spec;
        delete childBuilders["voice;"];
        modifiedKeys["voice"] = true;
        return this;
    }

    this.footnote = (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)): IDirectionBuilder => {
      if (typeof build === 'function') {
        delete updates["footnote"]
        const builder = (build as any)(new FootnoteBuilder(original && original["footnote"]));
        if (!original) updates["footnote"] = builder.build();
        else childBuilders["footnote"] = builder;
      } else {
        updates.footnote = build as any;
        delete childBuilders["footnote;"];
      }
      modifiedKeys["footnote"] = true;
      return this;
    }

    this.level = (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)): IDirectionBuilder => {
      if (typeof build === 'function') {
        delete updates["level"]
        const builder = (build as any)(new LevelBuilder(original && original["level"]));
        if (!original) updates["level"] = builder.build();
        else childBuilders["level"] = builder;
      } else {
        updates.level = build as any;
        delete childBuilders["level;"];
      }
      modifiedKeys["level"] = true;
      return this;
    }

    this.directive = (spec: boolean): IDirectionBuilder => {
        updates["directive"] = spec;
        delete childBuilders["directive;"];
        modifiedKeys["directive"] = true;
        return this;
    }
  }
}
export function patchDirection(base: Direction, builder: (build: IDirectionBuilder) => IDirectionBuilder): IAny[] { return builder(new DirectionBuilder(base)).patch(); }
export function buildDirection(builder: (build: IDirectionBuilder) => IDirectionBuilder): Direction { return builder(new DirectionBuilder()).build(); }

export interface IDirectionTypeBuilder {
  build?: () => DirectionType;
  patch: () => IAny[];
  percussionsAt: (idx: number, build: Percussion | ((builder: IPercussionBuilder) => IPercussionBuilder)) => IDirectionTypeBuilder;
  percussionsSplice: (start: number, deleteCount: number, ...items: Percussion[]) => IDirectionTypeBuilder;
  percussions: (percussions: Percussion[]) => IDirectionTypeBuilder;
  rehearsalsAt: (idx: number, build: Rehearsal | ((builder: IRehearsalBuilder) => IRehearsalBuilder)) => IDirectionTypeBuilder;
  rehearsalsSplice: (start: number, deleteCount: number, ...items: Rehearsal[]) => IDirectionTypeBuilder;
  rehearsals: (rehearsals: Rehearsal[]) => IDirectionTypeBuilder;
  pedal: (build: Pedal | ((builder: IPedalBuilder) => IPedalBuilder)) => IDirectionTypeBuilder;
  principalVoice: (build: PrincipalVoice | ((builder: IPrincipalVoiceBuilder) => IPrincipalVoiceBuilder)) => IDirectionTypeBuilder;
  accordionRegistration: (build: AccordionRegistration | ((builder: IAccordionRegistrationBuilder) => IAccordionRegistrationBuilder)) => IDirectionTypeBuilder;
  eyeglasses: (build: Eyeglasses | ((builder: IEyeglassesBuilder) => IEyeglassesBuilder)) => IDirectionTypeBuilder;
  image: (build: Image | ((builder: IImageBuilder) => IImageBuilder)) => IDirectionTypeBuilder;
  harpPedals: (build: HarpPedals | ((builder: IHarpPedalsBuilder) => IHarpPedalsBuilder)) => IDirectionTypeBuilder;
  metronome: (build: Metronome | ((builder: IMetronomeBuilder) => IMetronomeBuilder)) => IDirectionTypeBuilder;
  otherDirection: (build: OtherDirection | ((builder: IOtherDirectionBuilder) => IOtherDirectionBuilder)) => IDirectionTypeBuilder;
  segnosAt: (idx: number, build: Segno | ((builder: ISegnoBuilder) => ISegnoBuilder)) => IDirectionTypeBuilder;
  segnosSplice: (start: number, deleteCount: number, ...items: Segno[]) => IDirectionTypeBuilder;
  segnos: (segnos: Segno[]) => IDirectionTypeBuilder;
  scordatura: (build: Scordatura | ((builder: IScordaturaBuilder) => IScordaturaBuilder)) => IDirectionTypeBuilder;
  stringMute: (build: StringMute | ((builder: IStringMuteBuilder) => IStringMuteBuilder)) => IDirectionTypeBuilder;
  wedge: (build: Wedge | ((builder: IWedgeBuilder) => IWedgeBuilder)) => IDirectionTypeBuilder;
  dashes: (build: Dashes | ((builder: IDashesBuilder) => IDashesBuilder)) => IDirectionTypeBuilder;
  damp: (build: Damp | ((builder: IDampBuilder) => IDampBuilder)) => IDirectionTypeBuilder;
  bracket: (build: Bracket | ((builder: IBracketBuilder) => IBracketBuilder)) => IDirectionTypeBuilder;
  dynamics: (build: Dynamics | ((builder: IDynamicsBuilder) => IDynamicsBuilder)) => IDirectionTypeBuilder;
  octaveShift: (build: OctaveShift | ((builder: IOctaveShiftBuilder) => IOctaveShiftBuilder)) => IDirectionTypeBuilder;
  wordsAt: (idx: number, build: Words | ((builder: IWordsBuilder) => IWordsBuilder)) => IDirectionTypeBuilder;
  wordsSplice: (start: number, deleteCount: number, ...items: Words[]) => IDirectionTypeBuilder;
  words: (words: Words[]) => IDirectionTypeBuilder;
  dampAll: (build: DampAll | ((builder: IDampAllBuilder) => IDampAllBuilder)) => IDirectionTypeBuilder;
  codasAt: (idx: number, build: Coda | ((builder: ICodaBuilder) => ICodaBuilder)) => IDirectionTypeBuilder;
  codasSplice: (start: number, deleteCount: number, ...items: Coda[]) => IDirectionTypeBuilder;
  codas: (codas: Coda[]) => IDirectionTypeBuilder;
}

class DirectionTypeBuilder implements IDirectionTypeBuilder {
  build: () => DirectionType;
  patch: () => IAny[];
  percussionsAt: (idx: number, build: Percussion | ((builder: IPercussionBuilder) => IPercussionBuilder)) => IDirectionTypeBuilder;
  percussionsSplice: (start: number, deleteCount: number, ...items: Percussion[]) => IDirectionTypeBuilder;
  percussions: (percussions: Percussion[]) => IDirectionTypeBuilder;
  rehearsalsAt: (idx: number, build: Rehearsal | ((builder: IRehearsalBuilder) => IRehearsalBuilder)) => IDirectionTypeBuilder;
  rehearsalsSplice: (start: number, deleteCount: number, ...items: Rehearsal[]) => IDirectionTypeBuilder;
  rehearsals: (rehearsals: Rehearsal[]) => IDirectionTypeBuilder;
  pedal: (build: Pedal | ((builder: IPedalBuilder) => IPedalBuilder)) => IDirectionTypeBuilder;
  principalVoice: (build: PrincipalVoice | ((builder: IPrincipalVoiceBuilder) => IPrincipalVoiceBuilder)) => IDirectionTypeBuilder;
  accordionRegistration: (build: AccordionRegistration | ((builder: IAccordionRegistrationBuilder) => IAccordionRegistrationBuilder)) => IDirectionTypeBuilder;
  eyeglasses: (build: Eyeglasses | ((builder: IEyeglassesBuilder) => IEyeglassesBuilder)) => IDirectionTypeBuilder;
  image: (build: Image | ((builder: IImageBuilder) => IImageBuilder)) => IDirectionTypeBuilder;
  harpPedals: (build: HarpPedals | ((builder: IHarpPedalsBuilder) => IHarpPedalsBuilder)) => IDirectionTypeBuilder;
  metronome: (build: Metronome | ((builder: IMetronomeBuilder) => IMetronomeBuilder)) => IDirectionTypeBuilder;
  otherDirection: (build: OtherDirection | ((builder: IOtherDirectionBuilder) => IOtherDirectionBuilder)) => IDirectionTypeBuilder;
  segnosAt: (idx: number, build: Segno | ((builder: ISegnoBuilder) => ISegnoBuilder)) => IDirectionTypeBuilder;
  segnosSplice: (start: number, deleteCount: number, ...items: Segno[]) => IDirectionTypeBuilder;
  segnos: (segnos: Segno[]) => IDirectionTypeBuilder;
  scordatura: (build: Scordatura | ((builder: IScordaturaBuilder) => IScordaturaBuilder)) => IDirectionTypeBuilder;
  stringMute: (build: StringMute | ((builder: IStringMuteBuilder) => IStringMuteBuilder)) => IDirectionTypeBuilder;
  wedge: (build: Wedge | ((builder: IWedgeBuilder) => IWedgeBuilder)) => IDirectionTypeBuilder;
  dashes: (build: Dashes | ((builder: IDashesBuilder) => IDashesBuilder)) => IDirectionTypeBuilder;
  damp: (build: Damp | ((builder: IDampBuilder) => IDampBuilder)) => IDirectionTypeBuilder;
  bracket: (build: Bracket | ((builder: IBracketBuilder) => IBracketBuilder)) => IDirectionTypeBuilder;
  dynamics: (build: Dynamics | ((builder: IDynamicsBuilder) => IDynamicsBuilder)) => IDirectionTypeBuilder;
  octaveShift: (build: OctaveShift | ((builder: IOctaveShiftBuilder) => IOctaveShiftBuilder)) => IDirectionTypeBuilder;
  wordsAt: (idx: number, build: Words | ((builder: IWordsBuilder) => IWordsBuilder)) => IDirectionTypeBuilder;
  wordsSplice: (start: number, deleteCount: number, ...items: Words[]) => IDirectionTypeBuilder;
  words: (words: Words[]) => IDirectionTypeBuilder;
  dampAll: (build: DampAll | ((builder: IDampAllBuilder) => IDampAllBuilder)) => IDirectionTypeBuilder;
  codasAt: (idx: number, build: Coda | ((builder: ICodaBuilder) => ICodaBuilder)) => IDirectionTypeBuilder;
  codasSplice: (start: number, deleteCount: number, ...items: Coda[]) => IDirectionTypeBuilder;
  codas: (codas: Coda[]) => IDirectionTypeBuilder;
  constructor(original?: DirectionType) {
    let updates: DirectionType = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): DirectionType => {
        checkInvariants();
        (updates as any)._class = "DirectionType";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.percussions = (spec: Percussion[]): IDirectionTypeBuilder => {
        updates["percussions"] = spec;
        delete childBuilders["percussions;"];
        modifiedKeys["percussions"] = true;
        return this;
    }

    this.percussionsAt = (idx: number, build: Percussion | ((builder: IPercussionBuilder) => IPercussionBuilder)): IDirectionTypeBuilder => {
      makeReference("percussions");
      if (frozen["percussions"][idx]) {
          throw new Error("Patching percussions." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["percussions"] && !original["percussions"]) {
          // Clone snapshot.
          patches.push({p: ["percussions", idx], li: original._snapshot["percussions"]});
      }
      if (typeof build === 'function' && reference["percussions"][idx]) {
        let patch = (build as any)(new PercussionBuilder(reference["percussions"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["percussions", idx].concat(patch.p);
          return patch;
        }));
        frozen["percussions"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new PercussionBuilder(reference["percussions"][idx])).build() : build;
      if (original) {
        patches.push({p: ["percussions", idx], li: update});
      } else {
        updates["percussions"] = reference["percussions"]; // TODO: Merge?
      } 
      reference["percussions"][idx] = update;
      frozen["percussions"][idx] = true;
      return this;
    }

    this.percussionsSplice = (start: number, deleteCount: number, ...items: Percussion[]): IDirectionTypeBuilder => {
      makeReference("percussions");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["percussions"][idx]) {
            throw new Error("Replacing percussions." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["percussions"][idx];
          patches.push({p: ["percussions", idx], ld, li: items[idx - start]});
          frozen["percussions"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["percussions"][idx]) {
            throw new Error("Removing percussions." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["percussions"][idx];
          patches.push({p: ["percussions", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["percussions", idx], li: items[idx - start]});
          frozen["percussions"][idx] = true;
        }
      }
      reference["percussions"].splice(start, deleteCount, ...items);
      updates["percussions"] = reference["percussions"];
      frozen["percussions"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.rehearsals = (spec: Rehearsal[]): IDirectionTypeBuilder => {
        updates["rehearsals"] = spec;
        delete childBuilders["rehearsals;"];
        modifiedKeys["rehearsals"] = true;
        return this;
    }

    this.rehearsalsAt = (idx: number, build: Rehearsal | ((builder: IRehearsalBuilder) => IRehearsalBuilder)): IDirectionTypeBuilder => {
      makeReference("rehearsals");
      if (frozen["rehearsals"][idx]) {
          throw new Error("Patching rehearsals." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["rehearsals"] && !original["rehearsals"]) {
          // Clone snapshot.
          patches.push({p: ["rehearsals", idx], li: original._snapshot["rehearsals"]});
      }
      if (typeof build === 'function' && reference["rehearsals"][idx]) {
        let patch = (build as any)(new RehearsalBuilder(reference["rehearsals"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["rehearsals", idx].concat(patch.p);
          return patch;
        }));
        frozen["rehearsals"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new RehearsalBuilder(reference["rehearsals"][idx])).build() : build;
      if (original) {
        patches.push({p: ["rehearsals", idx], li: update});
      } else {
        updates["rehearsals"] = reference["rehearsals"]; // TODO: Merge?
      } 
      reference["rehearsals"][idx] = update;
      frozen["rehearsals"][idx] = true;
      return this;
    }

    this.rehearsalsSplice = (start: number, deleteCount: number, ...items: Rehearsal[]): IDirectionTypeBuilder => {
      makeReference("rehearsals");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["rehearsals"][idx]) {
            throw new Error("Replacing rehearsals." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["rehearsals"][idx];
          patches.push({p: ["rehearsals", idx], ld, li: items[idx - start]});
          frozen["rehearsals"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["rehearsals"][idx]) {
            throw new Error("Removing rehearsals." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["rehearsals"][idx];
          patches.push({p: ["rehearsals", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["rehearsals", idx], li: items[idx - start]});
          frozen["rehearsals"][idx] = true;
        }
      }
      reference["rehearsals"].splice(start, deleteCount, ...items);
      updates["rehearsals"] = reference["rehearsals"];
      frozen["rehearsals"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.pedal = (build: Pedal | ((builder: IPedalBuilder) => IPedalBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["pedal"]
        const builder = (build as any)(new PedalBuilder(original && original["pedal"]));
        if (!original) updates["pedal"] = builder.build();
        else childBuilders["pedal"] = builder;
      } else {
        updates.pedal = build as any;
        delete childBuilders["pedal;"];
      }
      modifiedKeys["pedal"] = true;
      return this;
    }

    this.principalVoice = (build: PrincipalVoice | ((builder: IPrincipalVoiceBuilder) => IPrincipalVoiceBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["principalVoice"]
        const builder = (build as any)(new PrincipalVoiceBuilder(original && original["principalVoice"]));
        if (!original) updates["principalVoice"] = builder.build();
        else childBuilders["principalVoice"] = builder;
      } else {
        updates.principalVoice = build as any;
        delete childBuilders["principalVoice;"];
      }
      modifiedKeys["principalVoice"] = true;
      return this;
    }

    this.accordionRegistration = (build: AccordionRegistration | ((builder: IAccordionRegistrationBuilder) => IAccordionRegistrationBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["accordionRegistration"]
        const builder = (build as any)(new AccordionRegistrationBuilder(original && original["accordionRegistration"]));
        if (!original) updates["accordionRegistration"] = builder.build();
        else childBuilders["accordionRegistration"] = builder;
      } else {
        updates.accordionRegistration = build as any;
        delete childBuilders["accordionRegistration;"];
      }
      modifiedKeys["accordionRegistration"] = true;
      return this;
    }

    this.eyeglasses = (build: Eyeglasses | ((builder: IEyeglassesBuilder) => IEyeglassesBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["eyeglasses"]
        const builder = (build as any)(new EyeglassesBuilder(original && original["eyeglasses"]));
        if (!original) updates["eyeglasses"] = builder.build();
        else childBuilders["eyeglasses"] = builder;
      } else {
        updates.eyeglasses = build as any;
        delete childBuilders["eyeglasses;"];
      }
      modifiedKeys["eyeglasses"] = true;
      return this;
    }

    this.image = (build: Image | ((builder: IImageBuilder) => IImageBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["image"]
        const builder = (build as any)(new ImageBuilder(original && original["image"]));
        if (!original) updates["image"] = builder.build();
        else childBuilders["image"] = builder;
      } else {
        updates.image = build as any;
        delete childBuilders["image;"];
      }
      modifiedKeys["image"] = true;
      return this;
    }

    this.harpPedals = (build: HarpPedals | ((builder: IHarpPedalsBuilder) => IHarpPedalsBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["harpPedals"]
        const builder = (build as any)(new HarpPedalsBuilder(original && original["harpPedals"]));
        if (!original) updates["harpPedals"] = builder.build();
        else childBuilders["harpPedals"] = builder;
      } else {
        updates.harpPedals = build as any;
        delete childBuilders["harpPedals;"];
      }
      modifiedKeys["harpPedals"] = true;
      return this;
    }

    this.metronome = (build: Metronome | ((builder: IMetronomeBuilder) => IMetronomeBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["metronome"]
        const builder = (build as any)(new MetronomeBuilder(original && original["metronome"]));
        if (!original) updates["metronome"] = builder.build();
        else childBuilders["metronome"] = builder;
      } else {
        updates.metronome = build as any;
        delete childBuilders["metronome;"];
      }
      modifiedKeys["metronome"] = true;
      return this;
    }

    this.otherDirection = (build: OtherDirection | ((builder: IOtherDirectionBuilder) => IOtherDirectionBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["otherDirection"]
        const builder = (build as any)(new OtherDirectionBuilder(original && original["otherDirection"]));
        if (!original) updates["otherDirection"] = builder.build();
        else childBuilders["otherDirection"] = builder;
      } else {
        updates.otherDirection = build as any;
        delete childBuilders["otherDirection;"];
      }
      modifiedKeys["otherDirection"] = true;
      return this;
    }

    this.segnos = (spec: Segno[]): IDirectionTypeBuilder => {
        updates["segnos"] = spec;
        delete childBuilders["segnos;"];
        modifiedKeys["segnos"] = true;
        return this;
    }

    this.segnosAt = (idx: number, build: Segno | ((builder: ISegnoBuilder) => ISegnoBuilder)): IDirectionTypeBuilder => {
      makeReference("segnos");
      if (frozen["segnos"][idx]) {
          throw new Error("Patching segnos." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["segnos"] && !original["segnos"]) {
          // Clone snapshot.
          patches.push({p: ["segnos", idx], li: original._snapshot["segnos"]});
      }
      if (typeof build === 'function' && reference["segnos"][idx]) {
        let patch = (build as any)(new SegnoBuilder(reference["segnos"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["segnos", idx].concat(patch.p);
          return patch;
        }));
        frozen["segnos"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new SegnoBuilder(reference["segnos"][idx])).build() : build;
      if (original) {
        patches.push({p: ["segnos", idx], li: update});
      } else {
        updates["segnos"] = reference["segnos"]; // TODO: Merge?
      } 
      reference["segnos"][idx] = update;
      frozen["segnos"][idx] = true;
      return this;
    }

    this.segnosSplice = (start: number, deleteCount: number, ...items: Segno[]): IDirectionTypeBuilder => {
      makeReference("segnos");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["segnos"][idx]) {
            throw new Error("Replacing segnos." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["segnos"][idx];
          patches.push({p: ["segnos", idx], ld, li: items[idx - start]});
          frozen["segnos"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["segnos"][idx]) {
            throw new Error("Removing segnos." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["segnos"][idx];
          patches.push({p: ["segnos", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["segnos", idx], li: items[idx - start]});
          frozen["segnos"][idx] = true;
        }
      }
      reference["segnos"].splice(start, deleteCount, ...items);
      updates["segnos"] = reference["segnos"];
      frozen["segnos"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.scordatura = (build: Scordatura | ((builder: IScordaturaBuilder) => IScordaturaBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["scordatura"]
        const builder = (build as any)(new ScordaturaBuilder(original && original["scordatura"]));
        if (!original) updates["scordatura"] = builder.build();
        else childBuilders["scordatura"] = builder;
      } else {
        updates.scordatura = build as any;
        delete childBuilders["scordatura;"];
      }
      modifiedKeys["scordatura"] = true;
      return this;
    }

    this.stringMute = (build: StringMute | ((builder: IStringMuteBuilder) => IStringMuteBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["stringMute"]
        const builder = (build as any)(new StringMuteBuilder(original && original["stringMute"]));
        if (!original) updates["stringMute"] = builder.build();
        else childBuilders["stringMute"] = builder;
      } else {
        updates.stringMute = build as any;
        delete childBuilders["stringMute;"];
      }
      modifiedKeys["stringMute"] = true;
      return this;
    }

    this.wedge = (build: Wedge | ((builder: IWedgeBuilder) => IWedgeBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["wedge"]
        const builder = (build as any)(new WedgeBuilder(original && original["wedge"]));
        if (!original) updates["wedge"] = builder.build();
        else childBuilders["wedge"] = builder;
      } else {
        updates.wedge = build as any;
        delete childBuilders["wedge;"];
      }
      modifiedKeys["wedge"] = true;
      return this;
    }

    this.dashes = (build: Dashes | ((builder: IDashesBuilder) => IDashesBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["dashes"]
        const builder = (build as any)(new DashesBuilder(original && original["dashes"]));
        if (!original) updates["dashes"] = builder.build();
        else childBuilders["dashes"] = builder;
      } else {
        updates.dashes = build as any;
        delete childBuilders["dashes;"];
      }
      modifiedKeys["dashes"] = true;
      return this;
    }

    this.damp = (build: Damp | ((builder: IDampBuilder) => IDampBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["damp"]
        const builder = (build as any)(new DampBuilder(original && original["damp"]));
        if (!original) updates["damp"] = builder.build();
        else childBuilders["damp"] = builder;
      } else {
        updates.damp = build as any;
        delete childBuilders["damp;"];
      }
      modifiedKeys["damp"] = true;
      return this;
    }

    this.bracket = (build: Bracket | ((builder: IBracketBuilder) => IBracketBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["bracket"]
        const builder = (build as any)(new BracketBuilder(original && original["bracket"]));
        if (!original) updates["bracket"] = builder.build();
        else childBuilders["bracket"] = builder;
      } else {
        updates.bracket = build as any;
        delete childBuilders["bracket;"];
      }
      modifiedKeys["bracket"] = true;
      return this;
    }

    this.dynamics = (build: Dynamics | ((builder: IDynamicsBuilder) => IDynamicsBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["dynamics"]
        const builder = (build as any)(new DynamicsBuilder(original && original["dynamics"]));
        if (!original) updates["dynamics"] = builder.build();
        else childBuilders["dynamics"] = builder;
      } else {
        updates.dynamics = build as any;
        delete childBuilders["dynamics;"];
      }
      modifiedKeys["dynamics"] = true;
      return this;
    }

    this.octaveShift = (build: OctaveShift | ((builder: IOctaveShiftBuilder) => IOctaveShiftBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["octaveShift"]
        const builder = (build as any)(new OctaveShiftBuilder(original && original["octaveShift"]));
        if (!original) updates["octaveShift"] = builder.build();
        else childBuilders["octaveShift"] = builder;
      } else {
        updates.octaveShift = build as any;
        delete childBuilders["octaveShift;"];
      }
      modifiedKeys["octaveShift"] = true;
      return this;
    }

    this.words = (spec: Words[]): IDirectionTypeBuilder => {
        updates["words"] = spec;
        delete childBuilders["words;"];
        modifiedKeys["words"] = true;
        return this;
    }

    this.wordsAt = (idx: number, build: Words | ((builder: IWordsBuilder) => IWordsBuilder)): IDirectionTypeBuilder => {
      makeReference("words");
      if (frozen["words"][idx]) {
          throw new Error("Patching words." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["words"] && !original["words"]) {
          // Clone snapshot.
          patches.push({p: ["words", idx], li: original._snapshot["words"]});
      }
      if (typeof build === 'function' && reference["words"][idx]) {
        let patch = (build as any)(new WordsBuilder(reference["words"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["words", idx].concat(patch.p);
          return patch;
        }));
        frozen["words"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new WordsBuilder(reference["words"][idx])).build() : build;
      if (original) {
        patches.push({p: ["words", idx], li: update});
      } else {
        updates["words"] = reference["words"]; // TODO: Merge?
      } 
      reference["words"][idx] = update;
      frozen["words"][idx] = true;
      return this;
    }

    this.wordsSplice = (start: number, deleteCount: number, ...items: Words[]): IDirectionTypeBuilder => {
      makeReference("words");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["words"][idx]) {
            throw new Error("Replacing words." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["words"][idx];
          patches.push({p: ["words", idx], ld, li: items[idx - start]});
          frozen["words"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["words"][idx]) {
            throw new Error("Removing words." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["words"][idx];
          patches.push({p: ["words", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["words", idx], li: items[idx - start]});
          frozen["words"][idx] = true;
        }
      }
      reference["words"].splice(start, deleteCount, ...items);
      updates["words"] = reference["words"];
      frozen["words"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.dampAll = (build: DampAll | ((builder: IDampAllBuilder) => IDampAllBuilder)): IDirectionTypeBuilder => {
      if (typeof build === 'function') {
        delete updates["dampAll"]
        const builder = (build as any)(new DampAllBuilder(original && original["dampAll"]));
        if (!original) updates["dampAll"] = builder.build();
        else childBuilders["dampAll"] = builder;
      } else {
        updates.dampAll = build as any;
        delete childBuilders["dampAll;"];
      }
      modifiedKeys["dampAll"] = true;
      return this;
    }

    this.codas = (spec: Coda[]): IDirectionTypeBuilder => {
        updates["codas"] = spec;
        delete childBuilders["codas;"];
        modifiedKeys["codas"] = true;
        return this;
    }

    this.codasAt = (idx: number, build: Coda | ((builder: ICodaBuilder) => ICodaBuilder)): IDirectionTypeBuilder => {
      makeReference("codas");
      if (frozen["codas"][idx]) {
          throw new Error("Patching codas." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["codas"] && !original["codas"]) {
          // Clone snapshot.
          patches.push({p: ["codas", idx], li: original._snapshot["codas"]});
      }
      if (typeof build === 'function' && reference["codas"][idx]) {
        let patch = (build as any)(new CodaBuilder(reference["codas"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["codas", idx].concat(patch.p);
          return patch;
        }));
        frozen["codas"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new CodaBuilder(reference["codas"][idx])).build() : build;
      if (original) {
        patches.push({p: ["codas", idx], li: update});
      } else {
        updates["codas"] = reference["codas"]; // TODO: Merge?
      } 
      reference["codas"][idx] = update;
      frozen["codas"][idx] = true;
      return this;
    }

    this.codasSplice = (start: number, deleteCount: number, ...items: Coda[]): IDirectionTypeBuilder => {
      makeReference("codas");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["codas"][idx]) {
            throw new Error("Replacing codas." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["codas"][idx];
          patches.push({p: ["codas", idx], ld, li: items[idx - start]});
          frozen["codas"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["codas"][idx]) {
            throw new Error("Removing codas." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["codas"][idx];
          patches.push({p: ["codas", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["codas", idx], li: items[idx - start]});
          frozen["codas"][idx] = true;
        }
      }
      reference["codas"].splice(start, deleteCount, ...items);
      updates["codas"] = reference["codas"];
      frozen["codas"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }
  }
}
export function patchDirectionType(base: DirectionType, builder: (build: IDirectionTypeBuilder) => IDirectionTypeBuilder): IAny[] { return builder(new DirectionTypeBuilder(base)).patch(); }
export function buildDirectionType(builder: (build: IDirectionTypeBuilder) => IDirectionTypeBuilder): DirectionType { return builder(new DirectionTypeBuilder()).build(); }

export interface IRehearsalBuilder {
  build?: () => Rehearsal;
  patch: () => IAny[];
  data: (data: string) => IRehearsalBuilder;
  justify: (justify: LeftCenterRight) => IRehearsalBuilder;
  defaultX: (defaultX: number) => IRehearsalBuilder;
  relativeY: (relativeY: number) => IRehearsalBuilder;
  defaultY: (defaultY: number) => IRehearsalBuilder;
  relativeX: (relativeX: number) => IRehearsalBuilder;
  fontFamily: (fontFamily: string) => IRehearsalBuilder;
  fontWeight: (fontWeight: NormalBold) => IRehearsalBuilder;
  fontStyle: (fontStyle: NormalItalic) => IRehearsalBuilder;
  fontSize: (fontSize: string) => IRehearsalBuilder;
  color: (color: string) => IRehearsalBuilder;
  halign: (halign: LeftCenterRight) => IRehearsalBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IRehearsalBuilder;
  underline: (underline: number) => IRehearsalBuilder;
  overline: (overline: number) => IRehearsalBuilder;
  lineThrough: (lineThrough: number) => IRehearsalBuilder;
  rotation: (rotation: number) => IRehearsalBuilder;
  letterSpacing: (letterSpacing: string) => IRehearsalBuilder;
  lineHeight: (lineHeight: string) => IRehearsalBuilder;
  dir: (dir: DirectionMode) => IRehearsalBuilder;
  enclosure: (enclosure: EnclosureShape) => IRehearsalBuilder;
}

class RehearsalBuilder implements IRehearsalBuilder {
  build: () => Rehearsal;
  patch: () => IAny[];
  data: (data: string) => IRehearsalBuilder;
  justify: (justify: LeftCenterRight) => IRehearsalBuilder;
  defaultX: (defaultX: number) => IRehearsalBuilder;
  relativeY: (relativeY: number) => IRehearsalBuilder;
  defaultY: (defaultY: number) => IRehearsalBuilder;
  relativeX: (relativeX: number) => IRehearsalBuilder;
  fontFamily: (fontFamily: string) => IRehearsalBuilder;
  fontWeight: (fontWeight: NormalBold) => IRehearsalBuilder;
  fontStyle: (fontStyle: NormalItalic) => IRehearsalBuilder;
  fontSize: (fontSize: string) => IRehearsalBuilder;
  color: (color: string) => IRehearsalBuilder;
  halign: (halign: LeftCenterRight) => IRehearsalBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IRehearsalBuilder;
  underline: (underline: number) => IRehearsalBuilder;
  overline: (overline: number) => IRehearsalBuilder;
  lineThrough: (lineThrough: number) => IRehearsalBuilder;
  rotation: (rotation: number) => IRehearsalBuilder;
  letterSpacing: (letterSpacing: string) => IRehearsalBuilder;
  lineHeight: (lineHeight: string) => IRehearsalBuilder;
  dir: (dir: DirectionMode) => IRehearsalBuilder;
  enclosure: (enclosure: EnclosureShape) => IRehearsalBuilder;
  constructor(original?: Rehearsal) {
    let updates: Rehearsal = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): Rehearsal => {
        checkInvariants();
        (updates as any)._class = "Rehearsal";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IRehearsalBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.justify = (spec: LeftCenterRight): IRehearsalBuilder => {
        updates["justify"] = spec;
        delete childBuilders["justify;"];
        modifiedKeys["justify"] = true;
        return this;
    }

    this.defaultX = (spec: number): IRehearsalBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IRehearsalBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IRehearsalBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IRehearsalBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IRehearsalBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IRehearsalBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IRehearsalBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IRehearsalBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IRehearsalBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IRehearsalBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IRehearsalBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }

    this.underline = (spec: number): IRehearsalBuilder => {
        updates["underline"] = spec;
        delete childBuilders["underline;"];
        modifiedKeys["underline"] = true;
        return this;
    }

    this.overline = (spec: number): IRehearsalBuilder => {
        updates["overline"] = spec;
        delete childBuilders["overline;"];
        modifiedKeys["overline"] = true;
        return this;
    }

    this.lineThrough = (spec: number): IRehearsalBuilder => {
        updates["lineThrough"] = spec;
        delete childBuilders["lineThrough;"];
        modifiedKeys["lineThrough"] = true;
        return this;
    }

    this.rotation = (spec: number): IRehearsalBuilder => {
        updates["rotation"] = spec;
        delete childBuilders["rotation;"];
        modifiedKeys["rotation"] = true;
        return this;
    }

    this.letterSpacing = (spec: string): IRehearsalBuilder => {
        updates["letterSpacing"] = spec;
        delete childBuilders["letterSpacing;"];
        modifiedKeys["letterSpacing"] = true;
        return this;
    }

    this.lineHeight = (spec: string): IRehearsalBuilder => {
        updates["lineHeight"] = spec;
        delete childBuilders["lineHeight;"];
        modifiedKeys["lineHeight"] = true;
        return this;
    }

    this.dir = (spec: DirectionMode): IRehearsalBuilder => {
        updates["dir"] = spec;
        delete childBuilders["dir;"];
        modifiedKeys["dir"] = true;
        return this;
    }

    this.enclosure = (spec: EnclosureShape): IRehearsalBuilder => {
        updates["enclosure"] = spec;
        delete childBuilders["enclosure;"];
        modifiedKeys["enclosure"] = true;
        return this;
    }
  }
}
export function patchRehearsal(base: Rehearsal, builder: (build: IRehearsalBuilder) => IRehearsalBuilder): IAny[] { return builder(new RehearsalBuilder(base)).patch(); }
export function buildRehearsal(builder: (build: IRehearsalBuilder) => IRehearsalBuilder): Rehearsal { return builder(new RehearsalBuilder()).build(); }

export interface IWordsBuilder {
  build?: () => Words;
  patch: () => IAny[];
  data: (data: string) => IWordsBuilder;
  justify: (justify: LeftCenterRight) => IWordsBuilder;
  defaultX: (defaultX: number) => IWordsBuilder;
  relativeY: (relativeY: number) => IWordsBuilder;
  defaultY: (defaultY: number) => IWordsBuilder;
  relativeX: (relativeX: number) => IWordsBuilder;
  fontFamily: (fontFamily: string) => IWordsBuilder;
  fontWeight: (fontWeight: NormalBold) => IWordsBuilder;
  fontStyle: (fontStyle: NormalItalic) => IWordsBuilder;
  fontSize: (fontSize: string) => IWordsBuilder;
  color: (color: string) => IWordsBuilder;
  halign: (halign: LeftCenterRight) => IWordsBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IWordsBuilder;
  underline: (underline: number) => IWordsBuilder;
  overline: (overline: number) => IWordsBuilder;
  lineThrough: (lineThrough: number) => IWordsBuilder;
  rotation: (rotation: number) => IWordsBuilder;
  letterSpacing: (letterSpacing: string) => IWordsBuilder;
  lineHeight: (lineHeight: string) => IWordsBuilder;
  dir: (dir: DirectionMode) => IWordsBuilder;
  enclosure: (enclosure: EnclosureShape) => IWordsBuilder;
}

class WordsBuilder implements IWordsBuilder {
  build: () => Words;
  patch: () => IAny[];
  data: (data: string) => IWordsBuilder;
  justify: (justify: LeftCenterRight) => IWordsBuilder;
  defaultX: (defaultX: number) => IWordsBuilder;
  relativeY: (relativeY: number) => IWordsBuilder;
  defaultY: (defaultY: number) => IWordsBuilder;
  relativeX: (relativeX: number) => IWordsBuilder;
  fontFamily: (fontFamily: string) => IWordsBuilder;
  fontWeight: (fontWeight: NormalBold) => IWordsBuilder;
  fontStyle: (fontStyle: NormalItalic) => IWordsBuilder;
  fontSize: (fontSize: string) => IWordsBuilder;
  color: (color: string) => IWordsBuilder;
  halign: (halign: LeftCenterRight) => IWordsBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IWordsBuilder;
  underline: (underline: number) => IWordsBuilder;
  overline: (overline: number) => IWordsBuilder;
  lineThrough: (lineThrough: number) => IWordsBuilder;
  rotation: (rotation: number) => IWordsBuilder;
  letterSpacing: (letterSpacing: string) => IWordsBuilder;
  lineHeight: (lineHeight: string) => IWordsBuilder;
  dir: (dir: DirectionMode) => IWordsBuilder;
  enclosure: (enclosure: EnclosureShape) => IWordsBuilder;
  constructor(original?: Words) {
    let updates: Words = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): Words => {
        checkInvariants();
        (updates as any)._class = "Words";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IWordsBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.justify = (spec: LeftCenterRight): IWordsBuilder => {
        updates["justify"] = spec;
        delete childBuilders["justify;"];
        modifiedKeys["justify"] = true;
        return this;
    }

    this.defaultX = (spec: number): IWordsBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IWordsBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IWordsBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IWordsBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IWordsBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IWordsBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IWordsBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IWordsBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IWordsBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IWordsBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IWordsBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }

    this.underline = (spec: number): IWordsBuilder => {
        updates["underline"] = spec;
        delete childBuilders["underline;"];
        modifiedKeys["underline"] = true;
        return this;
    }

    this.overline = (spec: number): IWordsBuilder => {
        updates["overline"] = spec;
        delete childBuilders["overline;"];
        modifiedKeys["overline"] = true;
        return this;
    }

    this.lineThrough = (spec: number): IWordsBuilder => {
        updates["lineThrough"] = spec;
        delete childBuilders["lineThrough;"];
        modifiedKeys["lineThrough"] = true;
        return this;
    }

    this.rotation = (spec: number): IWordsBuilder => {
        updates["rotation"] = spec;
        delete childBuilders["rotation;"];
        modifiedKeys["rotation"] = true;
        return this;
    }

    this.letterSpacing = (spec: string): IWordsBuilder => {
        updates["letterSpacing"] = spec;
        delete childBuilders["letterSpacing;"];
        modifiedKeys["letterSpacing"] = true;
        return this;
    }

    this.lineHeight = (spec: string): IWordsBuilder => {
        updates["lineHeight"] = spec;
        delete childBuilders["lineHeight;"];
        modifiedKeys["lineHeight"] = true;
        return this;
    }

    this.dir = (spec: DirectionMode): IWordsBuilder => {
        updates["dir"] = spec;
        delete childBuilders["dir;"];
        modifiedKeys["dir"] = true;
        return this;
    }

    this.enclosure = (spec: EnclosureShape): IWordsBuilder => {
        updates["enclosure"] = spec;
        delete childBuilders["enclosure;"];
        modifiedKeys["enclosure"] = true;
        return this;
    }
  }
}
export function patchWords(base: Words, builder: (build: IWordsBuilder) => IWordsBuilder): IAny[] { return builder(new WordsBuilder(base)).patch(); }
export function buildWords(builder: (build: IWordsBuilder) => IWordsBuilder): Words { return builder(new WordsBuilder()).build(); }

export interface IWedgeBuilder {
  build?: () => Wedge;
  patch: () => IAny[];
  number: (number: number) => IWedgeBuilder;
  niente: (niente: boolean) => IWedgeBuilder;
  type: (type: WedgeType) => IWedgeBuilder;
  spread: (spread: number) => IWedgeBuilder;
  defaultX: (defaultX: number) => IWedgeBuilder;
  relativeY: (relativeY: number) => IWedgeBuilder;
  defaultY: (defaultY: number) => IWedgeBuilder;
  relativeX: (relativeX: number) => IWedgeBuilder;
  color: (color: string) => IWedgeBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IWedgeBuilder;
  dashLength: (dashLength: number) => IWedgeBuilder;
  spaceLength: (spaceLength: number) => IWedgeBuilder;
}

class WedgeBuilder implements IWedgeBuilder {
  build: () => Wedge;
  patch: () => IAny[];
  number: (number: number) => IWedgeBuilder;
  niente: (niente: boolean) => IWedgeBuilder;
  type: (type: WedgeType) => IWedgeBuilder;
  spread: (spread: number) => IWedgeBuilder;
  defaultX: (defaultX: number) => IWedgeBuilder;
  relativeY: (relativeY: number) => IWedgeBuilder;
  defaultY: (defaultY: number) => IWedgeBuilder;
  relativeX: (relativeX: number) => IWedgeBuilder;
  color: (color: string) => IWedgeBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IWedgeBuilder;
  dashLength: (dashLength: number) => IWedgeBuilder;
  spaceLength: (spaceLength: number) => IWedgeBuilder;
  constructor(original?: Wedge) {
    let updates: Wedge = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Wedge => {
        checkInvariants();
        (updates as any)._class = "Wedge";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: number): IWedgeBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.niente = (spec: boolean): IWedgeBuilder => {
        updates["niente"] = spec;
        delete childBuilders["niente;"];
        modifiedKeys["niente"] = true;
        return this;
    }

    this.type = (spec: WedgeType): IWedgeBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.spread = (spec: number): IWedgeBuilder => {
        updates["spread"] = spec;
        delete childBuilders["spread;"];
        modifiedKeys["spread"] = true;
        return this;
    }

    this.defaultX = (spec: number): IWedgeBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IWedgeBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IWedgeBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IWedgeBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.color = (spec: string): IWedgeBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.lineType = (spec: SolidDashedDottedWavy): IWedgeBuilder => {
        updates["lineType"] = spec;
        delete childBuilders["lineType;"];
        modifiedKeys["lineType"] = true;
        return this;
    }

    this.dashLength = (spec: number): IWedgeBuilder => {
        updates["dashLength"] = spec;
        delete childBuilders["dashLength;"];
        modifiedKeys["dashLength"] = true;
        return this;
    }

    this.spaceLength = (spec: number): IWedgeBuilder => {
        updates["spaceLength"] = spec;
        delete childBuilders["spaceLength;"];
        modifiedKeys["spaceLength"] = true;
        return this;
    }
  }
}
export function patchWedge(base: Wedge, builder: (build: IWedgeBuilder) => IWedgeBuilder): IAny[] { return builder(new WedgeBuilder(base)).patch(); }
export function buildWedge(builder: (build: IWedgeBuilder) => IWedgeBuilder): Wedge { return builder(new WedgeBuilder()).build(); }

export interface IDashesBuilder {
  build?: () => Dashes;
  patch: () => IAny[];
  number: (number: number) => IDashesBuilder;
  type: (type: StartStopContinue) => IDashesBuilder;
  defaultX: (defaultX: number) => IDashesBuilder;
  relativeY: (relativeY: number) => IDashesBuilder;
  defaultY: (defaultY: number) => IDashesBuilder;
  relativeX: (relativeX: number) => IDashesBuilder;
  color: (color: string) => IDashesBuilder;
  dashLength: (dashLength: number) => IDashesBuilder;
  spaceLength: (spaceLength: number) => IDashesBuilder;
}

class DashesBuilder implements IDashesBuilder {
  build: () => Dashes;
  patch: () => IAny[];
  number: (number: number) => IDashesBuilder;
  type: (type: StartStopContinue) => IDashesBuilder;
  defaultX: (defaultX: number) => IDashesBuilder;
  relativeY: (relativeY: number) => IDashesBuilder;
  defaultY: (defaultY: number) => IDashesBuilder;
  relativeX: (relativeX: number) => IDashesBuilder;
  color: (color: string) => IDashesBuilder;
  dashLength: (dashLength: number) => IDashesBuilder;
  spaceLength: (spaceLength: number) => IDashesBuilder;
  constructor(original?: Dashes) {
    let updates: Dashes = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["number"]) ||
          childBuilders["number"] !== undefined ||
          updates.number !== undefined,
        "number is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Dashes => {
        checkInvariants();
        (updates as any)._class = "Dashes";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: number): IDashesBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.type = (spec: StartStopContinue): IDashesBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): IDashesBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDashesBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDashesBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDashesBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.color = (spec: string): IDashesBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.dashLength = (spec: number): IDashesBuilder => {
        updates["dashLength"] = spec;
        delete childBuilders["dashLength;"];
        modifiedKeys["dashLength"] = true;
        return this;
    }

    this.spaceLength = (spec: number): IDashesBuilder => {
        updates["spaceLength"] = spec;
        delete childBuilders["spaceLength;"];
        modifiedKeys["spaceLength"] = true;
        return this;
    }
  }
}
export function patchDashes(base: Dashes, builder: (build: IDashesBuilder) => IDashesBuilder): IAny[] { return builder(new DashesBuilder(base)).patch(); }
export function buildDashes(builder: (build: IDashesBuilder) => IDashesBuilder): Dashes { return builder(new DashesBuilder()).build(); }

export interface IBracketBuilder {
  build?: () => Bracket;
  patch: () => IAny[];
  endLength: (endLength: number) => IBracketBuilder;
  number: (number: number) => IBracketBuilder;
  type: (type: StartStopContinue) => IBracketBuilder;
  lineEnd: (lineEnd: LineEndType) => IBracketBuilder;
  defaultX: (defaultX: number) => IBracketBuilder;
  relativeY: (relativeY: number) => IBracketBuilder;
  defaultY: (defaultY: number) => IBracketBuilder;
  relativeX: (relativeX: number) => IBracketBuilder;
  color: (color: string) => IBracketBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IBracketBuilder;
  dashLength: (dashLength: number) => IBracketBuilder;
  spaceLength: (spaceLength: number) => IBracketBuilder;
}

class BracketBuilder implements IBracketBuilder {
  build: () => Bracket;
  patch: () => IAny[];
  endLength: (endLength: number) => IBracketBuilder;
  number: (number: number) => IBracketBuilder;
  type: (type: StartStopContinue) => IBracketBuilder;
  lineEnd: (lineEnd: LineEndType) => IBracketBuilder;
  defaultX: (defaultX: number) => IBracketBuilder;
  relativeY: (relativeY: number) => IBracketBuilder;
  defaultY: (defaultY: number) => IBracketBuilder;
  relativeX: (relativeX: number) => IBracketBuilder;
  color: (color: string) => IBracketBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IBracketBuilder;
  dashLength: (dashLength: number) => IBracketBuilder;
  spaceLength: (spaceLength: number) => IBracketBuilder;
  constructor(original?: Bracket) {
    let updates: Bracket = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["endLength"]) ||
          childBuilders["endLength"] !== undefined ||
          updates.endLength !== undefined,
        "endLength is a required field");
      console.assert(
          (original && !modifiedKeys["number"]) ||
          childBuilders["number"] !== undefined ||
          updates.number !== undefined,
        "number is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
      console.assert(
          (original && !modifiedKeys["lineEnd"]) ||
          childBuilders["lineEnd"] !== undefined ||
          updates.lineEnd !== undefined,
        "lineEnd is a required field");
    }

    if (!original) {
      this.build = (): Bracket => {
        checkInvariants();
        (updates as any)._class = "Bracket";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.endLength = (spec: number): IBracketBuilder => {
        updates["endLength"] = spec;
        delete childBuilders["endLength;"];
        modifiedKeys["endLength"] = true;
        return this;
    }

    this.number = (spec: number): IBracketBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.type = (spec: StartStopContinue): IBracketBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.lineEnd = (spec: LineEndType): IBracketBuilder => {
        updates["lineEnd"] = spec;
        delete childBuilders["lineEnd;"];
        modifiedKeys["lineEnd"] = true;
        return this;
    }

    this.defaultX = (spec: number): IBracketBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IBracketBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IBracketBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IBracketBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.color = (spec: string): IBracketBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.lineType = (spec: SolidDashedDottedWavy): IBracketBuilder => {
        updates["lineType"] = spec;
        delete childBuilders["lineType;"];
        modifiedKeys["lineType"] = true;
        return this;
    }

    this.dashLength = (spec: number): IBracketBuilder => {
        updates["dashLength"] = spec;
        delete childBuilders["dashLength;"];
        modifiedKeys["dashLength"] = true;
        return this;
    }

    this.spaceLength = (spec: number): IBracketBuilder => {
        updates["spaceLength"] = spec;
        delete childBuilders["spaceLength;"];
        modifiedKeys["spaceLength"] = true;
        return this;
    }
  }
}
export function patchBracket(base: Bracket, builder: (build: IBracketBuilder) => IBracketBuilder): IAny[] { return builder(new BracketBuilder(base)).patch(); }
export function buildBracket(builder: (build: IBracketBuilder) => IBracketBuilder): Bracket { return builder(new BracketBuilder()).build(); }

export interface IPedalBuilder {
  build?: () => Pedal;
  patch: () => IAny[];
  line: (line: boolean) => IPedalBuilder;
  sign: (sign: boolean) => IPedalBuilder;
  type: (type: PedalType) => IPedalBuilder;
  defaultX: (defaultX: number) => IPedalBuilder;
  relativeY: (relativeY: number) => IPedalBuilder;
  defaultY: (defaultY: number) => IPedalBuilder;
  relativeX: (relativeX: number) => IPedalBuilder;
  fontFamily: (fontFamily: string) => IPedalBuilder;
  fontWeight: (fontWeight: NormalBold) => IPedalBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPedalBuilder;
  fontSize: (fontSize: string) => IPedalBuilder;
  color: (color: string) => IPedalBuilder;
  halign: (halign: LeftCenterRight) => IPedalBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IPedalBuilder;
}

class PedalBuilder implements IPedalBuilder {
  build: () => Pedal;
  patch: () => IAny[];
  line: (line: boolean) => IPedalBuilder;
  sign: (sign: boolean) => IPedalBuilder;
  type: (type: PedalType) => IPedalBuilder;
  defaultX: (defaultX: number) => IPedalBuilder;
  relativeY: (relativeY: number) => IPedalBuilder;
  defaultY: (defaultY: number) => IPedalBuilder;
  relativeX: (relativeX: number) => IPedalBuilder;
  fontFamily: (fontFamily: string) => IPedalBuilder;
  fontWeight: (fontWeight: NormalBold) => IPedalBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPedalBuilder;
  fontSize: (fontSize: string) => IPedalBuilder;
  color: (color: string) => IPedalBuilder;
  halign: (halign: LeftCenterRight) => IPedalBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IPedalBuilder;
  constructor(original?: Pedal) {
    let updates: Pedal = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["line"]) ||
          childBuilders["line"] !== undefined ||
          updates.line !== undefined,
        "line is a required field");
      console.assert(
          (original && !modifiedKeys["sign"]) ||
          childBuilders["sign"] !== undefined ||
          updates.sign !== undefined,
        "sign is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Pedal => {
        checkInvariants();
        (updates as any)._class = "Pedal";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.line = (spec: boolean): IPedalBuilder => {
        updates["line"] = spec;
        delete childBuilders["line;"];
        modifiedKeys["line"] = true;
        return this;
    }

    this.sign = (spec: boolean): IPedalBuilder => {
        updates["sign"] = spec;
        delete childBuilders["sign;"];
        modifiedKeys["sign"] = true;
        return this;
    }

    this.type = (spec: PedalType): IPedalBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): IPedalBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IPedalBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IPedalBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IPedalBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IPedalBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IPedalBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IPedalBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IPedalBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IPedalBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IPedalBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IPedalBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchPedal(base: Pedal, builder: (build: IPedalBuilder) => IPedalBuilder): IAny[] { return builder(new PedalBuilder(base)).patch(); }
export function buildPedal(builder: (build: IPedalBuilder) => IPedalBuilder): Pedal { return builder(new PedalBuilder()).build(); }

export interface IMetronomeBuilder {
  build?: () => Metronome;
  patch: () => IAny[];
  metronomeNotesAt: (idx: number, build: MetronomeNote | ((builder: IMetronomeNoteBuilder) => IMetronomeNoteBuilder)) => IMetronomeBuilder;
  metronomeNotesSplice: (start: number, deleteCount: number, ...items: MetronomeNote[]) => IMetronomeBuilder;
  metronomeNotes: (metronomeNotes: MetronomeNote[]) => IMetronomeBuilder;
  perMinute: (build: PerMinute | ((builder: IPerMinuteBuilder) => IPerMinuteBuilder)) => IMetronomeBuilder;
  parentheses: (parentheses: boolean) => IMetronomeBuilder;
  beatUnit: (beatUnit: string) => IMetronomeBuilder;
  beatUnitDotsAt: (idx: number, build: BeatUnitDot | ((builder: IBeatUnitDotBuilder) => IBeatUnitDotBuilder)) => IMetronomeBuilder;
  beatUnitDotsSplice: (start: number, deleteCount: number, ...items: BeatUnitDot[]) => IMetronomeBuilder;
  beatUnitDots: (beatUnitDots: BeatUnitDot[]) => IMetronomeBuilder;
  beatUnitChange: (beatUnitChange: string) => IMetronomeBuilder;
  beatUnitDotsChangeAt: (idx: number, build: BeatUnitDot | ((builder: IBeatUnitDotBuilder) => IBeatUnitDotBuilder)) => IMetronomeBuilder;
  beatUnitDotsChangeSplice: (start: number, deleteCount: number, ...items: BeatUnitDot[]) => IMetronomeBuilder;
  beatUnitDotsChange: (beatUnitDotsChange: BeatUnitDot[]) => IMetronomeBuilder;
  metronomeRelation: (metronomeRelation: string) => IMetronomeBuilder;
  justify: (justify: LeftCenterRight) => IMetronomeBuilder;
  defaultX: (defaultX: number) => IMetronomeBuilder;
  relativeY: (relativeY: number) => IMetronomeBuilder;
  defaultY: (defaultY: number) => IMetronomeBuilder;
  relativeX: (relativeX: number) => IMetronomeBuilder;
  fontFamily: (fontFamily: string) => IMetronomeBuilder;
  fontWeight: (fontWeight: NormalBold) => IMetronomeBuilder;
  fontStyle: (fontStyle: NormalItalic) => IMetronomeBuilder;
  fontSize: (fontSize: string) => IMetronomeBuilder;
  color: (color: string) => IMetronomeBuilder;
  halign: (halign: LeftCenterRight) => IMetronomeBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IMetronomeBuilder;
}

class MetronomeBuilder implements IMetronomeBuilder {
  build: () => Metronome;
  patch: () => IAny[];
  metronomeNotesAt: (idx: number, build: MetronomeNote | ((builder: IMetronomeNoteBuilder) => IMetronomeNoteBuilder)) => IMetronomeBuilder;
  metronomeNotesSplice: (start: number, deleteCount: number, ...items: MetronomeNote[]) => IMetronomeBuilder;
  metronomeNotes: (metronomeNotes: MetronomeNote[]) => IMetronomeBuilder;
  perMinute: (build: PerMinute | ((builder: IPerMinuteBuilder) => IPerMinuteBuilder)) => IMetronomeBuilder;
  parentheses: (parentheses: boolean) => IMetronomeBuilder;
  beatUnit: (beatUnit: string) => IMetronomeBuilder;
  beatUnitDotsAt: (idx: number, build: BeatUnitDot | ((builder: IBeatUnitDotBuilder) => IBeatUnitDotBuilder)) => IMetronomeBuilder;
  beatUnitDotsSplice: (start: number, deleteCount: number, ...items: BeatUnitDot[]) => IMetronomeBuilder;
  beatUnitDots: (beatUnitDots: BeatUnitDot[]) => IMetronomeBuilder;
  beatUnitChange: (beatUnitChange: string) => IMetronomeBuilder;
  beatUnitDotsChangeAt: (idx: number, build: BeatUnitDot | ((builder: IBeatUnitDotBuilder) => IBeatUnitDotBuilder)) => IMetronomeBuilder;
  beatUnitDotsChangeSplice: (start: number, deleteCount: number, ...items: BeatUnitDot[]) => IMetronomeBuilder;
  beatUnitDotsChange: (beatUnitDotsChange: BeatUnitDot[]) => IMetronomeBuilder;
  metronomeRelation: (metronomeRelation: string) => IMetronomeBuilder;
  justify: (justify: LeftCenterRight) => IMetronomeBuilder;
  defaultX: (defaultX: number) => IMetronomeBuilder;
  relativeY: (relativeY: number) => IMetronomeBuilder;
  defaultY: (defaultY: number) => IMetronomeBuilder;
  relativeX: (relativeX: number) => IMetronomeBuilder;
  fontFamily: (fontFamily: string) => IMetronomeBuilder;
  fontWeight: (fontWeight: NormalBold) => IMetronomeBuilder;
  fontStyle: (fontStyle: NormalItalic) => IMetronomeBuilder;
  fontSize: (fontSize: string) => IMetronomeBuilder;
  color: (color: string) => IMetronomeBuilder;
  halign: (halign: LeftCenterRight) => IMetronomeBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IMetronomeBuilder;
  constructor(original?: Metronome) {
    let updates: Metronome = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["metronomeNotes"]) ||
          childBuilders["metronomeNotes"] !== undefined ||
          updates.metronomeNotes !== undefined,
        "metronomeNotes is a required field");
      console.assert(
          (original && !modifiedKeys["perMinute"]) ||
          childBuilders["perMinute"] !== undefined ||
          updates.perMinute !== undefined,
        "perMinute is a required field");
      console.assert(
          (original && !modifiedKeys["parentheses"]) ||
          childBuilders["parentheses"] !== undefined ||
          updates.parentheses !== undefined,
        "parentheses is a required field");
      console.assert(
          (original && !modifiedKeys["beatUnit"]) ||
          childBuilders["beatUnit"] !== undefined ||
          updates.beatUnit !== undefined,
        "beatUnit is a required field");
      console.assert(
          (original && !modifiedKeys["beatUnitDots"]) ||
          childBuilders["beatUnitDots"] !== undefined ||
          updates.beatUnitDots !== undefined,
        "beatUnitDots is a required field");
      console.assert(
          (original && !modifiedKeys["beatUnitChange"]) ||
          childBuilders["beatUnitChange"] !== undefined ||
          updates.beatUnitChange !== undefined,
        "beatUnitChange is a required field");
      console.assert(
          (original && !modifiedKeys["beatUnitDotsChange"]) ||
          childBuilders["beatUnitDotsChange"] !== undefined ||
          updates.beatUnitDotsChange !== undefined,
        "beatUnitDotsChange is a required field");
      console.assert(
          (original && !modifiedKeys["metronomeRelation"]) ||
          childBuilders["metronomeRelation"] !== undefined ||
          updates.metronomeRelation !== undefined,
        "metronomeRelation is a required field");
    }

    if (!original) {
      this.build = (): Metronome => {
        checkInvariants();
        (updates as any)._class = "Metronome";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.metronomeNotes = (spec: MetronomeNote[]): IMetronomeBuilder => {
        updates["metronomeNotes"] = spec;
        delete childBuilders["metronomeNotes;"];
        modifiedKeys["metronomeNotes"] = true;
        return this;
    }

    this.metronomeNotesAt = (idx: number, build: MetronomeNote | ((builder: IMetronomeNoteBuilder) => IMetronomeNoteBuilder)): IMetronomeBuilder => {
      makeReference("metronomeNotes");
      if (frozen["metronomeNotes"][idx]) {
          throw new Error("Patching metronomeNotes." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["metronomeNotes"] && !original["metronomeNotes"]) {
          // Clone snapshot.
          patches.push({p: ["metronomeNotes", idx], li: original._snapshot["metronomeNotes"]});
      }
      if (typeof build === 'function' && reference["metronomeNotes"][idx]) {
        let patch = (build as any)(new MetronomeNoteBuilder(reference["metronomeNotes"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["metronomeNotes", idx].concat(patch.p);
          return patch;
        }));
        frozen["metronomeNotes"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new MetronomeNoteBuilder(reference["metronomeNotes"][idx])).build() : build;
      if (original) {
        patches.push({p: ["metronomeNotes", idx], li: update});
      } else {
        updates["metronomeNotes"] = reference["metronomeNotes"]; // TODO: Merge?
      } 
      reference["metronomeNotes"][idx] = update;
      frozen["metronomeNotes"][idx] = true;
      return this;
    }

    this.metronomeNotesSplice = (start: number, deleteCount: number, ...items: MetronomeNote[]): IMetronomeBuilder => {
      makeReference("metronomeNotes");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["metronomeNotes"][idx]) {
            throw new Error("Replacing metronomeNotes." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["metronomeNotes"][idx];
          patches.push({p: ["metronomeNotes", idx], ld, li: items[idx - start]});
          frozen["metronomeNotes"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["metronomeNotes"][idx]) {
            throw new Error("Removing metronomeNotes." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["metronomeNotes"][idx];
          patches.push({p: ["metronomeNotes", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["metronomeNotes", idx], li: items[idx - start]});
          frozen["metronomeNotes"][idx] = true;
        }
      }
      reference["metronomeNotes"].splice(start, deleteCount, ...items);
      updates["metronomeNotes"] = reference["metronomeNotes"];
      frozen["metronomeNotes"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.perMinute = (build: PerMinute | ((builder: IPerMinuteBuilder) => IPerMinuteBuilder)): IMetronomeBuilder => {
      if (typeof build === 'function') {
        delete updates["perMinute"]
        const builder = (build as any)(new PerMinuteBuilder(original && original["perMinute"]));
        if (!original) updates["perMinute"] = builder.build();
        else childBuilders["perMinute"] = builder;
      } else {
        updates.perMinute = build as any;
        delete childBuilders["perMinute;"];
      }
      modifiedKeys["perMinute"] = true;
      return this;
    }

    this.parentheses = (spec: boolean): IMetronomeBuilder => {
        updates["parentheses"] = spec;
        delete childBuilders["parentheses;"];
        modifiedKeys["parentheses"] = true;
        return this;
    }

    this.beatUnit = (spec: string): IMetronomeBuilder => {
        updates["beatUnit"] = spec;
        delete childBuilders["beatUnit;"];
        modifiedKeys["beatUnit"] = true;
        return this;
    }

    this.beatUnitDots = (spec: BeatUnitDot[]): IMetronomeBuilder => {
        updates["beatUnitDots"] = spec;
        delete childBuilders["beatUnitDots;"];
        modifiedKeys["beatUnitDots"] = true;
        return this;
    }

    this.beatUnitDotsAt = (idx: number, build: BeatUnitDot | ((builder: IBeatUnitDotBuilder) => IBeatUnitDotBuilder)): IMetronomeBuilder => {
      makeReference("beatUnitDots");
      if (frozen["beatUnitDots"][idx]) {
          throw new Error("Patching beatUnitDots." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["beatUnitDots"] && !original["beatUnitDots"]) {
          // Clone snapshot.
          patches.push({p: ["beatUnitDots", idx], li: original._snapshot["beatUnitDots"]});
      }
      if (typeof build === 'function' && reference["beatUnitDots"][idx]) {
        let patch = (build as any)(new BeatUnitDotBuilder(reference["beatUnitDots"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["beatUnitDots", idx].concat(patch.p);
          return patch;
        }));
        frozen["beatUnitDots"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new BeatUnitDotBuilder(reference["beatUnitDots"][idx])).build() : build;
      if (original) {
        patches.push({p: ["beatUnitDots", idx], li: update});
      } else {
        updates["beatUnitDots"] = reference["beatUnitDots"]; // TODO: Merge?
      } 
      reference["beatUnitDots"][idx] = update;
      frozen["beatUnitDots"][idx] = true;
      return this;
    }

    this.beatUnitDotsSplice = (start: number, deleteCount: number, ...items: BeatUnitDot[]): IMetronomeBuilder => {
      makeReference("beatUnitDots");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["beatUnitDots"][idx]) {
            throw new Error("Replacing beatUnitDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["beatUnitDots"][idx];
          patches.push({p: ["beatUnitDots", idx], ld, li: items[idx - start]});
          frozen["beatUnitDots"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["beatUnitDots"][idx]) {
            throw new Error("Removing beatUnitDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["beatUnitDots"][idx];
          patches.push({p: ["beatUnitDots", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["beatUnitDots", idx], li: items[idx - start]});
          frozen["beatUnitDots"][idx] = true;
        }
      }
      reference["beatUnitDots"].splice(start, deleteCount, ...items);
      updates["beatUnitDots"] = reference["beatUnitDots"];
      frozen["beatUnitDots"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.beatUnitChange = (spec: string): IMetronomeBuilder => {
        updates["beatUnitChange"] = spec;
        delete childBuilders["beatUnitChange;"];
        modifiedKeys["beatUnitChange"] = true;
        return this;
    }

    this.beatUnitDotsChange = (spec: BeatUnitDot[]): IMetronomeBuilder => {
        updates["beatUnitDotsChange"] = spec;
        delete childBuilders["beatUnitDotsChange;"];
        modifiedKeys["beatUnitDotsChange"] = true;
        return this;
    }

    this.beatUnitDotsChangeAt = (idx: number, build: BeatUnitDot | ((builder: IBeatUnitDotBuilder) => IBeatUnitDotBuilder)): IMetronomeBuilder => {
      makeReference("beatUnitDotsChange");
      if (frozen["beatUnitDotsChange"][idx]) {
          throw new Error("Patching beatUnitDotsChange." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["beatUnitDotsChange"] && !original["beatUnitDotsChange"]) {
          // Clone snapshot.
          patches.push({p: ["beatUnitDotsChange", idx], li: original._snapshot["beatUnitDotsChange"]});
      }
      if (typeof build === 'function' && reference["beatUnitDotsChange"][idx]) {
        let patch = (build as any)(new BeatUnitDotBuilder(reference["beatUnitDotsChange"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["beatUnitDotsChange", idx].concat(patch.p);
          return patch;
        }));
        frozen["beatUnitDotsChange"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new BeatUnitDotBuilder(reference["beatUnitDotsChange"][idx])).build() : build;
      if (original) {
        patches.push({p: ["beatUnitDotsChange", idx], li: update});
      } else {
        updates["beatUnitDotsChange"] = reference["beatUnitDotsChange"]; // TODO: Merge?
      } 
      reference["beatUnitDotsChange"][idx] = update;
      frozen["beatUnitDotsChange"][idx] = true;
      return this;
    }

    this.beatUnitDotsChangeSplice = (start: number, deleteCount: number, ...items: BeatUnitDot[]): IMetronomeBuilder => {
      makeReference("beatUnitDotsChange");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["beatUnitDotsChange"][idx]) {
            throw new Error("Replacing beatUnitDotsChange." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["beatUnitDotsChange"][idx];
          patches.push({p: ["beatUnitDotsChange", idx], ld, li: items[idx - start]});
          frozen["beatUnitDotsChange"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["beatUnitDotsChange"][idx]) {
            throw new Error("Removing beatUnitDotsChange." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["beatUnitDotsChange"][idx];
          patches.push({p: ["beatUnitDotsChange", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["beatUnitDotsChange", idx], li: items[idx - start]});
          frozen["beatUnitDotsChange"][idx] = true;
        }
      }
      reference["beatUnitDotsChange"].splice(start, deleteCount, ...items);
      updates["beatUnitDotsChange"] = reference["beatUnitDotsChange"];
      frozen["beatUnitDotsChange"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.metronomeRelation = (spec: string): IMetronomeBuilder => {
        updates["metronomeRelation"] = spec;
        delete childBuilders["metronomeRelation;"];
        modifiedKeys["metronomeRelation"] = true;
        return this;
    }

    this.justify = (spec: LeftCenterRight): IMetronomeBuilder => {
        updates["justify"] = spec;
        delete childBuilders["justify;"];
        modifiedKeys["justify"] = true;
        return this;
    }

    this.defaultX = (spec: number): IMetronomeBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IMetronomeBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IMetronomeBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IMetronomeBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IMetronomeBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IMetronomeBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IMetronomeBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IMetronomeBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IMetronomeBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IMetronomeBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IMetronomeBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchMetronome(base: Metronome, builder: (build: IMetronomeBuilder) => IMetronomeBuilder): IAny[] { return builder(new MetronomeBuilder(base)).patch(); }
export function buildMetronome(builder: (build: IMetronomeBuilder) => IMetronomeBuilder): Metronome { return builder(new MetronomeBuilder()).build(); }

export interface IBeatUnitDotBuilder {
  build?: () => BeatUnitDot;
  patch: () => IAny[];
}

class BeatUnitDotBuilder implements IBeatUnitDotBuilder {
  build: () => BeatUnitDot;
  patch: () => IAny[];
  constructor(original?: BeatUnitDot) {
    let updates: BeatUnitDot = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): BeatUnitDot => {
        checkInvariants();
        (updates as any)._class = "BeatUnitDot";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchBeatUnitDot(base: BeatUnitDot, builder: (build: IBeatUnitDotBuilder) => IBeatUnitDotBuilder): IAny[] { return builder(new BeatUnitDotBuilder(base)).patch(); }
export function buildBeatUnitDot(builder: (build: IBeatUnitDotBuilder) => IBeatUnitDotBuilder): BeatUnitDot { return builder(new BeatUnitDotBuilder()).build(); }

export interface IPerMinuteBuilder {
  build?: () => PerMinute;
  patch: () => IAny[];
  data: (data: string) => IPerMinuteBuilder;
  fontFamily: (fontFamily: string) => IPerMinuteBuilder;
  fontWeight: (fontWeight: NormalBold) => IPerMinuteBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPerMinuteBuilder;
  fontSize: (fontSize: string) => IPerMinuteBuilder;
}

class PerMinuteBuilder implements IPerMinuteBuilder {
  build: () => PerMinute;
  patch: () => IAny[];
  data: (data: string) => IPerMinuteBuilder;
  fontFamily: (fontFamily: string) => IPerMinuteBuilder;
  fontWeight: (fontWeight: NormalBold) => IPerMinuteBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPerMinuteBuilder;
  fontSize: (fontSize: string) => IPerMinuteBuilder;
  constructor(original?: PerMinute) {
    let updates: PerMinute = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): PerMinute => {
        checkInvariants();
        (updates as any)._class = "PerMinute";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IPerMinuteBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IPerMinuteBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IPerMinuteBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IPerMinuteBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IPerMinuteBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }
  }
}
export function patchPerMinute(base: PerMinute, builder: (build: IPerMinuteBuilder) => IPerMinuteBuilder): IAny[] { return builder(new PerMinuteBuilder(base)).patch(); }
export function buildPerMinute(builder: (build: IPerMinuteBuilder) => IPerMinuteBuilder): PerMinute { return builder(new PerMinuteBuilder()).build(); }

export interface IMetronomeNoteBuilder {
  build?: () => MetronomeNote;
  patch: () => IAny[];
  metronomeDotsAt: (idx: number, build: MetronomeDot | ((builder: IMetronomeDotBuilder) => IMetronomeDotBuilder)) => IMetronomeNoteBuilder;
  metronomeDotsSplice: (start: number, deleteCount: number, ...items: MetronomeDot[]) => IMetronomeNoteBuilder;
  metronomeDots: (metronomeDots: MetronomeDot[]) => IMetronomeNoteBuilder;
  metronomeBeamsAt: (idx: number, build: MetronomeBeam | ((builder: IMetronomeBeamBuilder) => IMetronomeBeamBuilder)) => IMetronomeNoteBuilder;
  metronomeBeamsSplice: (start: number, deleteCount: number, ...items: MetronomeBeam[]) => IMetronomeNoteBuilder;
  metronomeBeams: (metronomeBeams: MetronomeBeam[]) => IMetronomeNoteBuilder;
  metronomeType: (metronomeType: string) => IMetronomeNoteBuilder;
  metronomeTuplet: (build: MetronomeTuplet | ((builder: IMetronomeTupletBuilder) => IMetronomeTupletBuilder)) => IMetronomeNoteBuilder;
}

class MetronomeNoteBuilder implements IMetronomeNoteBuilder {
  build: () => MetronomeNote;
  patch: () => IAny[];
  metronomeDotsAt: (idx: number, build: MetronomeDot | ((builder: IMetronomeDotBuilder) => IMetronomeDotBuilder)) => IMetronomeNoteBuilder;
  metronomeDotsSplice: (start: number, deleteCount: number, ...items: MetronomeDot[]) => IMetronomeNoteBuilder;
  metronomeDots: (metronomeDots: MetronomeDot[]) => IMetronomeNoteBuilder;
  metronomeBeamsAt: (idx: number, build: MetronomeBeam | ((builder: IMetronomeBeamBuilder) => IMetronomeBeamBuilder)) => IMetronomeNoteBuilder;
  metronomeBeamsSplice: (start: number, deleteCount: number, ...items: MetronomeBeam[]) => IMetronomeNoteBuilder;
  metronomeBeams: (metronomeBeams: MetronomeBeam[]) => IMetronomeNoteBuilder;
  metronomeType: (metronomeType: string) => IMetronomeNoteBuilder;
  metronomeTuplet: (build: MetronomeTuplet | ((builder: IMetronomeTupletBuilder) => IMetronomeTupletBuilder)) => IMetronomeNoteBuilder;
  constructor(original?: MetronomeNote) {
    let updates: MetronomeNote = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["metronomeDots"]) ||
          childBuilders["metronomeDots"] !== undefined ||
          updates.metronomeDots !== undefined,
        "metronomeDots is a required field");
      console.assert(
          (original && !modifiedKeys["metronomeBeams"]) ||
          childBuilders["metronomeBeams"] !== undefined ||
          updates.metronomeBeams !== undefined,
        "metronomeBeams is a required field");
      console.assert(
          (original && !modifiedKeys["metronomeType"]) ||
          childBuilders["metronomeType"] !== undefined ||
          updates.metronomeType !== undefined,
        "metronomeType is a required field");
      console.assert(
          (original && !modifiedKeys["metronomeTuplet"]) ||
          childBuilders["metronomeTuplet"] !== undefined ||
          updates.metronomeTuplet !== undefined,
        "metronomeTuplet is a required field");
    }

    if (!original) {
      this.build = (): MetronomeNote => {
        checkInvariants();
        (updates as any)._class = "MetronomeNote";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.metronomeDots = (spec: MetronomeDot[]): IMetronomeNoteBuilder => {
        updates["metronomeDots"] = spec;
        delete childBuilders["metronomeDots;"];
        modifiedKeys["metronomeDots"] = true;
        return this;
    }

    this.metronomeDotsAt = (idx: number, build: MetronomeDot | ((builder: IMetronomeDotBuilder) => IMetronomeDotBuilder)): IMetronomeNoteBuilder => {
      makeReference("metronomeDots");
      if (frozen["metronomeDots"][idx]) {
          throw new Error("Patching metronomeDots." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["metronomeDots"] && !original["metronomeDots"]) {
          // Clone snapshot.
          patches.push({p: ["metronomeDots", idx], li: original._snapshot["metronomeDots"]});
      }
      if (typeof build === 'function' && reference["metronomeDots"][idx]) {
        let patch = (build as any)(new MetronomeDotBuilder(reference["metronomeDots"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["metronomeDots", idx].concat(patch.p);
          return patch;
        }));
        frozen["metronomeDots"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new MetronomeDotBuilder(reference["metronomeDots"][idx])).build() : build;
      if (original) {
        patches.push({p: ["metronomeDots", idx], li: update});
      } else {
        updates["metronomeDots"] = reference["metronomeDots"]; // TODO: Merge?
      } 
      reference["metronomeDots"][idx] = update;
      frozen["metronomeDots"][idx] = true;
      return this;
    }

    this.metronomeDotsSplice = (start: number, deleteCount: number, ...items: MetronomeDot[]): IMetronomeNoteBuilder => {
      makeReference("metronomeDots");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["metronomeDots"][idx]) {
            throw new Error("Replacing metronomeDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["metronomeDots"][idx];
          patches.push({p: ["metronomeDots", idx], ld, li: items[idx - start]});
          frozen["metronomeDots"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["metronomeDots"][idx]) {
            throw new Error("Removing metronomeDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["metronomeDots"][idx];
          patches.push({p: ["metronomeDots", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["metronomeDots", idx], li: items[idx - start]});
          frozen["metronomeDots"][idx] = true;
        }
      }
      reference["metronomeDots"].splice(start, deleteCount, ...items);
      updates["metronomeDots"] = reference["metronomeDots"];
      frozen["metronomeDots"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.metronomeBeams = (spec: MetronomeBeam[]): IMetronomeNoteBuilder => {
        updates["metronomeBeams"] = spec;
        delete childBuilders["metronomeBeams;"];
        modifiedKeys["metronomeBeams"] = true;
        return this;
    }

    this.metronomeBeamsAt = (idx: number, build: MetronomeBeam | ((builder: IMetronomeBeamBuilder) => IMetronomeBeamBuilder)): IMetronomeNoteBuilder => {
      makeReference("metronomeBeams");
      if (frozen["metronomeBeams"][idx]) {
          throw new Error("Patching metronomeBeams." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["metronomeBeams"] && !original["metronomeBeams"]) {
          // Clone snapshot.
          patches.push({p: ["metronomeBeams", idx], li: original._snapshot["metronomeBeams"]});
      }
      if (typeof build === 'function' && reference["metronomeBeams"][idx]) {
        let patch = (build as any)(new MetronomeBeamBuilder(reference["metronomeBeams"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["metronomeBeams", idx].concat(patch.p);
          return patch;
        }));
        frozen["metronomeBeams"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new MetronomeBeamBuilder(reference["metronomeBeams"][idx])).build() : build;
      if (original) {
        patches.push({p: ["metronomeBeams", idx], li: update});
      } else {
        updates["metronomeBeams"] = reference["metronomeBeams"]; // TODO: Merge?
      } 
      reference["metronomeBeams"][idx] = update;
      frozen["metronomeBeams"][idx] = true;
      return this;
    }

    this.metronomeBeamsSplice = (start: number, deleteCount: number, ...items: MetronomeBeam[]): IMetronomeNoteBuilder => {
      makeReference("metronomeBeams");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["metronomeBeams"][idx]) {
            throw new Error("Replacing metronomeBeams." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["metronomeBeams"][idx];
          patches.push({p: ["metronomeBeams", idx], ld, li: items[idx - start]});
          frozen["metronomeBeams"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["metronomeBeams"][idx]) {
            throw new Error("Removing metronomeBeams." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["metronomeBeams"][idx];
          patches.push({p: ["metronomeBeams", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["metronomeBeams", idx], li: items[idx - start]});
          frozen["metronomeBeams"][idx] = true;
        }
      }
      reference["metronomeBeams"].splice(start, deleteCount, ...items);
      updates["metronomeBeams"] = reference["metronomeBeams"];
      frozen["metronomeBeams"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.metronomeType = (spec: string): IMetronomeNoteBuilder => {
        updates["metronomeType"] = spec;
        delete childBuilders["metronomeType;"];
        modifiedKeys["metronomeType"] = true;
        return this;
    }

    this.metronomeTuplet = (build: MetronomeTuplet | ((builder: IMetronomeTupletBuilder) => IMetronomeTupletBuilder)): IMetronomeNoteBuilder => {
      if (typeof build === 'function') {
        delete updates["metronomeTuplet"]
        const builder = (build as any)(new MetronomeTupletBuilder(original && original["metronomeTuplet"]));
        if (!original) updates["metronomeTuplet"] = builder.build();
        else childBuilders["metronomeTuplet"] = builder;
      } else {
        updates.metronomeTuplet = build as any;
        delete childBuilders["metronomeTuplet;"];
      }
      modifiedKeys["metronomeTuplet"] = true;
      return this;
    }
  }
}
export function patchMetronomeNote(base: MetronomeNote, builder: (build: IMetronomeNoteBuilder) => IMetronomeNoteBuilder): IAny[] { return builder(new MetronomeNoteBuilder(base)).patch(); }
export function buildMetronomeNote(builder: (build: IMetronomeNoteBuilder) => IMetronomeNoteBuilder): MetronomeNote { return builder(new MetronomeNoteBuilder()).build(); }

export interface IMetronomeDotBuilder {
  build?: () => MetronomeDot;
  patch: () => IAny[];
}

class MetronomeDotBuilder implements IMetronomeDotBuilder {
  build: () => MetronomeDot;
  patch: () => IAny[];
  constructor(original?: MetronomeDot) {
    let updates: MetronomeDot = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): MetronomeDot => {
        checkInvariants();
        (updates as any)._class = "MetronomeDot";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchMetronomeDot(base: MetronomeDot, builder: (build: IMetronomeDotBuilder) => IMetronomeDotBuilder): IAny[] { return builder(new MetronomeDotBuilder(base)).patch(); }
export function buildMetronomeDot(builder: (build: IMetronomeDotBuilder) => IMetronomeDotBuilder): MetronomeDot { return builder(new MetronomeDotBuilder()).build(); }

export interface IMetronomeBeamBuilder {
  build?: () => MetronomeBeam;
  patch: () => IAny[];
  number: (number: number) => IMetronomeBeamBuilder;
  data: (data: string) => IMetronomeBeamBuilder;
}

class MetronomeBeamBuilder implements IMetronomeBeamBuilder {
  build: () => MetronomeBeam;
  patch: () => IAny[];
  number: (number: number) => IMetronomeBeamBuilder;
  data: (data: string) => IMetronomeBeamBuilder;
  constructor(original?: MetronomeBeam) {
    let updates: MetronomeBeam = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["number"]) ||
          childBuilders["number"] !== undefined ||
          updates.number !== undefined,
        "number is a required field");
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): MetronomeBeam => {
        checkInvariants();
        (updates as any)._class = "MetronomeBeam";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: number): IMetronomeBeamBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.data = (spec: string): IMetronomeBeamBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }
  }
}
export function patchMetronomeBeam(base: MetronomeBeam, builder: (build: IMetronomeBeamBuilder) => IMetronomeBeamBuilder): IAny[] { return builder(new MetronomeBeamBuilder(base)).patch(); }
export function buildMetronomeBeam(builder: (build: IMetronomeBeamBuilder) => IMetronomeBeamBuilder): MetronomeBeam { return builder(new MetronomeBeamBuilder()).build(); }

export interface IMetronomeTupletBuilder {
  build?: () => MetronomeTuplet;
  patch: () => IAny[];
  actualNotes: (actualNotes: number) => IMetronomeTupletBuilder;
  bracket: (bracket: boolean) => IMetronomeTupletBuilder;
  showNumber: (showNumber: ActualBothNone) => IMetronomeTupletBuilder;
  normalType: (normalType: string) => IMetronomeTupletBuilder;
  type: (type: StartStop) => IMetronomeTupletBuilder;
  normalNotes: (normalNotes: number) => IMetronomeTupletBuilder;
  normalDotsAt: (idx: number, build: NormalDot | ((builder: INormalDotBuilder) => INormalDotBuilder)) => IMetronomeTupletBuilder;
  normalDotsSplice: (start: number, deleteCount: number, ...items: NormalDot[]) => IMetronomeTupletBuilder;
  normalDots: (normalDots: NormalDot[]) => IMetronomeTupletBuilder;
}

class MetronomeTupletBuilder implements IMetronomeTupletBuilder {
  build: () => MetronomeTuplet;
  patch: () => IAny[];
  actualNotes: (actualNotes: number) => IMetronomeTupletBuilder;
  bracket: (bracket: boolean) => IMetronomeTupletBuilder;
  showNumber: (showNumber: ActualBothNone) => IMetronomeTupletBuilder;
  normalType: (normalType: string) => IMetronomeTupletBuilder;
  type: (type: StartStop) => IMetronomeTupletBuilder;
  normalNotes: (normalNotes: number) => IMetronomeTupletBuilder;
  normalDotsAt: (idx: number, build: NormalDot | ((builder: INormalDotBuilder) => INormalDotBuilder)) => IMetronomeTupletBuilder;
  normalDotsSplice: (start: number, deleteCount: number, ...items: NormalDot[]) => IMetronomeTupletBuilder;
  normalDots: (normalDots: NormalDot[]) => IMetronomeTupletBuilder;
  constructor(original?: MetronomeTuplet) {
    let updates: MetronomeTuplet = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["actualNotes"]) ||
          childBuilders["actualNotes"] !== undefined ||
          updates.actualNotes !== undefined,
        "actualNotes is a required field");
      console.assert(
          (original && !modifiedKeys["bracket"]) ||
          childBuilders["bracket"] !== undefined ||
          updates.bracket !== undefined,
        "bracket is a required field");
      console.assert(
          (original && !modifiedKeys["showNumber"]) ||
          childBuilders["showNumber"] !== undefined ||
          updates.showNumber !== undefined,
        "showNumber is a required field");
      console.assert(
          (original && !modifiedKeys["normalType"]) ||
          childBuilders["normalType"] !== undefined ||
          updates.normalType !== undefined,
        "normalType is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
      console.assert(
          (original && !modifiedKeys["normalNotes"]) ||
          childBuilders["normalNotes"] !== undefined ||
          updates.normalNotes !== undefined,
        "normalNotes is a required field");
      console.assert(
          (original && !modifiedKeys["normalDots"]) ||
          childBuilders["normalDots"] !== undefined ||
          updates.normalDots !== undefined,
        "normalDots is a required field");
    }

    if (!original) {
      this.build = (): MetronomeTuplet => {
        checkInvariants();
        (updates as any)._class = "MetronomeTuplet";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.actualNotes = (spec: number): IMetronomeTupletBuilder => {
        updates["actualNotes"] = spec;
        delete childBuilders["actualNotes;"];
        modifiedKeys["actualNotes"] = true;
        return this;
    }

    this.bracket = (spec: boolean): IMetronomeTupletBuilder => {
        updates["bracket"] = spec;
        delete childBuilders["bracket;"];
        modifiedKeys["bracket"] = true;
        return this;
    }

    this.showNumber = (spec: ActualBothNone): IMetronomeTupletBuilder => {
        updates["showNumber"] = spec;
        delete childBuilders["showNumber;"];
        modifiedKeys["showNumber"] = true;
        return this;
    }

    this.normalType = (spec: string): IMetronomeTupletBuilder => {
        updates["normalType"] = spec;
        delete childBuilders["normalType;"];
        modifiedKeys["normalType"] = true;
        return this;
    }

    this.type = (spec: StartStop): IMetronomeTupletBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.normalNotes = (spec: number): IMetronomeTupletBuilder => {
        updates["normalNotes"] = spec;
        delete childBuilders["normalNotes;"];
        modifiedKeys["normalNotes"] = true;
        return this;
    }

    this.normalDots = (spec: NormalDot[]): IMetronomeTupletBuilder => {
        updates["normalDots"] = spec;
        delete childBuilders["normalDots;"];
        modifiedKeys["normalDots"] = true;
        return this;
    }

    this.normalDotsAt = (idx: number, build: NormalDot | ((builder: INormalDotBuilder) => INormalDotBuilder)): IMetronomeTupletBuilder => {
      makeReference("normalDots");
      if (frozen["normalDots"][idx]) {
          throw new Error("Patching normalDots." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["normalDots"] && !original["normalDots"]) {
          // Clone snapshot.
          patches.push({p: ["normalDots", idx], li: original._snapshot["normalDots"]});
      }
      if (typeof build === 'function' && reference["normalDots"][idx]) {
        let patch = (build as any)(new NormalDotBuilder(reference["normalDots"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["normalDots", idx].concat(patch.p);
          return patch;
        }));
        frozen["normalDots"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new NormalDotBuilder(reference["normalDots"][idx])).build() : build;
      if (original) {
        patches.push({p: ["normalDots", idx], li: update});
      } else {
        updates["normalDots"] = reference["normalDots"]; // TODO: Merge?
      } 
      reference["normalDots"][idx] = update;
      frozen["normalDots"][idx] = true;
      return this;
    }

    this.normalDotsSplice = (start: number, deleteCount: number, ...items: NormalDot[]): IMetronomeTupletBuilder => {
      makeReference("normalDots");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["normalDots"][idx]) {
            throw new Error("Replacing normalDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["normalDots"][idx];
          patches.push({p: ["normalDots", idx], ld, li: items[idx - start]});
          frozen["normalDots"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["normalDots"][idx]) {
            throw new Error("Removing normalDots." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["normalDots"][idx];
          patches.push({p: ["normalDots", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["normalDots", idx], li: items[idx - start]});
          frozen["normalDots"][idx] = true;
        }
      }
      reference["normalDots"].splice(start, deleteCount, ...items);
      updates["normalDots"] = reference["normalDots"];
      frozen["normalDots"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }
  }
}
export function patchMetronomeTuplet(base: MetronomeTuplet, builder: (build: IMetronomeTupletBuilder) => IMetronomeTupletBuilder): IAny[] { return builder(new MetronomeTupletBuilder(base)).patch(); }
export function buildMetronomeTuplet(builder: (build: IMetronomeTupletBuilder) => IMetronomeTupletBuilder): MetronomeTuplet { return builder(new MetronomeTupletBuilder()).build(); }

export interface IOctaveShiftBuilder {
  build?: () => OctaveShift;
  patch: () => IAny[];
  number: (number: number) => IOctaveShiftBuilder;
  size: (size: number) => IOctaveShiftBuilder;
  type: (type: OctaveShiftType) => IOctaveShiftBuilder;
  defaultX: (defaultX: number) => IOctaveShiftBuilder;
  relativeY: (relativeY: number) => IOctaveShiftBuilder;
  defaultY: (defaultY: number) => IOctaveShiftBuilder;
  relativeX: (relativeX: number) => IOctaveShiftBuilder;
  fontFamily: (fontFamily: string) => IOctaveShiftBuilder;
  fontWeight: (fontWeight: NormalBold) => IOctaveShiftBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOctaveShiftBuilder;
  fontSize: (fontSize: string) => IOctaveShiftBuilder;
  color: (color: string) => IOctaveShiftBuilder;
  dashLength: (dashLength: number) => IOctaveShiftBuilder;
  spaceLength: (spaceLength: number) => IOctaveShiftBuilder;
}

class OctaveShiftBuilder implements IOctaveShiftBuilder {
  build: () => OctaveShift;
  patch: () => IAny[];
  number: (number: number) => IOctaveShiftBuilder;
  size: (size: number) => IOctaveShiftBuilder;
  type: (type: OctaveShiftType) => IOctaveShiftBuilder;
  defaultX: (defaultX: number) => IOctaveShiftBuilder;
  relativeY: (relativeY: number) => IOctaveShiftBuilder;
  defaultY: (defaultY: number) => IOctaveShiftBuilder;
  relativeX: (relativeX: number) => IOctaveShiftBuilder;
  fontFamily: (fontFamily: string) => IOctaveShiftBuilder;
  fontWeight: (fontWeight: NormalBold) => IOctaveShiftBuilder;
  fontStyle: (fontStyle: NormalItalic) => IOctaveShiftBuilder;
  fontSize: (fontSize: string) => IOctaveShiftBuilder;
  color: (color: string) => IOctaveShiftBuilder;
  dashLength: (dashLength: number) => IOctaveShiftBuilder;
  spaceLength: (spaceLength: number) => IOctaveShiftBuilder;
  constructor(original?: OctaveShift) {
    let updates: OctaveShift = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["number"]) ||
          childBuilders["number"] !== undefined ||
          updates.number !== undefined,
        "number is a required field");
      console.assert(
          (original && !modifiedKeys["size"]) ||
          childBuilders["size"] !== undefined ||
          updates.size !== undefined,
        "size is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): OctaveShift => {
        checkInvariants();
        (updates as any)._class = "OctaveShift";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: number): IOctaveShiftBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.size = (spec: number): IOctaveShiftBuilder => {
        updates["size"] = spec;
        delete childBuilders["size;"];
        modifiedKeys["size"] = true;
        return this;
    }

    this.type = (spec: OctaveShiftType): IOctaveShiftBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): IOctaveShiftBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IOctaveShiftBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IOctaveShiftBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IOctaveShiftBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IOctaveShiftBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IOctaveShiftBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IOctaveShiftBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IOctaveShiftBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IOctaveShiftBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.dashLength = (spec: number): IOctaveShiftBuilder => {
        updates["dashLength"] = spec;
        delete childBuilders["dashLength;"];
        modifiedKeys["dashLength"] = true;
        return this;
    }

    this.spaceLength = (spec: number): IOctaveShiftBuilder => {
        updates["spaceLength"] = spec;
        delete childBuilders["spaceLength;"];
        modifiedKeys["spaceLength"] = true;
        return this;
    }
  }
}
export function patchOctaveShift(base: OctaveShift, builder: (build: IOctaveShiftBuilder) => IOctaveShiftBuilder): IAny[] { return builder(new OctaveShiftBuilder(base)).patch(); }
export function buildOctaveShift(builder: (build: IOctaveShiftBuilder) => IOctaveShiftBuilder): OctaveShift { return builder(new OctaveShiftBuilder()).build(); }

export interface IHarpPedalsBuilder {
  build?: () => HarpPedals;
  patch: () => IAny[];
  pedalTuningsAt: (idx: number, build: PedalTuning | ((builder: IPedalTuningBuilder) => IPedalTuningBuilder)) => IHarpPedalsBuilder;
  pedalTuningsSplice: (start: number, deleteCount: number, ...items: PedalTuning[]) => IHarpPedalsBuilder;
  pedalTunings: (pedalTunings: PedalTuning[]) => IHarpPedalsBuilder;
  defaultX: (defaultX: number) => IHarpPedalsBuilder;
  relativeY: (relativeY: number) => IHarpPedalsBuilder;
  defaultY: (defaultY: number) => IHarpPedalsBuilder;
  relativeX: (relativeX: number) => IHarpPedalsBuilder;
  fontFamily: (fontFamily: string) => IHarpPedalsBuilder;
  fontWeight: (fontWeight: NormalBold) => IHarpPedalsBuilder;
  fontStyle: (fontStyle: NormalItalic) => IHarpPedalsBuilder;
  fontSize: (fontSize: string) => IHarpPedalsBuilder;
  color: (color: string) => IHarpPedalsBuilder;
  halign: (halign: LeftCenterRight) => IHarpPedalsBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IHarpPedalsBuilder;
}

class HarpPedalsBuilder implements IHarpPedalsBuilder {
  build: () => HarpPedals;
  patch: () => IAny[];
  pedalTuningsAt: (idx: number, build: PedalTuning | ((builder: IPedalTuningBuilder) => IPedalTuningBuilder)) => IHarpPedalsBuilder;
  pedalTuningsSplice: (start: number, deleteCount: number, ...items: PedalTuning[]) => IHarpPedalsBuilder;
  pedalTunings: (pedalTunings: PedalTuning[]) => IHarpPedalsBuilder;
  defaultX: (defaultX: number) => IHarpPedalsBuilder;
  relativeY: (relativeY: number) => IHarpPedalsBuilder;
  defaultY: (defaultY: number) => IHarpPedalsBuilder;
  relativeX: (relativeX: number) => IHarpPedalsBuilder;
  fontFamily: (fontFamily: string) => IHarpPedalsBuilder;
  fontWeight: (fontWeight: NormalBold) => IHarpPedalsBuilder;
  fontStyle: (fontStyle: NormalItalic) => IHarpPedalsBuilder;
  fontSize: (fontSize: string) => IHarpPedalsBuilder;
  color: (color: string) => IHarpPedalsBuilder;
  halign: (halign: LeftCenterRight) => IHarpPedalsBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IHarpPedalsBuilder;
  constructor(original?: HarpPedals) {
    let updates: HarpPedals = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["pedalTunings"]) ||
          childBuilders["pedalTunings"] !== undefined ||
          updates.pedalTunings !== undefined,
        "pedalTunings is a required field");
    }

    if (!original) {
      this.build = (): HarpPedals => {
        checkInvariants();
        (updates as any)._class = "HarpPedals";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.pedalTunings = (spec: PedalTuning[]): IHarpPedalsBuilder => {
        updates["pedalTunings"] = spec;
        delete childBuilders["pedalTunings;"];
        modifiedKeys["pedalTunings"] = true;
        return this;
    }

    this.pedalTuningsAt = (idx: number, build: PedalTuning | ((builder: IPedalTuningBuilder) => IPedalTuningBuilder)): IHarpPedalsBuilder => {
      makeReference("pedalTunings");
      if (frozen["pedalTunings"][idx]) {
          throw new Error("Patching pedalTunings." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["pedalTunings"] && !original["pedalTunings"]) {
          // Clone snapshot.
          patches.push({p: ["pedalTunings", idx], li: original._snapshot["pedalTunings"]});
      }
      if (typeof build === 'function' && reference["pedalTunings"][idx]) {
        let patch = (build as any)(new PedalTuningBuilder(reference["pedalTunings"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["pedalTunings", idx].concat(patch.p);
          return patch;
        }));
        frozen["pedalTunings"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new PedalTuningBuilder(reference["pedalTunings"][idx])).build() : build;
      if (original) {
        patches.push({p: ["pedalTunings", idx], li: update});
      } else {
        updates["pedalTunings"] = reference["pedalTunings"]; // TODO: Merge?
      } 
      reference["pedalTunings"][idx] = update;
      frozen["pedalTunings"][idx] = true;
      return this;
    }

    this.pedalTuningsSplice = (start: number, deleteCount: number, ...items: PedalTuning[]): IHarpPedalsBuilder => {
      makeReference("pedalTunings");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["pedalTunings"][idx]) {
            throw new Error("Replacing pedalTunings." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["pedalTunings"][idx];
          patches.push({p: ["pedalTunings", idx], ld, li: items[idx - start]});
          frozen["pedalTunings"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["pedalTunings"][idx]) {
            throw new Error("Removing pedalTunings." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["pedalTunings"][idx];
          patches.push({p: ["pedalTunings", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["pedalTunings", idx], li: items[idx - start]});
          frozen["pedalTunings"][idx] = true;
        }
      }
      reference["pedalTunings"].splice(start, deleteCount, ...items);
      updates["pedalTunings"] = reference["pedalTunings"];
      frozen["pedalTunings"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.defaultX = (spec: number): IHarpPedalsBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IHarpPedalsBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IHarpPedalsBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IHarpPedalsBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IHarpPedalsBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IHarpPedalsBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IHarpPedalsBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IHarpPedalsBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IHarpPedalsBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IHarpPedalsBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IHarpPedalsBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchHarpPedals(base: HarpPedals, builder: (build: IHarpPedalsBuilder) => IHarpPedalsBuilder): IAny[] { return builder(new HarpPedalsBuilder(base)).patch(); }
export function buildHarpPedals(builder: (build: IHarpPedalsBuilder) => IHarpPedalsBuilder): HarpPedals { return builder(new HarpPedalsBuilder()).build(); }

export interface IPedalTuningBuilder {
  build?: () => PedalTuning;
  patch: () => IAny[];
  pedalStep: (pedalStep: string) => IPedalTuningBuilder;
  pedalAlter: (pedalAlter: string) => IPedalTuningBuilder;
}

class PedalTuningBuilder implements IPedalTuningBuilder {
  build: () => PedalTuning;
  patch: () => IAny[];
  pedalStep: (pedalStep: string) => IPedalTuningBuilder;
  pedalAlter: (pedalAlter: string) => IPedalTuningBuilder;
  constructor(original?: PedalTuning) {
    let updates: PedalTuning = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["pedalStep"]) ||
          childBuilders["pedalStep"] !== undefined ||
          updates.pedalStep !== undefined,
        "pedalStep is a required field");
      console.assert(
          (original && !modifiedKeys["pedalAlter"]) ||
          childBuilders["pedalAlter"] !== undefined ||
          updates.pedalAlter !== undefined,
        "pedalAlter is a required field");
    }

    if (!original) {
      this.build = (): PedalTuning => {
        checkInvariants();
        (updates as any)._class = "PedalTuning";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.pedalStep = (spec: string): IPedalTuningBuilder => {
        updates["pedalStep"] = spec;
        delete childBuilders["pedalStep;"];
        modifiedKeys["pedalStep"] = true;
        return this;
    }

    this.pedalAlter = (spec: string): IPedalTuningBuilder => {
        updates["pedalAlter"] = spec;
        delete childBuilders["pedalAlter;"];
        modifiedKeys["pedalAlter"] = true;
        return this;
    }
  }
}
export function patchPedalTuning(base: PedalTuning, builder: (build: IPedalTuningBuilder) => IPedalTuningBuilder): IAny[] { return builder(new PedalTuningBuilder(base)).patch(); }
export function buildPedalTuning(builder: (build: IPedalTuningBuilder) => IPedalTuningBuilder): PedalTuning { return builder(new PedalTuningBuilder()).build(); }

export interface IDampBuilder {
  build?: () => Damp;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IDampBuilder;
  relativeY: (relativeY: number) => IDampBuilder;
  defaultY: (defaultY: number) => IDampBuilder;
  relativeX: (relativeX: number) => IDampBuilder;
  fontFamily: (fontFamily: string) => IDampBuilder;
  fontWeight: (fontWeight: NormalBold) => IDampBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDampBuilder;
  fontSize: (fontSize: string) => IDampBuilder;
  color: (color: string) => IDampBuilder;
  halign: (halign: LeftCenterRight) => IDampBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IDampBuilder;
}

class DampBuilder implements IDampBuilder {
  build: () => Damp;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IDampBuilder;
  relativeY: (relativeY: number) => IDampBuilder;
  defaultY: (defaultY: number) => IDampBuilder;
  relativeX: (relativeX: number) => IDampBuilder;
  fontFamily: (fontFamily: string) => IDampBuilder;
  fontWeight: (fontWeight: NormalBold) => IDampBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDampBuilder;
  fontSize: (fontSize: string) => IDampBuilder;
  color: (color: string) => IDampBuilder;
  halign: (halign: LeftCenterRight) => IDampBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IDampBuilder;
  constructor(original?: Damp) {
    let updates: Damp = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Damp => {
        checkInvariants();
        (updates as any)._class = "Damp";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IDampBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDampBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDampBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDampBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDampBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDampBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDampBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDampBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDampBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IDampBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IDampBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchDamp(base: Damp, builder: (build: IDampBuilder) => IDampBuilder): IAny[] { return builder(new DampBuilder(base)).patch(); }
export function buildDamp(builder: (build: IDampBuilder) => IDampBuilder): Damp { return builder(new DampBuilder()).build(); }

export interface IDampAllBuilder {
  build?: () => DampAll;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IDampAllBuilder;
  relativeY: (relativeY: number) => IDampAllBuilder;
  defaultY: (defaultY: number) => IDampAllBuilder;
  relativeX: (relativeX: number) => IDampAllBuilder;
  fontFamily: (fontFamily: string) => IDampAllBuilder;
  fontWeight: (fontWeight: NormalBold) => IDampAllBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDampAllBuilder;
  fontSize: (fontSize: string) => IDampAllBuilder;
  color: (color: string) => IDampAllBuilder;
  halign: (halign: LeftCenterRight) => IDampAllBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IDampAllBuilder;
}

class DampAllBuilder implements IDampAllBuilder {
  build: () => DampAll;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IDampAllBuilder;
  relativeY: (relativeY: number) => IDampAllBuilder;
  defaultY: (defaultY: number) => IDampAllBuilder;
  relativeX: (relativeX: number) => IDampAllBuilder;
  fontFamily: (fontFamily: string) => IDampAllBuilder;
  fontWeight: (fontWeight: NormalBold) => IDampAllBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDampAllBuilder;
  fontSize: (fontSize: string) => IDampAllBuilder;
  color: (color: string) => IDampAllBuilder;
  halign: (halign: LeftCenterRight) => IDampAllBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IDampAllBuilder;
  constructor(original?: DampAll) {
    let updates: DampAll = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): DampAll => {
        checkInvariants();
        (updates as any)._class = "DampAll";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IDampAllBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDampAllBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDampAllBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDampAllBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDampAllBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDampAllBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDampAllBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDampAllBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDampAllBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IDampAllBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IDampAllBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchDampAll(base: DampAll, builder: (build: IDampAllBuilder) => IDampAllBuilder): IAny[] { return builder(new DampAllBuilder(base)).patch(); }
export function buildDampAll(builder: (build: IDampAllBuilder) => IDampAllBuilder): DampAll { return builder(new DampAllBuilder()).build(); }

export interface IEyeglassesBuilder {
  build?: () => Eyeglasses;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IEyeglassesBuilder;
  relativeY: (relativeY: number) => IEyeglassesBuilder;
  defaultY: (defaultY: number) => IEyeglassesBuilder;
  relativeX: (relativeX: number) => IEyeglassesBuilder;
  fontFamily: (fontFamily: string) => IEyeglassesBuilder;
  fontWeight: (fontWeight: NormalBold) => IEyeglassesBuilder;
  fontStyle: (fontStyle: NormalItalic) => IEyeglassesBuilder;
  fontSize: (fontSize: string) => IEyeglassesBuilder;
  color: (color: string) => IEyeglassesBuilder;
  halign: (halign: LeftCenterRight) => IEyeglassesBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IEyeglassesBuilder;
}

class EyeglassesBuilder implements IEyeglassesBuilder {
  build: () => Eyeglasses;
  patch: () => IAny[];
  defaultX: (defaultX: number) => IEyeglassesBuilder;
  relativeY: (relativeY: number) => IEyeglassesBuilder;
  defaultY: (defaultY: number) => IEyeglassesBuilder;
  relativeX: (relativeX: number) => IEyeglassesBuilder;
  fontFamily: (fontFamily: string) => IEyeglassesBuilder;
  fontWeight: (fontWeight: NormalBold) => IEyeglassesBuilder;
  fontStyle: (fontStyle: NormalItalic) => IEyeglassesBuilder;
  fontSize: (fontSize: string) => IEyeglassesBuilder;
  color: (color: string) => IEyeglassesBuilder;
  halign: (halign: LeftCenterRight) => IEyeglassesBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IEyeglassesBuilder;
  constructor(original?: Eyeglasses) {
    let updates: Eyeglasses = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Eyeglasses => {
        checkInvariants();
        (updates as any)._class = "Eyeglasses";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.defaultX = (spec: number): IEyeglassesBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IEyeglassesBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IEyeglassesBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IEyeglassesBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IEyeglassesBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IEyeglassesBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IEyeglassesBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IEyeglassesBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IEyeglassesBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IEyeglassesBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IEyeglassesBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchEyeglasses(base: Eyeglasses, builder: (build: IEyeglassesBuilder) => IEyeglassesBuilder): IAny[] { return builder(new EyeglassesBuilder(base)).patch(); }
export function buildEyeglasses(builder: (build: IEyeglassesBuilder) => IEyeglassesBuilder): Eyeglasses { return builder(new EyeglassesBuilder()).build(); }

export interface IStringMuteBuilder {
  build?: () => StringMute;
  patch: () => IAny[];
  type: (type: string) => IStringMuteBuilder;
  defaultX: (defaultX: number) => IStringMuteBuilder;
  relativeY: (relativeY: number) => IStringMuteBuilder;
  defaultY: (defaultY: number) => IStringMuteBuilder;
  relativeX: (relativeX: number) => IStringMuteBuilder;
  fontFamily: (fontFamily: string) => IStringMuteBuilder;
  fontWeight: (fontWeight: NormalBold) => IStringMuteBuilder;
  fontStyle: (fontStyle: NormalItalic) => IStringMuteBuilder;
  fontSize: (fontSize: string) => IStringMuteBuilder;
  color: (color: string) => IStringMuteBuilder;
  halign: (halign: LeftCenterRight) => IStringMuteBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IStringMuteBuilder;
}

class StringMuteBuilder implements IStringMuteBuilder {
  build: () => StringMute;
  patch: () => IAny[];
  type: (type: string) => IStringMuteBuilder;
  defaultX: (defaultX: number) => IStringMuteBuilder;
  relativeY: (relativeY: number) => IStringMuteBuilder;
  defaultY: (defaultY: number) => IStringMuteBuilder;
  relativeX: (relativeX: number) => IStringMuteBuilder;
  fontFamily: (fontFamily: string) => IStringMuteBuilder;
  fontWeight: (fontWeight: NormalBold) => IStringMuteBuilder;
  fontStyle: (fontStyle: NormalItalic) => IStringMuteBuilder;
  fontSize: (fontSize: string) => IStringMuteBuilder;
  color: (color: string) => IStringMuteBuilder;
  halign: (halign: LeftCenterRight) => IStringMuteBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IStringMuteBuilder;
  constructor(original?: StringMute) {
    let updates: StringMute = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): StringMute => {
        checkInvariants();
        (updates as any)._class = "StringMute";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.type = (spec: string): IStringMuteBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): IStringMuteBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IStringMuteBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IStringMuteBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IStringMuteBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IStringMuteBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IStringMuteBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IStringMuteBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IStringMuteBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IStringMuteBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IStringMuteBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IStringMuteBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchStringMute(base: StringMute, builder: (build: IStringMuteBuilder) => IStringMuteBuilder): IAny[] { return builder(new StringMuteBuilder(base)).patch(); }
export function buildStringMute(builder: (build: IStringMuteBuilder) => IStringMuteBuilder): StringMute { return builder(new StringMuteBuilder()).build(); }

export interface IScordaturaBuilder {
  build?: () => Scordatura;
  patch: () => IAny[];
  accordsAt: (idx: number, build: Accord | ((builder: IAccordBuilder) => IAccordBuilder)) => IScordaturaBuilder;
  accordsSplice: (start: number, deleteCount: number, ...items: Accord[]) => IScordaturaBuilder;
  accords: (accords: Accord[]) => IScordaturaBuilder;
}

class ScordaturaBuilder implements IScordaturaBuilder {
  build: () => Scordatura;
  patch: () => IAny[];
  accordsAt: (idx: number, build: Accord | ((builder: IAccordBuilder) => IAccordBuilder)) => IScordaturaBuilder;
  accordsSplice: (start: number, deleteCount: number, ...items: Accord[]) => IScordaturaBuilder;
  accords: (accords: Accord[]) => IScordaturaBuilder;
  constructor(original?: Scordatura) {
    let updates: Scordatura = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["accords"]) ||
          childBuilders["accords"] !== undefined ||
          updates.accords !== undefined,
        "accords is a required field");
    }

    if (!original) {
      this.build = (): Scordatura => {
        checkInvariants();
        (updates as any)._class = "Scordatura";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.accords = (spec: Accord[]): IScordaturaBuilder => {
        updates["accords"] = spec;
        delete childBuilders["accords;"];
        modifiedKeys["accords"] = true;
        return this;
    }

    this.accordsAt = (idx: number, build: Accord | ((builder: IAccordBuilder) => IAccordBuilder)): IScordaturaBuilder => {
      makeReference("accords");
      if (frozen["accords"][idx]) {
          throw new Error("Patching accords." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["accords"] && !original["accords"]) {
          // Clone snapshot.
          patches.push({p: ["accords", idx], li: original._snapshot["accords"]});
      }
      if (typeof build === 'function' && reference["accords"][idx]) {
        let patch = (build as any)(new AccordBuilder(reference["accords"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["accords", idx].concat(patch.p);
          return patch;
        }));
        frozen["accords"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new AccordBuilder(reference["accords"][idx])).build() : build;
      if (original) {
        patches.push({p: ["accords", idx], li: update});
      } else {
        updates["accords"] = reference["accords"]; // TODO: Merge?
      } 
      reference["accords"][idx] = update;
      frozen["accords"][idx] = true;
      return this;
    }

    this.accordsSplice = (start: number, deleteCount: number, ...items: Accord[]): IScordaturaBuilder => {
      makeReference("accords");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["accords"][idx]) {
            throw new Error("Replacing accords." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["accords"][idx];
          patches.push({p: ["accords", idx], ld, li: items[idx - start]});
          frozen["accords"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["accords"][idx]) {
            throw new Error("Removing accords." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["accords"][idx];
          patches.push({p: ["accords", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["accords", idx], li: items[idx - start]});
          frozen["accords"][idx] = true;
        }
      }
      reference["accords"].splice(start, deleteCount, ...items);
      updates["accords"] = reference["accords"];
      frozen["accords"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }
  }
}
export function patchScordatura(base: Scordatura, builder: (build: IScordaturaBuilder) => IScordaturaBuilder): IAny[] { return builder(new ScordaturaBuilder(base)).patch(); }
export function buildScordatura(builder: (build: IScordaturaBuilder) => IScordaturaBuilder): Scordatura { return builder(new ScordaturaBuilder()).build(); }

export interface IAccordBuilder {
  build?: () => Accord;
  patch: () => IAny[];
  tuningAlter: (tuningAlter: string) => IAccordBuilder;
  string: (string: string) => IAccordBuilder;
  tuningStep: (tuningStep: string) => IAccordBuilder;
  tuningOctave: (tuningOctave: string) => IAccordBuilder;
}

class AccordBuilder implements IAccordBuilder {
  build: () => Accord;
  patch: () => IAny[];
  tuningAlter: (tuningAlter: string) => IAccordBuilder;
  string: (string: string) => IAccordBuilder;
  tuningStep: (tuningStep: string) => IAccordBuilder;
  tuningOctave: (tuningOctave: string) => IAccordBuilder;
  constructor(original?: Accord) {
    let updates: Accord = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["tuningAlter"]) ||
          childBuilders["tuningAlter"] !== undefined ||
          updates.tuningAlter !== undefined,
        "tuningAlter is a required field");
      console.assert(
          (original && !modifiedKeys["string"]) ||
          childBuilders["string"] !== undefined ||
          updates.string !== undefined,
        "string is a required field");
      console.assert(
          (original && !modifiedKeys["tuningStep"]) ||
          childBuilders["tuningStep"] !== undefined ||
          updates.tuningStep !== undefined,
        "tuningStep is a required field");
      console.assert(
          (original && !modifiedKeys["tuningOctave"]) ||
          childBuilders["tuningOctave"] !== undefined ||
          updates.tuningOctave !== undefined,
        "tuningOctave is a required field");
    }

    if (!original) {
      this.build = (): Accord => {
        checkInvariants();
        (updates as any)._class = "Accord";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.tuningAlter = (spec: string): IAccordBuilder => {
        updates["tuningAlter"] = spec;
        delete childBuilders["tuningAlter;"];
        modifiedKeys["tuningAlter"] = true;
        return this;
    }

    this.string = (spec: string): IAccordBuilder => {
        updates["string"] = spec;
        delete childBuilders["string;"];
        modifiedKeys["string"] = true;
        return this;
    }

    this.tuningStep = (spec: string): IAccordBuilder => {
        updates["tuningStep"] = spec;
        delete childBuilders["tuningStep;"];
        modifiedKeys["tuningStep"] = true;
        return this;
    }

    this.tuningOctave = (spec: string): IAccordBuilder => {
        updates["tuningOctave"] = spec;
        delete childBuilders["tuningOctave;"];
        modifiedKeys["tuningOctave"] = true;
        return this;
    }
  }
}
export function patchAccord(base: Accord, builder: (build: IAccordBuilder) => IAccordBuilder): IAny[] { return builder(new AccordBuilder(base)).patch(); }
export function buildAccord(builder: (build: IAccordBuilder) => IAccordBuilder): Accord { return builder(new AccordBuilder()).build(); }

export interface IImageBuilder {
  build?: () => Image;
  patch: () => IAny[];
  type: (type: string) => IImageBuilder;
  source: (source: string) => IImageBuilder;
  defaultX: (defaultX: number) => IImageBuilder;
  relativeY: (relativeY: number) => IImageBuilder;
  defaultY: (defaultY: number) => IImageBuilder;
  relativeX: (relativeX: number) => IImageBuilder;
  halign: (halign: LeftCenterRight) => IImageBuilder;
  valignImage: (valignImage: TopMiddleBottomBaseline) => IImageBuilder;
}

class ImageBuilder implements IImageBuilder {
  build: () => Image;
  patch: () => IAny[];
  type: (type: string) => IImageBuilder;
  source: (source: string) => IImageBuilder;
  defaultX: (defaultX: number) => IImageBuilder;
  relativeY: (relativeY: number) => IImageBuilder;
  defaultY: (defaultY: number) => IImageBuilder;
  relativeX: (relativeX: number) => IImageBuilder;
  halign: (halign: LeftCenterRight) => IImageBuilder;
  valignImage: (valignImage: TopMiddleBottomBaseline) => IImageBuilder;
  constructor(original?: Image) {
    let updates: Image = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
      console.assert(
          (original && !modifiedKeys["source"]) ||
          childBuilders["source"] !== undefined ||
          updates.source !== undefined,
        "source is a required field");
    }

    if (!original) {
      this.build = (): Image => {
        checkInvariants();
        (updates as any)._class = "Image";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.type = (spec: string): IImageBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.source = (spec: string): IImageBuilder => {
        updates["source"] = spec;
        delete childBuilders["source;"];
        modifiedKeys["source"] = true;
        return this;
    }

    this.defaultX = (spec: number): IImageBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IImageBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IImageBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IImageBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IImageBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valignImage = (spec: TopMiddleBottomBaseline): IImageBuilder => {
        updates["valignImage"] = spec;
        delete childBuilders["valignImage;"];
        modifiedKeys["valignImage"] = true;
        return this;
    }
  }
}
export function patchImage(base: Image, builder: (build: IImageBuilder) => IImageBuilder): IAny[] { return builder(new ImageBuilder(base)).patch(); }
export function buildImage(builder: (build: IImageBuilder) => IImageBuilder): Image { return builder(new ImageBuilder()).build(); }

export interface IPrincipalVoiceBuilder {
  build?: () => PrincipalVoice;
  patch: () => IAny[];
  symbol: (symbol: VoiceSymbol) => IPrincipalVoiceBuilder;
  data: (data: string) => IPrincipalVoiceBuilder;
  type: (type: StartStop) => IPrincipalVoiceBuilder;
  defaultX: (defaultX: number) => IPrincipalVoiceBuilder;
  relativeY: (relativeY: number) => IPrincipalVoiceBuilder;
  defaultY: (defaultY: number) => IPrincipalVoiceBuilder;
  relativeX: (relativeX: number) => IPrincipalVoiceBuilder;
  fontFamily: (fontFamily: string) => IPrincipalVoiceBuilder;
  fontWeight: (fontWeight: NormalBold) => IPrincipalVoiceBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPrincipalVoiceBuilder;
  fontSize: (fontSize: string) => IPrincipalVoiceBuilder;
  color: (color: string) => IPrincipalVoiceBuilder;
  halign: (halign: LeftCenterRight) => IPrincipalVoiceBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IPrincipalVoiceBuilder;
}

class PrincipalVoiceBuilder implements IPrincipalVoiceBuilder {
  build: () => PrincipalVoice;
  patch: () => IAny[];
  symbol: (symbol: VoiceSymbol) => IPrincipalVoiceBuilder;
  data: (data: string) => IPrincipalVoiceBuilder;
  type: (type: StartStop) => IPrincipalVoiceBuilder;
  defaultX: (defaultX: number) => IPrincipalVoiceBuilder;
  relativeY: (relativeY: number) => IPrincipalVoiceBuilder;
  defaultY: (defaultY: number) => IPrincipalVoiceBuilder;
  relativeX: (relativeX: number) => IPrincipalVoiceBuilder;
  fontFamily: (fontFamily: string) => IPrincipalVoiceBuilder;
  fontWeight: (fontWeight: NormalBold) => IPrincipalVoiceBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPrincipalVoiceBuilder;
  fontSize: (fontSize: string) => IPrincipalVoiceBuilder;
  color: (color: string) => IPrincipalVoiceBuilder;
  halign: (halign: LeftCenterRight) => IPrincipalVoiceBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IPrincipalVoiceBuilder;
  constructor(original?: PrincipalVoice) {
    let updates: PrincipalVoice = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["symbol"]) ||
          childBuilders["symbol"] !== undefined ||
          updates.symbol !== undefined,
        "symbol is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): PrincipalVoice => {
        checkInvariants();
        (updates as any)._class = "PrincipalVoice";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.symbol = (spec: VoiceSymbol): IPrincipalVoiceBuilder => {
        updates["symbol"] = spec;
        delete childBuilders["symbol;"];
        modifiedKeys["symbol"] = true;
        return this;
    }

    this.data = (spec: string): IPrincipalVoiceBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.type = (spec: StartStop): IPrincipalVoiceBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.defaultX = (spec: number): IPrincipalVoiceBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IPrincipalVoiceBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IPrincipalVoiceBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IPrincipalVoiceBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IPrincipalVoiceBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IPrincipalVoiceBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IPrincipalVoiceBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IPrincipalVoiceBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IPrincipalVoiceBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IPrincipalVoiceBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IPrincipalVoiceBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchPrincipalVoice(base: PrincipalVoice, builder: (build: IPrincipalVoiceBuilder) => IPrincipalVoiceBuilder): IAny[] { return builder(new PrincipalVoiceBuilder(base)).patch(); }
export function buildPrincipalVoice(builder: (build: IPrincipalVoiceBuilder) => IPrincipalVoiceBuilder): PrincipalVoice { return builder(new PrincipalVoiceBuilder()).build(); }

export interface IAccordionRegistrationBuilder {
  build?: () => AccordionRegistration;
  patch: () => IAny[];
  accordionMiddle: (accordionMiddle: string) => IAccordionRegistrationBuilder;
  accordionHigh: (accordionHigh: boolean) => IAccordionRegistrationBuilder;
  accordionLow: (accordionLow: boolean) => IAccordionRegistrationBuilder;
  defaultX: (defaultX: number) => IAccordionRegistrationBuilder;
  relativeY: (relativeY: number) => IAccordionRegistrationBuilder;
  defaultY: (defaultY: number) => IAccordionRegistrationBuilder;
  relativeX: (relativeX: number) => IAccordionRegistrationBuilder;
  fontFamily: (fontFamily: string) => IAccordionRegistrationBuilder;
  fontWeight: (fontWeight: NormalBold) => IAccordionRegistrationBuilder;
  fontStyle: (fontStyle: NormalItalic) => IAccordionRegistrationBuilder;
  fontSize: (fontSize: string) => IAccordionRegistrationBuilder;
  color: (color: string) => IAccordionRegistrationBuilder;
  halign: (halign: LeftCenterRight) => IAccordionRegistrationBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IAccordionRegistrationBuilder;
}

class AccordionRegistrationBuilder implements IAccordionRegistrationBuilder {
  build: () => AccordionRegistration;
  patch: () => IAny[];
  accordionMiddle: (accordionMiddle: string) => IAccordionRegistrationBuilder;
  accordionHigh: (accordionHigh: boolean) => IAccordionRegistrationBuilder;
  accordionLow: (accordionLow: boolean) => IAccordionRegistrationBuilder;
  defaultX: (defaultX: number) => IAccordionRegistrationBuilder;
  relativeY: (relativeY: number) => IAccordionRegistrationBuilder;
  defaultY: (defaultY: number) => IAccordionRegistrationBuilder;
  relativeX: (relativeX: number) => IAccordionRegistrationBuilder;
  fontFamily: (fontFamily: string) => IAccordionRegistrationBuilder;
  fontWeight: (fontWeight: NormalBold) => IAccordionRegistrationBuilder;
  fontStyle: (fontStyle: NormalItalic) => IAccordionRegistrationBuilder;
  fontSize: (fontSize: string) => IAccordionRegistrationBuilder;
  color: (color: string) => IAccordionRegistrationBuilder;
  halign: (halign: LeftCenterRight) => IAccordionRegistrationBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IAccordionRegistrationBuilder;
  constructor(original?: AccordionRegistration) {
    let updates: AccordionRegistration = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["accordionMiddle"]) ||
          childBuilders["accordionMiddle"] !== undefined ||
          updates.accordionMiddle !== undefined,
        "accordionMiddle is a required field");
      console.assert(
          (original && !modifiedKeys["accordionHigh"]) ||
          childBuilders["accordionHigh"] !== undefined ||
          updates.accordionHigh !== undefined,
        "accordionHigh is a required field");
      console.assert(
          (original && !modifiedKeys["accordionLow"]) ||
          childBuilders["accordionLow"] !== undefined ||
          updates.accordionLow !== undefined,
        "accordionLow is a required field");
    }

    if (!original) {
      this.build = (): AccordionRegistration => {
        checkInvariants();
        (updates as any)._class = "AccordionRegistration";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.accordionMiddle = (spec: string): IAccordionRegistrationBuilder => {
        updates["accordionMiddle"] = spec;
        delete childBuilders["accordionMiddle;"];
        modifiedKeys["accordionMiddle"] = true;
        return this;
    }

    this.accordionHigh = (spec: boolean): IAccordionRegistrationBuilder => {
        updates["accordionHigh"] = spec;
        delete childBuilders["accordionHigh;"];
        modifiedKeys["accordionHigh"] = true;
        return this;
    }

    this.accordionLow = (spec: boolean): IAccordionRegistrationBuilder => {
        updates["accordionLow"] = spec;
        delete childBuilders["accordionLow;"];
        modifiedKeys["accordionLow"] = true;
        return this;
    }

    this.defaultX = (spec: number): IAccordionRegistrationBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IAccordionRegistrationBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IAccordionRegistrationBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IAccordionRegistrationBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IAccordionRegistrationBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IAccordionRegistrationBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IAccordionRegistrationBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IAccordionRegistrationBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IAccordionRegistrationBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IAccordionRegistrationBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IAccordionRegistrationBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchAccordionRegistration(base: AccordionRegistration, builder: (build: IAccordionRegistrationBuilder) => IAccordionRegistrationBuilder): IAny[] { return builder(new AccordionRegistrationBuilder(base)).patch(); }
export function buildAccordionRegistration(builder: (build: IAccordionRegistrationBuilder) => IAccordionRegistrationBuilder): AccordionRegistration { return builder(new AccordionRegistrationBuilder()).build(); }

export interface IPercussionBuilder {
  build?: () => Percussion;
  patch: () => IAny[];
  stickLocation: (stickLocation: string) => IPercussionBuilder;
  otherPercussion: (otherPercussion: string) => IPercussionBuilder;
  wood: (wood: string) => IPercussionBuilder;
  effect: (effect: string) => IPercussionBuilder;
  glass: (glass: string) => IPercussionBuilder;
  timpani: (build: Timpani | ((builder: ITimpaniBuilder) => ITimpaniBuilder)) => IPercussionBuilder;
  stick: (build: Stick | ((builder: IStickBuilder) => IStickBuilder)) => IPercussionBuilder;
  metal: (metal: string) => IPercussionBuilder;
  pitched: (pitched: string) => IPercussionBuilder;
  membrane: (membrane: string) => IPercussionBuilder;
  beater: (build: Beater | ((builder: IBeaterBuilder) => IBeaterBuilder)) => IPercussionBuilder;
  defaultX: (defaultX: number) => IPercussionBuilder;
  relativeY: (relativeY: number) => IPercussionBuilder;
  defaultY: (defaultY: number) => IPercussionBuilder;
  relativeX: (relativeX: number) => IPercussionBuilder;
  fontFamily: (fontFamily: string) => IPercussionBuilder;
  fontWeight: (fontWeight: NormalBold) => IPercussionBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPercussionBuilder;
  fontSize: (fontSize: string) => IPercussionBuilder;
  color: (color: string) => IPercussionBuilder;
  halign: (halign: LeftCenterRight) => IPercussionBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IPercussionBuilder;
  enclosure: (enclosure: EnclosureShape) => IPercussionBuilder;
}

class PercussionBuilder implements IPercussionBuilder {
  build: () => Percussion;
  patch: () => IAny[];
  stickLocation: (stickLocation: string) => IPercussionBuilder;
  otherPercussion: (otherPercussion: string) => IPercussionBuilder;
  wood: (wood: string) => IPercussionBuilder;
  effect: (effect: string) => IPercussionBuilder;
  glass: (glass: string) => IPercussionBuilder;
  timpani: (build: Timpani | ((builder: ITimpaniBuilder) => ITimpaniBuilder)) => IPercussionBuilder;
  stick: (build: Stick | ((builder: IStickBuilder) => IStickBuilder)) => IPercussionBuilder;
  metal: (metal: string) => IPercussionBuilder;
  pitched: (pitched: string) => IPercussionBuilder;
  membrane: (membrane: string) => IPercussionBuilder;
  beater: (build: Beater | ((builder: IBeaterBuilder) => IBeaterBuilder)) => IPercussionBuilder;
  defaultX: (defaultX: number) => IPercussionBuilder;
  relativeY: (relativeY: number) => IPercussionBuilder;
  defaultY: (defaultY: number) => IPercussionBuilder;
  relativeX: (relativeX: number) => IPercussionBuilder;
  fontFamily: (fontFamily: string) => IPercussionBuilder;
  fontWeight: (fontWeight: NormalBold) => IPercussionBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPercussionBuilder;
  fontSize: (fontSize: string) => IPercussionBuilder;
  color: (color: string) => IPercussionBuilder;
  halign: (halign: LeftCenterRight) => IPercussionBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IPercussionBuilder;
  enclosure: (enclosure: EnclosureShape) => IPercussionBuilder;
  constructor(original?: Percussion) {
    let updates: Percussion = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["stickLocation"]) ||
          childBuilders["stickLocation"] !== undefined ||
          updates.stickLocation !== undefined,
        "stickLocation is a required field");
      console.assert(
          (original && !modifiedKeys["otherPercussion"]) ||
          childBuilders["otherPercussion"] !== undefined ||
          updates.otherPercussion !== undefined,
        "otherPercussion is a required field");
      console.assert(
          (original && !modifiedKeys["wood"]) ||
          childBuilders["wood"] !== undefined ||
          updates.wood !== undefined,
        "wood is a required field");
      console.assert(
          (original && !modifiedKeys["effect"]) ||
          childBuilders["effect"] !== undefined ||
          updates.effect !== undefined,
        "effect is a required field");
      console.assert(
          (original && !modifiedKeys["glass"]) ||
          childBuilders["glass"] !== undefined ||
          updates.glass !== undefined,
        "glass is a required field");
      console.assert(
          (original && !modifiedKeys["timpani"]) ||
          childBuilders["timpani"] !== undefined ||
          updates.timpani !== undefined,
        "timpani is a required field");
      console.assert(
          (original && !modifiedKeys["stick"]) ||
          childBuilders["stick"] !== undefined ||
          updates.stick !== undefined,
        "stick is a required field");
      console.assert(
          (original && !modifiedKeys["metal"]) ||
          childBuilders["metal"] !== undefined ||
          updates.metal !== undefined,
        "metal is a required field");
      console.assert(
          (original && !modifiedKeys["pitched"]) ||
          childBuilders["pitched"] !== undefined ||
          updates.pitched !== undefined,
        "pitched is a required field");
      console.assert(
          (original && !modifiedKeys["membrane"]) ||
          childBuilders["membrane"] !== undefined ||
          updates.membrane !== undefined,
        "membrane is a required field");
      console.assert(
          (original && !modifiedKeys["beater"]) ||
          childBuilders["beater"] !== undefined ||
          updates.beater !== undefined,
        "beater is a required field");
    }

    if (!original) {
      this.build = (): Percussion => {
        checkInvariants();
        (updates as any)._class = "Percussion";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.stickLocation = (spec: string): IPercussionBuilder => {
        updates["stickLocation"] = spec;
        delete childBuilders["stickLocation;"];
        modifiedKeys["stickLocation"] = true;
        return this;
    }

    this.otherPercussion = (spec: string): IPercussionBuilder => {
        updates["otherPercussion"] = spec;
        delete childBuilders["otherPercussion;"];
        modifiedKeys["otherPercussion"] = true;
        return this;
    }

    this.wood = (spec: string): IPercussionBuilder => {
        updates["wood"] = spec;
        delete childBuilders["wood;"];
        modifiedKeys["wood"] = true;
        return this;
    }

    this.effect = (spec: string): IPercussionBuilder => {
        updates["effect"] = spec;
        delete childBuilders["effect;"];
        modifiedKeys["effect"] = true;
        return this;
    }

    this.glass = (spec: string): IPercussionBuilder => {
        updates["glass"] = spec;
        delete childBuilders["glass;"];
        modifiedKeys["glass"] = true;
        return this;
    }

    this.timpani = (build: Timpani | ((builder: ITimpaniBuilder) => ITimpaniBuilder)): IPercussionBuilder => {
      if (typeof build === 'function') {
        delete updates["timpani"]
        const builder = (build as any)(new TimpaniBuilder(original && original["timpani"]));
        if (!original) updates["timpani"] = builder.build();
        else childBuilders["timpani"] = builder;
      } else {
        updates.timpani = build as any;
        delete childBuilders["timpani;"];
      }
      modifiedKeys["timpani"] = true;
      return this;
    }

    this.stick = (build: Stick | ((builder: IStickBuilder) => IStickBuilder)): IPercussionBuilder => {
      if (typeof build === 'function') {
        delete updates["stick"]
        const builder = (build as any)(new StickBuilder(original && original["stick"]));
        if (!original) updates["stick"] = builder.build();
        else childBuilders["stick"] = builder;
      } else {
        updates.stick = build as any;
        delete childBuilders["stick;"];
      }
      modifiedKeys["stick"] = true;
      return this;
    }

    this.metal = (spec: string): IPercussionBuilder => {
        updates["metal"] = spec;
        delete childBuilders["metal;"];
        modifiedKeys["metal"] = true;
        return this;
    }

    this.pitched = (spec: string): IPercussionBuilder => {
        updates["pitched"] = spec;
        delete childBuilders["pitched;"];
        modifiedKeys["pitched"] = true;
        return this;
    }

    this.membrane = (spec: string): IPercussionBuilder => {
        updates["membrane"] = spec;
        delete childBuilders["membrane;"];
        modifiedKeys["membrane"] = true;
        return this;
    }

    this.beater = (build: Beater | ((builder: IBeaterBuilder) => IBeaterBuilder)): IPercussionBuilder => {
      if (typeof build === 'function') {
        delete updates["beater"]
        const builder = (build as any)(new BeaterBuilder(original && original["beater"]));
        if (!original) updates["beater"] = builder.build();
        else childBuilders["beater"] = builder;
      } else {
        updates.beater = build as any;
        delete childBuilders["beater;"];
      }
      modifiedKeys["beater"] = true;
      return this;
    }

    this.defaultX = (spec: number): IPercussionBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IPercussionBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IPercussionBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IPercussionBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IPercussionBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IPercussionBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IPercussionBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IPercussionBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IPercussionBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IPercussionBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IPercussionBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }

    this.enclosure = (spec: EnclosureShape): IPercussionBuilder => {
        updates["enclosure"] = spec;
        delete childBuilders["enclosure;"];
        modifiedKeys["enclosure"] = true;
        return this;
    }
  }
}
export function patchPercussion(base: Percussion, builder: (build: IPercussionBuilder) => IPercussionBuilder): IAny[] { return builder(new PercussionBuilder(base)).patch(); }
export function buildPercussion(builder: (build: IPercussionBuilder) => IPercussionBuilder): Percussion { return builder(new PercussionBuilder()).build(); }

export interface ITimpaniBuilder {
  build?: () => Timpani;
  patch: () => IAny[];
}

class TimpaniBuilder implements ITimpaniBuilder {
  build: () => Timpani;
  patch: () => IAny[];
  constructor(original?: Timpani) {
    let updates: Timpani = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Timpani => {
        checkInvariants();
        (updates as any)._class = "Timpani";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchTimpani(base: Timpani, builder: (build: ITimpaniBuilder) => ITimpaniBuilder): IAny[] { return builder(new TimpaniBuilder(base)).patch(); }
export function buildTimpani(builder: (build: ITimpaniBuilder) => ITimpaniBuilder): Timpani { return builder(new TimpaniBuilder()).build(); }

export interface IBeaterBuilder {
  build?: () => Beater;
  patch: () => IAny[];
  data: (data: string) => IBeaterBuilder;
  tip: (tip: TipDirection) => IBeaterBuilder;
}

class BeaterBuilder implements IBeaterBuilder {
  build: () => Beater;
  patch: () => IAny[];
  data: (data: string) => IBeaterBuilder;
  tip: (tip: TipDirection) => IBeaterBuilder;
  constructor(original?: Beater) {
    let updates: Beater = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
      console.assert(
          (original && !modifiedKeys["tip"]) ||
          childBuilders["tip"] !== undefined ||
          updates.tip !== undefined,
        "tip is a required field");
    }

    if (!original) {
      this.build = (): Beater => {
        checkInvariants();
        (updates as any)._class = "Beater";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IBeaterBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.tip = (spec: TipDirection): IBeaterBuilder => {
        updates["tip"] = spec;
        delete childBuilders["tip;"];
        modifiedKeys["tip"] = true;
        return this;
    }
  }
}
export function patchBeater(base: Beater, builder: (build: IBeaterBuilder) => IBeaterBuilder): IAny[] { return builder(new BeaterBuilder(base)).patch(); }
export function buildBeater(builder: (build: IBeaterBuilder) => IBeaterBuilder): Beater { return builder(new BeaterBuilder()).build(); }

export interface IStickBuilder {
  build?: () => Stick;
  patch: () => IAny[];
  stickMaterial: (stickMaterial: string) => IStickBuilder;
  stickType: (stickType: string) => IStickBuilder;
  tip: (tip: TipDirection) => IStickBuilder;
}

class StickBuilder implements IStickBuilder {
  build: () => Stick;
  patch: () => IAny[];
  stickMaterial: (stickMaterial: string) => IStickBuilder;
  stickType: (stickType: string) => IStickBuilder;
  tip: (tip: TipDirection) => IStickBuilder;
  constructor(original?: Stick) {
    let updates: Stick = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["stickMaterial"]) ||
          childBuilders["stickMaterial"] !== undefined ||
          updates.stickMaterial !== undefined,
        "stickMaterial is a required field");
      console.assert(
          (original && !modifiedKeys["stickType"]) ||
          childBuilders["stickType"] !== undefined ||
          updates.stickType !== undefined,
        "stickType is a required field");
      console.assert(
          (original && !modifiedKeys["tip"]) ||
          childBuilders["tip"] !== undefined ||
          updates.tip !== undefined,
        "tip is a required field");
    }

    if (!original) {
      this.build = (): Stick => {
        checkInvariants();
        (updates as any)._class = "Stick";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.stickMaterial = (spec: string): IStickBuilder => {
        updates["stickMaterial"] = spec;
        delete childBuilders["stickMaterial;"];
        modifiedKeys["stickMaterial"] = true;
        return this;
    }

    this.stickType = (spec: string): IStickBuilder => {
        updates["stickType"] = spec;
        delete childBuilders["stickType;"];
        modifiedKeys["stickType"] = true;
        return this;
    }

    this.tip = (spec: TipDirection): IStickBuilder => {
        updates["tip"] = spec;
        delete childBuilders["tip;"];
        modifiedKeys["tip"] = true;
        return this;
    }
  }
}
export function patchStick(base: Stick, builder: (build: IStickBuilder) => IStickBuilder): IAny[] { return builder(new StickBuilder(base)).patch(); }
export function buildStick(builder: (build: IStickBuilder) => IStickBuilder): Stick { return builder(new StickBuilder()).build(); }

export interface IOffsetBuilder {
  build?: () => Offset;
  patch: () => IAny[];
  data: (data: string) => IOffsetBuilder;
  sound: (sound: boolean) => IOffsetBuilder;
}

class OffsetBuilder implements IOffsetBuilder {
  build: () => Offset;
  patch: () => IAny[];
  data: (data: string) => IOffsetBuilder;
  sound: (sound: boolean) => IOffsetBuilder;
  constructor(original?: Offset) {
    let updates: Offset = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
      console.assert(
          (original && !modifiedKeys["sound"]) ||
          childBuilders["sound"] !== undefined ||
          updates.sound !== undefined,
        "sound is a required field");
    }

    if (!original) {
      this.build = (): Offset => {
        checkInvariants();
        (updates as any)._class = "Offset";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IOffsetBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.sound = (spec: boolean): IOffsetBuilder => {
        updates["sound"] = spec;
        delete childBuilders["sound;"];
        modifiedKeys["sound"] = true;
        return this;
    }
  }
}
export function patchOffset(base: Offset, builder: (build: IOffsetBuilder) => IOffsetBuilder): IAny[] { return builder(new OffsetBuilder(base)).patch(); }
export function buildOffset(builder: (build: IOffsetBuilder) => IOffsetBuilder): Offset { return builder(new OffsetBuilder()).build(); }

export interface IHarmonyChordBuilder {
  build?: () => HarmonyChord;
  patch: () => IAny[];
  root: (build: Root | ((builder: IRootBuilder) => IRootBuilder)) => IHarmonyChordBuilder;
  function: (build: Function | ((builder: IFunctionBuilder) => IFunctionBuilder)) => IHarmonyChordBuilder;
  kind: (build: Kind | ((builder: IKindBuilder) => IKindBuilder)) => IHarmonyChordBuilder;
  degreesAt: (idx: number, build: Degree | ((builder: IDegreeBuilder) => IDegreeBuilder)) => IHarmonyChordBuilder;
  degreesSplice: (start: number, deleteCount: number, ...items: Degree[]) => IHarmonyChordBuilder;
  degrees: (degrees: Degree[]) => IHarmonyChordBuilder;
  inversion: (build: Inversion | ((builder: IInversionBuilder) => IInversionBuilder)) => IHarmonyChordBuilder;
  bass: (build: Bass | ((builder: IBassBuilder) => IBassBuilder)) => IHarmonyChordBuilder;
}

class HarmonyChordBuilder implements IHarmonyChordBuilder {
  build: () => HarmonyChord;
  patch: () => IAny[];
  root: (build: Root | ((builder: IRootBuilder) => IRootBuilder)) => IHarmonyChordBuilder;
  function: (build: Function | ((builder: IFunctionBuilder) => IFunctionBuilder)) => IHarmonyChordBuilder;
  kind: (build: Kind | ((builder: IKindBuilder) => IKindBuilder)) => IHarmonyChordBuilder;
  degreesAt: (idx: number, build: Degree | ((builder: IDegreeBuilder) => IDegreeBuilder)) => IHarmonyChordBuilder;
  degreesSplice: (start: number, deleteCount: number, ...items: Degree[]) => IHarmonyChordBuilder;
  degrees: (degrees: Degree[]) => IHarmonyChordBuilder;
  inversion: (build: Inversion | ((builder: IInversionBuilder) => IInversionBuilder)) => IHarmonyChordBuilder;
  bass: (build: Bass | ((builder: IBassBuilder) => IBassBuilder)) => IHarmonyChordBuilder;
  constructor(original?: HarmonyChord) {
    let updates: HarmonyChord = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["root"]) ||
          childBuilders["root"] !== undefined ||
          updates.root !== undefined,
        "root is a required field");
      console.assert(
          (original && !modifiedKeys["function"]) ||
          childBuilders["function"] !== undefined ||
          updates.function !== undefined,
        "function is a required field");
      console.assert(
          (original && !modifiedKeys["kind"]) ||
          childBuilders["kind"] !== undefined ||
          updates.kind !== undefined,
        "kind is a required field");
      console.assert(
          (original && !modifiedKeys["degrees"]) ||
          childBuilders["degrees"] !== undefined ||
          updates.degrees !== undefined,
        "degrees is a required field");
      console.assert(
          (original && !modifiedKeys["inversion"]) ||
          childBuilders["inversion"] !== undefined ||
          updates.inversion !== undefined,
        "inversion is a required field");
      console.assert(
          (original && !modifiedKeys["bass"]) ||
          childBuilders["bass"] !== undefined ||
          updates.bass !== undefined,
        "bass is a required field");
    }

    if (!original) {
      this.build = (): HarmonyChord => {
        checkInvariants();
        (updates as any)._class = "HarmonyChord";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.root = (build: Root | ((builder: IRootBuilder) => IRootBuilder)): IHarmonyChordBuilder => {
      if (typeof build === 'function') {
        delete updates["root"]
        const builder = (build as any)(new RootBuilder(original && original["root"]));
        if (!original) updates["root"] = builder.build();
        else childBuilders["root"] = builder;
      } else {
        updates.root = build as any;
        delete childBuilders["root;"];
      }
      modifiedKeys["root"] = true;
      return this;
    }

    this.function = (build: Function | ((builder: IFunctionBuilder) => IFunctionBuilder)): IHarmonyChordBuilder => {
      if (typeof build === 'function') {
        delete updates["function"]
        const builder = (build as any)(new FunctionBuilder(original && original["function"]));
        if (!original) updates["function"] = builder.build();
        else childBuilders["function"] = builder;
      } else {
        updates.function = build as any;
        delete childBuilders["function;"];
      }
      modifiedKeys["function"] = true;
      return this;
    }

    this.kind = (build: Kind | ((builder: IKindBuilder) => IKindBuilder)): IHarmonyChordBuilder => {
      if (typeof build === 'function') {
        delete updates["kind"]
        const builder = (build as any)(new KindBuilder(original && original["kind"]));
        if (!original) updates["kind"] = builder.build();
        else childBuilders["kind"] = builder;
      } else {
        updates.kind = build as any;
        delete childBuilders["kind;"];
      }
      modifiedKeys["kind"] = true;
      return this;
    }

    this.degrees = (spec: Degree[]): IHarmonyChordBuilder => {
        updates["degrees"] = spec;
        delete childBuilders["degrees;"];
        modifiedKeys["degrees"] = true;
        return this;
    }

    this.degreesAt = (idx: number, build: Degree | ((builder: IDegreeBuilder) => IDegreeBuilder)): IHarmonyChordBuilder => {
      makeReference("degrees");
      if (frozen["degrees"][idx]) {
          throw new Error("Patching degrees." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["degrees"] && !original["degrees"]) {
          // Clone snapshot.
          patches.push({p: ["degrees", idx], li: original._snapshot["degrees"]});
      }
      if (typeof build === 'function' && reference["degrees"][idx]) {
        let patch = (build as any)(new DegreeBuilder(reference["degrees"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["degrees", idx].concat(patch.p);
          return patch;
        }));
        frozen["degrees"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new DegreeBuilder(reference["degrees"][idx])).build() : build;
      if (original) {
        patches.push({p: ["degrees", idx], li: update});
      } else {
        updates["degrees"] = reference["degrees"]; // TODO: Merge?
      } 
      reference["degrees"][idx] = update;
      frozen["degrees"][idx] = true;
      return this;
    }

    this.degreesSplice = (start: number, deleteCount: number, ...items: Degree[]): IHarmonyChordBuilder => {
      makeReference("degrees");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["degrees"][idx]) {
            throw new Error("Replacing degrees." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["degrees"][idx];
          patches.push({p: ["degrees", idx], ld, li: items[idx - start]});
          frozen["degrees"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["degrees"][idx]) {
            throw new Error("Removing degrees." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["degrees"][idx];
          patches.push({p: ["degrees", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["degrees", idx], li: items[idx - start]});
          frozen["degrees"][idx] = true;
        }
      }
      reference["degrees"].splice(start, deleteCount, ...items);
      updates["degrees"] = reference["degrees"];
      frozen["degrees"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.inversion = (build: Inversion | ((builder: IInversionBuilder) => IInversionBuilder)): IHarmonyChordBuilder => {
      if (typeof build === 'function') {
        delete updates["inversion"]
        const builder = (build as any)(new InversionBuilder(original && original["inversion"]));
        if (!original) updates["inversion"] = builder.build();
        else childBuilders["inversion"] = builder;
      } else {
        updates.inversion = build as any;
        delete childBuilders["inversion;"];
      }
      modifiedKeys["inversion"] = true;
      return this;
    }

    this.bass = (build: Bass | ((builder: IBassBuilder) => IBassBuilder)): IHarmonyChordBuilder => {
      if (typeof build === 'function') {
        delete updates["bass"]
        const builder = (build as any)(new BassBuilder(original && original["bass"]));
        if (!original) updates["bass"] = builder.build();
        else childBuilders["bass"] = builder;
      } else {
        updates.bass = build as any;
        delete childBuilders["bass;"];
      }
      modifiedKeys["bass"] = true;
      return this;
    }
  }
}
export function patchHarmonyChord(base: HarmonyChord, builder: (build: IHarmonyChordBuilder) => IHarmonyChordBuilder): IAny[] { return builder(new HarmonyChordBuilder(base)).patch(); }
export function buildHarmonyChord(builder: (build: IHarmonyChordBuilder) => IHarmonyChordBuilder): HarmonyChord { return builder(new HarmonyChordBuilder()).build(); }

export interface IHarmonyBuilder {
  build?: () => Harmony;
  patch: () => IAny[];
  frame: (build: Frame | ((builder: IFrameBuilder) => IFrameBuilder)) => IHarmonyBuilder;
  printFrame: (printFrame: boolean) => IHarmonyBuilder;
  staff: (staff: number) => IHarmonyBuilder;
  type: (type: ExplicitImpliedAlternate) => IHarmonyBuilder;
  offset: (build: Offset | ((builder: IOffsetBuilder) => IOffsetBuilder)) => IHarmonyBuilder;
  defaultX: (defaultX: number) => IHarmonyBuilder;
  relativeY: (relativeY: number) => IHarmonyBuilder;
  defaultY: (defaultY: number) => IHarmonyBuilder;
  relativeX: (relativeX: number) => IHarmonyBuilder;
  fontFamily: (fontFamily: string) => IHarmonyBuilder;
  fontWeight: (fontWeight: NormalBold) => IHarmonyBuilder;
  fontStyle: (fontStyle: NormalItalic) => IHarmonyBuilder;
  fontSize: (fontSize: string) => IHarmonyBuilder;
  color: (color: string) => IHarmonyBuilder;
  printObject: (printObject: boolean) => IHarmonyBuilder;
  placement: (placement: AboveBelow) => IHarmonyBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IHarmonyBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IHarmonyBuilder;
  root: (build: Root | ((builder: IRootBuilder) => IRootBuilder)) => IHarmonyBuilder;
  function: (build: Function | ((builder: IFunctionBuilder) => IFunctionBuilder)) => IHarmonyBuilder;
  kind: (build: Kind | ((builder: IKindBuilder) => IKindBuilder)) => IHarmonyBuilder;
  degreesAt: (idx: number, build: Degree | ((builder: IDegreeBuilder) => IDegreeBuilder)) => IHarmonyBuilder;
  degreesSplice: (start: number, deleteCount: number, ...items: Degree[]) => IHarmonyBuilder;
  degrees: (degrees: Degree[]) => IHarmonyBuilder;
  inversion: (build: Inversion | ((builder: IInversionBuilder) => IInversionBuilder)) => IHarmonyBuilder;
  bass: (build: Bass | ((builder: IBassBuilder) => IBassBuilder)) => IHarmonyBuilder;
}

class HarmonyBuilder implements IHarmonyBuilder {
  build: () => Harmony;
  patch: () => IAny[];
  frame: (build: Frame | ((builder: IFrameBuilder) => IFrameBuilder)) => IHarmonyBuilder;
  printFrame: (printFrame: boolean) => IHarmonyBuilder;
  staff: (staff: number) => IHarmonyBuilder;
  type: (type: ExplicitImpliedAlternate) => IHarmonyBuilder;
  offset: (build: Offset | ((builder: IOffsetBuilder) => IOffsetBuilder)) => IHarmonyBuilder;
  defaultX: (defaultX: number) => IHarmonyBuilder;
  relativeY: (relativeY: number) => IHarmonyBuilder;
  defaultY: (defaultY: number) => IHarmonyBuilder;
  relativeX: (relativeX: number) => IHarmonyBuilder;
  fontFamily: (fontFamily: string) => IHarmonyBuilder;
  fontWeight: (fontWeight: NormalBold) => IHarmonyBuilder;
  fontStyle: (fontStyle: NormalItalic) => IHarmonyBuilder;
  fontSize: (fontSize: string) => IHarmonyBuilder;
  color: (color: string) => IHarmonyBuilder;
  printObject: (printObject: boolean) => IHarmonyBuilder;
  placement: (placement: AboveBelow) => IHarmonyBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IHarmonyBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IHarmonyBuilder;
  root: (build: Root | ((builder: IRootBuilder) => IRootBuilder)) => IHarmonyBuilder;
  function: (build: Function | ((builder: IFunctionBuilder) => IFunctionBuilder)) => IHarmonyBuilder;
  kind: (build: Kind | ((builder: IKindBuilder) => IKindBuilder)) => IHarmonyBuilder;
  degreesAt: (idx: number, build: Degree | ((builder: IDegreeBuilder) => IDegreeBuilder)) => IHarmonyBuilder;
  degreesSplice: (start: number, deleteCount: number, ...items: Degree[]) => IHarmonyBuilder;
  degrees: (degrees: Degree[]) => IHarmonyBuilder;
  inversion: (build: Inversion | ((builder: IInversionBuilder) => IInversionBuilder)) => IHarmonyBuilder;
  bass: (build: Bass | ((builder: IBassBuilder) => IBassBuilder)) => IHarmonyBuilder;
  constructor(original?: Harmony) {
    let updates: Harmony = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["frame"]) ||
          childBuilders["frame"] !== undefined ||
          updates.frame !== undefined,
        "frame is a required field");
      console.assert(
          (original && !modifiedKeys["printFrame"]) ||
          childBuilders["printFrame"] !== undefined ||
          updates.printFrame !== undefined,
        "printFrame is a required field");
      console.assert(
          (original && !modifiedKeys["staff"]) ||
          childBuilders["staff"] !== undefined ||
          updates.staff !== undefined,
        "staff is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
      console.assert(
          (original && !modifiedKeys["offset"]) ||
          childBuilders["offset"] !== undefined ||
          updates.offset !== undefined,
        "offset is a required field");
      console.assert(
          (original && !modifiedKeys["root"]) ||
          childBuilders["root"] !== undefined ||
          updates.root !== undefined,
        "root is a required field");
      console.assert(
          (original && !modifiedKeys["function"]) ||
          childBuilders["function"] !== undefined ||
          updates.function !== undefined,
        "function is a required field");
      console.assert(
          (original && !modifiedKeys["kind"]) ||
          childBuilders["kind"] !== undefined ||
          updates.kind !== undefined,
        "kind is a required field");
      console.assert(
          (original && !modifiedKeys["degrees"]) ||
          childBuilders["degrees"] !== undefined ||
          updates.degrees !== undefined,
        "degrees is a required field");
      console.assert(
          (original && !modifiedKeys["inversion"]) ||
          childBuilders["inversion"] !== undefined ||
          updates.inversion !== undefined,
        "inversion is a required field");
      console.assert(
          (original && !modifiedKeys["bass"]) ||
          childBuilders["bass"] !== undefined ||
          updates.bass !== undefined,
        "bass is a required field");
    }

    if (!original) {
      this.build = (): Harmony => {
        checkInvariants();
        (updates as any)._class = "Harmony";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.frame = (build: Frame | ((builder: IFrameBuilder) => IFrameBuilder)): IHarmonyBuilder => {
      if (typeof build === 'function') {
        delete updates["frame"]
        const builder = (build as any)(new FrameBuilder(original && original["frame"]));
        if (!original) updates["frame"] = builder.build();
        else childBuilders["frame"] = builder;
      } else {
        updates.frame = build as any;
        delete childBuilders["frame;"];
      }
      modifiedKeys["frame"] = true;
      return this;
    }

    this.printFrame = (spec: boolean): IHarmonyBuilder => {
        updates["printFrame"] = spec;
        delete childBuilders["printFrame;"];
        modifiedKeys["printFrame"] = true;
        return this;
    }

    this.staff = (spec: number): IHarmonyBuilder => {
        updates["staff"] = spec;
        delete childBuilders["staff;"];
        modifiedKeys["staff"] = true;
        return this;
    }

    this.type = (spec: ExplicitImpliedAlternate): IHarmonyBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.offset = (build: Offset | ((builder: IOffsetBuilder) => IOffsetBuilder)): IHarmonyBuilder => {
      if (typeof build === 'function') {
        delete updates["offset"]
        const builder = (build as any)(new OffsetBuilder(original && original["offset"]));
        if (!original) updates["offset"] = builder.build();
        else childBuilders["offset"] = builder;
      } else {
        updates.offset = build as any;
        delete childBuilders["offset;"];
      }
      modifiedKeys["offset"] = true;
      return this;
    }

    this.defaultX = (spec: number): IHarmonyBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IHarmonyBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IHarmonyBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IHarmonyBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IHarmonyBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IHarmonyBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IHarmonyBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IHarmonyBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IHarmonyBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.printObject = (spec: boolean): IHarmonyBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.placement = (spec: AboveBelow): IHarmonyBuilder => {
        updates["placement"] = spec;
        delete childBuilders["placement;"];
        modifiedKeys["placement"] = true;
        return this;
    }

    this.footnote = (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)): IHarmonyBuilder => {
      if (typeof build === 'function') {
        delete updates["footnote"]
        const builder = (build as any)(new FootnoteBuilder(original && original["footnote"]));
        if (!original) updates["footnote"] = builder.build();
        else childBuilders["footnote"] = builder;
      } else {
        updates.footnote = build as any;
        delete childBuilders["footnote;"];
      }
      modifiedKeys["footnote"] = true;
      return this;
    }

    this.level = (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)): IHarmonyBuilder => {
      if (typeof build === 'function') {
        delete updates["level"]
        const builder = (build as any)(new LevelBuilder(original && original["level"]));
        if (!original) updates["level"] = builder.build();
        else childBuilders["level"] = builder;
      } else {
        updates.level = build as any;
        delete childBuilders["level;"];
      }
      modifiedKeys["level"] = true;
      return this;
    }

    this.root = (build: Root | ((builder: IRootBuilder) => IRootBuilder)): IHarmonyBuilder => {
      if (typeof build === 'function') {
        delete updates["root"]
        const builder = (build as any)(new RootBuilder(original && original["root"]));
        if (!original) updates["root"] = builder.build();
        else childBuilders["root"] = builder;
      } else {
        updates.root = build as any;
        delete childBuilders["root;"];
      }
      modifiedKeys["root"] = true;
      return this;
    }

    this.function = (build: Function | ((builder: IFunctionBuilder) => IFunctionBuilder)): IHarmonyBuilder => {
      if (typeof build === 'function') {
        delete updates["function"]
        const builder = (build as any)(new FunctionBuilder(original && original["function"]));
        if (!original) updates["function"] = builder.build();
        else childBuilders["function"] = builder;
      } else {
        updates.function = build as any;
        delete childBuilders["function;"];
      }
      modifiedKeys["function"] = true;
      return this;
    }

    this.kind = (build: Kind | ((builder: IKindBuilder) => IKindBuilder)): IHarmonyBuilder => {
      if (typeof build === 'function') {
        delete updates["kind"]
        const builder = (build as any)(new KindBuilder(original && original["kind"]));
        if (!original) updates["kind"] = builder.build();
        else childBuilders["kind"] = builder;
      } else {
        updates.kind = build as any;
        delete childBuilders["kind;"];
      }
      modifiedKeys["kind"] = true;
      return this;
    }

    this.degrees = (spec: Degree[]): IHarmonyBuilder => {
        updates["degrees"] = spec;
        delete childBuilders["degrees;"];
        modifiedKeys["degrees"] = true;
        return this;
    }

    this.degreesAt = (idx: number, build: Degree | ((builder: IDegreeBuilder) => IDegreeBuilder)): IHarmonyBuilder => {
      makeReference("degrees");
      if (frozen["degrees"][idx]) {
          throw new Error("Patching degrees." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["degrees"] && !original["degrees"]) {
          // Clone snapshot.
          patches.push({p: ["degrees", idx], li: original._snapshot["degrees"]});
      }
      if (typeof build === 'function' && reference["degrees"][idx]) {
        let patch = (build as any)(new DegreeBuilder(reference["degrees"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["degrees", idx].concat(patch.p);
          return patch;
        }));
        frozen["degrees"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new DegreeBuilder(reference["degrees"][idx])).build() : build;
      if (original) {
        patches.push({p: ["degrees", idx], li: update});
      } else {
        updates["degrees"] = reference["degrees"]; // TODO: Merge?
      } 
      reference["degrees"][idx] = update;
      frozen["degrees"][idx] = true;
      return this;
    }

    this.degreesSplice = (start: number, deleteCount: number, ...items: Degree[]): IHarmonyBuilder => {
      makeReference("degrees");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["degrees"][idx]) {
            throw new Error("Replacing degrees." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["degrees"][idx];
          patches.push({p: ["degrees", idx], ld, li: items[idx - start]});
          frozen["degrees"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["degrees"][idx]) {
            throw new Error("Removing degrees." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["degrees"][idx];
          patches.push({p: ["degrees", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["degrees", idx], li: items[idx - start]});
          frozen["degrees"][idx] = true;
        }
      }
      reference["degrees"].splice(start, deleteCount, ...items);
      updates["degrees"] = reference["degrees"];
      frozen["degrees"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.inversion = (build: Inversion | ((builder: IInversionBuilder) => IInversionBuilder)): IHarmonyBuilder => {
      if (typeof build === 'function') {
        delete updates["inversion"]
        const builder = (build as any)(new InversionBuilder(original && original["inversion"]));
        if (!original) updates["inversion"] = builder.build();
        else childBuilders["inversion"] = builder;
      } else {
        updates.inversion = build as any;
        delete childBuilders["inversion;"];
      }
      modifiedKeys["inversion"] = true;
      return this;
    }

    this.bass = (build: Bass | ((builder: IBassBuilder) => IBassBuilder)): IHarmonyBuilder => {
      if (typeof build === 'function') {
        delete updates["bass"]
        const builder = (build as any)(new BassBuilder(original && original["bass"]));
        if (!original) updates["bass"] = builder.build();
        else childBuilders["bass"] = builder;
      } else {
        updates.bass = build as any;
        delete childBuilders["bass;"];
      }
      modifiedKeys["bass"] = true;
      return this;
    }
  }
}
export function patchHarmony(base: Harmony, builder: (build: IHarmonyBuilder) => IHarmonyBuilder): IAny[] { return builder(new HarmonyBuilder(base)).patch(); }
export function buildHarmony(builder: (build: IHarmonyBuilder) => IHarmonyBuilder): Harmony { return builder(new HarmonyBuilder()).build(); }

export interface IRootBuilder {
  build?: () => Root;
  patch: () => IAny[];
  rootStep: (build: RootStep | ((builder: IRootStepBuilder) => IRootStepBuilder)) => IRootBuilder;
  rootAlter: (build: RootAlter | ((builder: IRootAlterBuilder) => IRootAlterBuilder)) => IRootBuilder;
}

class RootBuilder implements IRootBuilder {
  build: () => Root;
  patch: () => IAny[];
  rootStep: (build: RootStep | ((builder: IRootStepBuilder) => IRootStepBuilder)) => IRootBuilder;
  rootAlter: (build: RootAlter | ((builder: IRootAlterBuilder) => IRootAlterBuilder)) => IRootBuilder;
  constructor(original?: Root) {
    let updates: Root = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["rootStep"]) ||
          childBuilders["rootStep"] !== undefined ||
          updates.rootStep !== undefined,
        "rootStep is a required field");
      console.assert(
          (original && !modifiedKeys["rootAlter"]) ||
          childBuilders["rootAlter"] !== undefined ||
          updates.rootAlter !== undefined,
        "rootAlter is a required field");
    }

    if (!original) {
      this.build = (): Root => {
        checkInvariants();
        (updates as any)._class = "Root";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.rootStep = (build: RootStep | ((builder: IRootStepBuilder) => IRootStepBuilder)): IRootBuilder => {
      if (typeof build === 'function') {
        delete updates["rootStep"]
        const builder = (build as any)(new RootStepBuilder(original && original["rootStep"]));
        if (!original) updates["rootStep"] = builder.build();
        else childBuilders["rootStep"] = builder;
      } else {
        updates.rootStep = build as any;
        delete childBuilders["rootStep;"];
      }
      modifiedKeys["rootStep"] = true;
      return this;
    }

    this.rootAlter = (build: RootAlter | ((builder: IRootAlterBuilder) => IRootAlterBuilder)): IRootBuilder => {
      if (typeof build === 'function') {
        delete updates["rootAlter"]
        const builder = (build as any)(new RootAlterBuilder(original && original["rootAlter"]));
        if (!original) updates["rootAlter"] = builder.build();
        else childBuilders["rootAlter"] = builder;
      } else {
        updates.rootAlter = build as any;
        delete childBuilders["rootAlter;"];
      }
      modifiedKeys["rootAlter"] = true;
      return this;
    }
  }
}
export function patchRoot(base: Root, builder: (build: IRootBuilder) => IRootBuilder): IAny[] { return builder(new RootBuilder(base)).patch(); }
export function buildRoot(builder: (build: IRootBuilder) => IRootBuilder): Root { return builder(new RootBuilder()).build(); }

export interface IRootStepBuilder {
  build?: () => RootStep;
  patch: () => IAny[];
  text: (text: string) => IRootStepBuilder;
  data: (data: string) => IRootStepBuilder;
  defaultX: (defaultX: number) => IRootStepBuilder;
  relativeY: (relativeY: number) => IRootStepBuilder;
  defaultY: (defaultY: number) => IRootStepBuilder;
  relativeX: (relativeX: number) => IRootStepBuilder;
  fontFamily: (fontFamily: string) => IRootStepBuilder;
  fontWeight: (fontWeight: NormalBold) => IRootStepBuilder;
  fontStyle: (fontStyle: NormalItalic) => IRootStepBuilder;
  fontSize: (fontSize: string) => IRootStepBuilder;
  color: (color: string) => IRootStepBuilder;
}

class RootStepBuilder implements IRootStepBuilder {
  build: () => RootStep;
  patch: () => IAny[];
  text: (text: string) => IRootStepBuilder;
  data: (data: string) => IRootStepBuilder;
  defaultX: (defaultX: number) => IRootStepBuilder;
  relativeY: (relativeY: number) => IRootStepBuilder;
  defaultY: (defaultY: number) => IRootStepBuilder;
  relativeX: (relativeX: number) => IRootStepBuilder;
  fontFamily: (fontFamily: string) => IRootStepBuilder;
  fontWeight: (fontWeight: NormalBold) => IRootStepBuilder;
  fontStyle: (fontStyle: NormalItalic) => IRootStepBuilder;
  fontSize: (fontSize: string) => IRootStepBuilder;
  color: (color: string) => IRootStepBuilder;
  constructor(original?: RootStep) {
    let updates: RootStep = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["text"]) ||
          childBuilders["text"] !== undefined ||
          updates.text !== undefined,
        "text is a required field");
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): RootStep => {
        checkInvariants();
        (updates as any)._class = "RootStep";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.text = (spec: string): IRootStepBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.data = (spec: string): IRootStepBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IRootStepBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IRootStepBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IRootStepBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IRootStepBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IRootStepBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IRootStepBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IRootStepBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IRootStepBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IRootStepBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchRootStep(base: RootStep, builder: (build: IRootStepBuilder) => IRootStepBuilder): IAny[] { return builder(new RootStepBuilder(base)).patch(); }
export function buildRootStep(builder: (build: IRootStepBuilder) => IRootStepBuilder): RootStep { return builder(new RootStepBuilder()).build(); }

export interface IRootAlterBuilder {
  build?: () => RootAlter;
  patch: () => IAny[];
  location: (location: LeftRight) => IRootAlterBuilder;
  data: (data: string) => IRootAlterBuilder;
  defaultX: (defaultX: number) => IRootAlterBuilder;
  relativeY: (relativeY: number) => IRootAlterBuilder;
  defaultY: (defaultY: number) => IRootAlterBuilder;
  relativeX: (relativeX: number) => IRootAlterBuilder;
  fontFamily: (fontFamily: string) => IRootAlterBuilder;
  fontWeight: (fontWeight: NormalBold) => IRootAlterBuilder;
  fontStyle: (fontStyle: NormalItalic) => IRootAlterBuilder;
  fontSize: (fontSize: string) => IRootAlterBuilder;
  color: (color: string) => IRootAlterBuilder;
  printObject: (printObject: boolean) => IRootAlterBuilder;
}

class RootAlterBuilder implements IRootAlterBuilder {
  build: () => RootAlter;
  patch: () => IAny[];
  location: (location: LeftRight) => IRootAlterBuilder;
  data: (data: string) => IRootAlterBuilder;
  defaultX: (defaultX: number) => IRootAlterBuilder;
  relativeY: (relativeY: number) => IRootAlterBuilder;
  defaultY: (defaultY: number) => IRootAlterBuilder;
  relativeX: (relativeX: number) => IRootAlterBuilder;
  fontFamily: (fontFamily: string) => IRootAlterBuilder;
  fontWeight: (fontWeight: NormalBold) => IRootAlterBuilder;
  fontStyle: (fontStyle: NormalItalic) => IRootAlterBuilder;
  fontSize: (fontSize: string) => IRootAlterBuilder;
  color: (color: string) => IRootAlterBuilder;
  printObject: (printObject: boolean) => IRootAlterBuilder;
  constructor(original?: RootAlter) {
    let updates: RootAlter = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["location"]) ||
          childBuilders["location"] !== undefined ||
          updates.location !== undefined,
        "location is a required field");
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): RootAlter => {
        checkInvariants();
        (updates as any)._class = "RootAlter";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.location = (spec: LeftRight): IRootAlterBuilder => {
        updates["location"] = spec;
        delete childBuilders["location;"];
        modifiedKeys["location"] = true;
        return this;
    }

    this.data = (spec: string): IRootAlterBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IRootAlterBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IRootAlterBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IRootAlterBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IRootAlterBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IRootAlterBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IRootAlterBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IRootAlterBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IRootAlterBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IRootAlterBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.printObject = (spec: boolean): IRootAlterBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }
  }
}
export function patchRootAlter(base: RootAlter, builder: (build: IRootAlterBuilder) => IRootAlterBuilder): IAny[] { return builder(new RootAlterBuilder(base)).patch(); }
export function buildRootAlter(builder: (build: IRootAlterBuilder) => IRootAlterBuilder): RootAlter { return builder(new RootAlterBuilder()).build(); }

export interface IFunctionBuilder {
  build?: () => Function;
  patch: () => IAny[];
  data: (data: string) => IFunctionBuilder;
  defaultX: (defaultX: number) => IFunctionBuilder;
  relativeY: (relativeY: number) => IFunctionBuilder;
  defaultY: (defaultY: number) => IFunctionBuilder;
  relativeX: (relativeX: number) => IFunctionBuilder;
  fontFamily: (fontFamily: string) => IFunctionBuilder;
  fontWeight: (fontWeight: NormalBold) => IFunctionBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFunctionBuilder;
  fontSize: (fontSize: string) => IFunctionBuilder;
  color: (color: string) => IFunctionBuilder;
}

class FunctionBuilder implements IFunctionBuilder {
  build: () => Function;
  patch: () => IAny[];
  data: (data: string) => IFunctionBuilder;
  defaultX: (defaultX: number) => IFunctionBuilder;
  relativeY: (relativeY: number) => IFunctionBuilder;
  defaultY: (defaultY: number) => IFunctionBuilder;
  relativeX: (relativeX: number) => IFunctionBuilder;
  fontFamily: (fontFamily: string) => IFunctionBuilder;
  fontWeight: (fontWeight: NormalBold) => IFunctionBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFunctionBuilder;
  fontSize: (fontSize: string) => IFunctionBuilder;
  color: (color: string) => IFunctionBuilder;
  constructor(original?: Function) {
    let updates: Function = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): Function => {
        checkInvariants();
        (updates as any)._class = "Function";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IFunctionBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IFunctionBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IFunctionBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IFunctionBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IFunctionBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IFunctionBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IFunctionBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IFunctionBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IFunctionBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IFunctionBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchFunction(base: Function, builder: (build: IFunctionBuilder) => IFunctionBuilder): IAny[] { return builder(new FunctionBuilder(base)).patch(); }
export function buildFunction(builder: (build: IFunctionBuilder) => IFunctionBuilder): Function { return builder(new FunctionBuilder()).build(); }

export interface IKindBuilder {
  build?: () => Kind;
  patch: () => IAny[];
  parenthesesDegrees: (parenthesesDegrees: boolean) => IKindBuilder;
  useSymbols: (useSymbols: boolean) => IKindBuilder;
  text: (text: string) => IKindBuilder;
  data: (data: string) => IKindBuilder;
  stackDegrees: (stackDegrees: boolean) => IKindBuilder;
  bracketDegrees: (bracketDegrees: boolean) => IKindBuilder;
  defaultX: (defaultX: number) => IKindBuilder;
  relativeY: (relativeY: number) => IKindBuilder;
  defaultY: (defaultY: number) => IKindBuilder;
  relativeX: (relativeX: number) => IKindBuilder;
  fontFamily: (fontFamily: string) => IKindBuilder;
  fontWeight: (fontWeight: NormalBold) => IKindBuilder;
  fontStyle: (fontStyle: NormalItalic) => IKindBuilder;
  fontSize: (fontSize: string) => IKindBuilder;
  color: (color: string) => IKindBuilder;
  halign: (halign: LeftCenterRight) => IKindBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IKindBuilder;
}

class KindBuilder implements IKindBuilder {
  build: () => Kind;
  patch: () => IAny[];
  parenthesesDegrees: (parenthesesDegrees: boolean) => IKindBuilder;
  useSymbols: (useSymbols: boolean) => IKindBuilder;
  text: (text: string) => IKindBuilder;
  data: (data: string) => IKindBuilder;
  stackDegrees: (stackDegrees: boolean) => IKindBuilder;
  bracketDegrees: (bracketDegrees: boolean) => IKindBuilder;
  defaultX: (defaultX: number) => IKindBuilder;
  relativeY: (relativeY: number) => IKindBuilder;
  defaultY: (defaultY: number) => IKindBuilder;
  relativeX: (relativeX: number) => IKindBuilder;
  fontFamily: (fontFamily: string) => IKindBuilder;
  fontWeight: (fontWeight: NormalBold) => IKindBuilder;
  fontStyle: (fontStyle: NormalItalic) => IKindBuilder;
  fontSize: (fontSize: string) => IKindBuilder;
  color: (color: string) => IKindBuilder;
  halign: (halign: LeftCenterRight) => IKindBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IKindBuilder;
  constructor(original?: Kind) {
    let updates: Kind = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["parenthesesDegrees"]) ||
          childBuilders["parenthesesDegrees"] !== undefined ||
          updates.parenthesesDegrees !== undefined,
        "parenthesesDegrees is a required field");
      console.assert(
          (original && !modifiedKeys["useSymbols"]) ||
          childBuilders["useSymbols"] !== undefined ||
          updates.useSymbols !== undefined,
        "useSymbols is a required field");
      console.assert(
          (original && !modifiedKeys["text"]) ||
          childBuilders["text"] !== undefined ||
          updates.text !== undefined,
        "text is a required field");
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
      console.assert(
          (original && !modifiedKeys["stackDegrees"]) ||
          childBuilders["stackDegrees"] !== undefined ||
          updates.stackDegrees !== undefined,
        "stackDegrees is a required field");
      console.assert(
          (original && !modifiedKeys["bracketDegrees"]) ||
          childBuilders["bracketDegrees"] !== undefined ||
          updates.bracketDegrees !== undefined,
        "bracketDegrees is a required field");
    }

    if (!original) {
      this.build = (): Kind => {
        checkInvariants();
        (updates as any)._class = "Kind";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.parenthesesDegrees = (spec: boolean): IKindBuilder => {
        updates["parenthesesDegrees"] = spec;
        delete childBuilders["parenthesesDegrees;"];
        modifiedKeys["parenthesesDegrees"] = true;
        return this;
    }

    this.useSymbols = (spec: boolean): IKindBuilder => {
        updates["useSymbols"] = spec;
        delete childBuilders["useSymbols;"];
        modifiedKeys["useSymbols"] = true;
        return this;
    }

    this.text = (spec: string): IKindBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.data = (spec: string): IKindBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.stackDegrees = (spec: boolean): IKindBuilder => {
        updates["stackDegrees"] = spec;
        delete childBuilders["stackDegrees;"];
        modifiedKeys["stackDegrees"] = true;
        return this;
    }

    this.bracketDegrees = (spec: boolean): IKindBuilder => {
        updates["bracketDegrees"] = spec;
        delete childBuilders["bracketDegrees;"];
        modifiedKeys["bracketDegrees"] = true;
        return this;
    }

    this.defaultX = (spec: number): IKindBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IKindBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IKindBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IKindBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IKindBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IKindBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IKindBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IKindBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IKindBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IKindBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IKindBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchKind(base: Kind, builder: (build: IKindBuilder) => IKindBuilder): IAny[] { return builder(new KindBuilder(base)).patch(); }
export function buildKind(builder: (build: IKindBuilder) => IKindBuilder): Kind { return builder(new KindBuilder()).build(); }

export interface IInversionBuilder {
  build?: () => Inversion;
  patch: () => IAny[];
  data: (data: string) => IInversionBuilder;
  defaultX: (defaultX: number) => IInversionBuilder;
  relativeY: (relativeY: number) => IInversionBuilder;
  defaultY: (defaultY: number) => IInversionBuilder;
  relativeX: (relativeX: number) => IInversionBuilder;
  fontFamily: (fontFamily: string) => IInversionBuilder;
  fontWeight: (fontWeight: NormalBold) => IInversionBuilder;
  fontStyle: (fontStyle: NormalItalic) => IInversionBuilder;
  fontSize: (fontSize: string) => IInversionBuilder;
  color: (color: string) => IInversionBuilder;
}

class InversionBuilder implements IInversionBuilder {
  build: () => Inversion;
  patch: () => IAny[];
  data: (data: string) => IInversionBuilder;
  defaultX: (defaultX: number) => IInversionBuilder;
  relativeY: (relativeY: number) => IInversionBuilder;
  defaultY: (defaultY: number) => IInversionBuilder;
  relativeX: (relativeX: number) => IInversionBuilder;
  fontFamily: (fontFamily: string) => IInversionBuilder;
  fontWeight: (fontWeight: NormalBold) => IInversionBuilder;
  fontStyle: (fontStyle: NormalItalic) => IInversionBuilder;
  fontSize: (fontSize: string) => IInversionBuilder;
  color: (color: string) => IInversionBuilder;
  constructor(original?: Inversion) {
    let updates: Inversion = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): Inversion => {
        checkInvariants();
        (updates as any)._class = "Inversion";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IInversionBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IInversionBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IInversionBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IInversionBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IInversionBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IInversionBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IInversionBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IInversionBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IInversionBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IInversionBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchInversion(base: Inversion, builder: (build: IInversionBuilder) => IInversionBuilder): IAny[] { return builder(new InversionBuilder(base)).patch(); }
export function buildInversion(builder: (build: IInversionBuilder) => IInversionBuilder): Inversion { return builder(new InversionBuilder()).build(); }

export interface IBassBuilder {
  build?: () => Bass;
  patch: () => IAny[];
  bassStep: (build: BassStep | ((builder: IBassStepBuilder) => IBassStepBuilder)) => IBassBuilder;
  bassAlter: (build: BassAlter | ((builder: IBassAlterBuilder) => IBassAlterBuilder)) => IBassBuilder;
}

class BassBuilder implements IBassBuilder {
  build: () => Bass;
  patch: () => IAny[];
  bassStep: (build: BassStep | ((builder: IBassStepBuilder) => IBassStepBuilder)) => IBassBuilder;
  bassAlter: (build: BassAlter | ((builder: IBassAlterBuilder) => IBassAlterBuilder)) => IBassBuilder;
  constructor(original?: Bass) {
    let updates: Bass = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["bassStep"]) ||
          childBuilders["bassStep"] !== undefined ||
          updates.bassStep !== undefined,
        "bassStep is a required field");
      console.assert(
          (original && !modifiedKeys["bassAlter"]) ||
          childBuilders["bassAlter"] !== undefined ||
          updates.bassAlter !== undefined,
        "bassAlter is a required field");
    }

    if (!original) {
      this.build = (): Bass => {
        checkInvariants();
        (updates as any)._class = "Bass";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.bassStep = (build: BassStep | ((builder: IBassStepBuilder) => IBassStepBuilder)): IBassBuilder => {
      if (typeof build === 'function') {
        delete updates["bassStep"]
        const builder = (build as any)(new BassStepBuilder(original && original["bassStep"]));
        if (!original) updates["bassStep"] = builder.build();
        else childBuilders["bassStep"] = builder;
      } else {
        updates.bassStep = build as any;
        delete childBuilders["bassStep;"];
      }
      modifiedKeys["bassStep"] = true;
      return this;
    }

    this.bassAlter = (build: BassAlter | ((builder: IBassAlterBuilder) => IBassAlterBuilder)): IBassBuilder => {
      if (typeof build === 'function') {
        delete updates["bassAlter"]
        const builder = (build as any)(new BassAlterBuilder(original && original["bassAlter"]));
        if (!original) updates["bassAlter"] = builder.build();
        else childBuilders["bassAlter"] = builder;
      } else {
        updates.bassAlter = build as any;
        delete childBuilders["bassAlter;"];
      }
      modifiedKeys["bassAlter"] = true;
      return this;
    }
  }
}
export function patchBass(base: Bass, builder: (build: IBassBuilder) => IBassBuilder): IAny[] { return builder(new BassBuilder(base)).patch(); }
export function buildBass(builder: (build: IBassBuilder) => IBassBuilder): Bass { return builder(new BassBuilder()).build(); }

export interface IBassStepBuilder {
  build?: () => BassStep;
  patch: () => IAny[];
  text: (text: string) => IBassStepBuilder;
  data: (data: string) => IBassStepBuilder;
  defaultX: (defaultX: number) => IBassStepBuilder;
  relativeY: (relativeY: number) => IBassStepBuilder;
  defaultY: (defaultY: number) => IBassStepBuilder;
  relativeX: (relativeX: number) => IBassStepBuilder;
  fontFamily: (fontFamily: string) => IBassStepBuilder;
  fontWeight: (fontWeight: NormalBold) => IBassStepBuilder;
  fontStyle: (fontStyle: NormalItalic) => IBassStepBuilder;
  fontSize: (fontSize: string) => IBassStepBuilder;
  color: (color: string) => IBassStepBuilder;
}

class BassStepBuilder implements IBassStepBuilder {
  build: () => BassStep;
  patch: () => IAny[];
  text: (text: string) => IBassStepBuilder;
  data: (data: string) => IBassStepBuilder;
  defaultX: (defaultX: number) => IBassStepBuilder;
  relativeY: (relativeY: number) => IBassStepBuilder;
  defaultY: (defaultY: number) => IBassStepBuilder;
  relativeX: (relativeX: number) => IBassStepBuilder;
  fontFamily: (fontFamily: string) => IBassStepBuilder;
  fontWeight: (fontWeight: NormalBold) => IBassStepBuilder;
  fontStyle: (fontStyle: NormalItalic) => IBassStepBuilder;
  fontSize: (fontSize: string) => IBassStepBuilder;
  color: (color: string) => IBassStepBuilder;
  constructor(original?: BassStep) {
    let updates: BassStep = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["text"]) ||
          childBuilders["text"] !== undefined ||
          updates.text !== undefined,
        "text is a required field");
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): BassStep => {
        checkInvariants();
        (updates as any)._class = "BassStep";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.text = (spec: string): IBassStepBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.data = (spec: string): IBassStepBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IBassStepBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IBassStepBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IBassStepBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IBassStepBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IBassStepBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IBassStepBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IBassStepBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IBassStepBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IBassStepBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchBassStep(base: BassStep, builder: (build: IBassStepBuilder) => IBassStepBuilder): IAny[] { return builder(new BassStepBuilder(base)).patch(); }
export function buildBassStep(builder: (build: IBassStepBuilder) => IBassStepBuilder): BassStep { return builder(new BassStepBuilder()).build(); }

export interface IBassAlterBuilder {
  build?: () => BassAlter;
  patch: () => IAny[];
  location: (location: LeftRight) => IBassAlterBuilder;
  data: (data: string) => IBassAlterBuilder;
  defaultX: (defaultX: number) => IBassAlterBuilder;
  relativeY: (relativeY: number) => IBassAlterBuilder;
  defaultY: (defaultY: number) => IBassAlterBuilder;
  relativeX: (relativeX: number) => IBassAlterBuilder;
  fontFamily: (fontFamily: string) => IBassAlterBuilder;
  fontWeight: (fontWeight: NormalBold) => IBassAlterBuilder;
  fontStyle: (fontStyle: NormalItalic) => IBassAlterBuilder;
  fontSize: (fontSize: string) => IBassAlterBuilder;
  color: (color: string) => IBassAlterBuilder;
  printObject: (printObject: boolean) => IBassAlterBuilder;
}

class BassAlterBuilder implements IBassAlterBuilder {
  build: () => BassAlter;
  patch: () => IAny[];
  location: (location: LeftRight) => IBassAlterBuilder;
  data: (data: string) => IBassAlterBuilder;
  defaultX: (defaultX: number) => IBassAlterBuilder;
  relativeY: (relativeY: number) => IBassAlterBuilder;
  defaultY: (defaultY: number) => IBassAlterBuilder;
  relativeX: (relativeX: number) => IBassAlterBuilder;
  fontFamily: (fontFamily: string) => IBassAlterBuilder;
  fontWeight: (fontWeight: NormalBold) => IBassAlterBuilder;
  fontStyle: (fontStyle: NormalItalic) => IBassAlterBuilder;
  fontSize: (fontSize: string) => IBassAlterBuilder;
  color: (color: string) => IBassAlterBuilder;
  printObject: (printObject: boolean) => IBassAlterBuilder;
  constructor(original?: BassAlter) {
    let updates: BassAlter = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["location"]) ||
          childBuilders["location"] !== undefined ||
          updates.location !== undefined,
        "location is a required field");
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): BassAlter => {
        checkInvariants();
        (updates as any)._class = "BassAlter";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.location = (spec: LeftRight): IBassAlterBuilder => {
        updates["location"] = spec;
        delete childBuilders["location;"];
        modifiedKeys["location"] = true;
        return this;
    }

    this.data = (spec: string): IBassAlterBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IBassAlterBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IBassAlterBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IBassAlterBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IBassAlterBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IBassAlterBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IBassAlterBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IBassAlterBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IBassAlterBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IBassAlterBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.printObject = (spec: boolean): IBassAlterBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }
  }
}
export function patchBassAlter(base: BassAlter, builder: (build: IBassAlterBuilder) => IBassAlterBuilder): IAny[] { return builder(new BassAlterBuilder(base)).patch(); }
export function buildBassAlter(builder: (build: IBassAlterBuilder) => IBassAlterBuilder): BassAlter { return builder(new BassAlterBuilder()).build(); }

export interface IDegreeBuilder {
  build?: () => Degree;
  patch: () => IAny[];
  degreeAlter: (build: DegreeAlter | ((builder: IDegreeAlterBuilder) => IDegreeAlterBuilder)) => IDegreeBuilder;
  degreeValue: (build: DegreeValue | ((builder: IDegreeValueBuilder) => IDegreeValueBuilder)) => IDegreeBuilder;
  degreeType: (build: DegreeType | ((builder: IDegreeTypeBuilder) => IDegreeTypeBuilder)) => IDegreeBuilder;
  printObject: (printObject: boolean) => IDegreeBuilder;
}

class DegreeBuilder implements IDegreeBuilder {
  build: () => Degree;
  patch: () => IAny[];
  degreeAlter: (build: DegreeAlter | ((builder: IDegreeAlterBuilder) => IDegreeAlterBuilder)) => IDegreeBuilder;
  degreeValue: (build: DegreeValue | ((builder: IDegreeValueBuilder) => IDegreeValueBuilder)) => IDegreeBuilder;
  degreeType: (build: DegreeType | ((builder: IDegreeTypeBuilder) => IDegreeTypeBuilder)) => IDegreeBuilder;
  printObject: (printObject: boolean) => IDegreeBuilder;
  constructor(original?: Degree) {
    let updates: Degree = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["degreeAlter"]) ||
          childBuilders["degreeAlter"] !== undefined ||
          updates.degreeAlter !== undefined,
        "degreeAlter is a required field");
      console.assert(
          (original && !modifiedKeys["degreeValue"]) ||
          childBuilders["degreeValue"] !== undefined ||
          updates.degreeValue !== undefined,
        "degreeValue is a required field");
      console.assert(
          (original && !modifiedKeys["degreeType"]) ||
          childBuilders["degreeType"] !== undefined ||
          updates.degreeType !== undefined,
        "degreeType is a required field");
    }

    if (!original) {
      this.build = (): Degree => {
        checkInvariants();
        (updates as any)._class = "Degree";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.degreeAlter = (build: DegreeAlter | ((builder: IDegreeAlterBuilder) => IDegreeAlterBuilder)): IDegreeBuilder => {
      if (typeof build === 'function') {
        delete updates["degreeAlter"]
        const builder = (build as any)(new DegreeAlterBuilder(original && original["degreeAlter"]));
        if (!original) updates["degreeAlter"] = builder.build();
        else childBuilders["degreeAlter"] = builder;
      } else {
        updates.degreeAlter = build as any;
        delete childBuilders["degreeAlter;"];
      }
      modifiedKeys["degreeAlter"] = true;
      return this;
    }

    this.degreeValue = (build: DegreeValue | ((builder: IDegreeValueBuilder) => IDegreeValueBuilder)): IDegreeBuilder => {
      if (typeof build === 'function') {
        delete updates["degreeValue"]
        const builder = (build as any)(new DegreeValueBuilder(original && original["degreeValue"]));
        if (!original) updates["degreeValue"] = builder.build();
        else childBuilders["degreeValue"] = builder;
      } else {
        updates.degreeValue = build as any;
        delete childBuilders["degreeValue;"];
      }
      modifiedKeys["degreeValue"] = true;
      return this;
    }

    this.degreeType = (build: DegreeType | ((builder: IDegreeTypeBuilder) => IDegreeTypeBuilder)): IDegreeBuilder => {
      if (typeof build === 'function') {
        delete updates["degreeType"]
        const builder = (build as any)(new DegreeTypeBuilder(original && original["degreeType"]));
        if (!original) updates["degreeType"] = builder.build();
        else childBuilders["degreeType"] = builder;
      } else {
        updates.degreeType = build as any;
        delete childBuilders["degreeType;"];
      }
      modifiedKeys["degreeType"] = true;
      return this;
    }

    this.printObject = (spec: boolean): IDegreeBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }
  }
}
export function patchDegree(base: Degree, builder: (build: IDegreeBuilder) => IDegreeBuilder): IAny[] { return builder(new DegreeBuilder(base)).patch(); }
export function buildDegree(builder: (build: IDegreeBuilder) => IDegreeBuilder): Degree { return builder(new DegreeBuilder()).build(); }

export interface IDegreeValueBuilder {
  build?: () => DegreeValue;
  patch: () => IAny[];
  symbol: (symbol: ChordType) => IDegreeValueBuilder;
  text: (text: string) => IDegreeValueBuilder;
  data: (data: string) => IDegreeValueBuilder;
  defaultX: (defaultX: number) => IDegreeValueBuilder;
  relativeY: (relativeY: number) => IDegreeValueBuilder;
  defaultY: (defaultY: number) => IDegreeValueBuilder;
  relativeX: (relativeX: number) => IDegreeValueBuilder;
  fontFamily: (fontFamily: string) => IDegreeValueBuilder;
  fontWeight: (fontWeight: NormalBold) => IDegreeValueBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDegreeValueBuilder;
  fontSize: (fontSize: string) => IDegreeValueBuilder;
  color: (color: string) => IDegreeValueBuilder;
}

class DegreeValueBuilder implements IDegreeValueBuilder {
  build: () => DegreeValue;
  patch: () => IAny[];
  symbol: (symbol: ChordType) => IDegreeValueBuilder;
  text: (text: string) => IDegreeValueBuilder;
  data: (data: string) => IDegreeValueBuilder;
  defaultX: (defaultX: number) => IDegreeValueBuilder;
  relativeY: (relativeY: number) => IDegreeValueBuilder;
  defaultY: (defaultY: number) => IDegreeValueBuilder;
  relativeX: (relativeX: number) => IDegreeValueBuilder;
  fontFamily: (fontFamily: string) => IDegreeValueBuilder;
  fontWeight: (fontWeight: NormalBold) => IDegreeValueBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDegreeValueBuilder;
  fontSize: (fontSize: string) => IDegreeValueBuilder;
  color: (color: string) => IDegreeValueBuilder;
  constructor(original?: DegreeValue) {
    let updates: DegreeValue = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["symbol"]) ||
          childBuilders["symbol"] !== undefined ||
          updates.symbol !== undefined,
        "symbol is a required field");
      console.assert(
          (original && !modifiedKeys["text"]) ||
          childBuilders["text"] !== undefined ||
          updates.text !== undefined,
        "text is a required field");
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): DegreeValue => {
        checkInvariants();
        (updates as any)._class = "DegreeValue";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.symbol = (spec: ChordType): IDegreeValueBuilder => {
        updates["symbol"] = spec;
        delete childBuilders["symbol;"];
        modifiedKeys["symbol"] = true;
        return this;
    }

    this.text = (spec: string): IDegreeValueBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.data = (spec: string): IDegreeValueBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IDegreeValueBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDegreeValueBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDegreeValueBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDegreeValueBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDegreeValueBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDegreeValueBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDegreeValueBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDegreeValueBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDegreeValueBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchDegreeValue(base: DegreeValue, builder: (build: IDegreeValueBuilder) => IDegreeValueBuilder): IAny[] { return builder(new DegreeValueBuilder(base)).patch(); }
export function buildDegreeValue(builder: (build: IDegreeValueBuilder) => IDegreeValueBuilder): DegreeValue { return builder(new DegreeValueBuilder()).build(); }

export interface IDegreeAlterBuilder {
  build?: () => DegreeAlter;
  patch: () => IAny[];
  plusMinus: (plusMinus: boolean) => IDegreeAlterBuilder;
  data: (data: string) => IDegreeAlterBuilder;
  defaultX: (defaultX: number) => IDegreeAlterBuilder;
  relativeY: (relativeY: number) => IDegreeAlterBuilder;
  defaultY: (defaultY: number) => IDegreeAlterBuilder;
  relativeX: (relativeX: number) => IDegreeAlterBuilder;
  fontFamily: (fontFamily: string) => IDegreeAlterBuilder;
  fontWeight: (fontWeight: NormalBold) => IDegreeAlterBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDegreeAlterBuilder;
  fontSize: (fontSize: string) => IDegreeAlterBuilder;
  color: (color: string) => IDegreeAlterBuilder;
}

class DegreeAlterBuilder implements IDegreeAlterBuilder {
  build: () => DegreeAlter;
  patch: () => IAny[];
  plusMinus: (plusMinus: boolean) => IDegreeAlterBuilder;
  data: (data: string) => IDegreeAlterBuilder;
  defaultX: (defaultX: number) => IDegreeAlterBuilder;
  relativeY: (relativeY: number) => IDegreeAlterBuilder;
  defaultY: (defaultY: number) => IDegreeAlterBuilder;
  relativeX: (relativeX: number) => IDegreeAlterBuilder;
  fontFamily: (fontFamily: string) => IDegreeAlterBuilder;
  fontWeight: (fontWeight: NormalBold) => IDegreeAlterBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDegreeAlterBuilder;
  fontSize: (fontSize: string) => IDegreeAlterBuilder;
  color: (color: string) => IDegreeAlterBuilder;
  constructor(original?: DegreeAlter) {
    let updates: DegreeAlter = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["plusMinus"]) ||
          childBuilders["plusMinus"] !== undefined ||
          updates.plusMinus !== undefined,
        "plusMinus is a required field");
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): DegreeAlter => {
        checkInvariants();
        (updates as any)._class = "DegreeAlter";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.plusMinus = (spec: boolean): IDegreeAlterBuilder => {
        updates["plusMinus"] = spec;
        delete childBuilders["plusMinus;"];
        modifiedKeys["plusMinus"] = true;
        return this;
    }

    this.data = (spec: string): IDegreeAlterBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IDegreeAlterBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDegreeAlterBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDegreeAlterBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDegreeAlterBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDegreeAlterBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDegreeAlterBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDegreeAlterBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDegreeAlterBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDegreeAlterBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchDegreeAlter(base: DegreeAlter, builder: (build: IDegreeAlterBuilder) => IDegreeAlterBuilder): IAny[] { return builder(new DegreeAlterBuilder(base)).patch(); }
export function buildDegreeAlter(builder: (build: IDegreeAlterBuilder) => IDegreeAlterBuilder): DegreeAlter { return builder(new DegreeAlterBuilder()).build(); }

export interface IDegreeTypeBuilder {
  build?: () => DegreeType;
  patch: () => IAny[];
  text: (text: string) => IDegreeTypeBuilder;
  data: (data: string) => IDegreeTypeBuilder;
  defaultX: (defaultX: number) => IDegreeTypeBuilder;
  relativeY: (relativeY: number) => IDegreeTypeBuilder;
  defaultY: (defaultY: number) => IDegreeTypeBuilder;
  relativeX: (relativeX: number) => IDegreeTypeBuilder;
  fontFamily: (fontFamily: string) => IDegreeTypeBuilder;
  fontWeight: (fontWeight: NormalBold) => IDegreeTypeBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDegreeTypeBuilder;
  fontSize: (fontSize: string) => IDegreeTypeBuilder;
  color: (color: string) => IDegreeTypeBuilder;
}

class DegreeTypeBuilder implements IDegreeTypeBuilder {
  build: () => DegreeType;
  patch: () => IAny[];
  text: (text: string) => IDegreeTypeBuilder;
  data: (data: string) => IDegreeTypeBuilder;
  defaultX: (defaultX: number) => IDegreeTypeBuilder;
  relativeY: (relativeY: number) => IDegreeTypeBuilder;
  defaultY: (defaultY: number) => IDegreeTypeBuilder;
  relativeX: (relativeX: number) => IDegreeTypeBuilder;
  fontFamily: (fontFamily: string) => IDegreeTypeBuilder;
  fontWeight: (fontWeight: NormalBold) => IDegreeTypeBuilder;
  fontStyle: (fontStyle: NormalItalic) => IDegreeTypeBuilder;
  fontSize: (fontSize: string) => IDegreeTypeBuilder;
  color: (color: string) => IDegreeTypeBuilder;
  constructor(original?: DegreeType) {
    let updates: DegreeType = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["text"]) ||
          childBuilders["text"] !== undefined ||
          updates.text !== undefined,
        "text is a required field");
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): DegreeType => {
        checkInvariants();
        (updates as any)._class = "DegreeType";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.text = (spec: string): IDegreeTypeBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.data = (spec: string): IDegreeTypeBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IDegreeTypeBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IDegreeTypeBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IDegreeTypeBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IDegreeTypeBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IDegreeTypeBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IDegreeTypeBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IDegreeTypeBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IDegreeTypeBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IDegreeTypeBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchDegreeType(base: DegreeType, builder: (build: IDegreeTypeBuilder) => IDegreeTypeBuilder): IAny[] { return builder(new DegreeTypeBuilder(base)).patch(); }
export function buildDegreeType(builder: (build: IDegreeTypeBuilder) => IDegreeTypeBuilder): DegreeType { return builder(new DegreeTypeBuilder()).build(); }

export interface IFrameBuilder {
  build?: () => Frame;
  patch: () => IAny[];
  frameStrings: (frameStrings: string) => IFrameBuilder;
  frameNotesAt: (idx: number, build: FrameNote | ((builder: IFrameNoteBuilder) => IFrameNoteBuilder)) => IFrameBuilder;
  frameNotesSplice: (start: number, deleteCount: number, ...items: FrameNote[]) => IFrameBuilder;
  frameNotes: (frameNotes: FrameNote[]) => IFrameBuilder;
  unplayed: (unplayed: string) => IFrameBuilder;
  frameFrets: (frameFrets: string) => IFrameBuilder;
  firstFret: (build: FirstFret | ((builder: IFirstFretBuilder) => IFirstFretBuilder)) => IFrameBuilder;
  width: (width: number) => IFrameBuilder;
  height: (height: number) => IFrameBuilder;
  defaultX: (defaultX: number) => IFrameBuilder;
  relativeY: (relativeY: number) => IFrameBuilder;
  defaultY: (defaultY: number) => IFrameBuilder;
  relativeX: (relativeX: number) => IFrameBuilder;
  color: (color: string) => IFrameBuilder;
  halign: (halign: LeftCenterRight) => IFrameBuilder;
  valignImage: (valignImage: TopMiddleBottomBaseline) => IFrameBuilder;
}

class FrameBuilder implements IFrameBuilder {
  build: () => Frame;
  patch: () => IAny[];
  frameStrings: (frameStrings: string) => IFrameBuilder;
  frameNotesAt: (idx: number, build: FrameNote | ((builder: IFrameNoteBuilder) => IFrameNoteBuilder)) => IFrameBuilder;
  frameNotesSplice: (start: number, deleteCount: number, ...items: FrameNote[]) => IFrameBuilder;
  frameNotes: (frameNotes: FrameNote[]) => IFrameBuilder;
  unplayed: (unplayed: string) => IFrameBuilder;
  frameFrets: (frameFrets: string) => IFrameBuilder;
  firstFret: (build: FirstFret | ((builder: IFirstFretBuilder) => IFirstFretBuilder)) => IFrameBuilder;
  width: (width: number) => IFrameBuilder;
  height: (height: number) => IFrameBuilder;
  defaultX: (defaultX: number) => IFrameBuilder;
  relativeY: (relativeY: number) => IFrameBuilder;
  defaultY: (defaultY: number) => IFrameBuilder;
  relativeX: (relativeX: number) => IFrameBuilder;
  color: (color: string) => IFrameBuilder;
  halign: (halign: LeftCenterRight) => IFrameBuilder;
  valignImage: (valignImage: TopMiddleBottomBaseline) => IFrameBuilder;
  constructor(original?: Frame) {
    let updates: Frame = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["frameStrings"]) ||
          childBuilders["frameStrings"] !== undefined ||
          updates.frameStrings !== undefined,
        "frameStrings is a required field");
      console.assert(
          (original && !modifiedKeys["frameNotes"]) ||
          childBuilders["frameNotes"] !== undefined ||
          updates.frameNotes !== undefined,
        "frameNotes is a required field");
      console.assert(
          (original && !modifiedKeys["unplayed"]) ||
          childBuilders["unplayed"] !== undefined ||
          updates.unplayed !== undefined,
        "unplayed is a required field");
      console.assert(
          (original && !modifiedKeys["frameFrets"]) ||
          childBuilders["frameFrets"] !== undefined ||
          updates.frameFrets !== undefined,
        "frameFrets is a required field");
      console.assert(
          (original && !modifiedKeys["firstFret"]) ||
          childBuilders["firstFret"] !== undefined ||
          updates.firstFret !== undefined,
        "firstFret is a required field");
      console.assert(
          (original && !modifiedKeys["width"]) ||
          childBuilders["width"] !== undefined ||
          updates.width !== undefined,
        "width is a required field");
      console.assert(
          (original && !modifiedKeys["height"]) ||
          childBuilders["height"] !== undefined ||
          updates.height !== undefined,
        "height is a required field");
    }

    if (!original) {
      this.build = (): Frame => {
        checkInvariants();
        (updates as any)._class = "Frame";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.frameStrings = (spec: string): IFrameBuilder => {
        updates["frameStrings"] = spec;
        delete childBuilders["frameStrings;"];
        modifiedKeys["frameStrings"] = true;
        return this;
    }

    this.frameNotes = (spec: FrameNote[]): IFrameBuilder => {
        updates["frameNotes"] = spec;
        delete childBuilders["frameNotes;"];
        modifiedKeys["frameNotes"] = true;
        return this;
    }

    this.frameNotesAt = (idx: number, build: FrameNote | ((builder: IFrameNoteBuilder) => IFrameNoteBuilder)): IFrameBuilder => {
      makeReference("frameNotes");
      if (frozen["frameNotes"][idx]) {
          throw new Error("Patching frameNotes." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["frameNotes"] && !original["frameNotes"]) {
          // Clone snapshot.
          patches.push({p: ["frameNotes", idx], li: original._snapshot["frameNotes"]});
      }
      if (typeof build === 'function' && reference["frameNotes"][idx]) {
        let patch = (build as any)(new FrameNoteBuilder(reference["frameNotes"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["frameNotes", idx].concat(patch.p);
          return patch;
        }));
        frozen["frameNotes"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new FrameNoteBuilder(reference["frameNotes"][idx])).build() : build;
      if (original) {
        patches.push({p: ["frameNotes", idx], li: update});
      } else {
        updates["frameNotes"] = reference["frameNotes"]; // TODO: Merge?
      } 
      reference["frameNotes"][idx] = update;
      frozen["frameNotes"][idx] = true;
      return this;
    }

    this.frameNotesSplice = (start: number, deleteCount: number, ...items: FrameNote[]): IFrameBuilder => {
      makeReference("frameNotes");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["frameNotes"][idx]) {
            throw new Error("Replacing frameNotes." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["frameNotes"][idx];
          patches.push({p: ["frameNotes", idx], ld, li: items[idx - start]});
          frozen["frameNotes"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["frameNotes"][idx]) {
            throw new Error("Removing frameNotes." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["frameNotes"][idx];
          patches.push({p: ["frameNotes", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["frameNotes", idx], li: items[idx - start]});
          frozen["frameNotes"][idx] = true;
        }
      }
      reference["frameNotes"].splice(start, deleteCount, ...items);
      updates["frameNotes"] = reference["frameNotes"];
      frozen["frameNotes"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.unplayed = (spec: string): IFrameBuilder => {
        updates["unplayed"] = spec;
        delete childBuilders["unplayed;"];
        modifiedKeys["unplayed"] = true;
        return this;
    }

    this.frameFrets = (spec: string): IFrameBuilder => {
        updates["frameFrets"] = spec;
        delete childBuilders["frameFrets;"];
        modifiedKeys["frameFrets"] = true;
        return this;
    }

    this.firstFret = (build: FirstFret | ((builder: IFirstFretBuilder) => IFirstFretBuilder)): IFrameBuilder => {
      if (typeof build === 'function') {
        delete updates["firstFret"]
        const builder = (build as any)(new FirstFretBuilder(original && original["firstFret"]));
        if (!original) updates["firstFret"] = builder.build();
        else childBuilders["firstFret"] = builder;
      } else {
        updates.firstFret = build as any;
        delete childBuilders["firstFret;"];
      }
      modifiedKeys["firstFret"] = true;
      return this;
    }

    this.width = (spec: number): IFrameBuilder => {
        updates["width"] = spec;
        delete childBuilders["width;"];
        modifiedKeys["width"] = true;
        return this;
    }

    this.height = (spec: number): IFrameBuilder => {
        updates["height"] = spec;
        delete childBuilders["height;"];
        modifiedKeys["height"] = true;
        return this;
    }

    this.defaultX = (spec: number): IFrameBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IFrameBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IFrameBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IFrameBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.color = (spec: string): IFrameBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IFrameBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valignImage = (spec: TopMiddleBottomBaseline): IFrameBuilder => {
        updates["valignImage"] = spec;
        delete childBuilders["valignImage;"];
        modifiedKeys["valignImage"] = true;
        return this;
    }
  }
}
export function patchFrame(base: Frame, builder: (build: IFrameBuilder) => IFrameBuilder): IAny[] { return builder(new FrameBuilder(base)).patch(); }
export function buildFrame(builder: (build: IFrameBuilder) => IFrameBuilder): Frame { return builder(new FrameBuilder()).build(); }

export interface IFirstFretBuilder {
  build?: () => FirstFret;
  patch: () => IAny[];
  text: (text: string) => IFirstFretBuilder;
  location: (location: LeftRight) => IFirstFretBuilder;
  data: (data: string) => IFirstFretBuilder;
}

class FirstFretBuilder implements IFirstFretBuilder {
  build: () => FirstFret;
  patch: () => IAny[];
  text: (text: string) => IFirstFretBuilder;
  location: (location: LeftRight) => IFirstFretBuilder;
  data: (data: string) => IFirstFretBuilder;
  constructor(original?: FirstFret) {
    let updates: FirstFret = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["text"]) ||
          childBuilders["text"] !== undefined ||
          updates.text !== undefined,
        "text is a required field");
      console.assert(
          (original && !modifiedKeys["location"]) ||
          childBuilders["location"] !== undefined ||
          updates.location !== undefined,
        "location is a required field");
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): FirstFret => {
        checkInvariants();
        (updates as any)._class = "FirstFret";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.text = (spec: string): IFirstFretBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.location = (spec: LeftRight): IFirstFretBuilder => {
        updates["location"] = spec;
        delete childBuilders["location;"];
        modifiedKeys["location"] = true;
        return this;
    }

    this.data = (spec: string): IFirstFretBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }
  }
}
export function patchFirstFret(base: FirstFret, builder: (build: IFirstFretBuilder) => IFirstFretBuilder): IAny[] { return builder(new FirstFretBuilder(base)).patch(); }
export function buildFirstFret(builder: (build: IFirstFretBuilder) => IFirstFretBuilder): FirstFret { return builder(new FirstFretBuilder()).build(); }

export interface IFrameNoteBuilder {
  build?: () => FrameNote;
  patch: () => IAny[];
  barre: (build: Barre | ((builder: IBarreBuilder) => IBarreBuilder)) => IFrameNoteBuilder;
  string: (build: String | ((builder: IStringBuilder) => IStringBuilder)) => IFrameNoteBuilder;
  fingering: (build: Fingering | ((builder: IFingeringBuilder) => IFingeringBuilder)) => IFrameNoteBuilder;
  fret: (build: Fret | ((builder: IFretBuilder) => IFretBuilder)) => IFrameNoteBuilder;
}

class FrameNoteBuilder implements IFrameNoteBuilder {
  build: () => FrameNote;
  patch: () => IAny[];
  barre: (build: Barre | ((builder: IBarreBuilder) => IBarreBuilder)) => IFrameNoteBuilder;
  string: (build: String | ((builder: IStringBuilder) => IStringBuilder)) => IFrameNoteBuilder;
  fingering: (build: Fingering | ((builder: IFingeringBuilder) => IFingeringBuilder)) => IFrameNoteBuilder;
  fret: (build: Fret | ((builder: IFretBuilder) => IFretBuilder)) => IFrameNoteBuilder;
  constructor(original?: FrameNote) {
    let updates: FrameNote = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["barre"]) ||
          childBuilders["barre"] !== undefined ||
          updates.barre !== undefined,
        "barre is a required field");
      console.assert(
          (original && !modifiedKeys["string"]) ||
          childBuilders["string"] !== undefined ||
          updates.string !== undefined,
        "string is a required field");
      console.assert(
          (original && !modifiedKeys["fingering"]) ||
          childBuilders["fingering"] !== undefined ||
          updates.fingering !== undefined,
        "fingering is a required field");
      console.assert(
          (original && !modifiedKeys["fret"]) ||
          childBuilders["fret"] !== undefined ||
          updates.fret !== undefined,
        "fret is a required field");
    }

    if (!original) {
      this.build = (): FrameNote => {
        checkInvariants();
        (updates as any)._class = "FrameNote";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.barre = (build: Barre | ((builder: IBarreBuilder) => IBarreBuilder)): IFrameNoteBuilder => {
      if (typeof build === 'function') {
        delete updates["barre"]
        const builder = (build as any)(new BarreBuilder(original && original["barre"]));
        if (!original) updates["barre"] = builder.build();
        else childBuilders["barre"] = builder;
      } else {
        updates.barre = build as any;
        delete childBuilders["barre;"];
      }
      modifiedKeys["barre"] = true;
      return this;
    }

    this.string = (build: String | ((builder: IStringBuilder) => IStringBuilder)): IFrameNoteBuilder => {
      if (typeof build === 'function') {
        delete updates["string"]
        const builder = (build as any)(new StringBuilder(original && original["string"]));
        if (!original) updates["string"] = builder.build();
        else childBuilders["string"] = builder;
      } else {
        updates.string = build as any;
        delete childBuilders["string;"];
      }
      modifiedKeys["string"] = true;
      return this;
    }

    this.fingering = (build: Fingering | ((builder: IFingeringBuilder) => IFingeringBuilder)): IFrameNoteBuilder => {
      if (typeof build === 'function') {
        delete updates["fingering"]
        const builder = (build as any)(new FingeringBuilder(original && original["fingering"]));
        if (!original) updates["fingering"] = builder.build();
        else childBuilders["fingering"] = builder;
      } else {
        updates.fingering = build as any;
        delete childBuilders["fingering;"];
      }
      modifiedKeys["fingering"] = true;
      return this;
    }

    this.fret = (build: Fret | ((builder: IFretBuilder) => IFretBuilder)): IFrameNoteBuilder => {
      if (typeof build === 'function') {
        delete updates["fret"]
        const builder = (build as any)(new FretBuilder(original && original["fret"]));
        if (!original) updates["fret"] = builder.build();
        else childBuilders["fret"] = builder;
      } else {
        updates.fret = build as any;
        delete childBuilders["fret;"];
      }
      modifiedKeys["fret"] = true;
      return this;
    }
  }
}
export function patchFrameNote(base: FrameNote, builder: (build: IFrameNoteBuilder) => IFrameNoteBuilder): IAny[] { return builder(new FrameNoteBuilder(base)).patch(); }
export function buildFrameNote(builder: (build: IFrameNoteBuilder) => IFrameNoteBuilder): FrameNote { return builder(new FrameNoteBuilder()).build(); }

export interface IBarreBuilder {
  build?: () => Barre;
  patch: () => IAny[];
  type: (type: StartStop) => IBarreBuilder;
  color: (color: string) => IBarreBuilder;
}

class BarreBuilder implements IBarreBuilder {
  build: () => Barre;
  patch: () => IAny[];
  type: (type: StartStop) => IBarreBuilder;
  color: (color: string) => IBarreBuilder;
  constructor(original?: Barre) {
    let updates: Barre = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Barre => {
        checkInvariants();
        (updates as any)._class = "Barre";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.type = (spec: StartStop): IBarreBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.color = (spec: string): IBarreBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchBarre(base: Barre, builder: (build: IBarreBuilder) => IBarreBuilder): IAny[] { return builder(new BarreBuilder(base)).patch(); }
export function buildBarre(builder: (build: IBarreBuilder) => IBarreBuilder): Barre { return builder(new BarreBuilder()).build(); }

export interface IGroupingBuilder {
  build?: () => Grouping;
  patch: () => IAny[];
  featuresAt: (idx: number, build: Feature | ((builder: IFeatureBuilder) => IFeatureBuilder)) => IGroupingBuilder;
  featuresSplice: (start: number, deleteCount: number, ...items: Feature[]) => IGroupingBuilder;
  features: (features: Feature[]) => IGroupingBuilder;
  number: (number: number) => IGroupingBuilder;
  type: (type: StartStopSingle) => IGroupingBuilder;
  memberOf: (memberOf: string) => IGroupingBuilder;
}

class GroupingBuilder implements IGroupingBuilder {
  build: () => Grouping;
  patch: () => IAny[];
  featuresAt: (idx: number, build: Feature | ((builder: IFeatureBuilder) => IFeatureBuilder)) => IGroupingBuilder;
  featuresSplice: (start: number, deleteCount: number, ...items: Feature[]) => IGroupingBuilder;
  features: (features: Feature[]) => IGroupingBuilder;
  number: (number: number) => IGroupingBuilder;
  type: (type: StartStopSingle) => IGroupingBuilder;
  memberOf: (memberOf: string) => IGroupingBuilder;
  constructor(original?: Grouping) {
    let updates: Grouping = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["features"]) ||
          childBuilders["features"] !== undefined ||
          updates.features !== undefined,
        "features is a required field");
      console.assert(
          (original && !modifiedKeys["number"]) ||
          childBuilders["number"] !== undefined ||
          updates.number !== undefined,
        "number is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
      console.assert(
          (original && !modifiedKeys["memberOf"]) ||
          childBuilders["memberOf"] !== undefined ||
          updates.memberOf !== undefined,
        "memberOf is a required field");
    }

    if (!original) {
      this.build = (): Grouping => {
        checkInvariants();
        (updates as any)._class = "Grouping";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.features = (spec: Feature[]): IGroupingBuilder => {
        updates["features"] = spec;
        delete childBuilders["features;"];
        modifiedKeys["features"] = true;
        return this;
    }

    this.featuresAt = (idx: number, build: Feature | ((builder: IFeatureBuilder) => IFeatureBuilder)): IGroupingBuilder => {
      makeReference("features");
      if (frozen["features"][idx]) {
          throw new Error("Patching features." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["features"] && !original["features"]) {
          // Clone snapshot.
          patches.push({p: ["features", idx], li: original._snapshot["features"]});
      }
      if (typeof build === 'function' && reference["features"][idx]) {
        let patch = (build as any)(new FeatureBuilder(reference["features"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["features", idx].concat(patch.p);
          return patch;
        }));
        frozen["features"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new FeatureBuilder(reference["features"][idx])).build() : build;
      if (original) {
        patches.push({p: ["features", idx], li: update});
      } else {
        updates["features"] = reference["features"]; // TODO: Merge?
      } 
      reference["features"][idx] = update;
      frozen["features"][idx] = true;
      return this;
    }

    this.featuresSplice = (start: number, deleteCount: number, ...items: Feature[]): IGroupingBuilder => {
      makeReference("features");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["features"][idx]) {
            throw new Error("Replacing features." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["features"][idx];
          patches.push({p: ["features", idx], ld, li: items[idx - start]});
          frozen["features"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["features"][idx]) {
            throw new Error("Removing features." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["features"][idx];
          patches.push({p: ["features", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["features", idx], li: items[idx - start]});
          frozen["features"][idx] = true;
        }
      }
      reference["features"].splice(start, deleteCount, ...items);
      updates["features"] = reference["features"];
      frozen["features"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.number = (spec: number): IGroupingBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.type = (spec: StartStopSingle): IGroupingBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.memberOf = (spec: string): IGroupingBuilder => {
        updates["memberOf"] = spec;
        delete childBuilders["memberOf;"];
        modifiedKeys["memberOf"] = true;
        return this;
    }
  }
}
export function patchGrouping(base: Grouping, builder: (build: IGroupingBuilder) => IGroupingBuilder): IAny[] { return builder(new GroupingBuilder(base)).patch(); }
export function buildGrouping(builder: (build: IGroupingBuilder) => IGroupingBuilder): Grouping { return builder(new GroupingBuilder()).build(); }

export interface IFeatureBuilder {
  build?: () => Feature;
  patch: () => IAny[];
  data: (data: string) => IFeatureBuilder;
  type: (type: string) => IFeatureBuilder;
}

class FeatureBuilder implements IFeatureBuilder {
  build: () => Feature;
  patch: () => IAny[];
  data: (data: string) => IFeatureBuilder;
  type: (type: string) => IFeatureBuilder;
  constructor(original?: Feature) {
    let updates: Feature = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
    }

    if (!original) {
      this.build = (): Feature => {
        checkInvariants();
        (updates as any)._class = "Feature";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IFeatureBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.type = (spec: string): IFeatureBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }
  }
}
export function patchFeature(base: Feature, builder: (build: IFeatureBuilder) => IFeatureBuilder): IAny[] { return builder(new FeatureBuilder(base)).patch(); }
export function buildFeature(builder: (build: IFeatureBuilder) => IFeatureBuilder): Feature { return builder(new FeatureBuilder()).build(); }

export interface IPrintBuilder {
  build?: () => Print;
  patch: () => IAny[];
  measureNumbering: (build: MeasureNumbering | ((builder: IMeasureNumberingBuilder) => IMeasureNumberingBuilder)) => IPrintBuilder;
  partNameDisplay: (build: PartNameDisplay | ((builder: IPartNameDisplayBuilder) => IPartNameDisplayBuilder)) => IPrintBuilder;
  newSystem: (newSystem: boolean) => IPrintBuilder;
  newPage: (newPage: boolean) => IPrintBuilder;
  blankPage: (blankPage: string) => IPrintBuilder;
  measureLayout: (build: MeasureLayout | ((builder: IMeasureLayoutBuilder) => IMeasureLayoutBuilder)) => IPrintBuilder;
  partAbbreviationDisplay: (build: PartAbbreviationDisplay | ((builder: IPartAbbreviationDisplayBuilder) => IPartAbbreviationDisplayBuilder)) => IPrintBuilder;
  pageLayout: (build: PageLayout | ((builder: IPageLayoutBuilder) => IPageLayoutBuilder)) => IPrintBuilder;
  systemLayout: (build: SystemLayout | ((builder: ISystemLayoutBuilder) => ISystemLayoutBuilder)) => IPrintBuilder;
  staffSpacing: (staffSpacing: number) => IPrintBuilder;
  staffLayoutsAt: (idx: number, build: StaffLayout | ((builder: IStaffLayoutBuilder) => IStaffLayoutBuilder)) => IPrintBuilder;
  staffLayoutsSplice: (start: number, deleteCount: number, ...items: StaffLayout[]) => IPrintBuilder;
  staffLayouts: (staffLayouts: StaffLayout[]) => IPrintBuilder;
  pageNumber: (pageNumber: string) => IPrintBuilder;
}

class PrintBuilder implements IPrintBuilder {
  build: () => Print;
  patch: () => IAny[];
  measureNumbering: (build: MeasureNumbering | ((builder: IMeasureNumberingBuilder) => IMeasureNumberingBuilder)) => IPrintBuilder;
  partNameDisplay: (build: PartNameDisplay | ((builder: IPartNameDisplayBuilder) => IPartNameDisplayBuilder)) => IPrintBuilder;
  newSystem: (newSystem: boolean) => IPrintBuilder;
  newPage: (newPage: boolean) => IPrintBuilder;
  blankPage: (blankPage: string) => IPrintBuilder;
  measureLayout: (build: MeasureLayout | ((builder: IMeasureLayoutBuilder) => IMeasureLayoutBuilder)) => IPrintBuilder;
  partAbbreviationDisplay: (build: PartAbbreviationDisplay | ((builder: IPartAbbreviationDisplayBuilder) => IPartAbbreviationDisplayBuilder)) => IPrintBuilder;
  pageLayout: (build: PageLayout | ((builder: IPageLayoutBuilder) => IPageLayoutBuilder)) => IPrintBuilder;
  systemLayout: (build: SystemLayout | ((builder: ISystemLayoutBuilder) => ISystemLayoutBuilder)) => IPrintBuilder;
  staffSpacing: (staffSpacing: number) => IPrintBuilder;
  staffLayoutsAt: (idx: number, build: StaffLayout | ((builder: IStaffLayoutBuilder) => IStaffLayoutBuilder)) => IPrintBuilder;
  staffLayoutsSplice: (start: number, deleteCount: number, ...items: StaffLayout[]) => IPrintBuilder;
  staffLayouts: (staffLayouts: StaffLayout[]) => IPrintBuilder;
  pageNumber: (pageNumber: string) => IPrintBuilder;
  constructor(original?: Print) {
    let updates: Print = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["measureNumbering"]) ||
          childBuilders["measureNumbering"] !== undefined ||
          updates.measureNumbering !== undefined,
        "measureNumbering is a required field");
      console.assert(
          (original && !modifiedKeys["partNameDisplay"]) ||
          childBuilders["partNameDisplay"] !== undefined ||
          updates.partNameDisplay !== undefined,
        "partNameDisplay is a required field");
      console.assert(
          (original && !modifiedKeys["newSystem"]) ||
          childBuilders["newSystem"] !== undefined ||
          updates.newSystem !== undefined,
        "newSystem is a required field");
      console.assert(
          (original && !modifiedKeys["newPage"]) ||
          childBuilders["newPage"] !== undefined ||
          updates.newPage !== undefined,
        "newPage is a required field");
      console.assert(
          (original && !modifiedKeys["blankPage"]) ||
          childBuilders["blankPage"] !== undefined ||
          updates.blankPage !== undefined,
        "blankPage is a required field");
      console.assert(
          (original && !modifiedKeys["measureLayout"]) ||
          childBuilders["measureLayout"] !== undefined ||
          updates.measureLayout !== undefined,
        "measureLayout is a required field");
      console.assert(
          (original && !modifiedKeys["partAbbreviationDisplay"]) ||
          childBuilders["partAbbreviationDisplay"] !== undefined ||
          updates.partAbbreviationDisplay !== undefined,
        "partAbbreviationDisplay is a required field");
      console.assert(
          (original && !modifiedKeys["pageLayout"]) ||
          childBuilders["pageLayout"] !== undefined ||
          updates.pageLayout !== undefined,
        "pageLayout is a required field");
      console.assert(
          (original && !modifiedKeys["systemLayout"]) ||
          childBuilders["systemLayout"] !== undefined ||
          updates.systemLayout !== undefined,
        "systemLayout is a required field");
      console.assert(
          (original && !modifiedKeys["staffSpacing"]) ||
          childBuilders["staffSpacing"] !== undefined ||
          updates.staffSpacing !== undefined,
        "staffSpacing is a required field");
      console.assert(
          (original && !modifiedKeys["staffLayouts"]) ||
          childBuilders["staffLayouts"] !== undefined ||
          updates.staffLayouts !== undefined,
        "staffLayouts is a required field");
      console.assert(
          (original && !modifiedKeys["pageNumber"]) ||
          childBuilders["pageNumber"] !== undefined ||
          updates.pageNumber !== undefined,
        "pageNumber is a required field");
    }

    if (!original) {
      this.build = (): Print => {
        checkInvariants();
        (updates as any)._class = "Print";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.measureNumbering = (build: MeasureNumbering | ((builder: IMeasureNumberingBuilder) => IMeasureNumberingBuilder)): IPrintBuilder => {
      if (typeof build === 'function') {
        delete updates["measureNumbering"]
        const builder = (build as any)(new MeasureNumberingBuilder(original && original["measureNumbering"]));
        if (!original) updates["measureNumbering"] = builder.build();
        else childBuilders["measureNumbering"] = builder;
      } else {
        updates.measureNumbering = build as any;
        delete childBuilders["measureNumbering;"];
      }
      modifiedKeys["measureNumbering"] = true;
      return this;
    }

    this.partNameDisplay = (build: PartNameDisplay | ((builder: IPartNameDisplayBuilder) => IPartNameDisplayBuilder)): IPrintBuilder => {
      if (typeof build === 'function') {
        delete updates["partNameDisplay"]
        const builder = (build as any)(new PartNameDisplayBuilder(original && original["partNameDisplay"]));
        if (!original) updates["partNameDisplay"] = builder.build();
        else childBuilders["partNameDisplay"] = builder;
      } else {
        updates.partNameDisplay = build as any;
        delete childBuilders["partNameDisplay;"];
      }
      modifiedKeys["partNameDisplay"] = true;
      return this;
    }

    this.newSystem = (spec: boolean): IPrintBuilder => {
        updates["newSystem"] = spec;
        delete childBuilders["newSystem;"];
        modifiedKeys["newSystem"] = true;
        return this;
    }

    this.newPage = (spec: boolean): IPrintBuilder => {
        updates["newPage"] = spec;
        delete childBuilders["newPage;"];
        modifiedKeys["newPage"] = true;
        return this;
    }

    this.blankPage = (spec: string): IPrintBuilder => {
        updates["blankPage"] = spec;
        delete childBuilders["blankPage;"];
        modifiedKeys["blankPage"] = true;
        return this;
    }

    this.measureLayout = (build: MeasureLayout | ((builder: IMeasureLayoutBuilder) => IMeasureLayoutBuilder)): IPrintBuilder => {
      if (typeof build === 'function') {
        delete updates["measureLayout"]
        const builder = (build as any)(new MeasureLayoutBuilder(original && original["measureLayout"]));
        if (!original) updates["measureLayout"] = builder.build();
        else childBuilders["measureLayout"] = builder;
      } else {
        updates.measureLayout = build as any;
        delete childBuilders["measureLayout;"];
      }
      modifiedKeys["measureLayout"] = true;
      return this;
    }

    this.partAbbreviationDisplay = (build: PartAbbreviationDisplay | ((builder: IPartAbbreviationDisplayBuilder) => IPartAbbreviationDisplayBuilder)): IPrintBuilder => {
      if (typeof build === 'function') {
        delete updates["partAbbreviationDisplay"]
        const builder = (build as any)(new PartAbbreviationDisplayBuilder(original && original["partAbbreviationDisplay"]));
        if (!original) updates["partAbbreviationDisplay"] = builder.build();
        else childBuilders["partAbbreviationDisplay"] = builder;
      } else {
        updates.partAbbreviationDisplay = build as any;
        delete childBuilders["partAbbreviationDisplay;"];
      }
      modifiedKeys["partAbbreviationDisplay"] = true;
      return this;
    }

    this.pageLayout = (build: PageLayout | ((builder: IPageLayoutBuilder) => IPageLayoutBuilder)): IPrintBuilder => {
      if (typeof build === 'function') {
        delete updates["pageLayout"]
        const builder = (build as any)(new PageLayoutBuilder(original && original["pageLayout"]));
        if (!original) updates["pageLayout"] = builder.build();
        else childBuilders["pageLayout"] = builder;
      } else {
        updates.pageLayout = build as any;
        delete childBuilders["pageLayout;"];
      }
      modifiedKeys["pageLayout"] = true;
      return this;
    }

    this.systemLayout = (build: SystemLayout | ((builder: ISystemLayoutBuilder) => ISystemLayoutBuilder)): IPrintBuilder => {
      if (typeof build === 'function') {
        delete updates["systemLayout"]
        const builder = (build as any)(new SystemLayoutBuilder(original && original["systemLayout"]));
        if (!original) updates["systemLayout"] = builder.build();
        else childBuilders["systemLayout"] = builder;
      } else {
        updates.systemLayout = build as any;
        delete childBuilders["systemLayout;"];
      }
      modifiedKeys["systemLayout"] = true;
      return this;
    }

    this.staffSpacing = (spec: number): IPrintBuilder => {
        updates["staffSpacing"] = spec;
        delete childBuilders["staffSpacing;"];
        modifiedKeys["staffSpacing"] = true;
        return this;
    }

    this.staffLayouts = (spec: StaffLayout[]): IPrintBuilder => {
        updates["staffLayouts"] = spec;
        delete childBuilders["staffLayouts;"];
        modifiedKeys["staffLayouts"] = true;
        return this;
    }

    this.staffLayoutsAt = (idx: number, build: StaffLayout | ((builder: IStaffLayoutBuilder) => IStaffLayoutBuilder)): IPrintBuilder => {
      makeReference("staffLayouts");
      if (frozen["staffLayouts"][idx]) {
          throw new Error("Patching staffLayouts." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["staffLayouts"] && !original["staffLayouts"]) {
          // Clone snapshot.
          patches.push({p: ["staffLayouts", idx], li: original._snapshot["staffLayouts"]});
      }
      if (typeof build === 'function' && reference["staffLayouts"][idx]) {
        let patch = (build as any)(new StaffLayoutBuilder(reference["staffLayouts"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["staffLayouts", idx].concat(patch.p);
          return patch;
        }));
        frozen["staffLayouts"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new StaffLayoutBuilder(reference["staffLayouts"][idx])).build() : build;
      if (original) {
        patches.push({p: ["staffLayouts", idx], li: update});
      } else {
        updates["staffLayouts"] = reference["staffLayouts"]; // TODO: Merge?
      } 
      reference["staffLayouts"][idx] = update;
      frozen["staffLayouts"][idx] = true;
      return this;
    }

    this.staffLayoutsSplice = (start: number, deleteCount: number, ...items: StaffLayout[]): IPrintBuilder => {
      makeReference("staffLayouts");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["staffLayouts"][idx]) {
            throw new Error("Replacing staffLayouts." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["staffLayouts"][idx];
          patches.push({p: ["staffLayouts", idx], ld, li: items[idx - start]});
          frozen["staffLayouts"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["staffLayouts"][idx]) {
            throw new Error("Removing staffLayouts." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["staffLayouts"][idx];
          patches.push({p: ["staffLayouts", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["staffLayouts", idx], li: items[idx - start]});
          frozen["staffLayouts"][idx] = true;
        }
      }
      reference["staffLayouts"].splice(start, deleteCount, ...items);
      updates["staffLayouts"] = reference["staffLayouts"];
      frozen["staffLayouts"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.pageNumber = (spec: string): IPrintBuilder => {
        updates["pageNumber"] = spec;
        delete childBuilders["pageNumber;"];
        modifiedKeys["pageNumber"] = true;
        return this;
    }
  }
}
export function patchPrint(base: Print, builder: (build: IPrintBuilder) => IPrintBuilder): IAny[] { return builder(new PrintBuilder(base)).patch(); }
export function buildPrint(builder: (build: IPrintBuilder) => IPrintBuilder): Print { return builder(new PrintBuilder()).build(); }

export interface IMeasureNumberingBuilder {
  build?: () => MeasureNumbering;
  patch: () => IAny[];
  data: (data: string) => IMeasureNumberingBuilder;
  defaultX: (defaultX: number) => IMeasureNumberingBuilder;
  relativeY: (relativeY: number) => IMeasureNumberingBuilder;
  defaultY: (defaultY: number) => IMeasureNumberingBuilder;
  relativeX: (relativeX: number) => IMeasureNumberingBuilder;
  fontFamily: (fontFamily: string) => IMeasureNumberingBuilder;
  fontWeight: (fontWeight: NormalBold) => IMeasureNumberingBuilder;
  fontStyle: (fontStyle: NormalItalic) => IMeasureNumberingBuilder;
  fontSize: (fontSize: string) => IMeasureNumberingBuilder;
  color: (color: string) => IMeasureNumberingBuilder;
  halign: (halign: LeftCenterRight) => IMeasureNumberingBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IMeasureNumberingBuilder;
}

class MeasureNumberingBuilder implements IMeasureNumberingBuilder {
  build: () => MeasureNumbering;
  patch: () => IAny[];
  data: (data: string) => IMeasureNumberingBuilder;
  defaultX: (defaultX: number) => IMeasureNumberingBuilder;
  relativeY: (relativeY: number) => IMeasureNumberingBuilder;
  defaultY: (defaultY: number) => IMeasureNumberingBuilder;
  relativeX: (relativeX: number) => IMeasureNumberingBuilder;
  fontFamily: (fontFamily: string) => IMeasureNumberingBuilder;
  fontWeight: (fontWeight: NormalBold) => IMeasureNumberingBuilder;
  fontStyle: (fontStyle: NormalItalic) => IMeasureNumberingBuilder;
  fontSize: (fontSize: string) => IMeasureNumberingBuilder;
  color: (color: string) => IMeasureNumberingBuilder;
  halign: (halign: LeftCenterRight) => IMeasureNumberingBuilder;
  valign: (valign: TopMiddleBottomBaseline) => IMeasureNumberingBuilder;
  constructor(original?: MeasureNumbering) {
    let updates: MeasureNumbering = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): MeasureNumbering => {
        checkInvariants();
        (updates as any)._class = "MeasureNumbering";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IMeasureNumberingBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IMeasureNumberingBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IMeasureNumberingBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IMeasureNumberingBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IMeasureNumberingBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IMeasureNumberingBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IMeasureNumberingBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IMeasureNumberingBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IMeasureNumberingBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IMeasureNumberingBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): IMeasureNumberingBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): IMeasureNumberingBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }
  }
}
export function patchMeasureNumbering(base: MeasureNumbering, builder: (build: IMeasureNumberingBuilder) => IMeasureNumberingBuilder): IAny[] { return builder(new MeasureNumberingBuilder(base)).patch(); }
export function buildMeasureNumbering(builder: (build: IMeasureNumberingBuilder) => IMeasureNumberingBuilder): MeasureNumbering { return builder(new MeasureNumberingBuilder()).build(); }

export interface ISoundBuilder {
  build?: () => Sound;
  patch: () => IAny[];
  softPedal: (softPedal: string) => ISoundBuilder;
  midiInstrumentsAt: (idx: number, build: MidiInstrument | ((builder: IMidiInstrumentBuilder) => IMidiInstrumentBuilder)) => ISoundBuilder;
  midiInstrumentsSplice: (start: number, deleteCount: number, ...items: MidiInstrument[]) => ISoundBuilder;
  midiInstruments: (midiInstruments: MidiInstrument[]) => ISoundBuilder;
  pan: (pan: string) => ISoundBuilder;
  tocoda: (tocoda: string) => ISoundBuilder;
  decapo: (decapo: boolean) => ISoundBuilder;
  divisions: (divisions: number) => ISoundBuilder;
  pizzicato: (pizzicato: boolean) => ISoundBuilder;
  coda: (coda: string) => ISoundBuilder;
  segno: (segno: string) => ISoundBuilder;
  elevation: (elevation: string) => ISoundBuilder;
  fine: (fine: string) => ISoundBuilder;
  damperPedal: (damperPedal: string) => ISoundBuilder;
  dynamics: (dynamics: string) => ISoundBuilder;
  playsAt: (idx: number, build: Play | ((builder: IPlayBuilder) => IPlayBuilder)) => ISoundBuilder;
  playsSplice: (start: number, deleteCount: number, ...items: Play[]) => ISoundBuilder;
  plays: (plays: Play[]) => ISoundBuilder;
  offset: (build: Offset | ((builder: IOffsetBuilder) => IOffsetBuilder)) => ISoundBuilder;
  sostenutoPedal: (sostenutoPedal: string) => ISoundBuilder;
  dalsegno: (dalsegno: string) => ISoundBuilder;
  midiDevicesAt: (idx: number, build: MidiDevice | ((builder: IMidiDeviceBuilder) => IMidiDeviceBuilder)) => ISoundBuilder;
  midiDevicesSplice: (start: number, deleteCount: number, ...items: MidiDevice[]) => ISoundBuilder;
  midiDevices: (midiDevices: MidiDevice[]) => ISoundBuilder;
  tempo: (tempo: string) => ISoundBuilder;
  forwardRepeat: (forwardRepeat: boolean) => ISoundBuilder;
  timeOnly: (timeOnly: string) => ISoundBuilder;
}

class SoundBuilder implements ISoundBuilder {
  build: () => Sound;
  patch: () => IAny[];
  softPedal: (softPedal: string) => ISoundBuilder;
  midiInstrumentsAt: (idx: number, build: MidiInstrument | ((builder: IMidiInstrumentBuilder) => IMidiInstrumentBuilder)) => ISoundBuilder;
  midiInstrumentsSplice: (start: number, deleteCount: number, ...items: MidiInstrument[]) => ISoundBuilder;
  midiInstruments: (midiInstruments: MidiInstrument[]) => ISoundBuilder;
  pan: (pan: string) => ISoundBuilder;
  tocoda: (tocoda: string) => ISoundBuilder;
  decapo: (decapo: boolean) => ISoundBuilder;
  divisions: (divisions: number) => ISoundBuilder;
  pizzicato: (pizzicato: boolean) => ISoundBuilder;
  coda: (coda: string) => ISoundBuilder;
  segno: (segno: string) => ISoundBuilder;
  elevation: (elevation: string) => ISoundBuilder;
  fine: (fine: string) => ISoundBuilder;
  damperPedal: (damperPedal: string) => ISoundBuilder;
  dynamics: (dynamics: string) => ISoundBuilder;
  playsAt: (idx: number, build: Play | ((builder: IPlayBuilder) => IPlayBuilder)) => ISoundBuilder;
  playsSplice: (start: number, deleteCount: number, ...items: Play[]) => ISoundBuilder;
  plays: (plays: Play[]) => ISoundBuilder;
  offset: (build: Offset | ((builder: IOffsetBuilder) => IOffsetBuilder)) => ISoundBuilder;
  sostenutoPedal: (sostenutoPedal: string) => ISoundBuilder;
  dalsegno: (dalsegno: string) => ISoundBuilder;
  midiDevicesAt: (idx: number, build: MidiDevice | ((builder: IMidiDeviceBuilder) => IMidiDeviceBuilder)) => ISoundBuilder;
  midiDevicesSplice: (start: number, deleteCount: number, ...items: MidiDevice[]) => ISoundBuilder;
  midiDevices: (midiDevices: MidiDevice[]) => ISoundBuilder;
  tempo: (tempo: string) => ISoundBuilder;
  forwardRepeat: (forwardRepeat: boolean) => ISoundBuilder;
  timeOnly: (timeOnly: string) => ISoundBuilder;
  constructor(original?: Sound) {
    let updates: Sound = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["softPedal"]) ||
          childBuilders["softPedal"] !== undefined ||
          updates.softPedal !== undefined,
        "softPedal is a required field");
      console.assert(
          (original && !modifiedKeys["midiInstruments"]) ||
          childBuilders["midiInstruments"] !== undefined ||
          updates.midiInstruments !== undefined,
        "midiInstruments is a required field");
      console.assert(
          (original && !modifiedKeys["pan"]) ||
          childBuilders["pan"] !== undefined ||
          updates.pan !== undefined,
        "pan is a required field");
      console.assert(
          (original && !modifiedKeys["tocoda"]) ||
          childBuilders["tocoda"] !== undefined ||
          updates.tocoda !== undefined,
        "tocoda is a required field");
      console.assert(
          (original && !modifiedKeys["decapo"]) ||
          childBuilders["decapo"] !== undefined ||
          updates.decapo !== undefined,
        "decapo is a required field");
      console.assert(
          (original && !modifiedKeys["divisions"]) ||
          childBuilders["divisions"] !== undefined ||
          updates.divisions !== undefined,
        "divisions is a required field");
      console.assert(
          (original && !modifiedKeys["pizzicato"]) ||
          childBuilders["pizzicato"] !== undefined ||
          updates.pizzicato !== undefined,
        "pizzicato is a required field");
      console.assert(
          (original && !modifiedKeys["coda"]) ||
          childBuilders["coda"] !== undefined ||
          updates.coda !== undefined,
        "coda is a required field");
      console.assert(
          (original && !modifiedKeys["segno"]) ||
          childBuilders["segno"] !== undefined ||
          updates.segno !== undefined,
        "segno is a required field");
      console.assert(
          (original && !modifiedKeys["elevation"]) ||
          childBuilders["elevation"] !== undefined ||
          updates.elevation !== undefined,
        "elevation is a required field");
      console.assert(
          (original && !modifiedKeys["fine"]) ||
          childBuilders["fine"] !== undefined ||
          updates.fine !== undefined,
        "fine is a required field");
      console.assert(
          (original && !modifiedKeys["damperPedal"]) ||
          childBuilders["damperPedal"] !== undefined ||
          updates.damperPedal !== undefined,
        "damperPedal is a required field");
      console.assert(
          (original && !modifiedKeys["dynamics"]) ||
          childBuilders["dynamics"] !== undefined ||
          updates.dynamics !== undefined,
        "dynamics is a required field");
      console.assert(
          (original && !modifiedKeys["plays"]) ||
          childBuilders["plays"] !== undefined ||
          updates.plays !== undefined,
        "plays is a required field");
      console.assert(
          (original && !modifiedKeys["offset"]) ||
          childBuilders["offset"] !== undefined ||
          updates.offset !== undefined,
        "offset is a required field");
      console.assert(
          (original && !modifiedKeys["sostenutoPedal"]) ||
          childBuilders["sostenutoPedal"] !== undefined ||
          updates.sostenutoPedal !== undefined,
        "sostenutoPedal is a required field");
      console.assert(
          (original && !modifiedKeys["dalsegno"]) ||
          childBuilders["dalsegno"] !== undefined ||
          updates.dalsegno !== undefined,
        "dalsegno is a required field");
      console.assert(
          (original && !modifiedKeys["midiDevices"]) ||
          childBuilders["midiDevices"] !== undefined ||
          updates.midiDevices !== undefined,
        "midiDevices is a required field");
      console.assert(
          (original && !modifiedKeys["tempo"]) ||
          childBuilders["tempo"] !== undefined ||
          updates.tempo !== undefined,
        "tempo is a required field");
      console.assert(
          (original && !modifiedKeys["forwardRepeat"]) ||
          childBuilders["forwardRepeat"] !== undefined ||
          updates.forwardRepeat !== undefined,
        "forwardRepeat is a required field");
    }

    if (!original) {
      this.build = (): Sound => {
        checkInvariants();
        (updates as any)._class = "Sound";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.softPedal = (spec: string): ISoundBuilder => {
        updates["softPedal"] = spec;
        delete childBuilders["softPedal;"];
        modifiedKeys["softPedal"] = true;
        return this;
    }

    this.midiInstruments = (spec: MidiInstrument[]): ISoundBuilder => {
        updates["midiInstruments"] = spec;
        delete childBuilders["midiInstruments;"];
        modifiedKeys["midiInstruments"] = true;
        return this;
    }

    this.midiInstrumentsAt = (idx: number, build: MidiInstrument | ((builder: IMidiInstrumentBuilder) => IMidiInstrumentBuilder)): ISoundBuilder => {
      makeReference("midiInstruments");
      if (frozen["midiInstruments"][idx]) {
          throw new Error("Patching midiInstruments." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["midiInstruments"] && !original["midiInstruments"]) {
          // Clone snapshot.
          patches.push({p: ["midiInstruments", idx], li: original._snapshot["midiInstruments"]});
      }
      if (typeof build === 'function' && reference["midiInstruments"][idx]) {
        let patch = (build as any)(new MidiInstrumentBuilder(reference["midiInstruments"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["midiInstruments", idx].concat(patch.p);
          return patch;
        }));
        frozen["midiInstruments"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new MidiInstrumentBuilder(reference["midiInstruments"][idx])).build() : build;
      if (original) {
        patches.push({p: ["midiInstruments", idx], li: update});
      } else {
        updates["midiInstruments"] = reference["midiInstruments"]; // TODO: Merge?
      } 
      reference["midiInstruments"][idx] = update;
      frozen["midiInstruments"][idx] = true;
      return this;
    }

    this.midiInstrumentsSplice = (start: number, deleteCount: number, ...items: MidiInstrument[]): ISoundBuilder => {
      makeReference("midiInstruments");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["midiInstruments"][idx]) {
            throw new Error("Replacing midiInstruments." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["midiInstruments"][idx];
          patches.push({p: ["midiInstruments", idx], ld, li: items[idx - start]});
          frozen["midiInstruments"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["midiInstruments"][idx]) {
            throw new Error("Removing midiInstruments." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["midiInstruments"][idx];
          patches.push({p: ["midiInstruments", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["midiInstruments", idx], li: items[idx - start]});
          frozen["midiInstruments"][idx] = true;
        }
      }
      reference["midiInstruments"].splice(start, deleteCount, ...items);
      updates["midiInstruments"] = reference["midiInstruments"];
      frozen["midiInstruments"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.pan = (spec: string): ISoundBuilder => {
        updates["pan"] = spec;
        delete childBuilders["pan;"];
        modifiedKeys["pan"] = true;
        return this;
    }

    this.tocoda = (spec: string): ISoundBuilder => {
        updates["tocoda"] = spec;
        delete childBuilders["tocoda;"];
        modifiedKeys["tocoda"] = true;
        return this;
    }

    this.decapo = (spec: boolean): ISoundBuilder => {
        updates["decapo"] = spec;
        delete childBuilders["decapo;"];
        modifiedKeys["decapo"] = true;
        return this;
    }

    this.divisions = (spec: number): ISoundBuilder => {
        updates["divisions"] = spec;
        delete childBuilders["divisions;"];
        modifiedKeys["divisions"] = true;
        return this;
    }

    this.pizzicato = (spec: boolean): ISoundBuilder => {
        updates["pizzicato"] = spec;
        delete childBuilders["pizzicato;"];
        modifiedKeys["pizzicato"] = true;
        return this;
    }

    this.coda = (spec: string): ISoundBuilder => {
        updates["coda"] = spec;
        delete childBuilders["coda;"];
        modifiedKeys["coda"] = true;
        return this;
    }

    this.segno = (spec: string): ISoundBuilder => {
        updates["segno"] = spec;
        delete childBuilders["segno;"];
        modifiedKeys["segno"] = true;
        return this;
    }

    this.elevation = (spec: string): ISoundBuilder => {
        updates["elevation"] = spec;
        delete childBuilders["elevation;"];
        modifiedKeys["elevation"] = true;
        return this;
    }

    this.fine = (spec: string): ISoundBuilder => {
        updates["fine"] = spec;
        delete childBuilders["fine;"];
        modifiedKeys["fine"] = true;
        return this;
    }

    this.damperPedal = (spec: string): ISoundBuilder => {
        updates["damperPedal"] = spec;
        delete childBuilders["damperPedal;"];
        modifiedKeys["damperPedal"] = true;
        return this;
    }

    this.dynamics = (spec: string): ISoundBuilder => {
        updates["dynamics"] = spec;
        delete childBuilders["dynamics;"];
        modifiedKeys["dynamics"] = true;
        return this;
    }

    this.plays = (spec: Play[]): ISoundBuilder => {
        updates["plays"] = spec;
        delete childBuilders["plays;"];
        modifiedKeys["plays"] = true;
        return this;
    }

    this.playsAt = (idx: number, build: Play | ((builder: IPlayBuilder) => IPlayBuilder)): ISoundBuilder => {
      makeReference("plays");
      if (frozen["plays"][idx]) {
          throw new Error("Patching plays." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["plays"] && !original["plays"]) {
          // Clone snapshot.
          patches.push({p: ["plays", idx], li: original._snapshot["plays"]});
      }
      if (typeof build === 'function' && reference["plays"][idx]) {
        let patch = (build as any)(new PlayBuilder(reference["plays"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["plays", idx].concat(patch.p);
          return patch;
        }));
        frozen["plays"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new PlayBuilder(reference["plays"][idx])).build() : build;
      if (original) {
        patches.push({p: ["plays", idx], li: update});
      } else {
        updates["plays"] = reference["plays"]; // TODO: Merge?
      } 
      reference["plays"][idx] = update;
      frozen["plays"][idx] = true;
      return this;
    }

    this.playsSplice = (start: number, deleteCount: number, ...items: Play[]): ISoundBuilder => {
      makeReference("plays");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["plays"][idx]) {
            throw new Error("Replacing plays." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["plays"][idx];
          patches.push({p: ["plays", idx], ld, li: items[idx - start]});
          frozen["plays"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["plays"][idx]) {
            throw new Error("Removing plays." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["plays"][idx];
          patches.push({p: ["plays", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["plays", idx], li: items[idx - start]});
          frozen["plays"][idx] = true;
        }
      }
      reference["plays"].splice(start, deleteCount, ...items);
      updates["plays"] = reference["plays"];
      frozen["plays"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.offset = (build: Offset | ((builder: IOffsetBuilder) => IOffsetBuilder)): ISoundBuilder => {
      if (typeof build === 'function') {
        delete updates["offset"]
        const builder = (build as any)(new OffsetBuilder(original && original["offset"]));
        if (!original) updates["offset"] = builder.build();
        else childBuilders["offset"] = builder;
      } else {
        updates.offset = build as any;
        delete childBuilders["offset;"];
      }
      modifiedKeys["offset"] = true;
      return this;
    }

    this.sostenutoPedal = (spec: string): ISoundBuilder => {
        updates["sostenutoPedal"] = spec;
        delete childBuilders["sostenutoPedal;"];
        modifiedKeys["sostenutoPedal"] = true;
        return this;
    }

    this.dalsegno = (spec: string): ISoundBuilder => {
        updates["dalsegno"] = spec;
        delete childBuilders["dalsegno;"];
        modifiedKeys["dalsegno"] = true;
        return this;
    }

    this.midiDevices = (spec: MidiDevice[]): ISoundBuilder => {
        updates["midiDevices"] = spec;
        delete childBuilders["midiDevices;"];
        modifiedKeys["midiDevices"] = true;
        return this;
    }

    this.midiDevicesAt = (idx: number, build: MidiDevice | ((builder: IMidiDeviceBuilder) => IMidiDeviceBuilder)): ISoundBuilder => {
      makeReference("midiDevices");
      if (frozen["midiDevices"][idx]) {
          throw new Error("Patching midiDevices." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["midiDevices"] && !original["midiDevices"]) {
          // Clone snapshot.
          patches.push({p: ["midiDevices", idx], li: original._snapshot["midiDevices"]});
      }
      if (typeof build === 'function' && reference["midiDevices"][idx]) {
        let patch = (build as any)(new MidiDeviceBuilder(reference["midiDevices"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["midiDevices", idx].concat(patch.p);
          return patch;
        }));
        frozen["midiDevices"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new MidiDeviceBuilder(reference["midiDevices"][idx])).build() : build;
      if (original) {
        patches.push({p: ["midiDevices", idx], li: update});
      } else {
        updates["midiDevices"] = reference["midiDevices"]; // TODO: Merge?
      } 
      reference["midiDevices"][idx] = update;
      frozen["midiDevices"][idx] = true;
      return this;
    }

    this.midiDevicesSplice = (start: number, deleteCount: number, ...items: MidiDevice[]): ISoundBuilder => {
      makeReference("midiDevices");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["midiDevices"][idx]) {
            throw new Error("Replacing midiDevices." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["midiDevices"][idx];
          patches.push({p: ["midiDevices", idx], ld, li: items[idx - start]});
          frozen["midiDevices"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["midiDevices"][idx]) {
            throw new Error("Removing midiDevices." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["midiDevices"][idx];
          patches.push({p: ["midiDevices", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["midiDevices", idx], li: items[idx - start]});
          frozen["midiDevices"][idx] = true;
        }
      }
      reference["midiDevices"].splice(start, deleteCount, ...items);
      updates["midiDevices"] = reference["midiDevices"];
      frozen["midiDevices"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.tempo = (spec: string): ISoundBuilder => {
        updates["tempo"] = spec;
        delete childBuilders["tempo;"];
        modifiedKeys["tempo"] = true;
        return this;
    }

    this.forwardRepeat = (spec: boolean): ISoundBuilder => {
        updates["forwardRepeat"] = spec;
        delete childBuilders["forwardRepeat;"];
        modifiedKeys["forwardRepeat"] = true;
        return this;
    }

    this.timeOnly = (spec: string): ISoundBuilder => {
        updates["timeOnly"] = spec;
        delete childBuilders["timeOnly;"];
        modifiedKeys["timeOnly"] = true;
        return this;
    }
  }
}
export function patchSound(base: Sound, builder: (build: ISoundBuilder) => ISoundBuilder): IAny[] { return builder(new SoundBuilder(base)).patch(); }
export function buildSound(builder: (build: ISoundBuilder) => ISoundBuilder): Sound { return builder(new SoundBuilder()).build(); }

export interface IWorkBuilder {
  build?: () => Work;
  patch: () => IAny[];
  workNumber: (workNumber: string) => IWorkBuilder;
  workTitle: (workTitle: string) => IWorkBuilder;
  opus: (build: Opus | ((builder: IOpusBuilder) => IOpusBuilder)) => IWorkBuilder;
}

class WorkBuilder implements IWorkBuilder {
  build: () => Work;
  patch: () => IAny[];
  workNumber: (workNumber: string) => IWorkBuilder;
  workTitle: (workTitle: string) => IWorkBuilder;
  opus: (build: Opus | ((builder: IOpusBuilder) => IOpusBuilder)) => IWorkBuilder;
  constructor(original?: Work) {
    let updates: Work = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["workNumber"]) ||
          childBuilders["workNumber"] !== undefined ||
          updates.workNumber !== undefined,
        "workNumber is a required field");
      console.assert(
          (original && !modifiedKeys["workTitle"]) ||
          childBuilders["workTitle"] !== undefined ||
          updates.workTitle !== undefined,
        "workTitle is a required field");
      console.assert(
          (original && !modifiedKeys["opus"]) ||
          childBuilders["opus"] !== undefined ||
          updates.opus !== undefined,
        "opus is a required field");
    }

    if (!original) {
      this.build = (): Work => {
        checkInvariants();
        (updates as any)._class = "Work";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.workNumber = (spec: string): IWorkBuilder => {
        updates["workNumber"] = spec;
        delete childBuilders["workNumber;"];
        modifiedKeys["workNumber"] = true;
        return this;
    }

    this.workTitle = (spec: string): IWorkBuilder => {
        updates["workTitle"] = spec;
        delete childBuilders["workTitle;"];
        modifiedKeys["workTitle"] = true;
        return this;
    }

    this.opus = (build: Opus | ((builder: IOpusBuilder) => IOpusBuilder)): IWorkBuilder => {
      if (typeof build === 'function') {
        delete updates["opus"]
        const builder = (build as any)(new OpusBuilder(original && original["opus"]));
        if (!original) updates["opus"] = builder.build();
        else childBuilders["opus"] = builder;
      } else {
        updates.opus = build as any;
        delete childBuilders["opus;"];
      }
      modifiedKeys["opus"] = true;
      return this;
    }
  }
}
export function patchWork(base: Work, builder: (build: IWorkBuilder) => IWorkBuilder): IAny[] { return builder(new WorkBuilder(base)).patch(); }
export function buildWork(builder: (build: IWorkBuilder) => IWorkBuilder): Work { return builder(new WorkBuilder()).build(); }

export interface IOpusBuilder {
  build?: () => Opus;
  patch: () => IAny[];
}

class OpusBuilder implements IOpusBuilder {
  build: () => Opus;
  patch: () => IAny[];
  constructor(original?: Opus) {
    let updates: Opus = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Opus => {
        checkInvariants();
        (updates as any)._class = "Opus";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchOpus(base: Opus, builder: (build: IOpusBuilder) => IOpusBuilder): IAny[] { return builder(new OpusBuilder(base)).patch(); }
export function buildOpus(builder: (build: IOpusBuilder) => IOpusBuilder): Opus { return builder(new OpusBuilder()).build(); }

export interface IDefaultsBuilder {
  build?: () => Defaults;
  patch: () => IAny[];
  wordFont: (build: WordFont | ((builder: IWordFontBuilder) => IWordFontBuilder)) => IDefaultsBuilder;
  lyricLanguagesAt: (idx: number, build: LyricLanguage | ((builder: ILyricLanguageBuilder) => ILyricLanguageBuilder)) => IDefaultsBuilder;
  lyricLanguagesSplice: (start: number, deleteCount: number, ...items: LyricLanguage[]) => IDefaultsBuilder;
  lyricLanguages: (lyricLanguages: LyricLanguage[]) => IDefaultsBuilder;
  lyricFontsAt: (idx: number, build: LyricFont | ((builder: ILyricFontBuilder) => ILyricFontBuilder)) => IDefaultsBuilder;
  lyricFontsSplice: (start: number, deleteCount: number, ...items: LyricFont[]) => IDefaultsBuilder;
  lyricFonts: (lyricFonts: LyricFont[]) => IDefaultsBuilder;
  pageLayout: (build: PageLayout | ((builder: IPageLayoutBuilder) => IPageLayoutBuilder)) => IDefaultsBuilder;
  systemLayout: (build: SystemLayout | ((builder: ISystemLayoutBuilder) => ISystemLayoutBuilder)) => IDefaultsBuilder;
  appearance: (build: Appearance | ((builder: IAppearanceBuilder) => IAppearanceBuilder)) => IDefaultsBuilder;
  scaling: (build: Scaling | ((builder: IScalingBuilder) => IScalingBuilder)) => IDefaultsBuilder;
  staffLayoutsAt: (idx: number, build: StaffLayout | ((builder: IStaffLayoutBuilder) => IStaffLayoutBuilder)) => IDefaultsBuilder;
  staffLayoutsSplice: (start: number, deleteCount: number, ...items: StaffLayout[]) => IDefaultsBuilder;
  staffLayouts: (staffLayouts: StaffLayout[]) => IDefaultsBuilder;
  musicFont: (build: MusicFont | ((builder: IMusicFontBuilder) => IMusicFontBuilder)) => IDefaultsBuilder;
}

class DefaultsBuilder implements IDefaultsBuilder {
  build: () => Defaults;
  patch: () => IAny[];
  wordFont: (build: WordFont | ((builder: IWordFontBuilder) => IWordFontBuilder)) => IDefaultsBuilder;
  lyricLanguagesAt: (idx: number, build: LyricLanguage | ((builder: ILyricLanguageBuilder) => ILyricLanguageBuilder)) => IDefaultsBuilder;
  lyricLanguagesSplice: (start: number, deleteCount: number, ...items: LyricLanguage[]) => IDefaultsBuilder;
  lyricLanguages: (lyricLanguages: LyricLanguage[]) => IDefaultsBuilder;
  lyricFontsAt: (idx: number, build: LyricFont | ((builder: ILyricFontBuilder) => ILyricFontBuilder)) => IDefaultsBuilder;
  lyricFontsSplice: (start: number, deleteCount: number, ...items: LyricFont[]) => IDefaultsBuilder;
  lyricFonts: (lyricFonts: LyricFont[]) => IDefaultsBuilder;
  pageLayout: (build: PageLayout | ((builder: IPageLayoutBuilder) => IPageLayoutBuilder)) => IDefaultsBuilder;
  systemLayout: (build: SystemLayout | ((builder: ISystemLayoutBuilder) => ISystemLayoutBuilder)) => IDefaultsBuilder;
  appearance: (build: Appearance | ((builder: IAppearanceBuilder) => IAppearanceBuilder)) => IDefaultsBuilder;
  scaling: (build: Scaling | ((builder: IScalingBuilder) => IScalingBuilder)) => IDefaultsBuilder;
  staffLayoutsAt: (idx: number, build: StaffLayout | ((builder: IStaffLayoutBuilder) => IStaffLayoutBuilder)) => IDefaultsBuilder;
  staffLayoutsSplice: (start: number, deleteCount: number, ...items: StaffLayout[]) => IDefaultsBuilder;
  staffLayouts: (staffLayouts: StaffLayout[]) => IDefaultsBuilder;
  musicFont: (build: MusicFont | ((builder: IMusicFontBuilder) => IMusicFontBuilder)) => IDefaultsBuilder;
  constructor(original?: Defaults) {
    let updates: Defaults = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["wordFont"]) ||
          childBuilders["wordFont"] !== undefined ||
          updates.wordFont !== undefined,
        "wordFont is a required field");
      console.assert(
          (original && !modifiedKeys["lyricLanguages"]) ||
          childBuilders["lyricLanguages"] !== undefined ||
          updates.lyricLanguages !== undefined,
        "lyricLanguages is a required field");
      console.assert(
          (original && !modifiedKeys["lyricFonts"]) ||
          childBuilders["lyricFonts"] !== undefined ||
          updates.lyricFonts !== undefined,
        "lyricFonts is a required field");
      console.assert(
          (original && !modifiedKeys["pageLayout"]) ||
          childBuilders["pageLayout"] !== undefined ||
          updates.pageLayout !== undefined,
        "pageLayout is a required field");
      console.assert(
          (original && !modifiedKeys["systemLayout"]) ||
          childBuilders["systemLayout"] !== undefined ||
          updates.systemLayout !== undefined,
        "systemLayout is a required field");
      console.assert(
          (original && !modifiedKeys["appearance"]) ||
          childBuilders["appearance"] !== undefined ||
          updates.appearance !== undefined,
        "appearance is a required field");
      console.assert(
          (original && !modifiedKeys["scaling"]) ||
          childBuilders["scaling"] !== undefined ||
          updates.scaling !== undefined,
        "scaling is a required field");
      console.assert(
          (original && !modifiedKeys["staffLayouts"]) ||
          childBuilders["staffLayouts"] !== undefined ||
          updates.staffLayouts !== undefined,
        "staffLayouts is a required field");
      console.assert(
          (original && !modifiedKeys["musicFont"]) ||
          childBuilders["musicFont"] !== undefined ||
          updates.musicFont !== undefined,
        "musicFont is a required field");
    }

    if (!original) {
      this.build = (): Defaults => {
        checkInvariants();
        (updates as any)._class = "Defaults";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.wordFont = (build: WordFont | ((builder: IWordFontBuilder) => IWordFontBuilder)): IDefaultsBuilder => {
      if (typeof build === 'function') {
        delete updates["wordFont"]
        const builder = (build as any)(new WordFontBuilder(original && original["wordFont"]));
        if (!original) updates["wordFont"] = builder.build();
        else childBuilders["wordFont"] = builder;
      } else {
        updates.wordFont = build as any;
        delete childBuilders["wordFont;"];
      }
      modifiedKeys["wordFont"] = true;
      return this;
    }

    this.lyricLanguages = (spec: LyricLanguage[]): IDefaultsBuilder => {
        updates["lyricLanguages"] = spec;
        delete childBuilders["lyricLanguages;"];
        modifiedKeys["lyricLanguages"] = true;
        return this;
    }

    this.lyricLanguagesAt = (idx: number, build: LyricLanguage | ((builder: ILyricLanguageBuilder) => ILyricLanguageBuilder)): IDefaultsBuilder => {
      makeReference("lyricLanguages");
      if (frozen["lyricLanguages"][idx]) {
          throw new Error("Patching lyricLanguages." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["lyricLanguages"] && !original["lyricLanguages"]) {
          // Clone snapshot.
          patches.push({p: ["lyricLanguages", idx], li: original._snapshot["lyricLanguages"]});
      }
      if (typeof build === 'function' && reference["lyricLanguages"][idx]) {
        let patch = (build as any)(new LyricLanguageBuilder(reference["lyricLanguages"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["lyricLanguages", idx].concat(patch.p);
          return patch;
        }));
        frozen["lyricLanguages"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new LyricLanguageBuilder(reference["lyricLanguages"][idx])).build() : build;
      if (original) {
        patches.push({p: ["lyricLanguages", idx], li: update});
      } else {
        updates["lyricLanguages"] = reference["lyricLanguages"]; // TODO: Merge?
      } 
      reference["lyricLanguages"][idx] = update;
      frozen["lyricLanguages"][idx] = true;
      return this;
    }

    this.lyricLanguagesSplice = (start: number, deleteCount: number, ...items: LyricLanguage[]): IDefaultsBuilder => {
      makeReference("lyricLanguages");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["lyricLanguages"][idx]) {
            throw new Error("Replacing lyricLanguages." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["lyricLanguages"][idx];
          patches.push({p: ["lyricLanguages", idx], ld, li: items[idx - start]});
          frozen["lyricLanguages"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["lyricLanguages"][idx]) {
            throw new Error("Removing lyricLanguages." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["lyricLanguages"][idx];
          patches.push({p: ["lyricLanguages", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["lyricLanguages", idx], li: items[idx - start]});
          frozen["lyricLanguages"][idx] = true;
        }
      }
      reference["lyricLanguages"].splice(start, deleteCount, ...items);
      updates["lyricLanguages"] = reference["lyricLanguages"];
      frozen["lyricLanguages"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.lyricFonts = (spec: LyricFont[]): IDefaultsBuilder => {
        updates["lyricFonts"] = spec;
        delete childBuilders["lyricFonts;"];
        modifiedKeys["lyricFonts"] = true;
        return this;
    }

    this.lyricFontsAt = (idx: number, build: LyricFont | ((builder: ILyricFontBuilder) => ILyricFontBuilder)): IDefaultsBuilder => {
      makeReference("lyricFonts");
      if (frozen["lyricFonts"][idx]) {
          throw new Error("Patching lyricFonts." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["lyricFonts"] && !original["lyricFonts"]) {
          // Clone snapshot.
          patches.push({p: ["lyricFonts", idx], li: original._snapshot["lyricFonts"]});
      }
      if (typeof build === 'function' && reference["lyricFonts"][idx]) {
        let patch = (build as any)(new LyricFontBuilder(reference["lyricFonts"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["lyricFonts", idx].concat(patch.p);
          return patch;
        }));
        frozen["lyricFonts"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new LyricFontBuilder(reference["lyricFonts"][idx])).build() : build;
      if (original) {
        patches.push({p: ["lyricFonts", idx], li: update});
      } else {
        updates["lyricFonts"] = reference["lyricFonts"]; // TODO: Merge?
      } 
      reference["lyricFonts"][idx] = update;
      frozen["lyricFonts"][idx] = true;
      return this;
    }

    this.lyricFontsSplice = (start: number, deleteCount: number, ...items: LyricFont[]): IDefaultsBuilder => {
      makeReference("lyricFonts");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["lyricFonts"][idx]) {
            throw new Error("Replacing lyricFonts." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["lyricFonts"][idx];
          patches.push({p: ["lyricFonts", idx], ld, li: items[idx - start]});
          frozen["lyricFonts"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["lyricFonts"][idx]) {
            throw new Error("Removing lyricFonts." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["lyricFonts"][idx];
          patches.push({p: ["lyricFonts", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["lyricFonts", idx], li: items[idx - start]});
          frozen["lyricFonts"][idx] = true;
        }
      }
      reference["lyricFonts"].splice(start, deleteCount, ...items);
      updates["lyricFonts"] = reference["lyricFonts"];
      frozen["lyricFonts"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.pageLayout = (build: PageLayout | ((builder: IPageLayoutBuilder) => IPageLayoutBuilder)): IDefaultsBuilder => {
      if (typeof build === 'function') {
        delete updates["pageLayout"]
        const builder = (build as any)(new PageLayoutBuilder(original && original["pageLayout"]));
        if (!original) updates["pageLayout"] = builder.build();
        else childBuilders["pageLayout"] = builder;
      } else {
        updates.pageLayout = build as any;
        delete childBuilders["pageLayout;"];
      }
      modifiedKeys["pageLayout"] = true;
      return this;
    }

    this.systemLayout = (build: SystemLayout | ((builder: ISystemLayoutBuilder) => ISystemLayoutBuilder)): IDefaultsBuilder => {
      if (typeof build === 'function') {
        delete updates["systemLayout"]
        const builder = (build as any)(new SystemLayoutBuilder(original && original["systemLayout"]));
        if (!original) updates["systemLayout"] = builder.build();
        else childBuilders["systemLayout"] = builder;
      } else {
        updates.systemLayout = build as any;
        delete childBuilders["systemLayout;"];
      }
      modifiedKeys["systemLayout"] = true;
      return this;
    }

    this.appearance = (build: Appearance | ((builder: IAppearanceBuilder) => IAppearanceBuilder)): IDefaultsBuilder => {
      if (typeof build === 'function') {
        delete updates["appearance"]
        const builder = (build as any)(new AppearanceBuilder(original && original["appearance"]));
        if (!original) updates["appearance"] = builder.build();
        else childBuilders["appearance"] = builder;
      } else {
        updates.appearance = build as any;
        delete childBuilders["appearance;"];
      }
      modifiedKeys["appearance"] = true;
      return this;
    }

    this.scaling = (build: Scaling | ((builder: IScalingBuilder) => IScalingBuilder)): IDefaultsBuilder => {
      if (typeof build === 'function') {
        delete updates["scaling"]
        const builder = (build as any)(new ScalingBuilder(original && original["scaling"]));
        if (!original) updates["scaling"] = builder.build();
        else childBuilders["scaling"] = builder;
      } else {
        updates.scaling = build as any;
        delete childBuilders["scaling;"];
      }
      modifiedKeys["scaling"] = true;
      return this;
    }

    this.staffLayouts = (spec: StaffLayout[]): IDefaultsBuilder => {
        updates["staffLayouts"] = spec;
        delete childBuilders["staffLayouts;"];
        modifiedKeys["staffLayouts"] = true;
        return this;
    }

    this.staffLayoutsAt = (idx: number, build: StaffLayout | ((builder: IStaffLayoutBuilder) => IStaffLayoutBuilder)): IDefaultsBuilder => {
      makeReference("staffLayouts");
      if (frozen["staffLayouts"][idx]) {
          throw new Error("Patching staffLayouts." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["staffLayouts"] && !original["staffLayouts"]) {
          // Clone snapshot.
          patches.push({p: ["staffLayouts", idx], li: original._snapshot["staffLayouts"]});
      }
      if (typeof build === 'function' && reference["staffLayouts"][idx]) {
        let patch = (build as any)(new StaffLayoutBuilder(reference["staffLayouts"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["staffLayouts", idx].concat(patch.p);
          return patch;
        }));
        frozen["staffLayouts"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new StaffLayoutBuilder(reference["staffLayouts"][idx])).build() : build;
      if (original) {
        patches.push({p: ["staffLayouts", idx], li: update});
      } else {
        updates["staffLayouts"] = reference["staffLayouts"]; // TODO: Merge?
      } 
      reference["staffLayouts"][idx] = update;
      frozen["staffLayouts"][idx] = true;
      return this;
    }

    this.staffLayoutsSplice = (start: number, deleteCount: number, ...items: StaffLayout[]): IDefaultsBuilder => {
      makeReference("staffLayouts");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["staffLayouts"][idx]) {
            throw new Error("Replacing staffLayouts." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["staffLayouts"][idx];
          patches.push({p: ["staffLayouts", idx], ld, li: items[idx - start]});
          frozen["staffLayouts"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["staffLayouts"][idx]) {
            throw new Error("Removing staffLayouts." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["staffLayouts"][idx];
          patches.push({p: ["staffLayouts", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["staffLayouts", idx], li: items[idx - start]});
          frozen["staffLayouts"][idx] = true;
        }
      }
      reference["staffLayouts"].splice(start, deleteCount, ...items);
      updates["staffLayouts"] = reference["staffLayouts"];
      frozen["staffLayouts"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.musicFont = (build: MusicFont | ((builder: IMusicFontBuilder) => IMusicFontBuilder)): IDefaultsBuilder => {
      if (typeof build === 'function') {
        delete updates["musicFont"]
        const builder = (build as any)(new MusicFontBuilder(original && original["musicFont"]));
        if (!original) updates["musicFont"] = builder.build();
        else childBuilders["musicFont"] = builder;
      } else {
        updates.musicFont = build as any;
        delete childBuilders["musicFont;"];
      }
      modifiedKeys["musicFont"] = true;
      return this;
    }
  }
}
export function patchDefaults(base: Defaults, builder: (build: IDefaultsBuilder) => IDefaultsBuilder): IAny[] { return builder(new DefaultsBuilder(base)).patch(); }
export function buildDefaults(builder: (build: IDefaultsBuilder) => IDefaultsBuilder): Defaults { return builder(new DefaultsBuilder()).build(); }

export interface IMusicFontBuilder {
  build?: () => MusicFont;
  patch: () => IAny[];
  fontFamily: (fontFamily: string) => IMusicFontBuilder;
  fontWeight: (fontWeight: NormalBold) => IMusicFontBuilder;
  fontStyle: (fontStyle: NormalItalic) => IMusicFontBuilder;
  fontSize: (fontSize: string) => IMusicFontBuilder;
}

class MusicFontBuilder implements IMusicFontBuilder {
  build: () => MusicFont;
  patch: () => IAny[];
  fontFamily: (fontFamily: string) => IMusicFontBuilder;
  fontWeight: (fontWeight: NormalBold) => IMusicFontBuilder;
  fontStyle: (fontStyle: NormalItalic) => IMusicFontBuilder;
  fontSize: (fontSize: string) => IMusicFontBuilder;
  constructor(original?: MusicFont) {
    let updates: MusicFont = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): MusicFont => {
        checkInvariants();
        (updates as any)._class = "MusicFont";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.fontFamily = (spec: string): IMusicFontBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IMusicFontBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IMusicFontBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IMusicFontBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }
  }
}
export function patchMusicFont(base: MusicFont, builder: (build: IMusicFontBuilder) => IMusicFontBuilder): IAny[] { return builder(new MusicFontBuilder(base)).patch(); }
export function buildMusicFont(builder: (build: IMusicFontBuilder) => IMusicFontBuilder): MusicFont { return builder(new MusicFontBuilder()).build(); }

export interface IWordFontBuilder {
  build?: () => WordFont;
  patch: () => IAny[];
  fontFamily: (fontFamily: string) => IWordFontBuilder;
  fontWeight: (fontWeight: NormalBold) => IWordFontBuilder;
  fontStyle: (fontStyle: NormalItalic) => IWordFontBuilder;
  fontSize: (fontSize: string) => IWordFontBuilder;
}

class WordFontBuilder implements IWordFontBuilder {
  build: () => WordFont;
  patch: () => IAny[];
  fontFamily: (fontFamily: string) => IWordFontBuilder;
  fontWeight: (fontWeight: NormalBold) => IWordFontBuilder;
  fontStyle: (fontStyle: NormalItalic) => IWordFontBuilder;
  fontSize: (fontSize: string) => IWordFontBuilder;
  constructor(original?: WordFont) {
    let updates: WordFont = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): WordFont => {
        checkInvariants();
        (updates as any)._class = "WordFont";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.fontFamily = (spec: string): IWordFontBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IWordFontBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IWordFontBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IWordFontBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }
  }
}
export function patchWordFont(base: WordFont, builder: (build: IWordFontBuilder) => IWordFontBuilder): IAny[] { return builder(new WordFontBuilder(base)).patch(); }
export function buildWordFont(builder: (build: IWordFontBuilder) => IWordFontBuilder): WordFont { return builder(new WordFontBuilder()).build(); }

export interface ILyricFontBuilder {
  build?: () => LyricFont;
  patch: () => IAny[];
  number: (number: number) => ILyricFontBuilder;
  name: (name: string) => ILyricFontBuilder;
  fontFamily: (fontFamily: string) => ILyricFontBuilder;
  fontWeight: (fontWeight: NormalBold) => ILyricFontBuilder;
  fontStyle: (fontStyle: NormalItalic) => ILyricFontBuilder;
  fontSize: (fontSize: string) => ILyricFontBuilder;
}

class LyricFontBuilder implements ILyricFontBuilder {
  build: () => LyricFont;
  patch: () => IAny[];
  number: (number: number) => ILyricFontBuilder;
  name: (name: string) => ILyricFontBuilder;
  fontFamily: (fontFamily: string) => ILyricFontBuilder;
  fontWeight: (fontWeight: NormalBold) => ILyricFontBuilder;
  fontStyle: (fontStyle: NormalItalic) => ILyricFontBuilder;
  fontSize: (fontSize: string) => ILyricFontBuilder;
  constructor(original?: LyricFont) {
    let updates: LyricFont = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["number"]) ||
          childBuilders["number"] !== undefined ||
          updates.number !== undefined,
        "number is a required field");
      console.assert(
          (original && !modifiedKeys["name"]) ||
          childBuilders["name"] !== undefined ||
          updates.name !== undefined,
        "name is a required field");
    }

    if (!original) {
      this.build = (): LyricFont => {
        checkInvariants();
        (updates as any)._class = "LyricFont";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: number): ILyricFontBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.name = (spec: string): ILyricFontBuilder => {
        updates["name"] = spec;
        delete childBuilders["name;"];
        modifiedKeys["name"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ILyricFontBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ILyricFontBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ILyricFontBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ILyricFontBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }
  }
}
export function patchLyricFont(base: LyricFont, builder: (build: ILyricFontBuilder) => ILyricFontBuilder): IAny[] { return builder(new LyricFontBuilder(base)).patch(); }
export function buildLyricFont(builder: (build: ILyricFontBuilder) => ILyricFontBuilder): LyricFont { return builder(new LyricFontBuilder()).build(); }

export interface ILyricLanguageBuilder {
  build?: () => LyricLanguage;
  patch: () => IAny[];
  number: (number: number) => ILyricLanguageBuilder;
  name: (name: string) => ILyricLanguageBuilder;
}

class LyricLanguageBuilder implements ILyricLanguageBuilder {
  build: () => LyricLanguage;
  patch: () => IAny[];
  number: (number: number) => ILyricLanguageBuilder;
  name: (name: string) => ILyricLanguageBuilder;
  constructor(original?: LyricLanguage) {
    let updates: LyricLanguage = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["number"]) ||
          childBuilders["number"] !== undefined ||
          updates.number !== undefined,
        "number is a required field");
      console.assert(
          (original && !modifiedKeys["name"]) ||
          childBuilders["name"] !== undefined ||
          updates.name !== undefined,
        "name is a required field");
    }

    if (!original) {
      this.build = (): LyricLanguage => {
        checkInvariants();
        (updates as any)._class = "LyricLanguage";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: number): ILyricLanguageBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.name = (spec: string): ILyricLanguageBuilder => {
        updates["name"] = spec;
        delete childBuilders["name;"];
        modifiedKeys["name"] = true;
        return this;
    }
  }
}
export function patchLyricLanguage(base: LyricLanguage, builder: (build: ILyricLanguageBuilder) => ILyricLanguageBuilder): IAny[] { return builder(new LyricLanguageBuilder(base)).patch(); }
export function buildLyricLanguage(builder: (build: ILyricLanguageBuilder) => ILyricLanguageBuilder): LyricLanguage { return builder(new LyricLanguageBuilder()).build(); }

export interface ICreditBuilder {
  build?: () => Credit;
  patch: () => IAny[];
  creditTypes: (creditTypes: string[]) => ICreditBuilder;
  creditWordsAt: (idx: number, build: CreditWords | ((builder: ICreditWordsBuilder) => ICreditWordsBuilder)) => ICreditBuilder;
  creditWordsSplice: (start: number, deleteCount: number, ...items: CreditWords[]) => ICreditBuilder;
  creditWords: (creditWords: CreditWords[]) => ICreditBuilder;
  creditImage: (build: CreditImage | ((builder: ICreditImageBuilder) => ICreditImageBuilder)) => ICreditBuilder;
  page: (page: number) => ICreditBuilder;
}

class CreditBuilder implements ICreditBuilder {
  build: () => Credit;
  patch: () => IAny[];
  creditTypes: (creditTypes: string[]) => ICreditBuilder;
  creditWordsAt: (idx: number, build: CreditWords | ((builder: ICreditWordsBuilder) => ICreditWordsBuilder)) => ICreditBuilder;
  creditWordsSplice: (start: number, deleteCount: number, ...items: CreditWords[]) => ICreditBuilder;
  creditWords: (creditWords: CreditWords[]) => ICreditBuilder;
  creditImage: (build: CreditImage | ((builder: ICreditImageBuilder) => ICreditImageBuilder)) => ICreditBuilder;
  page: (page: number) => ICreditBuilder;
  constructor(original?: Credit) {
    let updates: Credit = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["creditTypes"]) ||
          childBuilders["creditTypes"] !== undefined ||
          updates.creditTypes !== undefined,
        "creditTypes is a required field");
      console.assert(
          (original && !modifiedKeys["creditWords"]) ||
          childBuilders["creditWords"] !== undefined ||
          updates.creditWords !== undefined,
        "creditWords is a required field");
      console.assert(
          (original && !modifiedKeys["creditImage"]) ||
          childBuilders["creditImage"] !== undefined ||
          updates.creditImage !== undefined,
        "creditImage is a required field");
      console.assert(
          (original && !modifiedKeys["page"]) ||
          childBuilders["page"] !== undefined ||
          updates.page !== undefined,
        "page is a required field");
    }

    if (!original) {
      this.build = (): Credit => {
        checkInvariants();
        (updates as any)._class = "Credit";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.creditTypes = (spec: string[]): ICreditBuilder => {
        updates["creditTypes"] = spec;
        delete childBuilders["creditTypes;"];
        modifiedKeys["creditTypes"] = true;
        return this;
    }

    this.creditWords = (spec: CreditWords[]): ICreditBuilder => {
        updates["creditWords"] = spec;
        delete childBuilders["creditWords;"];
        modifiedKeys["creditWords"] = true;
        return this;
    }

    this.creditWordsAt = (idx: number, build: CreditWords | ((builder: ICreditWordsBuilder) => ICreditWordsBuilder)): ICreditBuilder => {
      makeReference("creditWords");
      if (frozen["creditWords"][idx]) {
          throw new Error("Patching creditWords." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["creditWords"] && !original["creditWords"]) {
          // Clone snapshot.
          patches.push({p: ["creditWords", idx], li: original._snapshot["creditWords"]});
      }
      if (typeof build === 'function' && reference["creditWords"][idx]) {
        let patch = (build as any)(new CreditWordsBuilder(reference["creditWords"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["creditWords", idx].concat(patch.p);
          return patch;
        }));
        frozen["creditWords"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new CreditWordsBuilder(reference["creditWords"][idx])).build() : build;
      if (original) {
        patches.push({p: ["creditWords", idx], li: update});
      } else {
        updates["creditWords"] = reference["creditWords"]; // TODO: Merge?
      } 
      reference["creditWords"][idx] = update;
      frozen["creditWords"][idx] = true;
      return this;
    }

    this.creditWordsSplice = (start: number, deleteCount: number, ...items: CreditWords[]): ICreditBuilder => {
      makeReference("creditWords");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["creditWords"][idx]) {
            throw new Error("Replacing creditWords." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["creditWords"][idx];
          patches.push({p: ["creditWords", idx], ld, li: items[idx - start]});
          frozen["creditWords"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["creditWords"][idx]) {
            throw new Error("Removing creditWords." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["creditWords"][idx];
          patches.push({p: ["creditWords", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["creditWords", idx], li: items[idx - start]});
          frozen["creditWords"][idx] = true;
        }
      }
      reference["creditWords"].splice(start, deleteCount, ...items);
      updates["creditWords"] = reference["creditWords"];
      frozen["creditWords"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.creditImage = (build: CreditImage | ((builder: ICreditImageBuilder) => ICreditImageBuilder)): ICreditBuilder => {
      if (typeof build === 'function') {
        delete updates["creditImage"]
        const builder = (build as any)(new CreditImageBuilder(original && original["creditImage"]));
        if (!original) updates["creditImage"] = builder.build();
        else childBuilders["creditImage"] = builder;
      } else {
        updates.creditImage = build as any;
        delete childBuilders["creditImage;"];
      }
      modifiedKeys["creditImage"] = true;
      return this;
    }

    this.page = (spec: number): ICreditBuilder => {
        updates["page"] = spec;
        delete childBuilders["page;"];
        modifiedKeys["page"] = true;
        return this;
    }
  }
}
export function patchCredit(base: Credit, builder: (build: ICreditBuilder) => ICreditBuilder): IAny[] { return builder(new CreditBuilder(base)).patch(); }
export function buildCredit(builder: (build: ICreditBuilder) => ICreditBuilder): Credit { return builder(new CreditBuilder()).build(); }

export interface ICreditWordsBuilder {
  build?: () => CreditWords;
  patch: () => IAny[];
  words: (words: string) => ICreditWordsBuilder;
  justify: (justify: LeftCenterRight) => ICreditWordsBuilder;
  defaultX: (defaultX: number) => ICreditWordsBuilder;
  relativeY: (relativeY: number) => ICreditWordsBuilder;
  defaultY: (defaultY: number) => ICreditWordsBuilder;
  relativeX: (relativeX: number) => ICreditWordsBuilder;
  fontFamily: (fontFamily: string) => ICreditWordsBuilder;
  fontWeight: (fontWeight: NormalBold) => ICreditWordsBuilder;
  fontStyle: (fontStyle: NormalItalic) => ICreditWordsBuilder;
  fontSize: (fontSize: string) => ICreditWordsBuilder;
  color: (color: string) => ICreditWordsBuilder;
  halign: (halign: LeftCenterRight) => ICreditWordsBuilder;
  valign: (valign: TopMiddleBottomBaseline) => ICreditWordsBuilder;
  underline: (underline: number) => ICreditWordsBuilder;
  overline: (overline: number) => ICreditWordsBuilder;
  lineThrough: (lineThrough: number) => ICreditWordsBuilder;
  rotation: (rotation: number) => ICreditWordsBuilder;
  letterSpacing: (letterSpacing: string) => ICreditWordsBuilder;
  lineHeight: (lineHeight: string) => ICreditWordsBuilder;
  dir: (dir: DirectionMode) => ICreditWordsBuilder;
  enclosure: (enclosure: EnclosureShape) => ICreditWordsBuilder;
}

class CreditWordsBuilder implements ICreditWordsBuilder {
  build: () => CreditWords;
  patch: () => IAny[];
  words: (words: string) => ICreditWordsBuilder;
  justify: (justify: LeftCenterRight) => ICreditWordsBuilder;
  defaultX: (defaultX: number) => ICreditWordsBuilder;
  relativeY: (relativeY: number) => ICreditWordsBuilder;
  defaultY: (defaultY: number) => ICreditWordsBuilder;
  relativeX: (relativeX: number) => ICreditWordsBuilder;
  fontFamily: (fontFamily: string) => ICreditWordsBuilder;
  fontWeight: (fontWeight: NormalBold) => ICreditWordsBuilder;
  fontStyle: (fontStyle: NormalItalic) => ICreditWordsBuilder;
  fontSize: (fontSize: string) => ICreditWordsBuilder;
  color: (color: string) => ICreditWordsBuilder;
  halign: (halign: LeftCenterRight) => ICreditWordsBuilder;
  valign: (valign: TopMiddleBottomBaseline) => ICreditWordsBuilder;
  underline: (underline: number) => ICreditWordsBuilder;
  overline: (overline: number) => ICreditWordsBuilder;
  lineThrough: (lineThrough: number) => ICreditWordsBuilder;
  rotation: (rotation: number) => ICreditWordsBuilder;
  letterSpacing: (letterSpacing: string) => ICreditWordsBuilder;
  lineHeight: (lineHeight: string) => ICreditWordsBuilder;
  dir: (dir: DirectionMode) => ICreditWordsBuilder;
  enclosure: (enclosure: EnclosureShape) => ICreditWordsBuilder;
  constructor(original?: CreditWords) {
    let updates: CreditWords = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["words"]) ||
          childBuilders["words"] !== undefined ||
          updates.words !== undefined,
        "words is a required field");
    }

    if (!original) {
      this.build = (): CreditWords => {
        checkInvariants();
        (updates as any)._class = "CreditWords";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.words = (spec: string): ICreditWordsBuilder => {
        updates["words"] = spec;
        delete childBuilders["words;"];
        modifiedKeys["words"] = true;
        return this;
    }

    this.justify = (spec: LeftCenterRight): ICreditWordsBuilder => {
        updates["justify"] = spec;
        delete childBuilders["justify;"];
        modifiedKeys["justify"] = true;
        return this;
    }

    this.defaultX = (spec: number): ICreditWordsBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ICreditWordsBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ICreditWordsBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ICreditWordsBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): ICreditWordsBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): ICreditWordsBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): ICreditWordsBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): ICreditWordsBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): ICreditWordsBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): ICreditWordsBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valign = (spec: TopMiddleBottomBaseline): ICreditWordsBuilder => {
        updates["valign"] = spec;
        delete childBuilders["valign;"];
        modifiedKeys["valign"] = true;
        return this;
    }

    this.underline = (spec: number): ICreditWordsBuilder => {
        updates["underline"] = spec;
        delete childBuilders["underline;"];
        modifiedKeys["underline"] = true;
        return this;
    }

    this.overline = (spec: number): ICreditWordsBuilder => {
        updates["overline"] = spec;
        delete childBuilders["overline;"];
        modifiedKeys["overline"] = true;
        return this;
    }

    this.lineThrough = (spec: number): ICreditWordsBuilder => {
        updates["lineThrough"] = spec;
        delete childBuilders["lineThrough;"];
        modifiedKeys["lineThrough"] = true;
        return this;
    }

    this.rotation = (spec: number): ICreditWordsBuilder => {
        updates["rotation"] = spec;
        delete childBuilders["rotation;"];
        modifiedKeys["rotation"] = true;
        return this;
    }

    this.letterSpacing = (spec: string): ICreditWordsBuilder => {
        updates["letterSpacing"] = spec;
        delete childBuilders["letterSpacing;"];
        modifiedKeys["letterSpacing"] = true;
        return this;
    }

    this.lineHeight = (spec: string): ICreditWordsBuilder => {
        updates["lineHeight"] = spec;
        delete childBuilders["lineHeight;"];
        modifiedKeys["lineHeight"] = true;
        return this;
    }

    this.dir = (spec: DirectionMode): ICreditWordsBuilder => {
        updates["dir"] = spec;
        delete childBuilders["dir;"];
        modifiedKeys["dir"] = true;
        return this;
    }

    this.enclosure = (spec: EnclosureShape): ICreditWordsBuilder => {
        updates["enclosure"] = spec;
        delete childBuilders["enclosure;"];
        modifiedKeys["enclosure"] = true;
        return this;
    }
  }
}
export function patchCreditWords(base: CreditWords, builder: (build: ICreditWordsBuilder) => ICreditWordsBuilder): IAny[] { return builder(new CreditWordsBuilder(base)).patch(); }
export function buildCreditWords(builder: (build: ICreditWordsBuilder) => ICreditWordsBuilder): CreditWords { return builder(new CreditWordsBuilder()).build(); }

export interface ICreditImageBuilder {
  build?: () => CreditImage;
  patch: () => IAny[];
  type: (type: string) => ICreditImageBuilder;
  source: (source: string) => ICreditImageBuilder;
  defaultX: (defaultX: number) => ICreditImageBuilder;
  relativeY: (relativeY: number) => ICreditImageBuilder;
  defaultY: (defaultY: number) => ICreditImageBuilder;
  relativeX: (relativeX: number) => ICreditImageBuilder;
  halign: (halign: LeftCenterRight) => ICreditImageBuilder;
  valignImage: (valignImage: TopMiddleBottomBaseline) => ICreditImageBuilder;
}

class CreditImageBuilder implements ICreditImageBuilder {
  build: () => CreditImage;
  patch: () => IAny[];
  type: (type: string) => ICreditImageBuilder;
  source: (source: string) => ICreditImageBuilder;
  defaultX: (defaultX: number) => ICreditImageBuilder;
  relativeY: (relativeY: number) => ICreditImageBuilder;
  defaultY: (defaultY: number) => ICreditImageBuilder;
  relativeX: (relativeX: number) => ICreditImageBuilder;
  halign: (halign: LeftCenterRight) => ICreditImageBuilder;
  valignImage: (valignImage: TopMiddleBottomBaseline) => ICreditImageBuilder;
  constructor(original?: CreditImage) {
    let updates: CreditImage = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
      console.assert(
          (original && !modifiedKeys["source"]) ||
          childBuilders["source"] !== undefined ||
          updates.source !== undefined,
        "source is a required field");
    }

    if (!original) {
      this.build = (): CreditImage => {
        checkInvariants();
        (updates as any)._class = "CreditImage";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.type = (spec: string): ICreditImageBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.source = (spec: string): ICreditImageBuilder => {
        updates["source"] = spec;
        delete childBuilders["source;"];
        modifiedKeys["source"] = true;
        return this;
    }

    this.defaultX = (spec: number): ICreditImageBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): ICreditImageBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): ICreditImageBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): ICreditImageBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.halign = (spec: LeftCenterRight): ICreditImageBuilder => {
        updates["halign"] = spec;
        delete childBuilders["halign;"];
        modifiedKeys["halign"] = true;
        return this;
    }

    this.valignImage = (spec: TopMiddleBottomBaseline): ICreditImageBuilder => {
        updates["valignImage"] = spec;
        delete childBuilders["valignImage;"];
        modifiedKeys["valignImage"] = true;
        return this;
    }
  }
}
export function patchCreditImage(base: CreditImage, builder: (build: ICreditImageBuilder) => ICreditImageBuilder): IAny[] { return builder(new CreditImageBuilder(base)).patch(); }
export function buildCreditImage(builder: (build: ICreditImageBuilder) => ICreditImageBuilder): CreditImage { return builder(new CreditImageBuilder()).build(); }

export interface IScorePartBuilder {
  build?: () => ScorePart;
  patch: () => IAny[];
  identification: (build: Identification | ((builder: IIdentificationBuilder) => IIdentificationBuilder)) => IScorePartBuilder;
  partNameDisplay: (build: PartNameDisplay | ((builder: IPartNameDisplayBuilder) => IPartNameDisplayBuilder)) => IScorePartBuilder;
  scoreInstrumentsAt: (idx: number, build: ScoreInstrument | ((builder: IScoreInstrumentBuilder) => IScoreInstrumentBuilder)) => IScorePartBuilder;
  scoreInstrumentsSplice: (start: number, deleteCount: number, ...items: ScoreInstrument[]) => IScorePartBuilder;
  scoreInstruments: (scoreInstruments: ScoreInstrument[]) => IScorePartBuilder;
  midiDevicesAt: (idx: number, build: MidiDevice | ((builder: IMidiDeviceBuilder) => IMidiDeviceBuilder)) => IScorePartBuilder;
  midiDevicesSplice: (start: number, deleteCount: number, ...items: MidiDevice[]) => IScorePartBuilder;
  midiDevices: (midiDevices: MidiDevice[]) => IScorePartBuilder;
  partName: (build: PartName | ((builder: IPartNameBuilder) => IPartNameBuilder)) => IScorePartBuilder;
  partAbbreviationDisplay: (build: PartAbbreviationDisplay | ((builder: IPartAbbreviationDisplayBuilder) => IPartAbbreviationDisplayBuilder)) => IScorePartBuilder;
  partAbbreviation: (build: PartAbbreviation | ((builder: IPartAbbreviationBuilder) => IPartAbbreviationBuilder)) => IScorePartBuilder;
  groups: (groups: string[]) => IScorePartBuilder;
  midiInstrumentsAt: (idx: number, build: MidiInstrument | ((builder: IMidiInstrumentBuilder) => IMidiInstrumentBuilder)) => IScorePartBuilder;
  midiInstrumentsSplice: (start: number, deleteCount: number, ...items: MidiInstrument[]) => IScorePartBuilder;
  midiInstruments: (midiInstruments: MidiInstrument[]) => IScorePartBuilder;
  id: (id: string) => IScorePartBuilder;
}

class ScorePartBuilder implements IScorePartBuilder {
  build: () => ScorePart;
  patch: () => IAny[];
  identification: (build: Identification | ((builder: IIdentificationBuilder) => IIdentificationBuilder)) => IScorePartBuilder;
  partNameDisplay: (build: PartNameDisplay | ((builder: IPartNameDisplayBuilder) => IPartNameDisplayBuilder)) => IScorePartBuilder;
  scoreInstrumentsAt: (idx: number, build: ScoreInstrument | ((builder: IScoreInstrumentBuilder) => IScoreInstrumentBuilder)) => IScorePartBuilder;
  scoreInstrumentsSplice: (start: number, deleteCount: number, ...items: ScoreInstrument[]) => IScorePartBuilder;
  scoreInstruments: (scoreInstruments: ScoreInstrument[]) => IScorePartBuilder;
  midiDevicesAt: (idx: number, build: MidiDevice | ((builder: IMidiDeviceBuilder) => IMidiDeviceBuilder)) => IScorePartBuilder;
  midiDevicesSplice: (start: number, deleteCount: number, ...items: MidiDevice[]) => IScorePartBuilder;
  midiDevices: (midiDevices: MidiDevice[]) => IScorePartBuilder;
  partName: (build: PartName | ((builder: IPartNameBuilder) => IPartNameBuilder)) => IScorePartBuilder;
  partAbbreviationDisplay: (build: PartAbbreviationDisplay | ((builder: IPartAbbreviationDisplayBuilder) => IPartAbbreviationDisplayBuilder)) => IScorePartBuilder;
  partAbbreviation: (build: PartAbbreviation | ((builder: IPartAbbreviationBuilder) => IPartAbbreviationBuilder)) => IScorePartBuilder;
  groups: (groups: string[]) => IScorePartBuilder;
  midiInstrumentsAt: (idx: number, build: MidiInstrument | ((builder: IMidiInstrumentBuilder) => IMidiInstrumentBuilder)) => IScorePartBuilder;
  midiInstrumentsSplice: (start: number, deleteCount: number, ...items: MidiInstrument[]) => IScorePartBuilder;
  midiInstruments: (midiInstruments: MidiInstrument[]) => IScorePartBuilder;
  id: (id: string) => IScorePartBuilder;
  constructor(original?: ScorePart) {
    let updates: ScorePart = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["partName"]) ||
          childBuilders["partName"] !== undefined ||
          updates.partName !== undefined,
        "partName is a required field");
      console.assert(
          (original && !modifiedKeys["id"]) ||
          childBuilders["id"] !== undefined ||
          updates.id !== undefined,
        "id is a required field");
    }

    if (!original) {
      this.build = (): ScorePart => {
        checkInvariants();
        (updates as any)._class = "ScorePart";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.identification = (build: Identification | ((builder: IIdentificationBuilder) => IIdentificationBuilder)): IScorePartBuilder => {
      if (typeof build === 'function') {
        delete updates["identification"]
        const builder = (build as any)(new IdentificationBuilder(original && original["identification"]));
        if (!original) updates["identification"] = builder.build();
        else childBuilders["identification"] = builder;
      } else {
        updates.identification = build as any;
        delete childBuilders["identification;"];
      }
      modifiedKeys["identification"] = true;
      return this;
    }

    this.partNameDisplay = (build: PartNameDisplay | ((builder: IPartNameDisplayBuilder) => IPartNameDisplayBuilder)): IScorePartBuilder => {
      if (typeof build === 'function') {
        delete updates["partNameDisplay"]
        const builder = (build as any)(new PartNameDisplayBuilder(original && original["partNameDisplay"]));
        if (!original) updates["partNameDisplay"] = builder.build();
        else childBuilders["partNameDisplay"] = builder;
      } else {
        updates.partNameDisplay = build as any;
        delete childBuilders["partNameDisplay;"];
      }
      modifiedKeys["partNameDisplay"] = true;
      return this;
    }

    this.scoreInstruments = (spec: ScoreInstrument[]): IScorePartBuilder => {
        updates["scoreInstruments"] = spec;
        delete childBuilders["scoreInstruments;"];
        modifiedKeys["scoreInstruments"] = true;
        return this;
    }

    this.scoreInstrumentsAt = (idx: number, build: ScoreInstrument | ((builder: IScoreInstrumentBuilder) => IScoreInstrumentBuilder)): IScorePartBuilder => {
      makeReference("scoreInstruments");
      if (frozen["scoreInstruments"][idx]) {
          throw new Error("Patching scoreInstruments." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["scoreInstruments"] && !original["scoreInstruments"]) {
          // Clone snapshot.
          patches.push({p: ["scoreInstruments", idx], li: original._snapshot["scoreInstruments"]});
      }
      if (typeof build === 'function' && reference["scoreInstruments"][idx]) {
        let patch = (build as any)(new ScoreInstrumentBuilder(reference["scoreInstruments"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["scoreInstruments", idx].concat(patch.p);
          return patch;
        }));
        frozen["scoreInstruments"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new ScoreInstrumentBuilder(reference["scoreInstruments"][idx])).build() : build;
      if (original) {
        patches.push({p: ["scoreInstruments", idx], li: update});
      } else {
        updates["scoreInstruments"] = reference["scoreInstruments"]; // TODO: Merge?
      } 
      reference["scoreInstruments"][idx] = update;
      frozen["scoreInstruments"][idx] = true;
      return this;
    }

    this.scoreInstrumentsSplice = (start: number, deleteCount: number, ...items: ScoreInstrument[]): IScorePartBuilder => {
      makeReference("scoreInstruments");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["scoreInstruments"][idx]) {
            throw new Error("Replacing scoreInstruments." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["scoreInstruments"][idx];
          patches.push({p: ["scoreInstruments", idx], ld, li: items[idx - start]});
          frozen["scoreInstruments"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["scoreInstruments"][idx]) {
            throw new Error("Removing scoreInstruments." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["scoreInstruments"][idx];
          patches.push({p: ["scoreInstruments", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["scoreInstruments", idx], li: items[idx - start]});
          frozen["scoreInstruments"][idx] = true;
        }
      }
      reference["scoreInstruments"].splice(start, deleteCount, ...items);
      updates["scoreInstruments"] = reference["scoreInstruments"];
      frozen["scoreInstruments"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.midiDevices = (spec: MidiDevice[]): IScorePartBuilder => {
        updates["midiDevices"] = spec;
        delete childBuilders["midiDevices;"];
        modifiedKeys["midiDevices"] = true;
        return this;
    }

    this.midiDevicesAt = (idx: number, build: MidiDevice | ((builder: IMidiDeviceBuilder) => IMidiDeviceBuilder)): IScorePartBuilder => {
      makeReference("midiDevices");
      if (frozen["midiDevices"][idx]) {
          throw new Error("Patching midiDevices." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["midiDevices"] && !original["midiDevices"]) {
          // Clone snapshot.
          patches.push({p: ["midiDevices", idx], li: original._snapshot["midiDevices"]});
      }
      if (typeof build === 'function' && reference["midiDevices"][idx]) {
        let patch = (build as any)(new MidiDeviceBuilder(reference["midiDevices"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["midiDevices", idx].concat(patch.p);
          return patch;
        }));
        frozen["midiDevices"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new MidiDeviceBuilder(reference["midiDevices"][idx])).build() : build;
      if (original) {
        patches.push({p: ["midiDevices", idx], li: update});
      } else {
        updates["midiDevices"] = reference["midiDevices"]; // TODO: Merge?
      } 
      reference["midiDevices"][idx] = update;
      frozen["midiDevices"][idx] = true;
      return this;
    }

    this.midiDevicesSplice = (start: number, deleteCount: number, ...items: MidiDevice[]): IScorePartBuilder => {
      makeReference("midiDevices");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["midiDevices"][idx]) {
            throw new Error("Replacing midiDevices." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["midiDevices"][idx];
          patches.push({p: ["midiDevices", idx], ld, li: items[idx - start]});
          frozen["midiDevices"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["midiDevices"][idx]) {
            throw new Error("Removing midiDevices." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["midiDevices"][idx];
          patches.push({p: ["midiDevices", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["midiDevices", idx], li: items[idx - start]});
          frozen["midiDevices"][idx] = true;
        }
      }
      reference["midiDevices"].splice(start, deleteCount, ...items);
      updates["midiDevices"] = reference["midiDevices"];
      frozen["midiDevices"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.partName = (build: PartName | ((builder: IPartNameBuilder) => IPartNameBuilder)): IScorePartBuilder => {
      if (typeof build === 'function') {
        delete updates["partName"]
        const builder = (build as any)(new PartNameBuilder(original && original["partName"]));
        if (!original) updates["partName"] = builder.build();
        else childBuilders["partName"] = builder;
      } else {
        updates.partName = build as any;
        delete childBuilders["partName;"];
      }
      modifiedKeys["partName"] = true;
      return this;
    }

    this.partAbbreviationDisplay = (build: PartAbbreviationDisplay | ((builder: IPartAbbreviationDisplayBuilder) => IPartAbbreviationDisplayBuilder)): IScorePartBuilder => {
      if (typeof build === 'function') {
        delete updates["partAbbreviationDisplay"]
        const builder = (build as any)(new PartAbbreviationDisplayBuilder(original && original["partAbbreviationDisplay"]));
        if (!original) updates["partAbbreviationDisplay"] = builder.build();
        else childBuilders["partAbbreviationDisplay"] = builder;
      } else {
        updates.partAbbreviationDisplay = build as any;
        delete childBuilders["partAbbreviationDisplay;"];
      }
      modifiedKeys["partAbbreviationDisplay"] = true;
      return this;
    }

    this.partAbbreviation = (build: PartAbbreviation | ((builder: IPartAbbreviationBuilder) => IPartAbbreviationBuilder)): IScorePartBuilder => {
      if (typeof build === 'function') {
        delete updates["partAbbreviation"]
        const builder = (build as any)(new PartAbbreviationBuilder(original && original["partAbbreviation"]));
        if (!original) updates["partAbbreviation"] = builder.build();
        else childBuilders["partAbbreviation"] = builder;
      } else {
        updates.partAbbreviation = build as any;
        delete childBuilders["partAbbreviation;"];
      }
      modifiedKeys["partAbbreviation"] = true;
      return this;
    }

    this.groups = (spec: string[]): IScorePartBuilder => {
        updates["groups"] = spec;
        delete childBuilders["groups;"];
        modifiedKeys["groups"] = true;
        return this;
    }

    this.midiInstruments = (spec: MidiInstrument[]): IScorePartBuilder => {
        updates["midiInstruments"] = spec;
        delete childBuilders["midiInstruments;"];
        modifiedKeys["midiInstruments"] = true;
        return this;
    }

    this.midiInstrumentsAt = (idx: number, build: MidiInstrument | ((builder: IMidiInstrumentBuilder) => IMidiInstrumentBuilder)): IScorePartBuilder => {
      makeReference("midiInstruments");
      if (frozen["midiInstruments"][idx]) {
          throw new Error("Patching midiInstruments." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["midiInstruments"] && !original["midiInstruments"]) {
          // Clone snapshot.
          patches.push({p: ["midiInstruments", idx], li: original._snapshot["midiInstruments"]});
      }
      if (typeof build === 'function' && reference["midiInstruments"][idx]) {
        let patch = (build as any)(new MidiInstrumentBuilder(reference["midiInstruments"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["midiInstruments", idx].concat(patch.p);
          return patch;
        }));
        frozen["midiInstruments"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new MidiInstrumentBuilder(reference["midiInstruments"][idx])).build() : build;
      if (original) {
        patches.push({p: ["midiInstruments", idx], li: update});
      } else {
        updates["midiInstruments"] = reference["midiInstruments"]; // TODO: Merge?
      } 
      reference["midiInstruments"][idx] = update;
      frozen["midiInstruments"][idx] = true;
      return this;
    }

    this.midiInstrumentsSplice = (start: number, deleteCount: number, ...items: MidiInstrument[]): IScorePartBuilder => {
      makeReference("midiInstruments");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["midiInstruments"][idx]) {
            throw new Error("Replacing midiInstruments." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["midiInstruments"][idx];
          patches.push({p: ["midiInstruments", idx], ld, li: items[idx - start]});
          frozen["midiInstruments"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["midiInstruments"][idx]) {
            throw new Error("Removing midiInstruments." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["midiInstruments"][idx];
          patches.push({p: ["midiInstruments", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["midiInstruments", idx], li: items[idx - start]});
          frozen["midiInstruments"][idx] = true;
        }
      }
      reference["midiInstruments"].splice(start, deleteCount, ...items);
      updates["midiInstruments"] = reference["midiInstruments"];
      frozen["midiInstruments"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.id = (spec: string): IScorePartBuilder => {
        updates["id"] = spec;
        delete childBuilders["id;"];
        modifiedKeys["id"] = true;
        return this;
    }
  }
}
export function patchScorePart(base: ScorePart, builder: (build: IScorePartBuilder) => IScorePartBuilder): IAny[] { return builder(new ScorePartBuilder(base)).patch(); }
export function buildScorePart(builder: (build: IScorePartBuilder) => IScorePartBuilder): ScorePart { return builder(new ScorePartBuilder()).build(); }

export interface IPartNameBuilder {
  build?: () => PartName;
  patch: () => IAny[];
  partName: (partName: string) => IPartNameBuilder;
  defaultX: (defaultX: number) => IPartNameBuilder;
  relativeY: (relativeY: number) => IPartNameBuilder;
  defaultY: (defaultY: number) => IPartNameBuilder;
  relativeX: (relativeX: number) => IPartNameBuilder;
  fontFamily: (fontFamily: string) => IPartNameBuilder;
  fontWeight: (fontWeight: NormalBold) => IPartNameBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPartNameBuilder;
  fontSize: (fontSize: string) => IPartNameBuilder;
  color: (color: string) => IPartNameBuilder;
  printObject: (printObject: boolean) => IPartNameBuilder;
  justify: (justify: LeftCenterRight) => IPartNameBuilder;
}

class PartNameBuilder implements IPartNameBuilder {
  build: () => PartName;
  patch: () => IAny[];
  partName: (partName: string) => IPartNameBuilder;
  defaultX: (defaultX: number) => IPartNameBuilder;
  relativeY: (relativeY: number) => IPartNameBuilder;
  defaultY: (defaultY: number) => IPartNameBuilder;
  relativeX: (relativeX: number) => IPartNameBuilder;
  fontFamily: (fontFamily: string) => IPartNameBuilder;
  fontWeight: (fontWeight: NormalBold) => IPartNameBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPartNameBuilder;
  fontSize: (fontSize: string) => IPartNameBuilder;
  color: (color: string) => IPartNameBuilder;
  printObject: (printObject: boolean) => IPartNameBuilder;
  justify: (justify: LeftCenterRight) => IPartNameBuilder;
  constructor(original?: PartName) {
    let updates: PartName = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["partName"]) ||
          childBuilders["partName"] !== undefined ||
          updates.partName !== undefined,
        "partName is a required field");
    }

    if (!original) {
      this.build = (): PartName => {
        checkInvariants();
        (updates as any)._class = "PartName";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.partName = (spec: string): IPartNameBuilder => {
        updates["partName"] = spec;
        delete childBuilders["partName;"];
        modifiedKeys["partName"] = true;
        return this;
    }

    this.defaultX = (spec: number): IPartNameBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IPartNameBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IPartNameBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IPartNameBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IPartNameBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IPartNameBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IPartNameBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IPartNameBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IPartNameBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.printObject = (spec: boolean): IPartNameBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.justify = (spec: LeftCenterRight): IPartNameBuilder => {
        updates["justify"] = spec;
        delete childBuilders["justify;"];
        modifiedKeys["justify"] = true;
        return this;
    }
  }
}
export function patchPartName(base: PartName, builder: (build: IPartNameBuilder) => IPartNameBuilder): IAny[] { return builder(new PartNameBuilder(base)).patch(); }
export function buildPartName(builder: (build: IPartNameBuilder) => IPartNameBuilder): PartName { return builder(new PartNameBuilder()).build(); }

export interface IPartAbbreviationBuilder {
  build?: () => PartAbbreviation;
  patch: () => IAny[];
  abbreviation: (abbreviation: string) => IPartAbbreviationBuilder;
  defaultX: (defaultX: number) => IPartAbbreviationBuilder;
  relativeY: (relativeY: number) => IPartAbbreviationBuilder;
  defaultY: (defaultY: number) => IPartAbbreviationBuilder;
  relativeX: (relativeX: number) => IPartAbbreviationBuilder;
  fontFamily: (fontFamily: string) => IPartAbbreviationBuilder;
  fontWeight: (fontWeight: NormalBold) => IPartAbbreviationBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPartAbbreviationBuilder;
  fontSize: (fontSize: string) => IPartAbbreviationBuilder;
  color: (color: string) => IPartAbbreviationBuilder;
  printObject: (printObject: boolean) => IPartAbbreviationBuilder;
  justify: (justify: LeftCenterRight) => IPartAbbreviationBuilder;
}

class PartAbbreviationBuilder implements IPartAbbreviationBuilder {
  build: () => PartAbbreviation;
  patch: () => IAny[];
  abbreviation: (abbreviation: string) => IPartAbbreviationBuilder;
  defaultX: (defaultX: number) => IPartAbbreviationBuilder;
  relativeY: (relativeY: number) => IPartAbbreviationBuilder;
  defaultY: (defaultY: number) => IPartAbbreviationBuilder;
  relativeX: (relativeX: number) => IPartAbbreviationBuilder;
  fontFamily: (fontFamily: string) => IPartAbbreviationBuilder;
  fontWeight: (fontWeight: NormalBold) => IPartAbbreviationBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPartAbbreviationBuilder;
  fontSize: (fontSize: string) => IPartAbbreviationBuilder;
  color: (color: string) => IPartAbbreviationBuilder;
  printObject: (printObject: boolean) => IPartAbbreviationBuilder;
  justify: (justify: LeftCenterRight) => IPartAbbreviationBuilder;
  constructor(original?: PartAbbreviation) {
    let updates: PartAbbreviation = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["abbreviation"]) ||
          childBuilders["abbreviation"] !== undefined ||
          updates.abbreviation !== undefined,
        "abbreviation is a required field");
    }

    if (!original) {
      this.build = (): PartAbbreviation => {
        checkInvariants();
        (updates as any)._class = "PartAbbreviation";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.abbreviation = (spec: string): IPartAbbreviationBuilder => {
        updates["abbreviation"] = spec;
        delete childBuilders["abbreviation;"];
        modifiedKeys["abbreviation"] = true;
        return this;
    }

    this.defaultX = (spec: number): IPartAbbreviationBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IPartAbbreviationBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IPartAbbreviationBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IPartAbbreviationBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IPartAbbreviationBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IPartAbbreviationBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IPartAbbreviationBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IPartAbbreviationBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IPartAbbreviationBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.printObject = (spec: boolean): IPartAbbreviationBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }

    this.justify = (spec: LeftCenterRight): IPartAbbreviationBuilder => {
        updates["justify"] = spec;
        delete childBuilders["justify;"];
        modifiedKeys["justify"] = true;
        return this;
    }
  }
}
export function patchPartAbbreviation(base: PartAbbreviation, builder: (build: IPartAbbreviationBuilder) => IPartAbbreviationBuilder): IAny[] { return builder(new PartAbbreviationBuilder(base)).patch(); }
export function buildPartAbbreviation(builder: (build: IPartAbbreviationBuilder) => IPartAbbreviationBuilder): PartAbbreviation { return builder(new PartAbbreviationBuilder()).build(); }

export interface IPartGroupBuilder {
  build?: () => PartGroup;
  patch: () => IAny[];
  groupNameDisplay: (build: GroupNameDisplay | ((builder: IGroupNameDisplayBuilder) => IGroupNameDisplayBuilder)) => IPartGroupBuilder;
  groupSymbol: (build: GroupSymbol | ((builder: IGroupSymbolBuilder) => IGroupSymbolBuilder)) => IPartGroupBuilder;
  groupName: (build: GroupName | ((builder: IGroupNameBuilder) => IGroupNameBuilder)) => IPartGroupBuilder;
  groupAbbreviationDisplay: (build: GroupAbbreviationDisplay | ((builder: IGroupAbbreviationDisplayBuilder) => IGroupAbbreviationDisplayBuilder)) => IPartGroupBuilder;
  groupBarline: (build: GroupBarline | ((builder: IGroupBarlineBuilder) => IGroupBarlineBuilder)) => IPartGroupBuilder;
  number: (number: number) => IPartGroupBuilder;
  groupAbbreviation: (build: GroupAbbreviation | ((builder: IGroupAbbreviationBuilder) => IGroupAbbreviationBuilder)) => IPartGroupBuilder;
  type: (type: StartStop) => IPartGroupBuilder;
  groupTime: (build: GroupTime | ((builder: IGroupTimeBuilder) => IGroupTimeBuilder)) => IPartGroupBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IPartGroupBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IPartGroupBuilder;
}

class PartGroupBuilder implements IPartGroupBuilder {
  build: () => PartGroup;
  patch: () => IAny[];
  groupNameDisplay: (build: GroupNameDisplay | ((builder: IGroupNameDisplayBuilder) => IGroupNameDisplayBuilder)) => IPartGroupBuilder;
  groupSymbol: (build: GroupSymbol | ((builder: IGroupSymbolBuilder) => IGroupSymbolBuilder)) => IPartGroupBuilder;
  groupName: (build: GroupName | ((builder: IGroupNameBuilder) => IGroupNameBuilder)) => IPartGroupBuilder;
  groupAbbreviationDisplay: (build: GroupAbbreviationDisplay | ((builder: IGroupAbbreviationDisplayBuilder) => IGroupAbbreviationDisplayBuilder)) => IPartGroupBuilder;
  groupBarline: (build: GroupBarline | ((builder: IGroupBarlineBuilder) => IGroupBarlineBuilder)) => IPartGroupBuilder;
  number: (number: number) => IPartGroupBuilder;
  groupAbbreviation: (build: GroupAbbreviation | ((builder: IGroupAbbreviationBuilder) => IGroupAbbreviationBuilder)) => IPartGroupBuilder;
  type: (type: StartStop) => IPartGroupBuilder;
  groupTime: (build: GroupTime | ((builder: IGroupTimeBuilder) => IGroupTimeBuilder)) => IPartGroupBuilder;
  footnote: (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)) => IPartGroupBuilder;
  level: (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)) => IPartGroupBuilder;
  constructor(original?: PartGroup) {
    let updates: PartGroup = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["groupNameDisplay"]) ||
          childBuilders["groupNameDisplay"] !== undefined ||
          updates.groupNameDisplay !== undefined,
        "groupNameDisplay is a required field");
      console.assert(
          (original && !modifiedKeys["groupSymbol"]) ||
          childBuilders["groupSymbol"] !== undefined ||
          updates.groupSymbol !== undefined,
        "groupSymbol is a required field");
      console.assert(
          (original && !modifiedKeys["groupName"]) ||
          childBuilders["groupName"] !== undefined ||
          updates.groupName !== undefined,
        "groupName is a required field");
      console.assert(
          (original && !modifiedKeys["groupAbbreviationDisplay"]) ||
          childBuilders["groupAbbreviationDisplay"] !== undefined ||
          updates.groupAbbreviationDisplay !== undefined,
        "groupAbbreviationDisplay is a required field");
      console.assert(
          (original && !modifiedKeys["groupBarline"]) ||
          childBuilders["groupBarline"] !== undefined ||
          updates.groupBarline !== undefined,
        "groupBarline is a required field");
      console.assert(
          (original && !modifiedKeys["number"]) ||
          childBuilders["number"] !== undefined ||
          updates.number !== undefined,
        "number is a required field");
      console.assert(
          (original && !modifiedKeys["groupAbbreviation"]) ||
          childBuilders["groupAbbreviation"] !== undefined ||
          updates.groupAbbreviation !== undefined,
        "groupAbbreviation is a required field");
      console.assert(
          (original && !modifiedKeys["type"]) ||
          childBuilders["type"] !== undefined ||
          updates.type !== undefined,
        "type is a required field");
      console.assert(
          (original && !modifiedKeys["groupTime"]) ||
          childBuilders["groupTime"] !== undefined ||
          updates.groupTime !== undefined,
        "groupTime is a required field");
    }

    if (!original) {
      this.build = (): PartGroup => {
        checkInvariants();
        (updates as any)._class = "PartGroup";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.groupNameDisplay = (build: GroupNameDisplay | ((builder: IGroupNameDisplayBuilder) => IGroupNameDisplayBuilder)): IPartGroupBuilder => {
      if (typeof build === 'function') {
        delete updates["groupNameDisplay"]
        const builder = (build as any)(new GroupNameDisplayBuilder(original && original["groupNameDisplay"]));
        if (!original) updates["groupNameDisplay"] = builder.build();
        else childBuilders["groupNameDisplay"] = builder;
      } else {
        updates.groupNameDisplay = build as any;
        delete childBuilders["groupNameDisplay;"];
      }
      modifiedKeys["groupNameDisplay"] = true;
      return this;
    }

    this.groupSymbol = (build: GroupSymbol | ((builder: IGroupSymbolBuilder) => IGroupSymbolBuilder)): IPartGroupBuilder => {
      if (typeof build === 'function') {
        delete updates["groupSymbol"]
        const builder = (build as any)(new GroupSymbolBuilder(original && original["groupSymbol"]));
        if (!original) updates["groupSymbol"] = builder.build();
        else childBuilders["groupSymbol"] = builder;
      } else {
        updates.groupSymbol = build as any;
        delete childBuilders["groupSymbol;"];
      }
      modifiedKeys["groupSymbol"] = true;
      return this;
    }

    this.groupName = (build: GroupName | ((builder: IGroupNameBuilder) => IGroupNameBuilder)): IPartGroupBuilder => {
      if (typeof build === 'function') {
        delete updates["groupName"]
        const builder = (build as any)(new GroupNameBuilder(original && original["groupName"]));
        if (!original) updates["groupName"] = builder.build();
        else childBuilders["groupName"] = builder;
      } else {
        updates.groupName = build as any;
        delete childBuilders["groupName;"];
      }
      modifiedKeys["groupName"] = true;
      return this;
    }

    this.groupAbbreviationDisplay = (build: GroupAbbreviationDisplay | ((builder: IGroupAbbreviationDisplayBuilder) => IGroupAbbreviationDisplayBuilder)): IPartGroupBuilder => {
      if (typeof build === 'function') {
        delete updates["groupAbbreviationDisplay"]
        const builder = (build as any)(new GroupAbbreviationDisplayBuilder(original && original["groupAbbreviationDisplay"]));
        if (!original) updates["groupAbbreviationDisplay"] = builder.build();
        else childBuilders["groupAbbreviationDisplay"] = builder;
      } else {
        updates.groupAbbreviationDisplay = build as any;
        delete childBuilders["groupAbbreviationDisplay;"];
      }
      modifiedKeys["groupAbbreviationDisplay"] = true;
      return this;
    }

    this.groupBarline = (build: GroupBarline | ((builder: IGroupBarlineBuilder) => IGroupBarlineBuilder)): IPartGroupBuilder => {
      if (typeof build === 'function') {
        delete updates["groupBarline"]
        const builder = (build as any)(new GroupBarlineBuilder(original && original["groupBarline"]));
        if (!original) updates["groupBarline"] = builder.build();
        else childBuilders["groupBarline"] = builder;
      } else {
        updates.groupBarline = build as any;
        delete childBuilders["groupBarline;"];
      }
      modifiedKeys["groupBarline"] = true;
      return this;
    }

    this.number = (spec: number): IPartGroupBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.groupAbbreviation = (build: GroupAbbreviation | ((builder: IGroupAbbreviationBuilder) => IGroupAbbreviationBuilder)): IPartGroupBuilder => {
      if (typeof build === 'function') {
        delete updates["groupAbbreviation"]
        const builder = (build as any)(new GroupAbbreviationBuilder(original && original["groupAbbreviation"]));
        if (!original) updates["groupAbbreviation"] = builder.build();
        else childBuilders["groupAbbreviation"] = builder;
      } else {
        updates.groupAbbreviation = build as any;
        delete childBuilders["groupAbbreviation;"];
      }
      modifiedKeys["groupAbbreviation"] = true;
      return this;
    }

    this.type = (spec: StartStop): IPartGroupBuilder => {
        updates["type"] = spec;
        delete childBuilders["type;"];
        modifiedKeys["type"] = true;
        return this;
    }

    this.groupTime = (build: GroupTime | ((builder: IGroupTimeBuilder) => IGroupTimeBuilder)): IPartGroupBuilder => {
      if (typeof build === 'function') {
        delete updates["groupTime"]
        const builder = (build as any)(new GroupTimeBuilder(original && original["groupTime"]));
        if (!original) updates["groupTime"] = builder.build();
        else childBuilders["groupTime"] = builder;
      } else {
        updates.groupTime = build as any;
        delete childBuilders["groupTime;"];
      }
      modifiedKeys["groupTime"] = true;
      return this;
    }

    this.footnote = (build: Footnote | ((builder: IFootnoteBuilder) => IFootnoteBuilder)): IPartGroupBuilder => {
      if (typeof build === 'function') {
        delete updates["footnote"]
        const builder = (build as any)(new FootnoteBuilder(original && original["footnote"]));
        if (!original) updates["footnote"] = builder.build();
        else childBuilders["footnote"] = builder;
      } else {
        updates.footnote = build as any;
        delete childBuilders["footnote;"];
      }
      modifiedKeys["footnote"] = true;
      return this;
    }

    this.level = (build: Level | ((builder: ILevelBuilder) => ILevelBuilder)): IPartGroupBuilder => {
      if (typeof build === 'function') {
        delete updates["level"]
        const builder = (build as any)(new LevelBuilder(original && original["level"]));
        if (!original) updates["level"] = builder.build();
        else childBuilders["level"] = builder;
      } else {
        updates.level = build as any;
        delete childBuilders["level;"];
      }
      modifiedKeys["level"] = true;
      return this;
    }
  }
}
export function patchPartGroup(base: PartGroup, builder: (build: IPartGroupBuilder) => IPartGroupBuilder): IAny[] { return builder(new PartGroupBuilder(base)).patch(); }
export function buildPartGroup(builder: (build: IPartGroupBuilder) => IPartGroupBuilder): PartGroup { return builder(new PartGroupBuilder()).build(); }

export interface IGroupNameBuilder {
  build?: () => GroupName;
  patch: () => IAny[];
  name: (name: string) => IGroupNameBuilder;
  defaultX: (defaultX: number) => IGroupNameBuilder;
  relativeY: (relativeY: number) => IGroupNameBuilder;
  defaultY: (defaultY: number) => IGroupNameBuilder;
  relativeX: (relativeX: number) => IGroupNameBuilder;
  fontFamily: (fontFamily: string) => IGroupNameBuilder;
  fontWeight: (fontWeight: NormalBold) => IGroupNameBuilder;
  fontStyle: (fontStyle: NormalItalic) => IGroupNameBuilder;
  fontSize: (fontSize: string) => IGroupNameBuilder;
  color: (color: string) => IGroupNameBuilder;
  justify: (justify: LeftCenterRight) => IGroupNameBuilder;
}

class GroupNameBuilder implements IGroupNameBuilder {
  build: () => GroupName;
  patch: () => IAny[];
  name: (name: string) => IGroupNameBuilder;
  defaultX: (defaultX: number) => IGroupNameBuilder;
  relativeY: (relativeY: number) => IGroupNameBuilder;
  defaultY: (defaultY: number) => IGroupNameBuilder;
  relativeX: (relativeX: number) => IGroupNameBuilder;
  fontFamily: (fontFamily: string) => IGroupNameBuilder;
  fontWeight: (fontWeight: NormalBold) => IGroupNameBuilder;
  fontStyle: (fontStyle: NormalItalic) => IGroupNameBuilder;
  fontSize: (fontSize: string) => IGroupNameBuilder;
  color: (color: string) => IGroupNameBuilder;
  justify: (justify: LeftCenterRight) => IGroupNameBuilder;
  constructor(original?: GroupName) {
    let updates: GroupName = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["name"]) ||
          childBuilders["name"] !== undefined ||
          updates.name !== undefined,
        "name is a required field");
    }

    if (!original) {
      this.build = (): GroupName => {
        checkInvariants();
        (updates as any)._class = "GroupName";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.name = (spec: string): IGroupNameBuilder => {
        updates["name"] = spec;
        delete childBuilders["name;"];
        modifiedKeys["name"] = true;
        return this;
    }

    this.defaultX = (spec: number): IGroupNameBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IGroupNameBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IGroupNameBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IGroupNameBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IGroupNameBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IGroupNameBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IGroupNameBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IGroupNameBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IGroupNameBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.justify = (spec: LeftCenterRight): IGroupNameBuilder => {
        updates["justify"] = spec;
        delete childBuilders["justify;"];
        modifiedKeys["justify"] = true;
        return this;
    }
  }
}
export function patchGroupName(base: GroupName, builder: (build: IGroupNameBuilder) => IGroupNameBuilder): IAny[] { return builder(new GroupNameBuilder(base)).patch(); }
export function buildGroupName(builder: (build: IGroupNameBuilder) => IGroupNameBuilder): GroupName { return builder(new GroupNameBuilder()).build(); }

export interface IGroupNameDisplayBuilder {
  build?: () => GroupNameDisplay;
  patch: () => IAny[];
  nameAt: (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)) => IGroupNameDisplayBuilder;
  nameSplice: (start: number, deleteCount: number, ...items: TextSegment[]) => IGroupNameDisplayBuilder;
  name: (name: TextSegment[]) => IGroupNameDisplayBuilder;
  printObject: (printObject: boolean) => IGroupNameDisplayBuilder;
}

class GroupNameDisplayBuilder implements IGroupNameDisplayBuilder {
  build: () => GroupNameDisplay;
  patch: () => IAny[];
  nameAt: (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)) => IGroupNameDisplayBuilder;
  nameSplice: (start: number, deleteCount: number, ...items: TextSegment[]) => IGroupNameDisplayBuilder;
  name: (name: TextSegment[]) => IGroupNameDisplayBuilder;
  printObject: (printObject: boolean) => IGroupNameDisplayBuilder;
  constructor(original?: GroupNameDisplay) {
    let updates: GroupNameDisplay = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["name"]) ||
          childBuilders["name"] !== undefined ||
          updates.name !== undefined,
        "name is a required field");
    }

    if (!original) {
      this.build = (): GroupNameDisplay => {
        checkInvariants();
        (updates as any)._class = "GroupNameDisplay";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.name = (spec: TextSegment[]): IGroupNameDisplayBuilder => {
        updates["name"] = spec;
        delete childBuilders["name;"];
        modifiedKeys["name"] = true;
        return this;
    }

    this.nameAt = (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)): IGroupNameDisplayBuilder => {
      makeReference("name");
      if (frozen["name"][idx]) {
          throw new Error("Patching name." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["name"] && !original["name"]) {
          // Clone snapshot.
          patches.push({p: ["name", idx], li: original._snapshot["name"]});
      }
      if (typeof build === 'function' && reference["name"][idx]) {
        let patch = (build as any)(new TextSegmentBuilder(reference["name"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["name", idx].concat(patch.p);
          return patch;
        }));
        frozen["name"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new TextSegmentBuilder(reference["name"][idx])).build() : build;
      if (original) {
        patches.push({p: ["name", idx], li: update});
      } else {
        updates["name"] = reference["name"]; // TODO: Merge?
      } 
      reference["name"][idx] = update;
      frozen["name"][idx] = true;
      return this;
    }

    this.nameSplice = (start: number, deleteCount: number, ...items: TextSegment[]): IGroupNameDisplayBuilder => {
      makeReference("name");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["name"][idx]) {
            throw new Error("Replacing name." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["name"][idx];
          patches.push({p: ["name", idx], ld, li: items[idx - start]});
          frozen["name"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["name"][idx]) {
            throw new Error("Removing name." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["name"][idx];
          patches.push({p: ["name", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["name", idx], li: items[idx - start]});
          frozen["name"][idx] = true;
        }
      }
      reference["name"].splice(start, deleteCount, ...items);
      updates["name"] = reference["name"];
      frozen["name"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.printObject = (spec: boolean): IGroupNameDisplayBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }
  }
}
export function patchGroupNameDisplay(base: GroupNameDisplay, builder: (build: IGroupNameDisplayBuilder) => IGroupNameDisplayBuilder): IAny[] { return builder(new GroupNameDisplayBuilder(base)).patch(); }
export function buildGroupNameDisplay(builder: (build: IGroupNameDisplayBuilder) => IGroupNameDisplayBuilder): GroupNameDisplay { return builder(new GroupNameDisplayBuilder()).build(); }

export interface IGroupAbbreviationBuilder {
  build?: () => GroupAbbreviation;
  patch: () => IAny[];
  text: (text: string) => IGroupAbbreviationBuilder;
  defaultX: (defaultX: number) => IGroupAbbreviationBuilder;
  relativeY: (relativeY: number) => IGroupAbbreviationBuilder;
  defaultY: (defaultY: number) => IGroupAbbreviationBuilder;
  relativeX: (relativeX: number) => IGroupAbbreviationBuilder;
  fontFamily: (fontFamily: string) => IGroupAbbreviationBuilder;
  fontWeight: (fontWeight: NormalBold) => IGroupAbbreviationBuilder;
  fontStyle: (fontStyle: NormalItalic) => IGroupAbbreviationBuilder;
  fontSize: (fontSize: string) => IGroupAbbreviationBuilder;
  color: (color: string) => IGroupAbbreviationBuilder;
  justify: (justify: LeftCenterRight) => IGroupAbbreviationBuilder;
}

class GroupAbbreviationBuilder implements IGroupAbbreviationBuilder {
  build: () => GroupAbbreviation;
  patch: () => IAny[];
  text: (text: string) => IGroupAbbreviationBuilder;
  defaultX: (defaultX: number) => IGroupAbbreviationBuilder;
  relativeY: (relativeY: number) => IGroupAbbreviationBuilder;
  defaultY: (defaultY: number) => IGroupAbbreviationBuilder;
  relativeX: (relativeX: number) => IGroupAbbreviationBuilder;
  fontFamily: (fontFamily: string) => IGroupAbbreviationBuilder;
  fontWeight: (fontWeight: NormalBold) => IGroupAbbreviationBuilder;
  fontStyle: (fontStyle: NormalItalic) => IGroupAbbreviationBuilder;
  fontSize: (fontSize: string) => IGroupAbbreviationBuilder;
  color: (color: string) => IGroupAbbreviationBuilder;
  justify: (justify: LeftCenterRight) => IGroupAbbreviationBuilder;
  constructor(original?: GroupAbbreviation) {
    let updates: GroupAbbreviation = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["text"]) ||
          childBuilders["text"] !== undefined ||
          updates.text !== undefined,
        "text is a required field");
    }

    if (!original) {
      this.build = (): GroupAbbreviation => {
        checkInvariants();
        (updates as any)._class = "GroupAbbreviation";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.text = (spec: string): IGroupAbbreviationBuilder => {
        updates["text"] = spec;
        delete childBuilders["text;"];
        modifiedKeys["text"] = true;
        return this;
    }

    this.defaultX = (spec: number): IGroupAbbreviationBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IGroupAbbreviationBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IGroupAbbreviationBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IGroupAbbreviationBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.fontFamily = (spec: string): IGroupAbbreviationBuilder => {
        updates["fontFamily"] = spec;
        delete childBuilders["fontFamily;"];
        modifiedKeys["fontFamily"] = true;
        return this;
    }

    this.fontWeight = (spec: NormalBold): IGroupAbbreviationBuilder => {
        updates["fontWeight"] = spec;
        delete childBuilders["fontWeight;"];
        modifiedKeys["fontWeight"] = true;
        return this;
    }

    this.fontStyle = (spec: NormalItalic): IGroupAbbreviationBuilder => {
        updates["fontStyle"] = spec;
        delete childBuilders["fontStyle;"];
        modifiedKeys["fontStyle"] = true;
        return this;
    }

    this.fontSize = (spec: string): IGroupAbbreviationBuilder => {
        updates["fontSize"] = spec;
        delete childBuilders["fontSize;"];
        modifiedKeys["fontSize"] = true;
        return this;
    }

    this.color = (spec: string): IGroupAbbreviationBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }

    this.justify = (spec: LeftCenterRight): IGroupAbbreviationBuilder => {
        updates["justify"] = spec;
        delete childBuilders["justify;"];
        modifiedKeys["justify"] = true;
        return this;
    }
  }
}
export function patchGroupAbbreviation(base: GroupAbbreviation, builder: (build: IGroupAbbreviationBuilder) => IGroupAbbreviationBuilder): IAny[] { return builder(new GroupAbbreviationBuilder(base)).patch(); }
export function buildGroupAbbreviation(builder: (build: IGroupAbbreviationBuilder) => IGroupAbbreviationBuilder): GroupAbbreviation { return builder(new GroupAbbreviationBuilder()).build(); }

export interface IGroupAbbreviationDisplayBuilder {
  build?: () => GroupAbbreviationDisplay;
  patch: () => IAny[];
  nameAt: (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)) => IGroupAbbreviationDisplayBuilder;
  nameSplice: (start: number, deleteCount: number, ...items: TextSegment[]) => IGroupAbbreviationDisplayBuilder;
  name: (name: TextSegment[]) => IGroupAbbreviationDisplayBuilder;
  printObject: (printObject: boolean) => IGroupAbbreviationDisplayBuilder;
}

class GroupAbbreviationDisplayBuilder implements IGroupAbbreviationDisplayBuilder {
  build: () => GroupAbbreviationDisplay;
  patch: () => IAny[];
  nameAt: (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)) => IGroupAbbreviationDisplayBuilder;
  nameSplice: (start: number, deleteCount: number, ...items: TextSegment[]) => IGroupAbbreviationDisplayBuilder;
  name: (name: TextSegment[]) => IGroupAbbreviationDisplayBuilder;
  printObject: (printObject: boolean) => IGroupAbbreviationDisplayBuilder;
  constructor(original?: GroupAbbreviationDisplay) {
    let updates: GroupAbbreviationDisplay = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["name"]) ||
          childBuilders["name"] !== undefined ||
          updates.name !== undefined,
        "name is a required field");
    }

    if (!original) {
      this.build = (): GroupAbbreviationDisplay => {
        checkInvariants();
        (updates as any)._class = "GroupAbbreviationDisplay";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.name = (spec: TextSegment[]): IGroupAbbreviationDisplayBuilder => {
        updates["name"] = spec;
        delete childBuilders["name;"];
        modifiedKeys["name"] = true;
        return this;
    }

    this.nameAt = (idx: number, build: TextSegment | ((builder: ITextSegmentBuilder) => ITextSegmentBuilder)): IGroupAbbreviationDisplayBuilder => {
      makeReference("name");
      if (frozen["name"][idx]) {
          throw new Error("Patching name." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["name"] && !original["name"]) {
          // Clone snapshot.
          patches.push({p: ["name", idx], li: original._snapshot["name"]});
      }
      if (typeof build === 'function' && reference["name"][idx]) {
        let patch = (build as any)(new TextSegmentBuilder(reference["name"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["name", idx].concat(patch.p);
          return patch;
        }));
        frozen["name"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new TextSegmentBuilder(reference["name"][idx])).build() : build;
      if (original) {
        patches.push({p: ["name", idx], li: update});
      } else {
        updates["name"] = reference["name"]; // TODO: Merge?
      } 
      reference["name"][idx] = update;
      frozen["name"][idx] = true;
      return this;
    }

    this.nameSplice = (start: number, deleteCount: number, ...items: TextSegment[]): IGroupAbbreviationDisplayBuilder => {
      makeReference("name");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["name"][idx]) {
            throw new Error("Replacing name." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["name"][idx];
          patches.push({p: ["name", idx], ld, li: items[idx - start]});
          frozen["name"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["name"][idx]) {
            throw new Error("Removing name." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["name"][idx];
          patches.push({p: ["name", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["name", idx], li: items[idx - start]});
          frozen["name"][idx] = true;
        }
      }
      reference["name"].splice(start, deleteCount, ...items);
      updates["name"] = reference["name"];
      frozen["name"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.printObject = (spec: boolean): IGroupAbbreviationDisplayBuilder => {
        updates["printObject"] = spec;
        delete childBuilders["printObject;"];
        modifiedKeys["printObject"] = true;
        return this;
    }
  }
}
export function patchGroupAbbreviationDisplay(base: GroupAbbreviationDisplay, builder: (build: IGroupAbbreviationDisplayBuilder) => IGroupAbbreviationDisplayBuilder): IAny[] { return builder(new GroupAbbreviationDisplayBuilder(base)).patch(); }
export function buildGroupAbbreviationDisplay(builder: (build: IGroupAbbreviationDisplayBuilder) => IGroupAbbreviationDisplayBuilder): GroupAbbreviationDisplay { return builder(new GroupAbbreviationDisplayBuilder()).build(); }

export interface IGroupSymbolBuilder {
  build?: () => GroupSymbol;
  patch: () => IAny[];
  data: (data: PartSymbolType) => IGroupSymbolBuilder;
  defaultX: (defaultX: number) => IGroupSymbolBuilder;
  relativeY: (relativeY: number) => IGroupSymbolBuilder;
  defaultY: (defaultY: number) => IGroupSymbolBuilder;
  relativeX: (relativeX: number) => IGroupSymbolBuilder;
  color: (color: string) => IGroupSymbolBuilder;
}

class GroupSymbolBuilder implements IGroupSymbolBuilder {
  build: () => GroupSymbol;
  patch: () => IAny[];
  data: (data: PartSymbolType) => IGroupSymbolBuilder;
  defaultX: (defaultX: number) => IGroupSymbolBuilder;
  relativeY: (relativeY: number) => IGroupSymbolBuilder;
  defaultY: (defaultY: number) => IGroupSymbolBuilder;
  relativeX: (relativeX: number) => IGroupSymbolBuilder;
  color: (color: string) => IGroupSymbolBuilder;
  constructor(original?: GroupSymbol) {
    let updates: GroupSymbol = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): GroupSymbol => {
        checkInvariants();
        (updates as any)._class = "GroupSymbol";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: PartSymbolType): IGroupSymbolBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.defaultX = (spec: number): IGroupSymbolBuilder => {
        updates["defaultX"] = spec;
        delete childBuilders["defaultX;"];
        modifiedKeys["defaultX"] = true;
        return this;
    }

    this.relativeY = (spec: number): IGroupSymbolBuilder => {
        updates["relativeY"] = spec;
        delete childBuilders["relativeY;"];
        modifiedKeys["relativeY"] = true;
        return this;
    }

    this.defaultY = (spec: number): IGroupSymbolBuilder => {
        updates["defaultY"] = spec;
        delete childBuilders["defaultY;"];
        modifiedKeys["defaultY"] = true;
        return this;
    }

    this.relativeX = (spec: number): IGroupSymbolBuilder => {
        updates["relativeX"] = spec;
        delete childBuilders["relativeX;"];
        modifiedKeys["relativeX"] = true;
        return this;
    }

    this.color = (spec: string): IGroupSymbolBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchGroupSymbol(base: GroupSymbol, builder: (build: IGroupSymbolBuilder) => IGroupSymbolBuilder): IAny[] { return builder(new GroupSymbolBuilder(base)).patch(); }
export function buildGroupSymbol(builder: (build: IGroupSymbolBuilder) => IGroupSymbolBuilder): GroupSymbol { return builder(new GroupSymbolBuilder()).build(); }

export interface IGroupBarlineBuilder {
  build?: () => GroupBarline;
  patch: () => IAny[];
  data: (data: string) => IGroupBarlineBuilder;
  color: (color: string) => IGroupBarlineBuilder;
}

class GroupBarlineBuilder implements IGroupBarlineBuilder {
  build: () => GroupBarline;
  patch: () => IAny[];
  data: (data: string) => IGroupBarlineBuilder;
  color: (color: string) => IGroupBarlineBuilder;
  constructor(original?: GroupBarline) {
    let updates: GroupBarline = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["data"]) ||
          childBuilders["data"] !== undefined ||
          updates.data !== undefined,
        "data is a required field");
    }

    if (!original) {
      this.build = (): GroupBarline => {
        checkInvariants();
        (updates as any)._class = "GroupBarline";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.data = (spec: string): IGroupBarlineBuilder => {
        updates["data"] = spec;
        delete childBuilders["data;"];
        modifiedKeys["data"] = true;
        return this;
    }

    this.color = (spec: string): IGroupBarlineBuilder => {
        updates["color"] = spec;
        delete childBuilders["color;"];
        modifiedKeys["color"] = true;
        return this;
    }
  }
}
export function patchGroupBarline(base: GroupBarline, builder: (build: IGroupBarlineBuilder) => IGroupBarlineBuilder): IAny[] { return builder(new GroupBarlineBuilder(base)).patch(); }
export function buildGroupBarline(builder: (build: IGroupBarlineBuilder) => IGroupBarlineBuilder): GroupBarline { return builder(new GroupBarlineBuilder()).build(); }

export interface IGroupTimeBuilder {
  build?: () => GroupTime;
  patch: () => IAny[];
}

class GroupTimeBuilder implements IGroupTimeBuilder {
  build: () => GroupTime;
  patch: () => IAny[];
  constructor(original?: GroupTime) {
    let updates: GroupTime = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): GroupTime => {
        checkInvariants();
        (updates as any)._class = "GroupTime";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchGroupTime(base: GroupTime, builder: (build: IGroupTimeBuilder) => IGroupTimeBuilder): IAny[] { return builder(new GroupTimeBuilder(base)).patch(); }
export function buildGroupTime(builder: (build: IGroupTimeBuilder) => IGroupTimeBuilder): GroupTime { return builder(new GroupTimeBuilder()).build(); }

export interface IScoreInstrumentBuilder {
  build?: () => ScoreInstrument;
  patch: () => IAny[];
  instrumentName: (instrumentName: string) => IScoreInstrumentBuilder;
  instrumentSound: (instrumentSound: string) => IScoreInstrumentBuilder;
  ensemble: (ensemble: string) => IScoreInstrumentBuilder;
  virtualInstrument: (build: VirtualInstrument | ((builder: IVirtualInstrumentBuilder) => IVirtualInstrumentBuilder)) => IScoreInstrumentBuilder;
  instrumentAbbreviation: (instrumentAbbreviation: string) => IScoreInstrumentBuilder;
  solo: (build: Solo | ((builder: ISoloBuilder) => ISoloBuilder)) => IScoreInstrumentBuilder;
  id: (id: string) => IScoreInstrumentBuilder;
}

class ScoreInstrumentBuilder implements IScoreInstrumentBuilder {
  build: () => ScoreInstrument;
  patch: () => IAny[];
  instrumentName: (instrumentName: string) => IScoreInstrumentBuilder;
  instrumentSound: (instrumentSound: string) => IScoreInstrumentBuilder;
  ensemble: (ensemble: string) => IScoreInstrumentBuilder;
  virtualInstrument: (build: VirtualInstrument | ((builder: IVirtualInstrumentBuilder) => IVirtualInstrumentBuilder)) => IScoreInstrumentBuilder;
  instrumentAbbreviation: (instrumentAbbreviation: string) => IScoreInstrumentBuilder;
  solo: (build: Solo | ((builder: ISoloBuilder) => ISoloBuilder)) => IScoreInstrumentBuilder;
  id: (id: string) => IScoreInstrumentBuilder;
  constructor(original?: ScoreInstrument) {
    let updates: ScoreInstrument = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["instrumentName"]) ||
          childBuilders["instrumentName"] !== undefined ||
          updates.instrumentName !== undefined,
        "instrumentName is a required field");
      console.assert(
          (original && !modifiedKeys["id"]) ||
          childBuilders["id"] !== undefined ||
          updates.id !== undefined,
        "id is a required field");
    }

    if (!original) {
      this.build = (): ScoreInstrument => {
        checkInvariants();
        (updates as any)._class = "ScoreInstrument";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.instrumentName = (spec: string): IScoreInstrumentBuilder => {
        updates["instrumentName"] = spec;
        delete childBuilders["instrumentName;"];
        modifiedKeys["instrumentName"] = true;
        return this;
    }

    this.instrumentSound = (spec: string): IScoreInstrumentBuilder => {
        updates["instrumentSound"] = spec;
        delete childBuilders["instrumentSound;"];
        modifiedKeys["instrumentSound"] = true;
        return this;
    }

    this.ensemble = (spec: string): IScoreInstrumentBuilder => {
        updates["ensemble"] = spec;
        delete childBuilders["ensemble;"];
        modifiedKeys["ensemble"] = true;
        return this;
    }

    this.virtualInstrument = (build: VirtualInstrument | ((builder: IVirtualInstrumentBuilder) => IVirtualInstrumentBuilder)): IScoreInstrumentBuilder => {
      if (typeof build === 'function') {
        delete updates["virtualInstrument"]
        const builder = (build as any)(new VirtualInstrumentBuilder(original && original["virtualInstrument"]));
        if (!original) updates["virtualInstrument"] = builder.build();
        else childBuilders["virtualInstrument"] = builder;
      } else {
        updates.virtualInstrument = build as any;
        delete childBuilders["virtualInstrument;"];
      }
      modifiedKeys["virtualInstrument"] = true;
      return this;
    }

    this.instrumentAbbreviation = (spec: string): IScoreInstrumentBuilder => {
        updates["instrumentAbbreviation"] = spec;
        delete childBuilders["instrumentAbbreviation;"];
        modifiedKeys["instrumentAbbreviation"] = true;
        return this;
    }

    this.solo = (build: Solo | ((builder: ISoloBuilder) => ISoloBuilder)): IScoreInstrumentBuilder => {
      if (typeof build === 'function') {
        delete updates["solo"]
        const builder = (build as any)(new SoloBuilder(original && original["solo"]));
        if (!original) updates["solo"] = builder.build();
        else childBuilders["solo"] = builder;
      } else {
        updates.solo = build as any;
        delete childBuilders["solo;"];
      }
      modifiedKeys["solo"] = true;
      return this;
    }

    this.id = (spec: string): IScoreInstrumentBuilder => {
        updates["id"] = spec;
        delete childBuilders["id;"];
        modifiedKeys["id"] = true;
        return this;
    }
  }
}
export function patchScoreInstrument(base: ScoreInstrument, builder: (build: IScoreInstrumentBuilder) => IScoreInstrumentBuilder): IAny[] { return builder(new ScoreInstrumentBuilder(base)).patch(); }
export function buildScoreInstrument(builder: (build: IScoreInstrumentBuilder) => IScoreInstrumentBuilder): ScoreInstrument { return builder(new ScoreInstrumentBuilder()).build(); }

export interface ISoloBuilder {
  build?: () => Solo;
  patch: () => IAny[];
}

class SoloBuilder implements ISoloBuilder {
  build: () => Solo;
  patch: () => IAny[];
  constructor(original?: Solo) {
    let updates: Solo = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
    }

    if (!original) {
      this.build = (): Solo => {
        checkInvariants();
        (updates as any)._class = "Solo";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }
  }
}
export function patchSolo(base: Solo, builder: (build: ISoloBuilder) => ISoloBuilder): IAny[] { return builder(new SoloBuilder(base)).patch(); }
export function buildSolo(builder: (build: ISoloBuilder) => ISoloBuilder): Solo { return builder(new SoloBuilder()).build(); }

export interface IVirtualInstrumentBuilder {
  build?: () => VirtualInstrument;
  patch: () => IAny[];
  virtualLibrary: (virtualLibrary: string) => IVirtualInstrumentBuilder;
  virtualName: (virtualName: string) => IVirtualInstrumentBuilder;
}

class VirtualInstrumentBuilder implements IVirtualInstrumentBuilder {
  build: () => VirtualInstrument;
  patch: () => IAny[];
  virtualLibrary: (virtualLibrary: string) => IVirtualInstrumentBuilder;
  virtualName: (virtualName: string) => IVirtualInstrumentBuilder;
  constructor(original?: VirtualInstrument) {
    let updates: VirtualInstrument = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["virtualLibrary"]) ||
          childBuilders["virtualLibrary"] !== undefined ||
          updates.virtualLibrary !== undefined,
        "virtualLibrary is a required field");
      console.assert(
          (original && !modifiedKeys["virtualName"]) ||
          childBuilders["virtualName"] !== undefined ||
          updates.virtualName !== undefined,
        "virtualName is a required field");
    }

    if (!original) {
      this.build = (): VirtualInstrument => {
        checkInvariants();
        (updates as any)._class = "VirtualInstrument";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.virtualLibrary = (spec: string): IVirtualInstrumentBuilder => {
        updates["virtualLibrary"] = spec;
        delete childBuilders["virtualLibrary;"];
        modifiedKeys["virtualLibrary"] = true;
        return this;
    }

    this.virtualName = (spec: string): IVirtualInstrumentBuilder => {
        updates["virtualName"] = spec;
        delete childBuilders["virtualName;"];
        modifiedKeys["virtualName"] = true;
        return this;
    }
  }
}
export function patchVirtualInstrument(base: VirtualInstrument, builder: (build: IVirtualInstrumentBuilder) => IVirtualInstrumentBuilder): IAny[] { return builder(new VirtualInstrumentBuilder(base)).patch(); }
export function buildVirtualInstrument(builder: (build: IVirtualInstrumentBuilder) => IVirtualInstrumentBuilder): VirtualInstrument { return builder(new VirtualInstrumentBuilder()).build(); }

export interface IScoreHeaderBuilder {
  build?: () => ScoreHeader;
  patch: () => IAny[];
  movementTitle: (movementTitle: string) => IScoreHeaderBuilder;
  identification: (build: Identification | ((builder: IIdentificationBuilder) => IIdentificationBuilder)) => IScoreHeaderBuilder;
  defaults: (build: Defaults | ((builder: IDefaultsBuilder) => IDefaultsBuilder)) => IScoreHeaderBuilder;
  work: (build: Work | ((builder: IWorkBuilder) => IWorkBuilder)) => IScoreHeaderBuilder;
  creditsAt: (idx: number, build: Credit | ((builder: ICreditBuilder) => ICreditBuilder)) => IScoreHeaderBuilder;
  creditsSplice: (start: number, deleteCount: number, ...items: Credit[]) => IScoreHeaderBuilder;
  credits: (credits: Credit[]) => IScoreHeaderBuilder;
  partList: (partList: PartList) => IScoreHeaderBuilder;
  movementNumber: (movementNumber: string) => IScoreHeaderBuilder;
}

class ScoreHeaderBuilder implements IScoreHeaderBuilder {
  build: () => ScoreHeader;
  patch: () => IAny[];
  movementTitle: (movementTitle: string) => IScoreHeaderBuilder;
  identification: (build: Identification | ((builder: IIdentificationBuilder) => IIdentificationBuilder)) => IScoreHeaderBuilder;
  defaults: (build: Defaults | ((builder: IDefaultsBuilder) => IDefaultsBuilder)) => IScoreHeaderBuilder;
  work: (build: Work | ((builder: IWorkBuilder) => IWorkBuilder)) => IScoreHeaderBuilder;
  creditsAt: (idx: number, build: Credit | ((builder: ICreditBuilder) => ICreditBuilder)) => IScoreHeaderBuilder;
  creditsSplice: (start: number, deleteCount: number, ...items: Credit[]) => IScoreHeaderBuilder;
  credits: (credits: Credit[]) => IScoreHeaderBuilder;
  partList: (partList: PartList) => IScoreHeaderBuilder;
  movementNumber: (movementNumber: string) => IScoreHeaderBuilder;
  constructor(original?: ScoreHeader) {
    let updates: ScoreHeader = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["movementTitle"]) ||
          childBuilders["movementTitle"] !== undefined ||
          updates.movementTitle !== undefined,
        "movementTitle is a required field");
      console.assert(
          (original && !modifiedKeys["identification"]) ||
          childBuilders["identification"] !== undefined ||
          updates.identification !== undefined,
        "identification is a required field");
      console.assert(
          (original && !modifiedKeys["defaults"]) ||
          childBuilders["defaults"] !== undefined ||
          updates.defaults !== undefined,
        "defaults is a required field");
      console.assert(
          (original && !modifiedKeys["work"]) ||
          childBuilders["work"] !== undefined ||
          updates.work !== undefined,
        "work is a required field");
      console.assert(
          (original && !modifiedKeys["credits"]) ||
          childBuilders["credits"] !== undefined ||
          updates.credits !== undefined,
        "credits is a required field");
      console.assert(
          (original && !modifiedKeys["partList"]) ||
          childBuilders["partList"] !== undefined ||
          updates.partList !== undefined,
        "partList is a required field");
      console.assert(
          (original && !modifiedKeys["movementNumber"]) ||
          childBuilders["movementNumber"] !== undefined ||
          updates.movementNumber !== undefined,
        "movementNumber is a required field");
    }

    if (!original) {
      this.build = (): ScoreHeader => {
        checkInvariants();
        (updates as any)._class = "ScoreHeader";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.movementTitle = (spec: string): IScoreHeaderBuilder => {
        updates["movementTitle"] = spec;
        delete childBuilders["movementTitle;"];
        modifiedKeys["movementTitle"] = true;
        return this;
    }

    this.identification = (build: Identification | ((builder: IIdentificationBuilder) => IIdentificationBuilder)): IScoreHeaderBuilder => {
      if (typeof build === 'function') {
        delete updates["identification"]
        const builder = (build as any)(new IdentificationBuilder(original && original["identification"]));
        if (!original) updates["identification"] = builder.build();
        else childBuilders["identification"] = builder;
      } else {
        updates.identification = build as any;
        delete childBuilders["identification;"];
      }
      modifiedKeys["identification"] = true;
      return this;
    }

    this.defaults = (build: Defaults | ((builder: IDefaultsBuilder) => IDefaultsBuilder)): IScoreHeaderBuilder => {
      if (typeof build === 'function') {
        delete updates["defaults"]
        const builder = (build as any)(new DefaultsBuilder(original && original["defaults"]));
        if (!original) updates["defaults"] = builder.build();
        else childBuilders["defaults"] = builder;
      } else {
        updates.defaults = build as any;
        delete childBuilders["defaults;"];
      }
      modifiedKeys["defaults"] = true;
      return this;
    }

    this.work = (build: Work | ((builder: IWorkBuilder) => IWorkBuilder)): IScoreHeaderBuilder => {
      if (typeof build === 'function') {
        delete updates["work"]
        const builder = (build as any)(new WorkBuilder(original && original["work"]));
        if (!original) updates["work"] = builder.build();
        else childBuilders["work"] = builder;
      } else {
        updates.work = build as any;
        delete childBuilders["work;"];
      }
      modifiedKeys["work"] = true;
      return this;
    }

    this.credits = (spec: Credit[]): IScoreHeaderBuilder => {
        updates["credits"] = spec;
        delete childBuilders["credits;"];
        modifiedKeys["credits"] = true;
        return this;
    }

    this.creditsAt = (idx: number, build: Credit | ((builder: ICreditBuilder) => ICreditBuilder)): IScoreHeaderBuilder => {
      makeReference("credits");
      if (frozen["credits"][idx]) {
          throw new Error("Patching credits." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["credits"] && !original["credits"]) {
          // Clone snapshot.
          patches.push({p: ["credits", idx], li: original._snapshot["credits"]});
      }
      if (typeof build === 'function' && reference["credits"][idx]) {
        let patch = (build as any)(new CreditBuilder(reference["credits"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["credits", idx].concat(patch.p);
          return patch;
        }));
        frozen["credits"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new CreditBuilder(reference["credits"][idx])).build() : build;
      if (original) {
        patches.push({p: ["credits", idx], li: update});
      } else {
        updates["credits"] = reference["credits"]; // TODO: Merge?
      } 
      reference["credits"][idx] = update;
      frozen["credits"][idx] = true;
      return this;
    }

    this.creditsSplice = (start: number, deleteCount: number, ...items: Credit[]): IScoreHeaderBuilder => {
      makeReference("credits");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["credits"][idx]) {
            throw new Error("Replacing credits." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["credits"][idx];
          patches.push({p: ["credits", idx], ld, li: items[idx - start]});
          frozen["credits"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["credits"][idx]) {
            throw new Error("Removing credits." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["credits"][idx];
          patches.push({p: ["credits", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["credits", idx], li: items[idx - start]});
          frozen["credits"][idx] = true;
        }
      }
      reference["credits"].splice(start, deleteCount, ...items);
      updates["credits"] = reference["credits"];
      frozen["credits"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.partList = (spec: PartList): IScoreHeaderBuilder => {
        updates["partList"] = spec;
        delete childBuilders["partList;"];
        modifiedKeys["partList"] = true;
        return this;
    }

    this.movementNumber = (spec: string): IScoreHeaderBuilder => {
        updates["movementNumber"] = spec;
        delete childBuilders["movementNumber;"];
        modifiedKeys["movementNumber"] = true;
        return this;
    }
  }
}
export function patchScoreHeader(base: ScoreHeader, builder: (build: IScoreHeaderBuilder) => IScoreHeaderBuilder): IAny[] { return builder(new ScoreHeaderBuilder(base)).patch(); }
export function buildScoreHeader(builder: (build: IScoreHeaderBuilder) => IScoreHeaderBuilder): ScoreHeader { return builder(new ScoreHeaderBuilder()).build(); }

export interface IScoreTimewiseBuilder {
  build?: () => ScoreTimewise;
  patch: () => IAny[];
  measuresAt: (idx: number, build: Measure | ((builder: IMeasureBuilder) => IMeasureBuilder)) => IScoreTimewiseBuilder;
  measuresSplice: (start: number, deleteCount: number, ...items: Measure[]) => IScoreTimewiseBuilder;
  measures: (measures: Measure[]) => IScoreTimewiseBuilder;
  version: (version: string) => IScoreTimewiseBuilder;
  movementTitle: (movementTitle: string) => IScoreTimewiseBuilder;
  identification: (build: Identification | ((builder: IIdentificationBuilder) => IIdentificationBuilder)) => IScoreTimewiseBuilder;
  defaults: (build: Defaults | ((builder: IDefaultsBuilder) => IDefaultsBuilder)) => IScoreTimewiseBuilder;
  work: (build: Work | ((builder: IWorkBuilder) => IWorkBuilder)) => IScoreTimewiseBuilder;
  creditsAt: (idx: number, build: Credit | ((builder: ICreditBuilder) => ICreditBuilder)) => IScoreTimewiseBuilder;
  creditsSplice: (start: number, deleteCount: number, ...items: Credit[]) => IScoreTimewiseBuilder;
  credits: (credits: Credit[]) => IScoreTimewiseBuilder;
  partList: (partList: PartList) => IScoreTimewiseBuilder;
  movementNumber: (movementNumber: string) => IScoreTimewiseBuilder;
}

class ScoreTimewiseBuilder implements IScoreTimewiseBuilder {
  build: () => ScoreTimewise;
  patch: () => IAny[];
  measuresAt: (idx: number, build: Measure | ((builder: IMeasureBuilder) => IMeasureBuilder)) => IScoreTimewiseBuilder;
  measuresSplice: (start: number, deleteCount: number, ...items: Measure[]) => IScoreTimewiseBuilder;
  measures: (measures: Measure[]) => IScoreTimewiseBuilder;
  version: (version: string) => IScoreTimewiseBuilder;
  movementTitle: (movementTitle: string) => IScoreTimewiseBuilder;
  identification: (build: Identification | ((builder: IIdentificationBuilder) => IIdentificationBuilder)) => IScoreTimewiseBuilder;
  defaults: (build: Defaults | ((builder: IDefaultsBuilder) => IDefaultsBuilder)) => IScoreTimewiseBuilder;
  work: (build: Work | ((builder: IWorkBuilder) => IWorkBuilder)) => IScoreTimewiseBuilder;
  creditsAt: (idx: number, build: Credit | ((builder: ICreditBuilder) => ICreditBuilder)) => IScoreTimewiseBuilder;
  creditsSplice: (start: number, deleteCount: number, ...items: Credit[]) => IScoreTimewiseBuilder;
  credits: (credits: Credit[]) => IScoreTimewiseBuilder;
  partList: (partList: PartList) => IScoreTimewiseBuilder;
  movementNumber: (movementNumber: string) => IScoreTimewiseBuilder;
  constructor(original?: ScoreTimewise) {
    let updates: ScoreTimewise = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["measures"]) ||
          childBuilders["measures"] !== undefined ||
          updates.measures !== undefined,
        "measures is a required field");
      console.assert(
          (original && !modifiedKeys["version"]) ||
          childBuilders["version"] !== undefined ||
          updates.version !== undefined,
        "version is a required field");
      console.assert(
          (original && !modifiedKeys["movementTitle"]) ||
          childBuilders["movementTitle"] !== undefined ||
          updates.movementTitle !== undefined,
        "movementTitle is a required field");
      console.assert(
          (original && !modifiedKeys["identification"]) ||
          childBuilders["identification"] !== undefined ||
          updates.identification !== undefined,
        "identification is a required field");
      console.assert(
          (original && !modifiedKeys["defaults"]) ||
          childBuilders["defaults"] !== undefined ||
          updates.defaults !== undefined,
        "defaults is a required field");
      console.assert(
          (original && !modifiedKeys["work"]) ||
          childBuilders["work"] !== undefined ||
          updates.work !== undefined,
        "work is a required field");
      console.assert(
          (original && !modifiedKeys["credits"]) ||
          childBuilders["credits"] !== undefined ||
          updates.credits !== undefined,
        "credits is a required field");
      console.assert(
          (original && !modifiedKeys["partList"]) ||
          childBuilders["partList"] !== undefined ||
          updates.partList !== undefined,
        "partList is a required field");
      console.assert(
          (original && !modifiedKeys["movementNumber"]) ||
          childBuilders["movementNumber"] !== undefined ||
          updates.movementNumber !== undefined,
        "movementNumber is a required field");
    }

    if (!original) {
      this.build = (): ScoreTimewise => {
        checkInvariants();
        (updates as any)._class = "ScoreTimewise";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.measures = (spec: Measure[]): IScoreTimewiseBuilder => {
        updates["measures"] = spec;
        delete childBuilders["measures;"];
        modifiedKeys["measures"] = true;
        return this;
    }

    this.measuresAt = (idx: number, build: Measure | ((builder: IMeasureBuilder) => IMeasureBuilder)): IScoreTimewiseBuilder => {
      makeReference("measures");
      if (frozen["measures"][idx]) {
          throw new Error("Patching measures." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["measures"] && !original["measures"]) {
          // Clone snapshot.
          patches.push({p: ["measures", idx], li: original._snapshot["measures"]});
      }
      if (typeof build === 'function' && reference["measures"][idx]) {
        let patch = (build as any)(new MeasureBuilder(reference["measures"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["measures", idx].concat(patch.p);
          return patch;
        }));
        frozen["measures"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new MeasureBuilder(reference["measures"][idx])).build() : build;
      if (original) {
        patches.push({p: ["measures", idx], li: update});
      } else {
        updates["measures"] = reference["measures"]; // TODO: Merge?
      } 
      reference["measures"][idx] = update;
      frozen["measures"][idx] = true;
      return this;
    }

    this.measuresSplice = (start: number, deleteCount: number, ...items: Measure[]): IScoreTimewiseBuilder => {
      makeReference("measures");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["measures"][idx]) {
            throw new Error("Replacing measures." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["measures"][idx];
          patches.push({p: ["measures", idx], ld, li: items[idx - start]});
          frozen["measures"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["measures"][idx]) {
            throw new Error("Removing measures." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["measures"][idx];
          patches.push({p: ["measures", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["measures", idx], li: items[idx - start]});
          frozen["measures"][idx] = true;
        }
      }
      reference["measures"].splice(start, deleteCount, ...items);
      updates["measures"] = reference["measures"];
      frozen["measures"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.version = (spec: string): IScoreTimewiseBuilder => {
        updates["version"] = spec;
        delete childBuilders["version;"];
        modifiedKeys["version"] = true;
        return this;
    }

    this.movementTitle = (spec: string): IScoreTimewiseBuilder => {
        updates["movementTitle"] = spec;
        delete childBuilders["movementTitle;"];
        modifiedKeys["movementTitle"] = true;
        return this;
    }

    this.identification = (build: Identification | ((builder: IIdentificationBuilder) => IIdentificationBuilder)): IScoreTimewiseBuilder => {
      if (typeof build === 'function') {
        delete updates["identification"]
        const builder = (build as any)(new IdentificationBuilder(original && original["identification"]));
        if (!original) updates["identification"] = builder.build();
        else childBuilders["identification"] = builder;
      } else {
        updates.identification = build as any;
        delete childBuilders["identification;"];
      }
      modifiedKeys["identification"] = true;
      return this;
    }

    this.defaults = (build: Defaults | ((builder: IDefaultsBuilder) => IDefaultsBuilder)): IScoreTimewiseBuilder => {
      if (typeof build === 'function') {
        delete updates["defaults"]
        const builder = (build as any)(new DefaultsBuilder(original && original["defaults"]));
        if (!original) updates["defaults"] = builder.build();
        else childBuilders["defaults"] = builder;
      } else {
        updates.defaults = build as any;
        delete childBuilders["defaults;"];
      }
      modifiedKeys["defaults"] = true;
      return this;
    }

    this.work = (build: Work | ((builder: IWorkBuilder) => IWorkBuilder)): IScoreTimewiseBuilder => {
      if (typeof build === 'function') {
        delete updates["work"]
        const builder = (build as any)(new WorkBuilder(original && original["work"]));
        if (!original) updates["work"] = builder.build();
        else childBuilders["work"] = builder;
      } else {
        updates.work = build as any;
        delete childBuilders["work;"];
      }
      modifiedKeys["work"] = true;
      return this;
    }

    this.credits = (spec: Credit[]): IScoreTimewiseBuilder => {
        updates["credits"] = spec;
        delete childBuilders["credits;"];
        modifiedKeys["credits"] = true;
        return this;
    }

    this.creditsAt = (idx: number, build: Credit | ((builder: ICreditBuilder) => ICreditBuilder)): IScoreTimewiseBuilder => {
      makeReference("credits");
      if (frozen["credits"][idx]) {
          throw new Error("Patching credits." + idx + " twice in a builder is unsupported.");
      }
      if (original && original._snapshot && original._snapshot["credits"] && !original["credits"]) {
          // Clone snapshot.
          patches.push({p: ["credits", idx], li: original._snapshot["credits"]});
      }
      if (typeof build === 'function' && reference["credits"][idx]) {
        let patch = (build as any)(new CreditBuilder(reference["credits"][idx])).patch();
        patches = patches.concat(patch.map(patch => {
          // TODO: detach?
          patch.p = ["credits", idx].concat(patch.p);
          return patch;
        }));
        frozen["credits"][idx] = true;
        return this;
      }
      let update = typeof build === 'function' ? (build as any)(new CreditBuilder(reference["credits"][idx])).build() : build;
      if (original) {
        patches.push({p: ["credits", idx], li: update});
      } else {
        updates["credits"] = reference["credits"]; // TODO: Merge?
      } 
      reference["credits"][idx] = update;
      frozen["credits"][idx] = true;
      return this;
    }

    this.creditsSplice = (start: number, deleteCount: number, ...items: Credit[]): IScoreTimewiseBuilder => {
      makeReference("credits");
      let idx = start;
      if (original) {
        for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
          if (frozen["credits"][idx]) {
            throw new Error("Replacing credits." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["credits"][idx];
          patches.push({p: ["credits", idx], ld, li: items[idx - start]});
          frozen["credits"][idx] = true;
        }
        for (; idx < start + deleteCount; ++idx) {
          if (frozen["credits"][idx]) {
            throw new Error("Removing credits." + idx + " after patching in a builder is unsupported.");
          }
          let ld = reference["credits"][idx];
          patches.push({p: ["credits", idx], ld});
        }
        for (; idx < start + items.length; ++idx) {
          patches.push({p: ["credits", idx], li: items[idx - start]});
          frozen["credits"][idx] = true;
        }
      }
      reference["credits"].splice(start, deleteCount, ...items);
      updates["credits"] = reference["credits"];
      frozen["credits"].splice(start, deleteCount, ...items.map(i => true));
      return this;
    }

    this.partList = (spec: PartList): IScoreTimewiseBuilder => {
        updates["partList"] = spec;
        delete childBuilders["partList;"];
        modifiedKeys["partList"] = true;
        return this;
    }

    this.movementNumber = (spec: string): IScoreTimewiseBuilder => {
        updates["movementNumber"] = spec;
        delete childBuilders["movementNumber;"];
        modifiedKeys["movementNumber"] = true;
        return this;
    }
  }
}
export function patchScoreTimewise(base: ScoreTimewise, builder: (build: IScoreTimewiseBuilder) => IScoreTimewiseBuilder): IAny[] { return builder(new ScoreTimewiseBuilder(base)).patch(); }
export function buildScoreTimewise(builder: (build: IScoreTimewiseBuilder) => IScoreTimewiseBuilder): ScoreTimewise { return builder(new ScoreTimewiseBuilder()).build(); }

export interface IMeasureBuilder {
  build?: () => Measure;
  patch: () => IAny[];
  number: (number: string) => IMeasureBuilder;
  implicit: (implicit: boolean) => IMeasureBuilder;
  width: (width: number) => IMeasureBuilder;
  set: (key: string, val: boolean[]) => IMeasureBuilder;
  nonControlling: (nonControlling: boolean) => IMeasureBuilder;
}

class MeasureBuilder implements IMeasureBuilder {
  build: () => Measure;
  patch: () => IAny[];
  number: (number: string) => IMeasureBuilder;
  implicit: (implicit: boolean) => IMeasureBuilder;
  width: (width: number) => IMeasureBuilder;
  set: (key: string, val: boolean[]) => IMeasureBuilder;
  nonControlling: (nonControlling: boolean) => IMeasureBuilder;
  constructor(original?: Measure) {
    let updates: Measure = {} as any;
    let childBuilders: {[key: string]: any} = {};
    let modifiedKeys: {[key: string]: boolean} = {};
    let reference: {[key: string]: any[]} = {};
    let frozen: {[key: string]: boolean[]} = {};
    let patches: any[] = [];

    function makeReference(fieldName: string) {
      if (!reference[fieldName]) {
        if (original) {
          reference[fieldName] = ((original._snapshot || original)[fieldName] as any[] || [] as any[]).slice();
        } else {
          reference[fieldName] = [];
        }
        frozen[fieldName] = reference[fieldName].map(a => false);
      }
    }
    
    function checkInvariants() {
      console.assert(
          (original && !modifiedKeys["number"]) ||
          childBuilders["number"] !== undefined ||
          updates.number !== undefined,
        "number is a required field");
    }

    if (!original) {
      this.build = (): Measure => {
        checkInvariants();
        (updates as any)._class = "Measure";
        return updates;
      }
    }
    this.patch = (): any[] => {
      checkInvariants();
      return makePatch(original, updates, childBuilders, patches, modifiedKeys);
    }

    this.number = (spec: string): IMeasureBuilder => {
        updates["number"] = spec;
        delete childBuilders["number;"];
        modifiedKeys["number"] = true;
        return this;
    }

    this.implicit = (spec: boolean): IMeasureBuilder => {
        updates["implicit"] = spec;
        delete childBuilders["implicit;"];
        modifiedKeys["implicit"] = true;
        return this;
    }

    this.width = (spec: number): IMeasureBuilder => {
        updates["width"] = spec;
        delete childBuilders["width;"];
        modifiedKeys["width"] = true;
        return this;
    }
    this.set = (key: string, val: boolean[]): IMeasureBuilder => {
      updates[key] = val;
      modifiedKeys[key] = true;
      return this;
    }

    this.nonControlling = (spec: boolean): IMeasureBuilder => {
        updates["nonControlling"] = spec;
        delete childBuilders["nonControlling;"];
        modifiedKeys["nonControlling"] = true;
        return this;
    }
  }
}
export function patchMeasure(base: Measure, builder: (build: IMeasureBuilder) => IMeasureBuilder): IAny[] { return builder(new MeasureBuilder(base)).patch(); }
export function buildMeasure(builder: (build: IMeasureBuilder) => IMeasureBuilder): Measure { return builder(new MeasureBuilder()).build(); }

