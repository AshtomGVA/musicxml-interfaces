// Auto-generated by emitBuilders.js. Modification is unwise.

import {StartStop, StartStopContinue, StartStopSingle, SymbolSize, AboveBelow, OverUnder, UpDown, TopBottom, LeftRight, EnclosureShape, NormalItalic, NormalBold, LeftCenterRight, TopMiddleBottomBaseline, DirectionMode, StraightCurved, SolidDashedDottedWavy, NormalAngledSquare, UprightInverted, UpperMainBelow, WholeHalfUnison, WholeHalfNone, OddEvenBoth, CueGraceLarge, SeparatorType, TimeSymbolType, CancelLocation, PartSymbolType, ShowFretsType, Count, MxmlAccidental, StemType, NoteheadType, BeamType, AccelRitNone, ActualBothNone, HoleLocation, HoleClosedType, BreathMarkType, SyllabicType, BarlineLocation, BarStyleType, StartStopDiscontinue, WingedType, DirectionTypeBg, TipDirection, WedgeType, LineEndType, PedalType, OctaveShiftType, VoiceSymbol, ExplicitImpliedAlternate, ChordType, TextArray, EncodingDate, CalendarDate, Position, Placement, Orientation, DirectiveEntity, Bezier, Font, Color, TextDecoration, Justify, Halign, Valign, ValignImage, LetterSpacing, LineHeight, TextDirection, TextRotation, Enclosure, PrintStyle, PrintStyleAlign, LineShape, LineType, DashedFormatting, PrintObject, PrintSpacing, Printout, TextFormatting, LevelDisplay, TrillSound, BendSound, TimeOnly, DocumentAttributes, Editorial, EditorialVoice, Footnote, Level, Fermata, WavyLine, Segno, Coda, NormalDot, Dynamics, Fingering, Fret, String, DisplayText, AccidentalText, PartNameDisplay, PartAbbreviationDisplay, MidiDevice, MidiInstrument, Play, OtherPlay, Scaling, PageMargins, PageLayout, SystemLayout, SystemMargins, SystemDividers, LeftDivider, RightDivider, StaffLayout, MeasureLayout, LineWidth, NoteSize, Distance, Appearance, Creator, Rights, Encoder, Relation, MiscellaneousField, Miscellaneous, Identification, Supports, Encoding, TimeSeparator, TimeSymbol, Cancel, KeyOctave, Key, Time, Interchangeable, PartSymbol, Clef, StaffTuning, StaffDetails, Double, Transpose, Directive, SlashDot, MultipleRest, MeasureRepeat, BeatRepeat, Slash, MeasureStyle, Attributes, Cue, Grace, Chord, Unpitched, Pitch, FullNote, Rest, Tie, Instrument, Note, Type, Dot, Accidental, TimeModification, Stem, Notehead, NoteheadText, Beam, Notations, Tied, Slur, Tuplet, TupletActual, TupletNormal, TupletNumber, TupletType, TupletDot, Glissando, Slide, OtherNotation, OtherDirection, Ornaments, TrillMark, Turn, DelayedTurn, InvertedTurn, DelayedInvertedTurn, VerticalTurn, Shake, Mordent, InvertedMordent, Schleifer, Tremolo, OtherOrnament, AccidentalMark, Technical, UpBow, DownBow, Harmonic, OpenString, ThumbPosition, Pluck, DoubleTongue, TripleTongue, Stopped, SnapPizzicato, HammerOn, PullOff, Bend, WithBar, Tap, Heel, Toe, Fingernails, Hole, HoleClosed, Arrow, Handbell, OtherTechnical, Articulations, Accent, StrongAccent, Staccato, Tenuto, DetachedLegato, Staccatissimo, Spiccato, Scoop, Plop, Doit, Falloff, BreathMark, Caesura, Stress, Unstress, OtherArticulation, Arpeggiate, NonArpeggiate, Laughing, Humming, EndLine, EndParagraph, LyricParts, Lyric, Text, Syllabic, Elision, Extend, FiguredBass, Figure, Prefix, FigureNumber, Suffix, Backup, Forward, Barline, BarStyle, Ending, Repeat, Direction, DirectionType, Rehearsal, Words, Wedge, Dashes, Bracket, Pedal, Metronome, BeatUnitDot, PerMinute, MetronomeNote, MetronomeDot, MetronomeBeam, MetronomeTuplet, OctaveShift, HarpPedals, PedalTuning, Damp, DampAll, Eyeglasses, StringMute, Scordatura, Accord, Image, PrincipalVoice, AccordionRegistration, Percussion, Timpani, Beater, Stick, Offset, HarmonyChord, Harmony, Root, RootStep, RootAlter, Function, Kind, Inversion, Bass, BassStep, BassAlter, Degree, DegreeValue, DegreeAlter, DegreeType, Frame, FirstFret, FrameNote, Barre, Grouping, Feature, Print, MeasureNumbering, Sound, Work, Opus, Defaults, MusicFont, WordFont, LyricFont, LyricLanguage, Credit, CreditWords, CreditImage, ScorePart, PartName, PartAbbreviation, PartGroup, GroupName, GroupNameDisplay, GroupAbbreviation, GroupAbbreviationDisplay, GroupSymbol, GroupBarline, GroupTime, ScoreInstrument, Solo, VirtualInstrument, ScoreHeader, ScoreTimewise, Measure, PartList} from "./musicxml-interfaces";

export interface ITextArrayBuilder {
  build: () => TextArray;
  patch: () => any[];
  acc: (build: (builder: IAccidentalTextBuilder) => IAccidentalTextBuilder) => ITextArrayBuilder;
  text: (build: (builder: IDisplayTextBuilder) => IDisplayTextBuilder) => ITextArrayBuilder;
}
class TextArrayBuilder implements ITextArrayBuilder{
  _p: TextArray = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TextArray;
  constructor(toPatch?: TextArray) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): TextArray {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TextArray";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  acc(build: (builder: IAccidentalTextBuilder) => IAccidentalTextBuilder): ITextArrayBuilder {
    this._b["acc"] = build(new AccidentalTextBuilder(this._o && this._o["acc"]));
    this._m["acc"] = true;
    return this;
  }
  text(build: (builder: IDisplayTextBuilder) => IDisplayTextBuilder): ITextArrayBuilder {
    this._b["text"] = build(new DisplayTextBuilder(this._o && this._o["text"]));
    this._m["text"] = true;
    return this;
  }
}
export function patchTextArray(base: TextArray): ITextArrayBuilder { return new TextArrayBuilder(base); }
export function buildTextArray(): ITextArrayBuilder { return new TextArrayBuilder(); }

export interface IEncodingDateBuilder {
  build: () => EncodingDate;
  patch: () => any[];
  month: (month: number) => IEncodingDateBuilder;
  day: (day: number) => IEncodingDateBuilder;
  year: (year: number) => IEncodingDateBuilder;
}
class EncodingDateBuilder implements IEncodingDateBuilder{
  _p: EncodingDate = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: EncodingDate;
  constructor(toPatch?: EncodingDate) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["month"]) || this._b["month"] !== undefined || this._p.month !== undefined, "month is a required field");
    console.assert((this._o && !this._m["day"]) || this._b["day"] !== undefined || this._p.day !== undefined, "day is a required field");
    console.assert((this._o && !this._m["year"]) || this._b["year"] !== undefined || this._p.year !== undefined, "year is a required field");
  }
  build(): EncodingDate {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "EncodingDate";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  month(month: number): IEncodingDateBuilder {
    this._p.month = month;
    this._m["month"] = true;
    return this;
  }
  day(day: number): IEncodingDateBuilder {
    this._p.day = day;
    this._m["day"] = true;
    return this;
  }
  year(year: number): IEncodingDateBuilder {
    this._p.year = year;
    this._m["year"] = true;
    return this;
  }
}
export function patchEncodingDate(base: EncodingDate): IEncodingDateBuilder { return new EncodingDateBuilder(base); }
export function buildEncodingDate(): IEncodingDateBuilder { return new EncodingDateBuilder(); }

export interface ICalendarDateBuilder {
  build: () => CalendarDate;
  patch: () => any[];
  month: (month: number) => ICalendarDateBuilder;
  day: (day: number) => ICalendarDateBuilder;
  year: (year: number) => ICalendarDateBuilder;
}
class CalendarDateBuilder implements ICalendarDateBuilder{
  _p: CalendarDate = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: CalendarDate;
  constructor(toPatch?: CalendarDate) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["month"]) || this._b["month"] !== undefined || this._p.month !== undefined, "month is a required field");
    console.assert((this._o && !this._m["day"]) || this._b["day"] !== undefined || this._p.day !== undefined, "day is a required field");
    console.assert((this._o && !this._m["year"]) || this._b["year"] !== undefined || this._p.year !== undefined, "year is a required field");
  }
  build(): CalendarDate {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "CalendarDate";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  month(month: number): ICalendarDateBuilder {
    this._p.month = month;
    this._m["month"] = true;
    return this;
  }
  day(day: number): ICalendarDateBuilder {
    this._p.day = day;
    this._m["day"] = true;
    return this;
  }
  year(year: number): ICalendarDateBuilder {
    this._p.year = year;
    this._m["year"] = true;
    return this;
  }
}
export function patchCalendarDate(base: CalendarDate): ICalendarDateBuilder { return new CalendarDateBuilder(base); }
export function buildCalendarDate(): ICalendarDateBuilder { return new CalendarDateBuilder(); }

export interface IPositionBuilder {
  build: () => Position;
  patch: () => any[];
  defaultX: (defaultX: number) => IPositionBuilder;
  relativeY: (relativeY: number) => IPositionBuilder;
  defaultY: (defaultY: number) => IPositionBuilder;
  relativeX: (relativeX: number) => IPositionBuilder;
}
class PositionBuilder implements IPositionBuilder{
  _p: Position = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Position;
  constructor(toPatch?: Position) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Position {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Position";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IPositionBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IPositionBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IPositionBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IPositionBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchPosition(base: Position): IPositionBuilder { return new PositionBuilder(base); }
export function buildPosition(): IPositionBuilder { return new PositionBuilder(); }

export interface IPlacementBuilder {
  build: () => Placement;
  patch: () => any[];
  placement: (placement: AboveBelow) => IPlacementBuilder;
}
class PlacementBuilder implements IPlacementBuilder{
  _p: Placement = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Placement;
  constructor(toPatch?: Placement) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Placement {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Placement";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  placement(placement: AboveBelow): IPlacementBuilder {
    this._p.placement = placement;
    this._m["placement"] = true;
    return this;
  }
}
export function patchPlacement(base: Placement): IPlacementBuilder { return new PlacementBuilder(base); }
export function buildPlacement(): IPlacementBuilder { return new PlacementBuilder(); }

export interface IOrientationBuilder {
  build: () => Orientation;
  patch: () => any[];
  orientation: (orientation: OverUnder) => IOrientationBuilder;
}
class OrientationBuilder implements IOrientationBuilder{
  _p: Orientation = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Orientation;
  constructor(toPatch?: Orientation) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Orientation {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Orientation";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  orientation(orientation: OverUnder): IOrientationBuilder {
    this._p.orientation = orientation;
    this._m["orientation"] = true;
    return this;
  }
}
export function patchOrientation(base: Orientation): IOrientationBuilder { return new OrientationBuilder(base); }
export function buildOrientation(): IOrientationBuilder { return new OrientationBuilder(); }

export interface IDirectiveEntityBuilder {
  build: () => DirectiveEntity;
  patch: () => any[];
  directive: (directive: boolean) => IDirectiveEntityBuilder;
}
class DirectiveEntityBuilder implements IDirectiveEntityBuilder{
  _p: DirectiveEntity = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: DirectiveEntity;
  constructor(toPatch?: DirectiveEntity) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): DirectiveEntity {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "DirectiveEntity";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  directive(directive: boolean): IDirectiveEntityBuilder {
    this._p.directive = directive;
    this._m["directive"] = true;
    return this;
  }
}
export function patchDirectiveEntity(base: DirectiveEntity): IDirectiveEntityBuilder { return new DirectiveEntityBuilder(base); }
export function buildDirectiveEntity(): IDirectiveEntityBuilder { return new DirectiveEntityBuilder(); }

export interface IBezierBuilder {
  build: () => Bezier;
  patch: () => any[];
  bezierX2: (bezierX2: number) => IBezierBuilder;
  bezierOffset: (bezierOffset: number) => IBezierBuilder;
  bezierOffset2: (bezierOffset2: number) => IBezierBuilder;
  bezierX: (bezierX: number) => IBezierBuilder;
  bezierY: (bezierY: number) => IBezierBuilder;
  bezierY2: (bezierY2: number) => IBezierBuilder;
}
class BezierBuilder implements IBezierBuilder{
  _p: Bezier = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Bezier;
  constructor(toPatch?: Bezier) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Bezier {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Bezier";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  bezierX2(bezierX2: number): IBezierBuilder {
    this._p.bezierX2 = bezierX2;
    this._m["bezierX2"] = true;
    return this;
  }
  bezierOffset(bezierOffset: number): IBezierBuilder {
    this._p.bezierOffset = bezierOffset;
    this._m["bezierOffset"] = true;
    return this;
  }
  bezierOffset2(bezierOffset2: number): IBezierBuilder {
    this._p.bezierOffset2 = bezierOffset2;
    this._m["bezierOffset2"] = true;
    return this;
  }
  bezierX(bezierX: number): IBezierBuilder {
    this._p.bezierX = bezierX;
    this._m["bezierX"] = true;
    return this;
  }
  bezierY(bezierY: number): IBezierBuilder {
    this._p.bezierY = bezierY;
    this._m["bezierY"] = true;
    return this;
  }
  bezierY2(bezierY2: number): IBezierBuilder {
    this._p.bezierY2 = bezierY2;
    this._m["bezierY2"] = true;
    return this;
  }
}
export function patchBezier(base: Bezier): IBezierBuilder { return new BezierBuilder(base); }
export function buildBezier(): IBezierBuilder { return new BezierBuilder(); }

export interface IFontBuilder {
  build: () => Font;
  patch: () => any[];
  fontFamily: (fontFamily: string) => IFontBuilder;
  fontWeight: (fontWeight: NormalBold) => IFontBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFontBuilder;
  fontSize: (fontSize: string) => IFontBuilder;
}
class FontBuilder implements IFontBuilder{
  _p: Font = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Font;
  constructor(toPatch?: Font) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Font {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Font";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  fontFamily(fontFamily: string): IFontBuilder {
    this._p.fontFamily = fontFamily;
    this._m["fontFamily"] = true;
    return this;
  }
  fontWeight(fontWeight: NormalBold): IFontBuilder {
    this._p.fontWeight = fontWeight;
    this._m["fontWeight"] = true;
    return this;
  }
  fontStyle(fontStyle: NormalItalic): IFontBuilder {
    this._p.fontStyle = fontStyle;
    this._m["fontStyle"] = true;
    return this;
  }
  fontSize(fontSize: string): IFontBuilder {
    this._p.fontSize = fontSize;
    this._m["fontSize"] = true;
    return this;
  }
}
export function patchFont(base: Font): IFontBuilder { return new FontBuilder(base); }
export function buildFont(): IFontBuilder { return new FontBuilder(); }

export interface IColorBuilder {
  build: () => Color;
  patch: () => any[];
  color: (color: string) => IColorBuilder;
}
class ColorBuilder implements IColorBuilder{
  _p: Color = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Color;
  constructor(toPatch?: Color) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Color {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Color";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  color(color: string): IColorBuilder {
    this._p.color = color;
    this._m["color"] = true;
    return this;
  }
}
export function patchColor(base: Color): IColorBuilder { return new ColorBuilder(base); }
export function buildColor(): IColorBuilder { return new ColorBuilder(); }

export interface ITextDecorationBuilder {
  build: () => TextDecoration;
  patch: () => any[];
  underline: (underline: number) => ITextDecorationBuilder;
  overline: (overline: number) => ITextDecorationBuilder;
  lineThrough: (lineThrough: number) => ITextDecorationBuilder;
}
class TextDecorationBuilder implements ITextDecorationBuilder{
  _p: TextDecoration = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TextDecoration;
  constructor(toPatch?: TextDecoration) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): TextDecoration {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TextDecoration";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  underline(underline: number): ITextDecorationBuilder {
    this._p.underline = underline;
    this._m["underline"] = true;
    return this;
  }
  overline(overline: number): ITextDecorationBuilder {
    this._p.overline = overline;
    this._m["overline"] = true;
    return this;
  }
  lineThrough(lineThrough: number): ITextDecorationBuilder {
    this._p.lineThrough = lineThrough;
    this._m["lineThrough"] = true;
    return this;
  }
}
export function patchTextDecoration(base: TextDecoration): ITextDecorationBuilder { return new TextDecorationBuilder(base); }
export function buildTextDecoration(): ITextDecorationBuilder { return new TextDecorationBuilder(); }

export interface IJustifyBuilder {
  build: () => Justify;
  patch: () => any[];
  justify: (justify: LeftCenterRight) => IJustifyBuilder;
}
class JustifyBuilder implements IJustifyBuilder{
  _p: Justify = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Justify;
  constructor(toPatch?: Justify) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Justify {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Justify";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  justify(justify: LeftCenterRight): IJustifyBuilder {
    this._p.justify = justify;
    this._m["justify"] = true;
    return this;
  }
}
export function patchJustify(base: Justify): IJustifyBuilder { return new JustifyBuilder(base); }
export function buildJustify(): IJustifyBuilder { return new JustifyBuilder(); }

export interface IHalignBuilder {
  build: () => Halign;
  patch: () => any[];
  halign: (halign: LeftCenterRight) => IHalignBuilder;
}
class HalignBuilder implements IHalignBuilder{
  _p: Halign = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Halign;
  constructor(toPatch?: Halign) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Halign {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Halign";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  halign(halign: LeftCenterRight): IHalignBuilder {
    this._p.halign = halign;
    this._m["halign"] = true;
    return this;
  }
}
export function patchHalign(base: Halign): IHalignBuilder { return new HalignBuilder(base); }
export function buildHalign(): IHalignBuilder { return new HalignBuilder(); }

export interface IValignBuilder {
  build: () => Valign;
  patch: () => any[];
  valign: (valign: TopMiddleBottomBaseline) => IValignBuilder;
}
class ValignBuilder implements IValignBuilder{
  _p: Valign = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Valign;
  constructor(toPatch?: Valign) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Valign {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Valign";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  valign(valign: TopMiddleBottomBaseline): IValignBuilder {
    this._p.valign = valign;
    this._m["valign"] = true;
    return this;
  }
}
export function patchValign(base: Valign): IValignBuilder { return new ValignBuilder(base); }
export function buildValign(): IValignBuilder { return new ValignBuilder(); }

export interface IValignImageBuilder {
  build: () => ValignImage;
  patch: () => any[];
  valignImage: (valignImage: TopMiddleBottomBaseline) => IValignImageBuilder;
}
class ValignImageBuilder implements IValignImageBuilder{
  _p: ValignImage = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: ValignImage;
  constructor(toPatch?: ValignImage) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): ValignImage {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "ValignImage";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  valignImage(valignImage: TopMiddleBottomBaseline): IValignImageBuilder {
    this._p.valignImage = valignImage;
    this._m["valignImage"] = true;
    return this;
  }
}
export function patchValignImage(base: ValignImage): IValignImageBuilder { return new ValignImageBuilder(base); }
export function buildValignImage(): IValignImageBuilder { return new ValignImageBuilder(); }

export interface ILetterSpacingBuilder {
  build: () => LetterSpacing;
  patch: () => any[];
  letterSpacing: (letterSpacing: string) => ILetterSpacingBuilder;
}
class LetterSpacingBuilder implements ILetterSpacingBuilder{
  _p: LetterSpacing = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: LetterSpacing;
  constructor(toPatch?: LetterSpacing) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): LetterSpacing {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "LetterSpacing";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  letterSpacing(letterSpacing: string): ILetterSpacingBuilder {
    this._p.letterSpacing = letterSpacing;
    this._m["letterSpacing"] = true;
    return this;
  }
}
export function patchLetterSpacing(base: LetterSpacing): ILetterSpacingBuilder { return new LetterSpacingBuilder(base); }
export function buildLetterSpacing(): ILetterSpacingBuilder { return new LetterSpacingBuilder(); }

export interface ILineHeightBuilder {
  build: () => LineHeight;
  patch: () => any[];
  lineHeight: (lineHeight: string) => ILineHeightBuilder;
}
class LineHeightBuilder implements ILineHeightBuilder{
  _p: LineHeight = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: LineHeight;
  constructor(toPatch?: LineHeight) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): LineHeight {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "LineHeight";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  lineHeight(lineHeight: string): ILineHeightBuilder {
    this._p.lineHeight = lineHeight;
    this._m["lineHeight"] = true;
    return this;
  }
}
export function patchLineHeight(base: LineHeight): ILineHeightBuilder { return new LineHeightBuilder(base); }
export function buildLineHeight(): ILineHeightBuilder { return new LineHeightBuilder(); }

export interface ITextDirectionBuilder {
  build: () => TextDirection;
  patch: () => any[];
  dir: (dir: DirectionMode) => ITextDirectionBuilder;
}
class TextDirectionBuilder implements ITextDirectionBuilder{
  _p: TextDirection = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TextDirection;
  constructor(toPatch?: TextDirection) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): TextDirection {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TextDirection";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  dir(dir: DirectionMode): ITextDirectionBuilder {
    this._p.dir = dir;
    this._m["dir"] = true;
    return this;
  }
}
export function patchTextDirection(base: TextDirection): ITextDirectionBuilder { return new TextDirectionBuilder(base); }
export function buildTextDirection(): ITextDirectionBuilder { return new TextDirectionBuilder(); }

export interface ITextRotationBuilder {
  build: () => TextRotation;
  patch: () => any[];
  rotation: (rotation: number) => ITextRotationBuilder;
}
class TextRotationBuilder implements ITextRotationBuilder{
  _p: TextRotation = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TextRotation;
  constructor(toPatch?: TextRotation) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): TextRotation {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TextRotation";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  rotation(rotation: number): ITextRotationBuilder {
    this._p.rotation = rotation;
    this._m["rotation"] = true;
    return this;
  }
}
export function patchTextRotation(base: TextRotation): ITextRotationBuilder { return new TextRotationBuilder(base); }
export function buildTextRotation(): ITextRotationBuilder { return new TextRotationBuilder(); }

export interface IEnclosureBuilder {
  build: () => Enclosure;
  patch: () => any[];
  enclosure: (enclosure: EnclosureShape) => IEnclosureBuilder;
}
class EnclosureBuilder implements IEnclosureBuilder{
  _p: Enclosure = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Enclosure;
  constructor(toPatch?: Enclosure) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Enclosure {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Enclosure";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  enclosure(enclosure: EnclosureShape): IEnclosureBuilder {
    this._p.enclosure = enclosure;
    this._m["enclosure"] = true;
    return this;
  }
}
export function patchEnclosure(base: Enclosure): IEnclosureBuilder { return new EnclosureBuilder(base); }
export function buildEnclosure(): IEnclosureBuilder { return new EnclosureBuilder(); }

export interface IPrintStyleBuilder {
  build: () => PrintStyle;
  patch: () => any[];
  defaultX: (defaultX: number) => IPrintStyleBuilder;
  relativeY: (relativeY: number) => IPrintStyleBuilder;
  defaultY: (defaultY: number) => IPrintStyleBuilder;
  relativeX: (relativeX: number) => IPrintStyleBuilder;
}
class PrintStyleBuilder implements IPrintStyleBuilder{
  _p: PrintStyle = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PrintStyle;
  constructor(toPatch?: PrintStyle) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): PrintStyle {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PrintStyle";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IPrintStyleBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IPrintStyleBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IPrintStyleBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IPrintStyleBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchPrintStyle(base: PrintStyle): IPrintStyleBuilder { return new PrintStyleBuilder(base); }
export function buildPrintStyle(): IPrintStyleBuilder { return new PrintStyleBuilder(); }

export interface IPrintStyleAlignBuilder {
  build: () => PrintStyleAlign;
  patch: () => any[];
  defaultX: (defaultX: number) => IPrintStyleAlignBuilder;
  relativeY: (relativeY: number) => IPrintStyleAlignBuilder;
  defaultY: (defaultY: number) => IPrintStyleAlignBuilder;
  relativeX: (relativeX: number) => IPrintStyleAlignBuilder;
}
class PrintStyleAlignBuilder implements IPrintStyleAlignBuilder{
  _p: PrintStyleAlign = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PrintStyleAlign;
  constructor(toPatch?: PrintStyleAlign) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): PrintStyleAlign {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PrintStyleAlign";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IPrintStyleAlignBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IPrintStyleAlignBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IPrintStyleAlignBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IPrintStyleAlignBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchPrintStyleAlign(base: PrintStyleAlign): IPrintStyleAlignBuilder { return new PrintStyleAlignBuilder(base); }
export function buildPrintStyleAlign(): IPrintStyleAlignBuilder { return new PrintStyleAlignBuilder(); }

export interface ILineShapeBuilder {
  build: () => LineShape;
  patch: () => any[];
  lineShape: (lineShape: StraightCurved) => ILineShapeBuilder;
}
class LineShapeBuilder implements ILineShapeBuilder{
  _p: LineShape = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: LineShape;
  constructor(toPatch?: LineShape) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): LineShape {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "LineShape";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  lineShape(lineShape: StraightCurved): ILineShapeBuilder {
    this._p.lineShape = lineShape;
    this._m["lineShape"] = true;
    return this;
  }
}
export function patchLineShape(base: LineShape): ILineShapeBuilder { return new LineShapeBuilder(base); }
export function buildLineShape(): ILineShapeBuilder { return new LineShapeBuilder(); }

export interface ILineTypeBuilder {
  build: () => LineType;
  patch: () => any[];
  lineType: (lineType: SolidDashedDottedWavy) => ILineTypeBuilder;
}
class LineTypeBuilder implements ILineTypeBuilder{
  _p: LineType = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: LineType;
  constructor(toPatch?: LineType) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): LineType {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "LineType";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  lineType(lineType: SolidDashedDottedWavy): ILineTypeBuilder {
    this._p.lineType = lineType;
    this._m["lineType"] = true;
    return this;
  }
}
export function patchLineType(base: LineType): ILineTypeBuilder { return new LineTypeBuilder(base); }
export function buildLineType(): ILineTypeBuilder { return new LineTypeBuilder(); }

export interface IDashedFormattingBuilder {
  build: () => DashedFormatting;
  patch: () => any[];
  dashLength: (dashLength: number) => IDashedFormattingBuilder;
  spaceLength: (spaceLength: number) => IDashedFormattingBuilder;
}
class DashedFormattingBuilder implements IDashedFormattingBuilder{
  _p: DashedFormatting = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: DashedFormatting;
  constructor(toPatch?: DashedFormatting) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): DashedFormatting {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "DashedFormatting";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  dashLength(dashLength: number): IDashedFormattingBuilder {
    this._p.dashLength = dashLength;
    this._m["dashLength"] = true;
    return this;
  }
  spaceLength(spaceLength: number): IDashedFormattingBuilder {
    this._p.spaceLength = spaceLength;
    this._m["spaceLength"] = true;
    return this;
  }
}
export function patchDashedFormatting(base: DashedFormatting): IDashedFormattingBuilder { return new DashedFormattingBuilder(base); }
export function buildDashedFormatting(): IDashedFormattingBuilder { return new DashedFormattingBuilder(); }

export interface IPrintObjectBuilder {
  build: () => PrintObject;
  patch: () => any[];
  printObject: (printObject: boolean) => IPrintObjectBuilder;
}
class PrintObjectBuilder implements IPrintObjectBuilder{
  _p: PrintObject = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PrintObject;
  constructor(toPatch?: PrintObject) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): PrintObject {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PrintObject";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  printObject(printObject: boolean): IPrintObjectBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchPrintObject(base: PrintObject): IPrintObjectBuilder { return new PrintObjectBuilder(base); }
export function buildPrintObject(): IPrintObjectBuilder { return new PrintObjectBuilder(); }

export interface IPrintSpacingBuilder {
  build: () => PrintSpacing;
  patch: () => any[];
  printSpacing: (printSpacing: boolean) => IPrintSpacingBuilder;
}
class PrintSpacingBuilder implements IPrintSpacingBuilder{
  _p: PrintSpacing = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PrintSpacing;
  constructor(toPatch?: PrintSpacing) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): PrintSpacing {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PrintSpacing";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  printSpacing(printSpacing: boolean): IPrintSpacingBuilder {
    this._p.printSpacing = printSpacing;
    this._m["printSpacing"] = true;
    return this;
  }
}
export function patchPrintSpacing(base: PrintSpacing): IPrintSpacingBuilder { return new PrintSpacingBuilder(base); }
export function buildPrintSpacing(): IPrintSpacingBuilder { return new PrintSpacingBuilder(); }

export interface IPrintoutBuilder {
  build: () => Printout;
  patch: () => any[];
  printDot: (printDot: boolean) => IPrintoutBuilder;
  printLyric: (printLyric: boolean) => IPrintoutBuilder;
  printObject: (printObject: boolean) => IPrintoutBuilder;
}
class PrintoutBuilder implements IPrintoutBuilder{
  _p: Printout = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Printout;
  constructor(toPatch?: Printout) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Printout {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Printout";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  printDot(printDot: boolean): IPrintoutBuilder {
    this._p.printDot = printDot;
    this._m["printDot"] = true;
    return this;
  }
  printLyric(printLyric: boolean): IPrintoutBuilder {
    this._p.printLyric = printLyric;
    this._m["printLyric"] = true;
    return this;
  }
  printObject(printObject: boolean): IPrintoutBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchPrintout(base: Printout): IPrintoutBuilder { return new PrintoutBuilder(base); }
export function buildPrintout(): IPrintoutBuilder { return new PrintoutBuilder(); }

export interface ITextFormattingBuilder {
  build: () => TextFormatting;
  patch: () => any[];
  justify: (justify: LeftCenterRight) => ITextFormattingBuilder;
}
class TextFormattingBuilder implements ITextFormattingBuilder{
  _p: TextFormatting = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TextFormatting;
  constructor(toPatch?: TextFormatting) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): TextFormatting {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TextFormatting";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  justify(justify: LeftCenterRight): ITextFormattingBuilder {
    this._p.justify = justify;
    this._m["justify"] = true;
    return this;
  }
}
export function patchTextFormatting(base: TextFormatting): ITextFormattingBuilder { return new TextFormattingBuilder(base); }
export function buildTextFormatting(): ITextFormattingBuilder { return new TextFormattingBuilder(); }

export interface ILevelDisplayBuilder {
  build: () => LevelDisplay;
  patch: () => any[];
  bracket: (bracket: boolean) => ILevelDisplayBuilder;
  size: (size: SymbolSize) => ILevelDisplayBuilder;
  parentheses: (parentheses: boolean) => ILevelDisplayBuilder;
}
class LevelDisplayBuilder implements ILevelDisplayBuilder{
  _p: LevelDisplay = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: LevelDisplay;
  constructor(toPatch?: LevelDisplay) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): LevelDisplay {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "LevelDisplay";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  bracket(bracket: boolean): ILevelDisplayBuilder {
    this._p.bracket = bracket;
    this._m["bracket"] = true;
    return this;
  }
  size(size: SymbolSize): ILevelDisplayBuilder {
    this._p.size = size;
    this._m["size"] = true;
    return this;
  }
  parentheses(parentheses: boolean): ILevelDisplayBuilder {
    this._p.parentheses = parentheses;
    this._m["parentheses"] = true;
    return this;
  }
}
export function patchLevelDisplay(base: LevelDisplay): ILevelDisplayBuilder { return new LevelDisplayBuilder(base); }
export function buildLevelDisplay(): ILevelDisplayBuilder { return new LevelDisplayBuilder(); }

export interface ITrillSoundBuilder {
  build: () => TrillSound;
  patch: () => any[];
  startNote: (startNote: UpperMainBelow) => ITrillSoundBuilder;
  accelerate: (accelerate: boolean) => ITrillSoundBuilder;
  beats: (beats: number) => ITrillSoundBuilder;
  lastBeat: (lastBeat: number) => ITrillSoundBuilder;
  trillStep: (trillStep: WholeHalfUnison) => ITrillSoundBuilder;
  twoNoteTurn: (twoNoteTurn: WholeHalfNone) => ITrillSoundBuilder;
  secondBeat: (secondBeat: number) => ITrillSoundBuilder;
}
class TrillSoundBuilder implements ITrillSoundBuilder{
  _p: TrillSound = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TrillSound;
  constructor(toPatch?: TrillSound) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): TrillSound {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TrillSound";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  startNote(startNote: UpperMainBelow): ITrillSoundBuilder {
    this._p.startNote = startNote;
    this._m["startNote"] = true;
    return this;
  }
  accelerate(accelerate: boolean): ITrillSoundBuilder {
    this._p.accelerate = accelerate;
    this._m["accelerate"] = true;
    return this;
  }
  beats(beats: number): ITrillSoundBuilder {
    this._p.beats = beats;
    this._m["beats"] = true;
    return this;
  }
  lastBeat(lastBeat: number): ITrillSoundBuilder {
    this._p.lastBeat = lastBeat;
    this._m["lastBeat"] = true;
    return this;
  }
  trillStep(trillStep: WholeHalfUnison): ITrillSoundBuilder {
    this._p.trillStep = trillStep;
    this._m["trillStep"] = true;
    return this;
  }
  twoNoteTurn(twoNoteTurn: WholeHalfNone): ITrillSoundBuilder {
    this._p.twoNoteTurn = twoNoteTurn;
    this._m["twoNoteTurn"] = true;
    return this;
  }
  secondBeat(secondBeat: number): ITrillSoundBuilder {
    this._p.secondBeat = secondBeat;
    this._m["secondBeat"] = true;
    return this;
  }
}
export function patchTrillSound(base: TrillSound): ITrillSoundBuilder { return new TrillSoundBuilder(base); }
export function buildTrillSound(): ITrillSoundBuilder { return new TrillSoundBuilder(); }

export interface IBendSoundBuilder {
  build: () => BendSound;
  patch: () => any[];
  accelerate: (accelerate: boolean) => IBendSoundBuilder;
  beats: (beats: number) => IBendSoundBuilder;
  firstBeat: (firstBeat: number) => IBendSoundBuilder;
  lastBeat: (lastBeat: number) => IBendSoundBuilder;
}
class BendSoundBuilder implements IBendSoundBuilder{
  _p: BendSound = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: BendSound;
  constructor(toPatch?: BendSound) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): BendSound {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "BendSound";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  accelerate(accelerate: boolean): IBendSoundBuilder {
    this._p.accelerate = accelerate;
    this._m["accelerate"] = true;
    return this;
  }
  beats(beats: number): IBendSoundBuilder {
    this._p.beats = beats;
    this._m["beats"] = true;
    return this;
  }
  firstBeat(firstBeat: number): IBendSoundBuilder {
    this._p.firstBeat = firstBeat;
    this._m["firstBeat"] = true;
    return this;
  }
  lastBeat(lastBeat: number): IBendSoundBuilder {
    this._p.lastBeat = lastBeat;
    this._m["lastBeat"] = true;
    return this;
  }
}
export function patchBendSound(base: BendSound): IBendSoundBuilder { return new BendSoundBuilder(base); }
export function buildBendSound(): IBendSoundBuilder { return new BendSoundBuilder(); }

export interface ITimeOnlyBuilder {
  build: () => TimeOnly;
  patch: () => any[];
  timeOnly: (timeOnly: string) => ITimeOnlyBuilder;
}
class TimeOnlyBuilder implements ITimeOnlyBuilder{
  _p: TimeOnly = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TimeOnly;
  constructor(toPatch?: TimeOnly) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): TimeOnly {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TimeOnly";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  timeOnly(timeOnly: string): ITimeOnlyBuilder {
    this._p.timeOnly = timeOnly;
    this._m["timeOnly"] = true;
    return this;
  }
}
export function patchTimeOnly(base: TimeOnly): ITimeOnlyBuilder { return new TimeOnlyBuilder(base); }
export function buildTimeOnly(): ITimeOnlyBuilder { return new TimeOnlyBuilder(); }

export interface IDocumentAttributesBuilder {
  build: () => DocumentAttributes;
  patch: () => any[];
  version: (version: string) => IDocumentAttributesBuilder;
}
class DocumentAttributesBuilder implements IDocumentAttributesBuilder{
  _p: DocumentAttributes = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: DocumentAttributes;
  constructor(toPatch?: DocumentAttributes) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["version"]) || this._b["version"] !== undefined || this._p.version !== undefined, "version is a required field");
  }
  build(): DocumentAttributes {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "DocumentAttributes";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  version(version: string): IDocumentAttributesBuilder {
    this._p.version = version;
    this._m["version"] = true;
    return this;
  }
}
export function patchDocumentAttributes(base: DocumentAttributes): IDocumentAttributesBuilder { return new DocumentAttributesBuilder(base); }
export function buildDocumentAttributes(): IDocumentAttributesBuilder { return new DocumentAttributesBuilder(); }

export interface IEditorialBuilder {
  build: () => Editorial;
  patch: () => any[];
  footnote: (build: (builder: IFootnoteBuilder) => IFootnoteBuilder) => IEditorialBuilder;
  level: (build: (builder: ILevelBuilder) => ILevelBuilder) => IEditorialBuilder;
  _class: (_class: string) => IEditorialBuilder;
}
class EditorialBuilder implements IEditorialBuilder{
  _p: Editorial = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Editorial;
  constructor(toPatch?: Editorial) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Editorial {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Editorial";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  footnote(build: (builder: IFootnoteBuilder) => IFootnoteBuilder): IEditorialBuilder {
    this._b["footnote"] = build(new FootnoteBuilder(this._o && this._o["footnote"]));
    this._m["footnote"] = true;
    return this;
  }
  level(build: (builder: ILevelBuilder) => ILevelBuilder): IEditorialBuilder {
    this._b["level"] = build(new LevelBuilder(this._o && this._o["level"]));
    this._m["level"] = true;
    return this;
  }
  _class(_class: string): IEditorialBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchEditorial(base: Editorial): IEditorialBuilder { return new EditorialBuilder(base); }
export function buildEditorial(): IEditorialBuilder { return new EditorialBuilder(); }

export interface IEditorialVoiceBuilder {
  build: () => EditorialVoice;
  patch: () => any[];
  voice: (voice: number) => IEditorialVoiceBuilder;
  footnote: (build: (builder: IFootnoteBuilder) => IFootnoteBuilder) => IEditorialVoiceBuilder;
  level: (build: (builder: ILevelBuilder) => ILevelBuilder) => IEditorialVoiceBuilder;
  _class: (_class: string) => IEditorialVoiceBuilder;
}
class EditorialVoiceBuilder implements IEditorialVoiceBuilder{
  _p: EditorialVoice = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: EditorialVoice;
  constructor(toPatch?: EditorialVoice) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): EditorialVoice {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "EditorialVoice";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  voice(voice: number): IEditorialVoiceBuilder {
    this._p.voice = voice;
    this._m["voice"] = true;
    return this;
  }
  footnote(build: (builder: IFootnoteBuilder) => IFootnoteBuilder): IEditorialVoiceBuilder {
    this._b["footnote"] = build(new FootnoteBuilder(this._o && this._o["footnote"]));
    this._m["footnote"] = true;
    return this;
  }
  level(build: (builder: ILevelBuilder) => ILevelBuilder): IEditorialVoiceBuilder {
    this._b["level"] = build(new LevelBuilder(this._o && this._o["level"]));
    this._m["level"] = true;
    return this;
  }
  _class(_class: string): IEditorialVoiceBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchEditorialVoice(base: EditorialVoice): IEditorialVoiceBuilder { return new EditorialVoiceBuilder(base); }
export function buildEditorialVoice(): IEditorialVoiceBuilder { return new EditorialVoiceBuilder(); }

export interface IFootnoteBuilder {
  build: () => Footnote;
  patch: () => any[];
  text: (text: string) => IFootnoteBuilder;
  justify: (justify: LeftCenterRight) => IFootnoteBuilder;
}
class FootnoteBuilder implements IFootnoteBuilder{
  _p: Footnote = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Footnote;
  constructor(toPatch?: Footnote) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["text"]) || this._b["text"] !== undefined || this._p.text !== undefined, "text is a required field");
  }
  build(): Footnote {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Footnote";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  text(text: string): IFootnoteBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  justify(justify: LeftCenterRight): IFootnoteBuilder {
    this._p.justify = justify;
    this._m["justify"] = true;
    return this;
  }
}
export function patchFootnote(base: Footnote): IFootnoteBuilder { return new FootnoteBuilder(base); }
export function buildFootnote(): IFootnoteBuilder { return new FootnoteBuilder(); }

export interface ILevelBuilder {
  build: () => Level;
  patch: () => any[];
  text: (text: string) => ILevelBuilder;
  reference: (reference: boolean) => ILevelBuilder;
  bracket: (bracket: boolean) => ILevelBuilder;
  size: (size: SymbolSize) => ILevelBuilder;
  parentheses: (parentheses: boolean) => ILevelBuilder;
}
class LevelBuilder implements ILevelBuilder{
  _p: Level = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Level;
  constructor(toPatch?: Level) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["text"]) || this._b["text"] !== undefined || this._p.text !== undefined, "text is a required field");
  }
  build(): Level {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Level";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  text(text: string): ILevelBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  reference(reference: boolean): ILevelBuilder {
    this._p.reference = reference;
    this._m["reference"] = true;
    return this;
  }
  bracket(bracket: boolean): ILevelBuilder {
    this._p.bracket = bracket;
    this._m["bracket"] = true;
    return this;
  }
  size(size: SymbolSize): ILevelBuilder {
    this._p.size = size;
    this._m["size"] = true;
    return this;
  }
  parentheses(parentheses: boolean): ILevelBuilder {
    this._p.parentheses = parentheses;
    this._m["parentheses"] = true;
    return this;
  }
}
export function patchLevel(base: Level): ILevelBuilder { return new LevelBuilder(base); }
export function buildLevel(): ILevelBuilder { return new LevelBuilder(); }

export interface IFermataBuilder {
  build: () => Fermata;
  patch: () => any[];
  shape: (shape: NormalAngledSquare) => IFermataBuilder;
  type: (type: UprightInverted) => IFermataBuilder;
  defaultX: (defaultX: number) => IFermataBuilder;
  relativeY: (relativeY: number) => IFermataBuilder;
  defaultY: (defaultY: number) => IFermataBuilder;
  relativeX: (relativeX: number) => IFermataBuilder;
}
class FermataBuilder implements IFermataBuilder{
  _p: Fermata = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Fermata;
  constructor(toPatch?: Fermata) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["shape"]) || this._b["shape"] !== undefined || this._p.shape !== undefined, "shape is a required field");
  }
  build(): Fermata {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Fermata";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  shape(shape: NormalAngledSquare): IFermataBuilder {
    this._p.shape = shape;
    this._m["shape"] = true;
    return this;
  }
  type(type: UprightInverted): IFermataBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  defaultX(defaultX: number): IFermataBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IFermataBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IFermataBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IFermataBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchFermata(base: Fermata): IFermataBuilder { return new FermataBuilder(base); }
export function buildFermata(): IFermataBuilder { return new FermataBuilder(); }

export interface IWavyLineBuilder {
  build: () => WavyLine;
  patch: () => any[];
  number: (number: number) => IWavyLineBuilder;
  type: (type: StartStopContinue) => IWavyLineBuilder;
  defaultX: (defaultX: number) => IWavyLineBuilder;
  relativeY: (relativeY: number) => IWavyLineBuilder;
  defaultY: (defaultY: number) => IWavyLineBuilder;
  relativeX: (relativeX: number) => IWavyLineBuilder;
}
class WavyLineBuilder implements IWavyLineBuilder{
  _p: WavyLine = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: WavyLine;
  constructor(toPatch?: WavyLine) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): WavyLine {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "WavyLine";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: number): IWavyLineBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  type(type: StartStopContinue): IWavyLineBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  defaultX(defaultX: number): IWavyLineBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IWavyLineBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IWavyLineBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IWavyLineBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchWavyLine(base: WavyLine): IWavyLineBuilder { return new WavyLineBuilder(base); }
export function buildWavyLine(): IWavyLineBuilder { return new WavyLineBuilder(); }

export interface ISegnoBuilder {
  build: () => Segno;
  patch: () => any[];
  defaultX: (defaultX: number) => ISegnoBuilder;
  relativeY: (relativeY: number) => ISegnoBuilder;
  defaultY: (defaultY: number) => ISegnoBuilder;
  relativeX: (relativeX: number) => ISegnoBuilder;
}
class SegnoBuilder implements ISegnoBuilder{
  _p: Segno = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Segno;
  constructor(toPatch?: Segno) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Segno {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Segno";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): ISegnoBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): ISegnoBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): ISegnoBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): ISegnoBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchSegno(base: Segno): ISegnoBuilder { return new SegnoBuilder(base); }
export function buildSegno(): ISegnoBuilder { return new SegnoBuilder(); }

export interface ICodaBuilder {
  build: () => Coda;
  patch: () => any[];
  defaultX: (defaultX: number) => ICodaBuilder;
  relativeY: (relativeY: number) => ICodaBuilder;
  defaultY: (defaultY: number) => ICodaBuilder;
  relativeX: (relativeX: number) => ICodaBuilder;
}
class CodaBuilder implements ICodaBuilder{
  _p: Coda = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Coda;
  constructor(toPatch?: Coda) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Coda {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Coda";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): ICodaBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): ICodaBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): ICodaBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): ICodaBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchCoda(base: Coda): ICodaBuilder { return new CodaBuilder(base); }
export function buildCoda(): ICodaBuilder { return new CodaBuilder(); }

export interface INormalDotBuilder {
  build: () => NormalDot;
  patch: () => any[];
}
class NormalDotBuilder implements INormalDotBuilder{
  _p: NormalDot = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: NormalDot;
  constructor(toPatch?: NormalDot) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): NormalDot {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "NormalDot";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
}
export function patchNormalDot(base: NormalDot): INormalDotBuilder { return new NormalDotBuilder(base); }
export function buildNormalDot(): INormalDotBuilder { return new NormalDotBuilder(); }

export interface IDynamicsBuilder {
  build: () => Dynamics;
  patch: () => any[];
  fp: (fp: boolean) => IDynamicsBuilder;
  pp: (pp: boolean) => IDynamicsBuilder;
  ppp: (ppp: boolean) => IDynamicsBuilder;
  fff: (fff: boolean) => IDynamicsBuilder;
  sf: (sf: boolean) => IDynamicsBuilder;
  rf: (rf: boolean) => IDynamicsBuilder;
  mp: (mp: boolean) => IDynamicsBuilder;
  sfpp: (sfpp: boolean) => IDynamicsBuilder;
  f: (f: boolean) => IDynamicsBuilder;
  ffffff: (ffffff: boolean) => IDynamicsBuilder;
  sfz: (sfz: boolean) => IDynamicsBuilder;
  ff: (ff: boolean) => IDynamicsBuilder;
  pppppp: (pppppp: boolean) => IDynamicsBuilder;
  rfz: (rfz: boolean) => IDynamicsBuilder;
  otherDynamics: (otherDynamics: string) => IDynamicsBuilder;
  fz: (fz: boolean) => IDynamicsBuilder;
  ppppp: (ppppp: boolean) => IDynamicsBuilder;
  mf: (mf: boolean) => IDynamicsBuilder;
  pppp: (pppp: boolean) => IDynamicsBuilder;
  fffff: (fffff: boolean) => IDynamicsBuilder;
  sffz: (sffz: boolean) => IDynamicsBuilder;
  sfp: (sfp: boolean) => IDynamicsBuilder;
  p: (p: boolean) => IDynamicsBuilder;
  ffff: (ffff: boolean) => IDynamicsBuilder;
  defaultX: (defaultX: number) => IDynamicsBuilder;
  relativeY: (relativeY: number) => IDynamicsBuilder;
  defaultY: (defaultY: number) => IDynamicsBuilder;
  relativeX: (relativeX: number) => IDynamicsBuilder;
}
class DynamicsBuilder implements IDynamicsBuilder{
  _p: Dynamics = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Dynamics;
  constructor(toPatch?: Dynamics) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["fp"]) || this._b["fp"] !== undefined || this._p.fp !== undefined, "fp is a required field");
    console.assert((this._o && !this._m["pp"]) || this._b["pp"] !== undefined || this._p.pp !== undefined, "pp is a required field");
    console.assert((this._o && !this._m["ppp"]) || this._b["ppp"] !== undefined || this._p.ppp !== undefined, "ppp is a required field");
    console.assert((this._o && !this._m["fff"]) || this._b["fff"] !== undefined || this._p.fff !== undefined, "fff is a required field");
    console.assert((this._o && !this._m["sf"]) || this._b["sf"] !== undefined || this._p.sf !== undefined, "sf is a required field");
    console.assert((this._o && !this._m["rf"]) || this._b["rf"] !== undefined || this._p.rf !== undefined, "rf is a required field");
    console.assert((this._o && !this._m["mp"]) || this._b["mp"] !== undefined || this._p.mp !== undefined, "mp is a required field");
    console.assert((this._o && !this._m["sfpp"]) || this._b["sfpp"] !== undefined || this._p.sfpp !== undefined, "sfpp is a required field");
    console.assert((this._o && !this._m["f"]) || this._b["f"] !== undefined || this._p.f !== undefined, "f is a required field");
    console.assert((this._o && !this._m["ffffff"]) || this._b["ffffff"] !== undefined || this._p.ffffff !== undefined, "ffffff is a required field");
    console.assert((this._o && !this._m["sfz"]) || this._b["sfz"] !== undefined || this._p.sfz !== undefined, "sfz is a required field");
    console.assert((this._o && !this._m["ff"]) || this._b["ff"] !== undefined || this._p.ff !== undefined, "ff is a required field");
    console.assert((this._o && !this._m["pppppp"]) || this._b["pppppp"] !== undefined || this._p.pppppp !== undefined, "pppppp is a required field");
    console.assert((this._o && !this._m["rfz"]) || this._b["rfz"] !== undefined || this._p.rfz !== undefined, "rfz is a required field");
    console.assert((this._o && !this._m["fz"]) || this._b["fz"] !== undefined || this._p.fz !== undefined, "fz is a required field");
    console.assert((this._o && !this._m["ppppp"]) || this._b["ppppp"] !== undefined || this._p.ppppp !== undefined, "ppppp is a required field");
    console.assert((this._o && !this._m["mf"]) || this._b["mf"] !== undefined || this._p.mf !== undefined, "mf is a required field");
    console.assert((this._o && !this._m["pppp"]) || this._b["pppp"] !== undefined || this._p.pppp !== undefined, "pppp is a required field");
    console.assert((this._o && !this._m["fffff"]) || this._b["fffff"] !== undefined || this._p.fffff !== undefined, "fffff is a required field");
    console.assert((this._o && !this._m["sffz"]) || this._b["sffz"] !== undefined || this._p.sffz !== undefined, "sffz is a required field");
    console.assert((this._o && !this._m["sfp"]) || this._b["sfp"] !== undefined || this._p.sfp !== undefined, "sfp is a required field");
    console.assert((this._o && !this._m["p"]) || this._b["p"] !== undefined || this._p.p !== undefined, "p is a required field");
    console.assert((this._o && !this._m["ffff"]) || this._b["ffff"] !== undefined || this._p.ffff !== undefined, "ffff is a required field");
  }
  build(): Dynamics {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Dynamics";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  fp(fp: boolean): IDynamicsBuilder {
    this._p.fp = fp;
    this._m["fp"] = true;
    return this;
  }
  pp(pp: boolean): IDynamicsBuilder {
    this._p.pp = pp;
    this._m["pp"] = true;
    return this;
  }
  ppp(ppp: boolean): IDynamicsBuilder {
    this._p.ppp = ppp;
    this._m["ppp"] = true;
    return this;
  }
  fff(fff: boolean): IDynamicsBuilder {
    this._p.fff = fff;
    this._m["fff"] = true;
    return this;
  }
  sf(sf: boolean): IDynamicsBuilder {
    this._p.sf = sf;
    this._m["sf"] = true;
    return this;
  }
  rf(rf: boolean): IDynamicsBuilder {
    this._p.rf = rf;
    this._m["rf"] = true;
    return this;
  }
  mp(mp: boolean): IDynamicsBuilder {
    this._p.mp = mp;
    this._m["mp"] = true;
    return this;
  }
  sfpp(sfpp: boolean): IDynamicsBuilder {
    this._p.sfpp = sfpp;
    this._m["sfpp"] = true;
    return this;
  }
  f(f: boolean): IDynamicsBuilder {
    this._p.f = f;
    this._m["f"] = true;
    return this;
  }
  ffffff(ffffff: boolean): IDynamicsBuilder {
    this._p.ffffff = ffffff;
    this._m["ffffff"] = true;
    return this;
  }
  sfz(sfz: boolean): IDynamicsBuilder {
    this._p.sfz = sfz;
    this._m["sfz"] = true;
    return this;
  }
  ff(ff: boolean): IDynamicsBuilder {
    this._p.ff = ff;
    this._m["ff"] = true;
    return this;
  }
  pppppp(pppppp: boolean): IDynamicsBuilder {
    this._p.pppppp = pppppp;
    this._m["pppppp"] = true;
    return this;
  }
  rfz(rfz: boolean): IDynamicsBuilder {
    this._p.rfz = rfz;
    this._m["rfz"] = true;
    return this;
  }
  otherDynamics(otherDynamics: string): IDynamicsBuilder {
    this._p.otherDynamics = otherDynamics;
    this._m["otherDynamics"] = true;
    return this;
  }
  fz(fz: boolean): IDynamicsBuilder {
    this._p.fz = fz;
    this._m["fz"] = true;
    return this;
  }
  ppppp(ppppp: boolean): IDynamicsBuilder {
    this._p.ppppp = ppppp;
    this._m["ppppp"] = true;
    return this;
  }
  mf(mf: boolean): IDynamicsBuilder {
    this._p.mf = mf;
    this._m["mf"] = true;
    return this;
  }
  pppp(pppp: boolean): IDynamicsBuilder {
    this._p.pppp = pppp;
    this._m["pppp"] = true;
    return this;
  }
  fffff(fffff: boolean): IDynamicsBuilder {
    this._p.fffff = fffff;
    this._m["fffff"] = true;
    return this;
  }
  sffz(sffz: boolean): IDynamicsBuilder {
    this._p.sffz = sffz;
    this._m["sffz"] = true;
    return this;
  }
  sfp(sfp: boolean): IDynamicsBuilder {
    this._p.sfp = sfp;
    this._m["sfp"] = true;
    return this;
  }
  p(p: boolean): IDynamicsBuilder {
    this._p.p = p;
    this._m["p"] = true;
    return this;
  }
  ffff(ffff: boolean): IDynamicsBuilder {
    this._p.ffff = ffff;
    this._m["ffff"] = true;
    return this;
  }
  defaultX(defaultX: number): IDynamicsBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IDynamicsBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IDynamicsBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IDynamicsBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchDynamics(base: Dynamics): IDynamicsBuilder { return new DynamicsBuilder(base); }
export function buildDynamics(): IDynamicsBuilder { return new DynamicsBuilder(); }

export interface IFingeringBuilder {
  build: () => Fingering;
  patch: () => any[];
  substitution: (substitution: boolean) => IFingeringBuilder;
  finger: (finger: number) => IFingeringBuilder;
  alternate: (alternate: boolean) => IFingeringBuilder;
  defaultX: (defaultX: number) => IFingeringBuilder;
  relativeY: (relativeY: number) => IFingeringBuilder;
  defaultY: (defaultY: number) => IFingeringBuilder;
  relativeX: (relativeX: number) => IFingeringBuilder;
}
class FingeringBuilder implements IFingeringBuilder{
  _p: Fingering = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Fingering;
  constructor(toPatch?: Fingering) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Fingering {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Fingering";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  substitution(substitution: boolean): IFingeringBuilder {
    this._p.substitution = substitution;
    this._m["substitution"] = true;
    return this;
  }
  finger(finger: number): IFingeringBuilder {
    this._p.finger = finger;
    this._m["finger"] = true;
    return this;
  }
  alternate(alternate: boolean): IFingeringBuilder {
    this._p.alternate = alternate;
    this._m["alternate"] = true;
    return this;
  }
  defaultX(defaultX: number): IFingeringBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IFingeringBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IFingeringBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IFingeringBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchFingering(base: Fingering): IFingeringBuilder { return new FingeringBuilder(base); }
export function buildFingering(): IFingeringBuilder { return new FingeringBuilder(); }

export interface IFretBuilder {
  build: () => Fret;
  patch: () => any[];
  fret: (fret: number) => IFretBuilder;
  fontFamily: (fontFamily: string) => IFretBuilder;
  fontWeight: (fontWeight: NormalBold) => IFretBuilder;
  fontStyle: (fontStyle: NormalItalic) => IFretBuilder;
  fontSize: (fontSize: string) => IFretBuilder;
}
class FretBuilder implements IFretBuilder{
  _p: Fret = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Fret;
  constructor(toPatch?: Fret) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["fret"]) || this._b["fret"] !== undefined || this._p.fret !== undefined, "fret is a required field");
  }
  build(): Fret {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Fret";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  fret(fret: number): IFretBuilder {
    this._p.fret = fret;
    this._m["fret"] = true;
    return this;
  }
  fontFamily(fontFamily: string): IFretBuilder {
    this._p.fontFamily = fontFamily;
    this._m["fontFamily"] = true;
    return this;
  }
  fontWeight(fontWeight: NormalBold): IFretBuilder {
    this._p.fontWeight = fontWeight;
    this._m["fontWeight"] = true;
    return this;
  }
  fontStyle(fontStyle: NormalItalic): IFretBuilder {
    this._p.fontStyle = fontStyle;
    this._m["fontStyle"] = true;
    return this;
  }
  fontSize(fontSize: string): IFretBuilder {
    this._p.fontSize = fontSize;
    this._m["fontSize"] = true;
    return this;
  }
}
export function patchFret(base: Fret): IFretBuilder { return new FretBuilder(base); }
export function buildFret(): IFretBuilder { return new FretBuilder(); }

export interface IStringBuilder {
  build: () => String;
  patch: () => any[];
  stringNum: (stringNum: number) => IStringBuilder;
  defaultX: (defaultX: number) => IStringBuilder;
  relativeY: (relativeY: number) => IStringBuilder;
  defaultY: (defaultY: number) => IStringBuilder;
  relativeX: (relativeX: number) => IStringBuilder;
}
class StringBuilder implements IStringBuilder{
  _p: String = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: String;
  constructor(toPatch?: String) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["stringNum"]) || this._b["stringNum"] !== undefined || this._p.stringNum !== undefined, "stringNum is a required field");
  }
  build(): String {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "String";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  stringNum(stringNum: number): IStringBuilder {
    this._p.stringNum = stringNum;
    this._m["stringNum"] = true;
    return this;
  }
  defaultX(defaultX: number): IStringBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IStringBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IStringBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IStringBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchString(base: String): IStringBuilder { return new StringBuilder(base); }
export function buildString(): IStringBuilder { return new StringBuilder(); }

export interface IDisplayTextBuilder {
  build: () => DisplayText;
  patch: () => any[];
  text: (text: string) => IDisplayTextBuilder;
  justify: (justify: LeftCenterRight) => IDisplayTextBuilder;
}
class DisplayTextBuilder implements IDisplayTextBuilder{
  _p: DisplayText = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: DisplayText;
  constructor(toPatch?: DisplayText) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["text"]) || this._b["text"] !== undefined || this._p.text !== undefined, "text is a required field");
  }
  build(): DisplayText {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "DisplayText";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  text(text: string): IDisplayTextBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  justify(justify: LeftCenterRight): IDisplayTextBuilder {
    this._p.justify = justify;
    this._m["justify"] = true;
    return this;
  }
}
export function patchDisplayText(base: DisplayText): IDisplayTextBuilder { return new DisplayTextBuilder(base); }
export function buildDisplayText(): IDisplayTextBuilder { return new DisplayTextBuilder(); }

export interface IAccidentalTextBuilder {
  build: () => AccidentalText;
  patch: () => any[];
  text: (text: string) => IAccidentalTextBuilder;
  justify: (justify: LeftCenterRight) => IAccidentalTextBuilder;
}
class AccidentalTextBuilder implements IAccidentalTextBuilder{
  _p: AccidentalText = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: AccidentalText;
  constructor(toPatch?: AccidentalText) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["text"]) || this._b["text"] !== undefined || this._p.text !== undefined, "text is a required field");
  }
  build(): AccidentalText {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "AccidentalText";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  text(text: string): IAccidentalTextBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  justify(justify: LeftCenterRight): IAccidentalTextBuilder {
    this._p.justify = justify;
    this._m["justify"] = true;
    return this;
  }
}
export function patchAccidentalText(base: AccidentalText): IAccidentalTextBuilder { return new AccidentalTextBuilder(base); }
export function buildAccidentalText(): IAccidentalTextBuilder { return new AccidentalTextBuilder(); }

export interface IPartNameDisplayBuilder {
  build: () => PartNameDisplay;
  patch: () => any[];
  name: (build: (builder: ITextArrayBuilder) => ITextArrayBuilder) => IPartNameDisplayBuilder;
  printObject: (printObject: boolean) => IPartNameDisplayBuilder;
}
class PartNameDisplayBuilder implements IPartNameDisplayBuilder{
  _p: PartNameDisplay = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PartNameDisplay;
  constructor(toPatch?: PartNameDisplay) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["name"]) || this._b["name"] !== undefined || this._p.name !== undefined, "name is a required field");
  }
  build(): PartNameDisplay {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PartNameDisplay";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  name(build: (builder: ITextArrayBuilder) => ITextArrayBuilder): IPartNameDisplayBuilder {
    this._b["name"] = build(new TextArrayBuilder(this._o && this._o["name"]));
    this._m["name"] = true;
    return this;
  }
  printObject(printObject: boolean): IPartNameDisplayBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchPartNameDisplay(base: PartNameDisplay): IPartNameDisplayBuilder { return new PartNameDisplayBuilder(base); }
export function buildPartNameDisplay(): IPartNameDisplayBuilder { return new PartNameDisplayBuilder(); }

export interface IPartAbbreviationDisplayBuilder {
  build: () => PartAbbreviationDisplay;
  patch: () => any[];
  name: (build: (builder: ITextArrayBuilder) => ITextArrayBuilder) => IPartAbbreviationDisplayBuilder;
  printObject: (printObject: boolean) => IPartAbbreviationDisplayBuilder;
}
class PartAbbreviationDisplayBuilder implements IPartAbbreviationDisplayBuilder{
  _p: PartAbbreviationDisplay = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PartAbbreviationDisplay;
  constructor(toPatch?: PartAbbreviationDisplay) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["name"]) || this._b["name"] !== undefined || this._p.name !== undefined, "name is a required field");
  }
  build(): PartAbbreviationDisplay {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PartAbbreviationDisplay";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  name(build: (builder: ITextArrayBuilder) => ITextArrayBuilder): IPartAbbreviationDisplayBuilder {
    this._b["name"] = build(new TextArrayBuilder(this._o && this._o["name"]));
    this._m["name"] = true;
    return this;
  }
  printObject(printObject: boolean): IPartAbbreviationDisplayBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchPartAbbreviationDisplay(base: PartAbbreviationDisplay): IPartAbbreviationDisplayBuilder { return new PartAbbreviationDisplayBuilder(base); }
export function buildPartAbbreviationDisplay(): IPartAbbreviationDisplayBuilder { return new PartAbbreviationDisplayBuilder(); }

export interface IMidiDeviceBuilder {
  build: () => MidiDevice;
  patch: () => any[];
  port: (port: number) => IMidiDeviceBuilder;
  deviceName: (deviceName: string) => IMidiDeviceBuilder;
  id: (id: number) => IMidiDeviceBuilder;
}
class MidiDeviceBuilder implements IMidiDeviceBuilder{
  _p: MidiDevice = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: MidiDevice;
  constructor(toPatch?: MidiDevice) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["deviceName"]) || this._b["deviceName"] !== undefined || this._p.deviceName !== undefined, "deviceName is a required field");
  }
  build(): MidiDevice {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "MidiDevice";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  port(port: number): IMidiDeviceBuilder {
    this._p.port = port;
    this._m["port"] = true;
    return this;
  }
  deviceName(deviceName: string): IMidiDeviceBuilder {
    this._p.deviceName = deviceName;
    this._m["deviceName"] = true;
    return this;
  }
  id(id: number): IMidiDeviceBuilder {
    this._p.id = id;
    this._m["id"] = true;
    return this;
  }
}
export function patchMidiDevice(base: MidiDevice): IMidiDeviceBuilder { return new MidiDeviceBuilder(base); }
export function buildMidiDevice(): IMidiDeviceBuilder { return new MidiDeviceBuilder(); }

export interface IMidiInstrumentBuilder {
  build: () => MidiInstrument;
  patch: () => any[];
  midiUnpitched: (midiUnpitched: number) => IMidiInstrumentBuilder;
  volume: (volume: number) => IMidiInstrumentBuilder;
  pan: (pan: number) => IMidiInstrumentBuilder;
  elevation: (elevation: number) => IMidiInstrumentBuilder;
  midiBank: (midiBank: number) => IMidiInstrumentBuilder;
  midiProgram: (midiProgram: number) => IMidiInstrumentBuilder;
  id: (id: string) => IMidiInstrumentBuilder;
  midiChannel: (midiChannel: number) => IMidiInstrumentBuilder;
  midiName: (midiName: string) => IMidiInstrumentBuilder;
}
class MidiInstrumentBuilder implements IMidiInstrumentBuilder{
  _p: MidiInstrument = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: MidiInstrument;
  constructor(toPatch?: MidiInstrument) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["id"]) || this._b["id"] !== undefined || this._p.id !== undefined, "id is a required field");
  }
  build(): MidiInstrument {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "MidiInstrument";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  midiUnpitched(midiUnpitched: number): IMidiInstrumentBuilder {
    this._p.midiUnpitched = midiUnpitched;
    this._m["midiUnpitched"] = true;
    return this;
  }
  volume(volume: number): IMidiInstrumentBuilder {
    this._p.volume = volume;
    this._m["volume"] = true;
    return this;
  }
  pan(pan: number): IMidiInstrumentBuilder {
    this._p.pan = pan;
    this._m["pan"] = true;
    return this;
  }
  elevation(elevation: number): IMidiInstrumentBuilder {
    this._p.elevation = elevation;
    this._m["elevation"] = true;
    return this;
  }
  midiBank(midiBank: number): IMidiInstrumentBuilder {
    this._p.midiBank = midiBank;
    this._m["midiBank"] = true;
    return this;
  }
  midiProgram(midiProgram: number): IMidiInstrumentBuilder {
    this._p.midiProgram = midiProgram;
    this._m["midiProgram"] = true;
    return this;
  }
  id(id: string): IMidiInstrumentBuilder {
    this._p.id = id;
    this._m["id"] = true;
    return this;
  }
  midiChannel(midiChannel: number): IMidiInstrumentBuilder {
    this._p.midiChannel = midiChannel;
    this._m["midiChannel"] = true;
    return this;
  }
  midiName(midiName: string): IMidiInstrumentBuilder {
    this._p.midiName = midiName;
    this._m["midiName"] = true;
    return this;
  }
}
export function patchMidiInstrument(base: MidiInstrument): IMidiInstrumentBuilder { return new MidiInstrumentBuilder(base); }
export function buildMidiInstrument(): IMidiInstrumentBuilder { return new MidiInstrumentBuilder(); }

export interface IPlayBuilder {
  build: () => Play;
  patch: () => any[];
  ipa: (ipa: string) => IPlayBuilder;
  mute: (mute: string) => IPlayBuilder;
  otherPlay: (build: (builder: IOtherPlayBuilder) => IOtherPlayBuilder) => IPlayBuilder;
  semiPitched: (semiPitched: string) => IPlayBuilder;
  id: (id: string) => IPlayBuilder;
}
class PlayBuilder implements IPlayBuilder{
  _p: Play = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Play;
  constructor(toPatch?: Play) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["id"]) || this._b["id"] !== undefined || this._p.id !== undefined, "id is a required field");
  }
  build(): Play {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Play";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  ipa(ipa: string): IPlayBuilder {
    this._p.ipa = ipa;
    this._m["ipa"] = true;
    return this;
  }
  mute(mute: string): IPlayBuilder {
    this._p.mute = mute;
    this._m["mute"] = true;
    return this;
  }
  otherPlay(build: (builder: IOtherPlayBuilder) => IOtherPlayBuilder): IPlayBuilder {
    this._b["otherPlay"] = build(new OtherPlayBuilder(this._o && this._o["otherPlay"]));
    this._m["otherPlay"] = true;
    return this;
  }
  semiPitched(semiPitched: string): IPlayBuilder {
    this._p.semiPitched = semiPitched;
    this._m["semiPitched"] = true;
    return this;
  }
  id(id: string): IPlayBuilder {
    this._p.id = id;
    this._m["id"] = true;
    return this;
  }
}
export function patchPlay(base: Play): IPlayBuilder { return new PlayBuilder(base); }
export function buildPlay(): IPlayBuilder { return new PlayBuilder(); }

export interface IOtherPlayBuilder {
  build: () => OtherPlay;
  patch: () => any[];
  data: (data: string) => IOtherPlayBuilder;
  type: (type: string) => IOtherPlayBuilder;
}
class OtherPlayBuilder implements IOtherPlayBuilder{
  _p: OtherPlay = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: OtherPlay;
  constructor(toPatch?: OtherPlay) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): OtherPlay {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "OtherPlay";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IOtherPlayBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  type(type: string): IOtherPlayBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
}
export function patchOtherPlay(base: OtherPlay): IOtherPlayBuilder { return new OtherPlayBuilder(base); }
export function buildOtherPlay(): IOtherPlayBuilder { return new OtherPlayBuilder(); }

export interface IScalingBuilder {
  build: () => Scaling;
  patch: () => any[];
  tenths: (tenths: number) => IScalingBuilder;
  millimeters: (millimeters: number) => IScalingBuilder;
}
class ScalingBuilder implements IScalingBuilder{
  _p: Scaling = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Scaling;
  constructor(toPatch?: Scaling) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Scaling {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Scaling";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  tenths(tenths: number): IScalingBuilder {
    this._p.tenths = tenths;
    this._m["tenths"] = true;
    return this;
  }
  millimeters(millimeters: number): IScalingBuilder {
    this._p.millimeters = millimeters;
    this._m["millimeters"] = true;
    return this;
  }
}
export function patchScaling(base: Scaling): IScalingBuilder { return new ScalingBuilder(base); }
export function buildScaling(): IScalingBuilder { return new ScalingBuilder(); }

export interface IPageMarginsBuilder {
  build: () => PageMargins;
  patch: () => any[];
  topMargin: (topMargin: number) => IPageMarginsBuilder;
  leftMargin: (leftMargin: number) => IPageMarginsBuilder;
  bottomMargin: (bottomMargin: number) => IPageMarginsBuilder;
  type: (type: OddEvenBoth) => IPageMarginsBuilder;
  rightMargin: (rightMargin: number) => IPageMarginsBuilder;
}
class PageMarginsBuilder implements IPageMarginsBuilder{
  _p: PageMargins = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PageMargins;
  constructor(toPatch?: PageMargins) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["topMargin"]) || this._b["topMargin"] !== undefined || this._p.topMargin !== undefined, "topMargin is a required field");
    console.assert((this._o && !this._m["leftMargin"]) || this._b["leftMargin"] !== undefined || this._p.leftMargin !== undefined, "leftMargin is a required field");
    console.assert((this._o && !this._m["bottomMargin"]) || this._b["bottomMargin"] !== undefined || this._p.bottomMargin !== undefined, "bottomMargin is a required field");
    console.assert((this._o && !this._m["rightMargin"]) || this._b["rightMargin"] !== undefined || this._p.rightMargin !== undefined, "rightMargin is a required field");
  }
  build(): PageMargins {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PageMargins";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  topMargin(topMargin: number): IPageMarginsBuilder {
    this._p.topMargin = topMargin;
    this._m["topMargin"] = true;
    return this;
  }
  leftMargin(leftMargin: number): IPageMarginsBuilder {
    this._p.leftMargin = leftMargin;
    this._m["leftMargin"] = true;
    return this;
  }
  bottomMargin(bottomMargin: number): IPageMarginsBuilder {
    this._p.bottomMargin = bottomMargin;
    this._m["bottomMargin"] = true;
    return this;
  }
  type(type: OddEvenBoth): IPageMarginsBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  rightMargin(rightMargin: number): IPageMarginsBuilder {
    this._p.rightMargin = rightMargin;
    this._m["rightMargin"] = true;
    return this;
  }
}
export function patchPageMargins(base: PageMargins): IPageMarginsBuilder { return new PageMarginsBuilder(base); }
export function buildPageMargins(): IPageMarginsBuilder { return new PageMarginsBuilder(); }

export interface IPageLayoutBuilder {
  build: () => PageLayout;
  patch: () => any[];
  pageHeight: (pageHeight: number) => IPageLayoutBuilder;
  pageWidth: (pageWidth: number) => IPageLayoutBuilder;
  pageMargins: (pageMargins: PageMargins[]) => IPageLayoutBuilder;
}
class PageLayoutBuilder implements IPageLayoutBuilder{
  _p: PageLayout = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PageLayout;
  constructor(toPatch?: PageLayout) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): PageLayout {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PageLayout";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  pageHeight(pageHeight: number): IPageLayoutBuilder {
    this._p.pageHeight = pageHeight;
    this._m["pageHeight"] = true;
    return this;
  }
  pageWidth(pageWidth: number): IPageLayoutBuilder {
    this._p.pageWidth = pageWidth;
    this._m["pageWidth"] = true;
    return this;
  }
  pageMargins(pageMargins: PageMargins[]): IPageLayoutBuilder {
    this._p.pageMargins = pageMargins;
    this._m["pageMargins"] = true;
    return this;
  }
}
export function patchPageLayout(base: PageLayout): IPageLayoutBuilder { return new PageLayoutBuilder(base); }
export function buildPageLayout(): IPageLayoutBuilder { return new PageLayoutBuilder(); }

export interface ISystemLayoutBuilder {
  build: () => SystemLayout;
  patch: () => any[];
  systemDividers: (build: (builder: ISystemDividersBuilder) => ISystemDividersBuilder) => ISystemLayoutBuilder;
  systemMargins: (build: (builder: ISystemMarginsBuilder) => ISystemMarginsBuilder) => ISystemLayoutBuilder;
  systemDistance: (systemDistance: number) => ISystemLayoutBuilder;
  topSystemDistance: (topSystemDistance: number) => ISystemLayoutBuilder;
}
class SystemLayoutBuilder implements ISystemLayoutBuilder{
  _p: SystemLayout = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: SystemLayout;
  constructor(toPatch?: SystemLayout) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): SystemLayout {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "SystemLayout";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  systemDividers(build: (builder: ISystemDividersBuilder) => ISystemDividersBuilder): ISystemLayoutBuilder {
    this._b["systemDividers"] = build(new SystemDividersBuilder(this._o && this._o["systemDividers"]));
    this._m["systemDividers"] = true;
    return this;
  }
  systemMargins(build: (builder: ISystemMarginsBuilder) => ISystemMarginsBuilder): ISystemLayoutBuilder {
    this._b["systemMargins"] = build(new SystemMarginsBuilder(this._o && this._o["systemMargins"]));
    this._m["systemMargins"] = true;
    return this;
  }
  systemDistance(systemDistance: number): ISystemLayoutBuilder {
    this._p.systemDistance = systemDistance;
    this._m["systemDistance"] = true;
    return this;
  }
  topSystemDistance(topSystemDistance: number): ISystemLayoutBuilder {
    this._p.topSystemDistance = topSystemDistance;
    this._m["topSystemDistance"] = true;
    return this;
  }
}
export function patchSystemLayout(base: SystemLayout): ISystemLayoutBuilder { return new SystemLayoutBuilder(base); }
export function buildSystemLayout(): ISystemLayoutBuilder { return new SystemLayoutBuilder(); }

export interface ISystemMarginsBuilder {
  build: () => SystemMargins;
  patch: () => any[];
  leftMargin: (leftMargin: number) => ISystemMarginsBuilder;
  rightMargin: (rightMargin: number) => ISystemMarginsBuilder;
}
class SystemMarginsBuilder implements ISystemMarginsBuilder{
  _p: SystemMargins = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: SystemMargins;
  constructor(toPatch?: SystemMargins) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["leftMargin"]) || this._b["leftMargin"] !== undefined || this._p.leftMargin !== undefined, "leftMargin is a required field");
    console.assert((this._o && !this._m["rightMargin"]) || this._b["rightMargin"] !== undefined || this._p.rightMargin !== undefined, "rightMargin is a required field");
  }
  build(): SystemMargins {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "SystemMargins";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  leftMargin(leftMargin: number): ISystemMarginsBuilder {
    this._p.leftMargin = leftMargin;
    this._m["leftMargin"] = true;
    return this;
  }
  rightMargin(rightMargin: number): ISystemMarginsBuilder {
    this._p.rightMargin = rightMargin;
    this._m["rightMargin"] = true;
    return this;
  }
}
export function patchSystemMargins(base: SystemMargins): ISystemMarginsBuilder { return new SystemMarginsBuilder(base); }
export function buildSystemMargins(): ISystemMarginsBuilder { return new SystemMarginsBuilder(); }

export interface ISystemDividersBuilder {
  build: () => SystemDividers;
  patch: () => any[];
  rightDivider: (build: (builder: IRightDividerBuilder) => IRightDividerBuilder) => ISystemDividersBuilder;
  leftDivider: (build: (builder: ILeftDividerBuilder) => ILeftDividerBuilder) => ISystemDividersBuilder;
}
class SystemDividersBuilder implements ISystemDividersBuilder{
  _p: SystemDividers = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: SystemDividers;
  constructor(toPatch?: SystemDividers) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["rightDivider"]) || this._b["rightDivider"] !== undefined || this._p.rightDivider !== undefined, "rightDivider is a required field");
    console.assert((this._o && !this._m["leftDivider"]) || this._b["leftDivider"] !== undefined || this._p.leftDivider !== undefined, "leftDivider is a required field");
  }
  build(): SystemDividers {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "SystemDividers";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  rightDivider(build: (builder: IRightDividerBuilder) => IRightDividerBuilder): ISystemDividersBuilder {
    this._b["rightDivider"] = build(new RightDividerBuilder(this._o && this._o["rightDivider"]));
    this._m["rightDivider"] = true;
    return this;
  }
  leftDivider(build: (builder: ILeftDividerBuilder) => ILeftDividerBuilder): ISystemDividersBuilder {
    this._b["leftDivider"] = build(new LeftDividerBuilder(this._o && this._o["leftDivider"]));
    this._m["leftDivider"] = true;
    return this;
  }
}
export function patchSystemDividers(base: SystemDividers): ISystemDividersBuilder { return new SystemDividersBuilder(base); }
export function buildSystemDividers(): ISystemDividersBuilder { return new SystemDividersBuilder(); }

export interface ILeftDividerBuilder {
  build: () => LeftDivider;
  patch: () => any[];
  printObject: (printObject: boolean) => ILeftDividerBuilder;
}
class LeftDividerBuilder implements ILeftDividerBuilder{
  _p: LeftDivider = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: LeftDivider;
  constructor(toPatch?: LeftDivider) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): LeftDivider {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "LeftDivider";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  printObject(printObject: boolean): ILeftDividerBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchLeftDivider(base: LeftDivider): ILeftDividerBuilder { return new LeftDividerBuilder(base); }
export function buildLeftDivider(): ILeftDividerBuilder { return new LeftDividerBuilder(); }

export interface IRightDividerBuilder {
  build: () => RightDivider;
  patch: () => any[];
  printObject: (printObject: boolean) => IRightDividerBuilder;
}
class RightDividerBuilder implements IRightDividerBuilder{
  _p: RightDivider = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: RightDivider;
  constructor(toPatch?: RightDivider) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): RightDivider {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "RightDivider";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  printObject(printObject: boolean): IRightDividerBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchRightDivider(base: RightDivider): IRightDividerBuilder { return new RightDividerBuilder(base); }
export function buildRightDivider(): IRightDividerBuilder { return new RightDividerBuilder(); }

export interface IStaffLayoutBuilder {
  build: () => StaffLayout;
  patch: () => any[];
  staffDistance: (staffDistance: number) => IStaffLayoutBuilder;
  num: (num: number) => IStaffLayoutBuilder;
}
class StaffLayoutBuilder implements IStaffLayoutBuilder{
  _p: StaffLayout = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: StaffLayout;
  constructor(toPatch?: StaffLayout) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["num"]) || this._b["num"] !== undefined || this._p.num !== undefined, "num is a required field");
  }
  build(): StaffLayout {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "StaffLayout";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  staffDistance(staffDistance: number): IStaffLayoutBuilder {
    this._p.staffDistance = staffDistance;
    this._m["staffDistance"] = true;
    return this;
  }
  num(num: number): IStaffLayoutBuilder {
    this._p.num = num;
    this._m["num"] = true;
    return this;
  }
}
export function patchStaffLayout(base: StaffLayout): IStaffLayoutBuilder { return new StaffLayoutBuilder(base); }
export function buildStaffLayout(): IStaffLayoutBuilder { return new StaffLayoutBuilder(); }

export interface IMeasureLayoutBuilder {
  build: () => MeasureLayout;
  patch: () => any[];
  measureDistance: (measureDistance: number) => IMeasureLayoutBuilder;
}
class MeasureLayoutBuilder implements IMeasureLayoutBuilder{
  _p: MeasureLayout = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: MeasureLayout;
  constructor(toPatch?: MeasureLayout) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): MeasureLayout {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "MeasureLayout";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  measureDistance(measureDistance: number): IMeasureLayoutBuilder {
    this._p.measureDistance = measureDistance;
    this._m["measureDistance"] = true;
    return this;
  }
}
export function patchMeasureLayout(base: MeasureLayout): IMeasureLayoutBuilder { return new MeasureLayoutBuilder(base); }
export function buildMeasureLayout(): IMeasureLayoutBuilder { return new MeasureLayoutBuilder(); }

export interface ILineWidthBuilder {
  build: () => LineWidth;
  patch: () => any[];
  tenths: (tenths: number) => ILineWidthBuilder;
  type: (type: string) => ILineWidthBuilder;
}
class LineWidthBuilder implements ILineWidthBuilder{
  _p: LineWidth = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: LineWidth;
  constructor(toPatch?: LineWidth) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["tenths"]) || this._b["tenths"] !== undefined || this._p.tenths !== undefined, "tenths is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): LineWidth {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "LineWidth";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  tenths(tenths: number): ILineWidthBuilder {
    this._p.tenths = tenths;
    this._m["tenths"] = true;
    return this;
  }
  type(type: string): ILineWidthBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
}
export function patchLineWidth(base: LineWidth): ILineWidthBuilder { return new LineWidthBuilder(base); }
export function buildLineWidth(): ILineWidthBuilder { return new LineWidthBuilder(); }

export interface INoteSizeBuilder {
  build: () => NoteSize;
  patch: () => any[];
  size: (size: number) => INoteSizeBuilder;
  type: (type: CueGraceLarge) => INoteSizeBuilder;
}
class NoteSizeBuilder implements INoteSizeBuilder{
  _p: NoteSize = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: NoteSize;
  constructor(toPatch?: NoteSize) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["size"]) || this._b["size"] !== undefined || this._p.size !== undefined, "size is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): NoteSize {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "NoteSize";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  size(size: number): INoteSizeBuilder {
    this._p.size = size;
    this._m["size"] = true;
    return this;
  }
  type(type: CueGraceLarge): INoteSizeBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
}
export function patchNoteSize(base: NoteSize): INoteSizeBuilder { return new NoteSizeBuilder(base); }
export function buildNoteSize(): INoteSizeBuilder { return new NoteSizeBuilder(); }

export interface IDistanceBuilder {
  build: () => Distance;
  patch: () => any[];
  tenths: (tenths: number) => IDistanceBuilder;
  type: (type: string) => IDistanceBuilder;
}
class DistanceBuilder implements IDistanceBuilder{
  _p: Distance = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Distance;
  constructor(toPatch?: Distance) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["tenths"]) || this._b["tenths"] !== undefined || this._p.tenths !== undefined, "tenths is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Distance {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Distance";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  tenths(tenths: number): IDistanceBuilder {
    this._p.tenths = tenths;
    this._m["tenths"] = true;
    return this;
  }
  type(type: string): IDistanceBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
}
export function patchDistance(base: Distance): IDistanceBuilder { return new DistanceBuilder(base); }
export function buildDistance(): IDistanceBuilder { return new DistanceBuilder(); }

export interface IAppearanceBuilder {
  build: () => Appearance;
  patch: () => any[];
  set: (key: string, val: NoteSize) => IAppearanceBuilder;
  otherAppearances: (otherAppearances: string[]) => IAppearanceBuilder;
}
class AppearanceBuilder implements IAppearanceBuilder{
  _p: Appearance = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Appearance;
  constructor(toPatch?: Appearance) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Appearance {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Appearance";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  set(key: string, val: NoteSize): IAppearanceBuilder {
    this._p[key] = val;
    this._m[key] = true;
    return this;
  }
  otherAppearances(otherAppearances: string[]): IAppearanceBuilder {
    this._p.otherAppearances = otherAppearances;
    this._m["otherAppearances"] = true;
    return this;
  }
}
export function patchAppearance(base: Appearance): IAppearanceBuilder { return new AppearanceBuilder(base); }
export function buildAppearance(): IAppearanceBuilder { return new AppearanceBuilder(); }

export interface ICreatorBuilder {
  build: () => Creator;
  patch: () => any[];
  creator: (creator: string) => ICreatorBuilder;
  type: (type: string) => ICreatorBuilder;
}
class CreatorBuilder implements ICreatorBuilder{
  _p: Creator = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Creator;
  constructor(toPatch?: Creator) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["creator"]) || this._b["creator"] !== undefined || this._p.creator !== undefined, "creator is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Creator {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Creator";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  creator(creator: string): ICreatorBuilder {
    this._p.creator = creator;
    this._m["creator"] = true;
    return this;
  }
  type(type: string): ICreatorBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
}
export function patchCreator(base: Creator): ICreatorBuilder { return new CreatorBuilder(base); }
export function buildCreator(): ICreatorBuilder { return new CreatorBuilder(); }

export interface IRightsBuilder {
  build: () => Rights;
  patch: () => any[];
  type: (type: string) => IRightsBuilder;
  rights: (rights: string) => IRightsBuilder;
}
class RightsBuilder implements IRightsBuilder{
  _p: Rights = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Rights;
  constructor(toPatch?: Rights) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
    console.assert((this._o && !this._m["rights"]) || this._b["rights"] !== undefined || this._p.rights !== undefined, "rights is a required field");
  }
  build(): Rights {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Rights";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  type(type: string): IRightsBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  rights(rights: string): IRightsBuilder {
    this._p.rights = rights;
    this._m["rights"] = true;
    return this;
  }
}
export function patchRights(base: Rights): IRightsBuilder { return new RightsBuilder(base); }
export function buildRights(): IRightsBuilder { return new RightsBuilder(); }

export interface IEncoderBuilder {
  build: () => Encoder;
  patch: () => any[];
  encoder: (encoder: string) => IEncoderBuilder;
  type: (type: string) => IEncoderBuilder;
}
class EncoderBuilder implements IEncoderBuilder{
  _p: Encoder = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Encoder;
  constructor(toPatch?: Encoder) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["encoder"]) || this._b["encoder"] !== undefined || this._p.encoder !== undefined, "encoder is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Encoder {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Encoder";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  encoder(encoder: string): IEncoderBuilder {
    this._p.encoder = encoder;
    this._m["encoder"] = true;
    return this;
  }
  type(type: string): IEncoderBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
}
export function patchEncoder(base: Encoder): IEncoderBuilder { return new EncoderBuilder(base); }
export function buildEncoder(): IEncoderBuilder { return new EncoderBuilder(); }

export interface IRelationBuilder {
  build: () => Relation;
  patch: () => any[];
  type: (type: string) => IRelationBuilder;
  data: (data: string) => IRelationBuilder;
}
class RelationBuilder implements IRelationBuilder{
  _p: Relation = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Relation;
  constructor(toPatch?: Relation) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): Relation {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Relation";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  type(type: string): IRelationBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  data(data: string): IRelationBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
}
export function patchRelation(base: Relation): IRelationBuilder { return new RelationBuilder(base); }
export function buildRelation(): IRelationBuilder { return new RelationBuilder(); }

export interface IMiscellaneousFieldBuilder {
  build: () => MiscellaneousField;
  patch: () => any[];
  data: (data: string) => IMiscellaneousFieldBuilder;
  name: (name: string) => IMiscellaneousFieldBuilder;
}
class MiscellaneousFieldBuilder implements IMiscellaneousFieldBuilder{
  _p: MiscellaneousField = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: MiscellaneousField;
  constructor(toPatch?: MiscellaneousField) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
    console.assert((this._o && !this._m["name"]) || this._b["name"] !== undefined || this._p.name !== undefined, "name is a required field");
  }
  build(): MiscellaneousField {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "MiscellaneousField";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IMiscellaneousFieldBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  name(name: string): IMiscellaneousFieldBuilder {
    this._p.name = name;
    this._m["name"] = true;
    return this;
  }
}
export function patchMiscellaneousField(base: MiscellaneousField): IMiscellaneousFieldBuilder { return new MiscellaneousFieldBuilder(base); }
export function buildMiscellaneousField(): IMiscellaneousFieldBuilder { return new MiscellaneousFieldBuilder(); }

export interface IMiscellaneousBuilder {
  build: () => Miscellaneous;
  patch: () => any[];
  miscellaneousFields: (miscellaneousFields: MiscellaneousField[]) => IMiscellaneousBuilder;
}
class MiscellaneousBuilder implements IMiscellaneousBuilder{
  _p: Miscellaneous = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Miscellaneous;
  constructor(toPatch?: Miscellaneous) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Miscellaneous {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Miscellaneous";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  miscellaneousFields(miscellaneousFields: MiscellaneousField[]): IMiscellaneousBuilder {
    this._p.miscellaneousFields = miscellaneousFields;
    this._m["miscellaneousFields"] = true;
    return this;
  }
}
export function patchMiscellaneous(base: Miscellaneous): IMiscellaneousBuilder { return new MiscellaneousBuilder(base); }
export function buildMiscellaneous(): IMiscellaneousBuilder { return new MiscellaneousBuilder(); }

export interface IIdentificationBuilder {
  build: () => Identification;
  patch: () => any[];
  miscellaneous: (build: (builder: IMiscellaneousBuilder) => IMiscellaneousBuilder) => IIdentificationBuilder;
  creators: (creators: Creator[]) => IIdentificationBuilder;
  relations: (relations: Relation[]) => IIdentificationBuilder;
  rights: (rights: Rights[]) => IIdentificationBuilder;
  encoding: (build: (builder: IEncodingBuilder) => IEncodingBuilder) => IIdentificationBuilder;
  source: (source: string) => IIdentificationBuilder;
}
class IdentificationBuilder implements IIdentificationBuilder{
  _p: Identification = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Identification;
  constructor(toPatch?: Identification) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["miscellaneous"]) || this._b["miscellaneous"] !== undefined || this._p.miscellaneous !== undefined, "miscellaneous is a required field");
    console.assert((this._o && !this._m["encoding"]) || this._b["encoding"] !== undefined || this._p.encoding !== undefined, "encoding is a required field");
    console.assert((this._o && !this._m["source"]) || this._b["source"] !== undefined || this._p.source !== undefined, "source is a required field");
  }
  build(): Identification {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Identification";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  miscellaneous(build: (builder: IMiscellaneousBuilder) => IMiscellaneousBuilder): IIdentificationBuilder {
    this._b["miscellaneous"] = build(new MiscellaneousBuilder(this._o && this._o["miscellaneous"]));
    this._m["miscellaneous"] = true;
    return this;
  }
  creators(creators: Creator[]): IIdentificationBuilder {
    this._p.creators = creators;
    this._m["creators"] = true;
    return this;
  }
  relations(relations: Relation[]): IIdentificationBuilder {
    this._p.relations = relations;
    this._m["relations"] = true;
    return this;
  }
  rights(rights: Rights[]): IIdentificationBuilder {
    this._p.rights = rights;
    this._m["rights"] = true;
    return this;
  }
  encoding(build: (builder: IEncodingBuilder) => IEncodingBuilder): IIdentificationBuilder {
    this._b["encoding"] = build(new EncodingBuilder(this._o && this._o["encoding"]));
    this._m["encoding"] = true;
    return this;
  }
  source(source: string): IIdentificationBuilder {
    this._p.source = source;
    this._m["source"] = true;
    return this;
  }
}
export function patchIdentification(base: Identification): IIdentificationBuilder { return new IdentificationBuilder(base); }
export function buildIdentification(): IIdentificationBuilder { return new IdentificationBuilder(); }

export interface ISupportsBuilder {
  build: () => Supports;
  patch: () => any[];
  element: (element: string) => ISupportsBuilder;
  attribute: (attribute: string) => ISupportsBuilder;
  value: (value: string) => ISupportsBuilder;
  type: (type: string) => ISupportsBuilder;
}
class SupportsBuilder implements ISupportsBuilder{
  _p: Supports = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Supports;
  constructor(toPatch?: Supports) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["element"]) || this._b["element"] !== undefined || this._p.element !== undefined, "element is a required field");
    console.assert((this._o && !this._m["value"]) || this._b["value"] !== undefined || this._p.value !== undefined, "value is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Supports {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Supports";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  element(element: string): ISupportsBuilder {
    this._p.element = element;
    this._m["element"] = true;
    return this;
  }
  attribute(attribute: string): ISupportsBuilder {
    this._p.attribute = attribute;
    this._m["attribute"] = true;
    return this;
  }
  value(value: string): ISupportsBuilder {
    this._p.value = value;
    this._m["value"] = true;
    return this;
  }
  type(type: string): ISupportsBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
}
export function patchSupports(base: Supports): ISupportsBuilder { return new SupportsBuilder(base); }
export function buildSupports(): ISupportsBuilder { return new SupportsBuilder(); }

export interface IEncodingBuilder {
  build: () => Encoding;
  patch: () => any[];
  encodingDescriptions: (encodingDescriptions: string[]) => IEncodingBuilder;
  encodingDate: (build: (builder: IEncodingDateBuilder) => IEncodingDateBuilder) => IEncodingBuilder;
  set: (key: string, val: Supports) => IEncodingBuilder;
  encoders: (encoders: Encoder[]) => IEncodingBuilder;
  softwares: (softwares: string[]) => IEncodingBuilder;
}
class EncodingBuilder implements IEncodingBuilder{
  _p: Encoding = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Encoding;
  constructor(toPatch?: Encoding) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Encoding {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Encoding";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  encodingDescriptions(encodingDescriptions: string[]): IEncodingBuilder {
    this._p.encodingDescriptions = encodingDescriptions;
    this._m["encodingDescriptions"] = true;
    return this;
  }
  encodingDate(build: (builder: IEncodingDateBuilder) => IEncodingDateBuilder): IEncodingBuilder {
    this._b["encodingDate"] = build(new EncodingDateBuilder(this._o && this._o["encodingDate"]));
    this._m["encodingDate"] = true;
    return this;
  }
  set(key: string, val: Supports): IEncodingBuilder {
    this._p[key] = val;
    this._m[key] = true;
    return this;
  }
  encoders(encoders: Encoder[]): IEncodingBuilder {
    this._p.encoders = encoders;
    this._m["encoders"] = true;
    return this;
  }
  softwares(softwares: string[]): IEncodingBuilder {
    this._p.softwares = softwares;
    this._m["softwares"] = true;
    return this;
  }
}
export function patchEncoding(base: Encoding): IEncodingBuilder { return new EncodingBuilder(base); }
export function buildEncoding(): IEncodingBuilder { return new EncodingBuilder(); }

export interface ITimeSeparatorBuilder {
  build: () => TimeSeparator;
  patch: () => any[];
  separator: (separator: SeparatorType) => ITimeSeparatorBuilder;
}
class TimeSeparatorBuilder implements ITimeSeparatorBuilder{
  _p: TimeSeparator = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TimeSeparator;
  constructor(toPatch?: TimeSeparator) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): TimeSeparator {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TimeSeparator";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  separator(separator: SeparatorType): ITimeSeparatorBuilder {
    this._p.separator = separator;
    this._m["separator"] = true;
    return this;
  }
}
export function patchTimeSeparator(base: TimeSeparator): ITimeSeparatorBuilder { return new TimeSeparatorBuilder(base); }
export function buildTimeSeparator(): ITimeSeparatorBuilder { return new TimeSeparatorBuilder(); }

export interface ITimeSymbolBuilder {
  build: () => TimeSymbol;
  patch: () => any[];
  symbol: (symbol: TimeSymbolType) => ITimeSymbolBuilder;
}
class TimeSymbolBuilder implements ITimeSymbolBuilder{
  _p: TimeSymbol = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TimeSymbol;
  constructor(toPatch?: TimeSymbol) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): TimeSymbol {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TimeSymbol";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  symbol(symbol: TimeSymbolType): ITimeSymbolBuilder {
    this._p.symbol = symbol;
    this._m["symbol"] = true;
    return this;
  }
}
export function patchTimeSymbol(base: TimeSymbol): ITimeSymbolBuilder { return new TimeSymbolBuilder(base); }
export function buildTimeSymbol(): ITimeSymbolBuilder { return new TimeSymbolBuilder(); }

export interface ICancelBuilder {
  build: () => Cancel;
  patch: () => any[];
  fifths: (fifths: number) => ICancelBuilder;
  location: (location: CancelLocation) => ICancelBuilder;
}
class CancelBuilder implements ICancelBuilder{
  _p: Cancel = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Cancel;
  constructor(toPatch?: Cancel) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["fifths"]) || this._b["fifths"] !== undefined || this._p.fifths !== undefined, "fifths is a required field");
  }
  build(): Cancel {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Cancel";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  fifths(fifths: number): ICancelBuilder {
    this._p.fifths = fifths;
    this._m["fifths"] = true;
    return this;
  }
  location(location: CancelLocation): ICancelBuilder {
    this._p.location = location;
    this._m["location"] = true;
    return this;
  }
}
export function patchCancel(base: Cancel): ICancelBuilder { return new CancelBuilder(base); }
export function buildCancel(): ICancelBuilder { return new CancelBuilder(); }

export interface IKeyOctaveBuilder {
  build: () => KeyOctave;
  patch: () => any[];
  octave: (octave: number) => IKeyOctaveBuilder;
  number: (number: number) => IKeyOctaveBuilder;
  cancel: (cancel: boolean) => IKeyOctaveBuilder;
}
class KeyOctaveBuilder implements IKeyOctaveBuilder{
  _p: KeyOctave = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: KeyOctave;
  constructor(toPatch?: KeyOctave) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["octave"]) || this._b["octave"] !== undefined || this._p.octave !== undefined, "octave is a required field");
    console.assert((this._o && !this._m["number"]) || this._b["number"] !== undefined || this._p.number !== undefined, "number is a required field");
  }
  build(): KeyOctave {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "KeyOctave";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  octave(octave: number): IKeyOctaveBuilder {
    this._p.octave = octave;
    this._m["octave"] = true;
    return this;
  }
  number(number: number): IKeyOctaveBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  cancel(cancel: boolean): IKeyOctaveBuilder {
    this._p.cancel = cancel;
    this._m["cancel"] = true;
    return this;
  }
}
export function patchKeyOctave(base: KeyOctave): IKeyOctaveBuilder { return new KeyOctaveBuilder(base); }
export function buildKeyOctave(): IKeyOctaveBuilder { return new KeyOctaveBuilder(); }

export interface IKeyBuilder {
  build: () => Key;
  patch: () => any[];
  cancel: (build: (builder: ICancelBuilder) => ICancelBuilder) => IKeyBuilder;
  keySteps: (keySteps: string[]) => IKeyBuilder;
  keyOctaves: (keyOctaves: KeyOctave[]) => IKeyBuilder;
  number: (number: number) => IKeyBuilder;
  fifths: (fifths: number) => IKeyBuilder;
  keyAlters: (keyAlters: string[]) => IKeyBuilder;
  keyAccidentals: (keyAccidentals: string[]) => IKeyBuilder;
  mode: (mode: string) => IKeyBuilder;
  _class: (_class: string) => IKeyBuilder;
  defaultX: (defaultX: number) => IKeyBuilder;
  relativeY: (relativeY: number) => IKeyBuilder;
  defaultY: (defaultY: number) => IKeyBuilder;
  relativeX: (relativeX: number) => IKeyBuilder;
}
class KeyBuilder implements IKeyBuilder{
  _p: Key = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Key;
  constructor(toPatch?: Key) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["keySteps"]) || this._b["keySteps"] !== undefined || this._p.keySteps !== undefined, "keySteps is a required field");
    console.assert((this._o && !this._m["fifths"]) || this._b["fifths"] !== undefined || this._p.fifths !== undefined, "fifths is a required field");
    console.assert((this._o && !this._m["keyAlters"]) || this._b["keyAlters"] !== undefined || this._p.keyAlters !== undefined, "keyAlters is a required field");
    console.assert((this._o && !this._m["keyAccidentals"]) || this._b["keyAccidentals"] !== undefined || this._p.keyAccidentals !== undefined, "keyAccidentals is a required field");
  }
  build(): Key {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Key";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  cancel(build: (builder: ICancelBuilder) => ICancelBuilder): IKeyBuilder {
    this._b["cancel"] = build(new CancelBuilder(this._o && this._o["cancel"]));
    this._m["cancel"] = true;
    return this;
  }
  keySteps(keySteps: string[]): IKeyBuilder {
    this._p.keySteps = keySteps;
    this._m["keySteps"] = true;
    return this;
  }
  keyOctaves(keyOctaves: KeyOctave[]): IKeyBuilder {
    this._p.keyOctaves = keyOctaves;
    this._m["keyOctaves"] = true;
    return this;
  }
  number(number: number): IKeyBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  fifths(fifths: number): IKeyBuilder {
    this._p.fifths = fifths;
    this._m["fifths"] = true;
    return this;
  }
  keyAlters(keyAlters: string[]): IKeyBuilder {
    this._p.keyAlters = keyAlters;
    this._m["keyAlters"] = true;
    return this;
  }
  keyAccidentals(keyAccidentals: string[]): IKeyBuilder {
    this._p.keyAccidentals = keyAccidentals;
    this._m["keyAccidentals"] = true;
    return this;
  }
  mode(mode: string): IKeyBuilder {
    this._p.mode = mode;
    this._m["mode"] = true;
    return this;
  }
  _class(_class: string): IKeyBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
  defaultX(defaultX: number): IKeyBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IKeyBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IKeyBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IKeyBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchKey(base: Key): IKeyBuilder { return new KeyBuilder(base); }
export function buildKey(): IKeyBuilder { return new KeyBuilder(); }

export interface ITimeBuilder {
  build: () => Time;
  patch: () => any[];
  interchangeable: (build: (builder: IInterchangeableBuilder) => IInterchangeableBuilder) => ITimeBuilder;
  beats: (beats: string[]) => ITimeBuilder;
  beatTypes: (beatTypes: number[]) => ITimeBuilder;
  senzaMisura: (senzaMisura: string) => ITimeBuilder;
  _class: (_class: string) => ITimeBuilder;
  symbol: (symbol: TimeSymbolType) => ITimeBuilder;
}
class TimeBuilder implements ITimeBuilder{
  _p: Time = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Time;
  constructor(toPatch?: Time) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["beats"]) || this._b["beats"] !== undefined || this._p.beats !== undefined, "beats is a required field");
    console.assert((this._o && !this._m["beatTypes"]) || this._b["beatTypes"] !== undefined || this._p.beatTypes !== undefined, "beatTypes is a required field");
  }
  build(): Time {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Time";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  interchangeable(build: (builder: IInterchangeableBuilder) => IInterchangeableBuilder): ITimeBuilder {
    this._b["interchangeable"] = build(new InterchangeableBuilder(this._o && this._o["interchangeable"]));
    this._m["interchangeable"] = true;
    return this;
  }
  beats(beats: string[]): ITimeBuilder {
    this._p.beats = beats;
    this._m["beats"] = true;
    return this;
  }
  beatTypes(beatTypes: number[]): ITimeBuilder {
    this._p.beatTypes = beatTypes;
    this._m["beatTypes"] = true;
    return this;
  }
  senzaMisura(senzaMisura: string): ITimeBuilder {
    this._p.senzaMisura = senzaMisura;
    this._m["senzaMisura"] = true;
    return this;
  }
  _class(_class: string): ITimeBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
  symbol(symbol: TimeSymbolType): ITimeBuilder {
    this._p.symbol = symbol;
    this._m["symbol"] = true;
    return this;
  }
}
export function patchTime(base: Time): ITimeBuilder { return new TimeBuilder(base); }
export function buildTime(): ITimeBuilder { return new TimeBuilder(); }

export interface IInterchangeableBuilder {
  build: () => Interchangeable;
  patch: () => any[];
  beats: (beats: string[]) => IInterchangeableBuilder;
  beatTypes: (beatTypes: number[]) => IInterchangeableBuilder;
  timeRelation: (timeRelation: string) => IInterchangeableBuilder;
  symbol: (symbol: TimeSymbolType) => IInterchangeableBuilder;
}
class InterchangeableBuilder implements IInterchangeableBuilder{
  _p: Interchangeable = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Interchangeable;
  constructor(toPatch?: Interchangeable) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["beats"]) || this._b["beats"] !== undefined || this._p.beats !== undefined, "beats is a required field");
    console.assert((this._o && !this._m["beatTypes"]) || this._b["beatTypes"] !== undefined || this._p.beatTypes !== undefined, "beatTypes is a required field");
  }
  build(): Interchangeable {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Interchangeable";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  beats(beats: string[]): IInterchangeableBuilder {
    this._p.beats = beats;
    this._m["beats"] = true;
    return this;
  }
  beatTypes(beatTypes: number[]): IInterchangeableBuilder {
    this._p.beatTypes = beatTypes;
    this._m["beatTypes"] = true;
    return this;
  }
  timeRelation(timeRelation: string): IInterchangeableBuilder {
    this._p.timeRelation = timeRelation;
    this._m["timeRelation"] = true;
    return this;
  }
  symbol(symbol: TimeSymbolType): IInterchangeableBuilder {
    this._p.symbol = symbol;
    this._m["symbol"] = true;
    return this;
  }
}
export function patchInterchangeable(base: Interchangeable): IInterchangeableBuilder { return new InterchangeableBuilder(base); }
export function buildInterchangeable(): IInterchangeableBuilder { return new InterchangeableBuilder(); }

export interface IPartSymbolBuilder {
  build: () => PartSymbol;
  patch: () => any[];
  topStaff: (topStaff: number) => IPartSymbolBuilder;
  type: (type: PartSymbolType) => IPartSymbolBuilder;
  bottomStaff: (bottomStaff: number) => IPartSymbolBuilder;
  _class: (_class: string) => IPartSymbolBuilder;
  defaultX: (defaultX: number) => IPartSymbolBuilder;
  relativeY: (relativeY: number) => IPartSymbolBuilder;
  defaultY: (defaultY: number) => IPartSymbolBuilder;
  relativeX: (relativeX: number) => IPartSymbolBuilder;
}
class PartSymbolBuilder implements IPartSymbolBuilder{
  _p: PartSymbol = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PartSymbol;
  constructor(toPatch?: PartSymbol) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): PartSymbol {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PartSymbol";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  topStaff(topStaff: number): IPartSymbolBuilder {
    this._p.topStaff = topStaff;
    this._m["topStaff"] = true;
    return this;
  }
  type(type: PartSymbolType): IPartSymbolBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  bottomStaff(bottomStaff: number): IPartSymbolBuilder {
    this._p.bottomStaff = bottomStaff;
    this._m["bottomStaff"] = true;
    return this;
  }
  _class(_class: string): IPartSymbolBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
  defaultX(defaultX: number): IPartSymbolBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IPartSymbolBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IPartSymbolBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IPartSymbolBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchPartSymbol(base: PartSymbol): IPartSymbolBuilder { return new PartSymbolBuilder(base); }
export function buildPartSymbol(): IPartSymbolBuilder { return new PartSymbolBuilder(); }

export interface IClefBuilder {
  build: () => Clef;
  patch: () => any[];
  clefOctaveChange: (clefOctaveChange: string) => IClefBuilder;
  sign: (sign: string) => IClefBuilder;
  number: (number: number) => IClefBuilder;
  size: (size: SymbolSize) => IClefBuilder;
  line: (line: number) => IClefBuilder;
  afterBarline: (afterBarline: boolean) => IClefBuilder;
  additional: (additional: boolean) => IClefBuilder;
  defaultX: (defaultX: number) => IClefBuilder;
  relativeY: (relativeY: number) => IClefBuilder;
  defaultY: (defaultY: number) => IClefBuilder;
  relativeX: (relativeX: number) => IClefBuilder;
}
class ClefBuilder implements IClefBuilder{
  _p: Clef = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Clef;
  constructor(toPatch?: Clef) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["clefOctaveChange"]) || this._b["clefOctaveChange"] !== undefined || this._p.clefOctaveChange !== undefined, "clefOctaveChange is a required field");
    console.assert((this._o && !this._m["sign"]) || this._b["sign"] !== undefined || this._p.sign !== undefined, "sign is a required field");
    console.assert((this._o && !this._m["line"]) || this._b["line"] !== undefined || this._p.line !== undefined, "line is a required field");
  }
  build(): Clef {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Clef";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  clefOctaveChange(clefOctaveChange: string): IClefBuilder {
    this._p.clefOctaveChange = clefOctaveChange;
    this._m["clefOctaveChange"] = true;
    return this;
  }
  sign(sign: string): IClefBuilder {
    this._p.sign = sign;
    this._m["sign"] = true;
    return this;
  }
  number(number: number): IClefBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  size(size: SymbolSize): IClefBuilder {
    this._p.size = size;
    this._m["size"] = true;
    return this;
  }
  line(line: number): IClefBuilder {
    this._p.line = line;
    this._m["line"] = true;
    return this;
  }
  afterBarline(afterBarline: boolean): IClefBuilder {
    this._p.afterBarline = afterBarline;
    this._m["afterBarline"] = true;
    return this;
  }
  additional(additional: boolean): IClefBuilder {
    this._p.additional = additional;
    this._m["additional"] = true;
    return this;
  }
  defaultX(defaultX: number): IClefBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IClefBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IClefBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IClefBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchClef(base: Clef): IClefBuilder { return new ClefBuilder(base); }
export function buildClef(): IClefBuilder { return new ClefBuilder(); }

export interface IStaffTuningBuilder {
  build: () => StaffTuning;
  patch: () => any[];
  tuningAlter: (tuningAlter: string) => IStaffTuningBuilder;
  line: (line: string) => IStaffTuningBuilder;
  tuningStep: (tuningStep: string) => IStaffTuningBuilder;
  tuningOctave: (tuningOctave: string) => IStaffTuningBuilder;
}
class StaffTuningBuilder implements IStaffTuningBuilder{
  _p: StaffTuning = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: StaffTuning;
  constructor(toPatch?: StaffTuning) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["line"]) || this._b["line"] !== undefined || this._p.line !== undefined, "line is a required field");
    console.assert((this._o && !this._m["tuningStep"]) || this._b["tuningStep"] !== undefined || this._p.tuningStep !== undefined, "tuningStep is a required field");
    console.assert((this._o && !this._m["tuningOctave"]) || this._b["tuningOctave"] !== undefined || this._p.tuningOctave !== undefined, "tuningOctave is a required field");
  }
  build(): StaffTuning {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "StaffTuning";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  tuningAlter(tuningAlter: string): IStaffTuningBuilder {
    this._p.tuningAlter = tuningAlter;
    this._m["tuningAlter"] = true;
    return this;
  }
  line(line: string): IStaffTuningBuilder {
    this._p.line = line;
    this._m["line"] = true;
    return this;
  }
  tuningStep(tuningStep: string): IStaffTuningBuilder {
    this._p.tuningStep = tuningStep;
    this._m["tuningStep"] = true;
    return this;
  }
  tuningOctave(tuningOctave: string): IStaffTuningBuilder {
    this._p.tuningOctave = tuningOctave;
    this._m["tuningOctave"] = true;
    return this;
  }
}
export function patchStaffTuning(base: StaffTuning): IStaffTuningBuilder { return new StaffTuningBuilder(base); }
export function buildStaffTuning(): IStaffTuningBuilder { return new StaffTuningBuilder(); }

export interface IStaffDetailsBuilder {
  build: () => StaffDetails;
  patch: () => any[];
  staffLines: (staffLines: number) => IStaffDetailsBuilder;
  staffTunings: (staffTunings: StaffTuning[]) => IStaffDetailsBuilder;
  staffSize: (staffSize: number) => IStaffDetailsBuilder;
  showFrets: (showFrets: ShowFretsType) => IStaffDetailsBuilder;
  capo: (capo: string) => IStaffDetailsBuilder;
  number: (number: number) => IStaffDetailsBuilder;
  staffType: (staffType: string) => IStaffDetailsBuilder;
  printObject: (printObject: boolean) => IStaffDetailsBuilder;
}
class StaffDetailsBuilder implements IStaffDetailsBuilder{
  _p: StaffDetails = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: StaffDetails;
  constructor(toPatch?: StaffDetails) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): StaffDetails {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "StaffDetails";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  staffLines(staffLines: number): IStaffDetailsBuilder {
    this._p.staffLines = staffLines;
    this._m["staffLines"] = true;
    return this;
  }
  staffTunings(staffTunings: StaffTuning[]): IStaffDetailsBuilder {
    this._p.staffTunings = staffTunings;
    this._m["staffTunings"] = true;
    return this;
  }
  staffSize(staffSize: number): IStaffDetailsBuilder {
    this._p.staffSize = staffSize;
    this._m["staffSize"] = true;
    return this;
  }
  showFrets(showFrets: ShowFretsType): IStaffDetailsBuilder {
    this._p.showFrets = showFrets;
    this._m["showFrets"] = true;
    return this;
  }
  capo(capo: string): IStaffDetailsBuilder {
    this._p.capo = capo;
    this._m["capo"] = true;
    return this;
  }
  number(number: number): IStaffDetailsBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  staffType(staffType: string): IStaffDetailsBuilder {
    this._p.staffType = staffType;
    this._m["staffType"] = true;
    return this;
  }
  printObject(printObject: boolean): IStaffDetailsBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchStaffDetails(base: StaffDetails): IStaffDetailsBuilder { return new StaffDetailsBuilder(base); }
export function buildStaffDetails(): IStaffDetailsBuilder { return new StaffDetailsBuilder(); }

export interface IDoubleBuilder {
  build: () => Double;
  patch: () => any[];
}
class DoubleBuilder implements IDoubleBuilder{
  _p: Double = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Double;
  constructor(toPatch?: Double) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Double {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Double";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
}
export function patchDouble(base: Double): IDoubleBuilder { return new DoubleBuilder(base); }
export function buildDouble(): IDoubleBuilder { return new DoubleBuilder(); }

export interface ITransposeBuilder {
  build: () => Transpose;
  patch: () => any[];
  number: (number: number) => ITransposeBuilder;
  diatonic: (diatonic: string) => ITransposeBuilder;
  octaveChange: (octaveChange: string) => ITransposeBuilder;
  double: (build: (builder: IDoubleBuilder) => IDoubleBuilder) => ITransposeBuilder;
  chromatic: (chromatic: string) => ITransposeBuilder;
}
class TransposeBuilder implements ITransposeBuilder{
  _p: Transpose = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Transpose;
  constructor(toPatch?: Transpose) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["chromatic"]) || this._b["chromatic"] !== undefined || this._p.chromatic !== undefined, "chromatic is a required field");
  }
  build(): Transpose {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Transpose";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: number): ITransposeBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  diatonic(diatonic: string): ITransposeBuilder {
    this._p.diatonic = diatonic;
    this._m["diatonic"] = true;
    return this;
  }
  octaveChange(octaveChange: string): ITransposeBuilder {
    this._p.octaveChange = octaveChange;
    this._m["octaveChange"] = true;
    return this;
  }
  double(build: (builder: IDoubleBuilder) => IDoubleBuilder): ITransposeBuilder {
    this._b["double"] = build(new DoubleBuilder(this._o && this._o["double"]));
    this._m["double"] = true;
    return this;
  }
  chromatic(chromatic: string): ITransposeBuilder {
    this._p.chromatic = chromatic;
    this._m["chromatic"] = true;
    return this;
  }
}
export function patchTranspose(base: Transpose): ITransposeBuilder { return new TransposeBuilder(base); }
export function buildTranspose(): ITransposeBuilder { return new TransposeBuilder(); }

export interface IDirectiveBuilder {
  build: () => Directive;
  patch: () => any[];
  data: (data: string) => IDirectiveBuilder;
  defaultX: (defaultX: number) => IDirectiveBuilder;
  relativeY: (relativeY: number) => IDirectiveBuilder;
  defaultY: (defaultY: number) => IDirectiveBuilder;
  relativeX: (relativeX: number) => IDirectiveBuilder;
}
class DirectiveBuilder implements IDirectiveBuilder{
  _p: Directive = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Directive;
  constructor(toPatch?: Directive) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): Directive {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Directive";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IDirectiveBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IDirectiveBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IDirectiveBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IDirectiveBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IDirectiveBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchDirective(base: Directive): IDirectiveBuilder { return new DirectiveBuilder(base); }
export function buildDirective(): IDirectiveBuilder { return new DirectiveBuilder(); }

export interface ISlashDotBuilder {
  build: () => SlashDot;
  patch: () => any[];
}
class SlashDotBuilder implements ISlashDotBuilder{
  _p: SlashDot = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: SlashDot;
  constructor(toPatch?: SlashDot) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): SlashDot {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "SlashDot";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
}
export function patchSlashDot(base: SlashDot): ISlashDotBuilder { return new SlashDotBuilder(base); }
export function buildSlashDot(): ISlashDotBuilder { return new SlashDotBuilder(); }

export interface IMultipleRestBuilder {
  build: () => MultipleRest;
  patch: () => any[];
  useSymbols: (useSymbols: boolean) => IMultipleRestBuilder;
  count: (count: number) => IMultipleRestBuilder;
}
class MultipleRestBuilder implements IMultipleRestBuilder{
  _p: MultipleRest = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: MultipleRest;
  constructor(toPatch?: MultipleRest) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["count"]) || this._b["count"] !== undefined || this._p.count !== undefined, "count is a required field");
  }
  build(): MultipleRest {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "MultipleRest";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  useSymbols(useSymbols: boolean): IMultipleRestBuilder {
    this._p.useSymbols = useSymbols;
    this._m["useSymbols"] = true;
    return this;
  }
  count(count: number): IMultipleRestBuilder {
    this._p.count = count;
    this._m["count"] = true;
    return this;
  }
}
export function patchMultipleRest(base: MultipleRest): IMultipleRestBuilder { return new MultipleRestBuilder(base); }
export function buildMultipleRest(): IMultipleRestBuilder { return new MultipleRestBuilder(); }

export interface IMeasureRepeatBuilder {
  build: () => MeasureRepeat;
  patch: () => any[];
  data: (data: string) => IMeasureRepeatBuilder;
  type: (type: StartStop) => IMeasureRepeatBuilder;
  slashes: (slashes: number) => IMeasureRepeatBuilder;
}
class MeasureRepeatBuilder implements IMeasureRepeatBuilder{
  _p: MeasureRepeat = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: MeasureRepeat;
  constructor(toPatch?: MeasureRepeat) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): MeasureRepeat {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "MeasureRepeat";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IMeasureRepeatBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  type(type: StartStop): IMeasureRepeatBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  slashes(slashes: number): IMeasureRepeatBuilder {
    this._p.slashes = slashes;
    this._m["slashes"] = true;
    return this;
  }
}
export function patchMeasureRepeat(base: MeasureRepeat): IMeasureRepeatBuilder { return new MeasureRepeatBuilder(base); }
export function buildMeasureRepeat(): IMeasureRepeatBuilder { return new MeasureRepeatBuilder(); }

export interface IBeatRepeatBuilder {
  build: () => BeatRepeat;
  patch: () => any[];
  slashType: (slashType: string) => IBeatRepeatBuilder;
  useDots: (useDots: boolean) => IBeatRepeatBuilder;
  slashDots: (slashDots: SlashDot[]) => IBeatRepeatBuilder;
  slases: (slases: number) => IBeatRepeatBuilder;
  type: (type: StartStop) => IBeatRepeatBuilder;
}
class BeatRepeatBuilder implements IBeatRepeatBuilder{
  _p: BeatRepeat = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: BeatRepeat;
  constructor(toPatch?: BeatRepeat) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): BeatRepeat {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "BeatRepeat";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  slashType(slashType: string): IBeatRepeatBuilder {
    this._p.slashType = slashType;
    this._m["slashType"] = true;
    return this;
  }
  useDots(useDots: boolean): IBeatRepeatBuilder {
    this._p.useDots = useDots;
    this._m["useDots"] = true;
    return this;
  }
  slashDots(slashDots: SlashDot[]): IBeatRepeatBuilder {
    this._p.slashDots = slashDots;
    this._m["slashDots"] = true;
    return this;
  }
  slases(slases: number): IBeatRepeatBuilder {
    this._p.slases = slases;
    this._m["slases"] = true;
    return this;
  }
  type(type: StartStop): IBeatRepeatBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
}
export function patchBeatRepeat(base: BeatRepeat): IBeatRepeatBuilder { return new BeatRepeatBuilder(base); }
export function buildBeatRepeat(): IBeatRepeatBuilder { return new BeatRepeatBuilder(); }

export interface ISlashBuilder {
  build: () => Slash;
  patch: () => any[];
  slashType: (slashType: string) => ISlashBuilder;
  useDots: (useDots: boolean) => ISlashBuilder;
  useStems: (useStems: boolean) => ISlashBuilder;
  slashDots: (slashDots: SlashDot[]) => ISlashBuilder;
  type: (type: StartStop) => ISlashBuilder;
}
class SlashBuilder implements ISlashBuilder{
  _p: Slash = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Slash;
  constructor(toPatch?: Slash) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Slash {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Slash";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  slashType(slashType: string): ISlashBuilder {
    this._p.slashType = slashType;
    this._m["slashType"] = true;
    return this;
  }
  useDots(useDots: boolean): ISlashBuilder {
    this._p.useDots = useDots;
    this._m["useDots"] = true;
    return this;
  }
  useStems(useStems: boolean): ISlashBuilder {
    this._p.useStems = useStems;
    this._m["useStems"] = true;
    return this;
  }
  slashDots(slashDots: SlashDot[]): ISlashBuilder {
    this._p.slashDots = slashDots;
    this._m["slashDots"] = true;
    return this;
  }
  type(type: StartStop): ISlashBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
}
export function patchSlash(base: Slash): ISlashBuilder { return new SlashBuilder(base); }
export function buildSlash(): ISlashBuilder { return new SlashBuilder(); }

export interface IMeasureStyleBuilder {
  build: () => MeasureStyle;
  patch: () => any[];
  measureRepeat: (build: (builder: IMeasureRepeatBuilder) => IMeasureRepeatBuilder) => IMeasureStyleBuilder;
  beatRepeat: (build: (builder: IBeatRepeatBuilder) => IBeatRepeatBuilder) => IMeasureStyleBuilder;
  multipleRest: (build: (builder: IMultipleRestBuilder) => IMultipleRestBuilder) => IMeasureStyleBuilder;
  slash: (build: (builder: ISlashBuilder) => ISlashBuilder) => IMeasureStyleBuilder;
  number: (number: number) => IMeasureStyleBuilder;
  fontFamily: (fontFamily: string) => IMeasureStyleBuilder;
  fontWeight: (fontWeight: NormalBold) => IMeasureStyleBuilder;
  fontStyle: (fontStyle: NormalItalic) => IMeasureStyleBuilder;
  fontSize: (fontSize: string) => IMeasureStyleBuilder;
}
class MeasureStyleBuilder implements IMeasureStyleBuilder{
  _p: MeasureStyle = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: MeasureStyle;
  constructor(toPatch?: MeasureStyle) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): MeasureStyle {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "MeasureStyle";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  measureRepeat(build: (builder: IMeasureRepeatBuilder) => IMeasureRepeatBuilder): IMeasureStyleBuilder {
    this._b["measureRepeat"] = build(new MeasureRepeatBuilder(this._o && this._o["measureRepeat"]));
    this._m["measureRepeat"] = true;
    return this;
  }
  beatRepeat(build: (builder: IBeatRepeatBuilder) => IBeatRepeatBuilder): IMeasureStyleBuilder {
    this._b["beatRepeat"] = build(new BeatRepeatBuilder(this._o && this._o["beatRepeat"]));
    this._m["beatRepeat"] = true;
    return this;
  }
  multipleRest(build: (builder: IMultipleRestBuilder) => IMultipleRestBuilder): IMeasureStyleBuilder {
    this._b["multipleRest"] = build(new MultipleRestBuilder(this._o && this._o["multipleRest"]));
    this._m["multipleRest"] = true;
    return this;
  }
  slash(build: (builder: ISlashBuilder) => ISlashBuilder): IMeasureStyleBuilder {
    this._b["slash"] = build(new SlashBuilder(this._o && this._o["slash"]));
    this._m["slash"] = true;
    return this;
  }
  number(number: number): IMeasureStyleBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  fontFamily(fontFamily: string): IMeasureStyleBuilder {
    this._p.fontFamily = fontFamily;
    this._m["fontFamily"] = true;
    return this;
  }
  fontWeight(fontWeight: NormalBold): IMeasureStyleBuilder {
    this._p.fontWeight = fontWeight;
    this._m["fontWeight"] = true;
    return this;
  }
  fontStyle(fontStyle: NormalItalic): IMeasureStyleBuilder {
    this._p.fontStyle = fontStyle;
    this._m["fontStyle"] = true;
    return this;
  }
  fontSize(fontSize: string): IMeasureStyleBuilder {
    this._p.fontSize = fontSize;
    this._m["fontSize"] = true;
    return this;
  }
}
export function patchMeasureStyle(base: MeasureStyle): IMeasureStyleBuilder { return new MeasureStyleBuilder(base); }
export function buildMeasureStyle(): IMeasureStyleBuilder { return new MeasureStyleBuilder(); }

export interface IAttributesBuilder {
  build: () => Attributes;
  patch: () => any[];
  divisions: (divisions: number) => IAttributesBuilder;
  partSymbol: (build: (builder: IPartSymbolBuilder) => IPartSymbolBuilder) => IAttributesBuilder;
  clefs: (clefs: Clef[]) => IAttributesBuilder;
  measureStyles: (measureStyles: MeasureStyle[]) => IAttributesBuilder;
  times: (times: Time[]) => IAttributesBuilder;
  staffDetails: (staffDetails: StaffDetails[]) => IAttributesBuilder;
  transposes: (transposes: Transpose[]) => IAttributesBuilder;
  staves: (staves: number) => IAttributesBuilder;
  instruments: (instruments: string) => IAttributesBuilder;
  keySignatures: (keySignatures: Key[]) => IAttributesBuilder;
  directives: (directives: Directive[]) => IAttributesBuilder;
  footnote: (build: (builder: IFootnoteBuilder) => IFootnoteBuilder) => IAttributesBuilder;
  level: (build: (builder: ILevelBuilder) => ILevelBuilder) => IAttributesBuilder;
  _class: (_class: string) => IAttributesBuilder;
}
class AttributesBuilder implements IAttributesBuilder{
  _p: Attributes = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Attributes;
  constructor(toPatch?: Attributes) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["divisions"]) || this._b["divisions"] !== undefined || this._p.divisions !== undefined, "divisions is a required field");
  }
  build(): Attributes {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Attributes";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  divisions(divisions: number): IAttributesBuilder {
    this._p.divisions = divisions;
    this._m["divisions"] = true;
    return this;
  }
  partSymbol(build: (builder: IPartSymbolBuilder) => IPartSymbolBuilder): IAttributesBuilder {
    this._b["partSymbol"] = build(new PartSymbolBuilder(this._o && this._o["partSymbol"]));
    this._m["partSymbol"] = true;
    return this;
  }
  clefs(clefs: Clef[]): IAttributesBuilder {
    this._p.clefs = clefs;
    this._m["clefs"] = true;
    return this;
  }
  measureStyles(measureStyles: MeasureStyle[]): IAttributesBuilder {
    this._p.measureStyles = measureStyles;
    this._m["measureStyles"] = true;
    return this;
  }
  times(times: Time[]): IAttributesBuilder {
    this._p.times = times;
    this._m["times"] = true;
    return this;
  }
  staffDetails(staffDetails: StaffDetails[]): IAttributesBuilder {
    this._p.staffDetails = staffDetails;
    this._m["staffDetails"] = true;
    return this;
  }
  transposes(transposes: Transpose[]): IAttributesBuilder {
    this._p.transposes = transposes;
    this._m["transposes"] = true;
    return this;
  }
  staves(staves: number): IAttributesBuilder {
    this._p.staves = staves;
    this._m["staves"] = true;
    return this;
  }
  instruments(instruments: string): IAttributesBuilder {
    this._p.instruments = instruments;
    this._m["instruments"] = true;
    return this;
  }
  keySignatures(keySignatures: Key[]): IAttributesBuilder {
    this._p.keySignatures = keySignatures;
    this._m["keySignatures"] = true;
    return this;
  }
  directives(directives: Directive[]): IAttributesBuilder {
    this._p.directives = directives;
    this._m["directives"] = true;
    return this;
  }
  footnote(build: (builder: IFootnoteBuilder) => IFootnoteBuilder): IAttributesBuilder {
    this._b["footnote"] = build(new FootnoteBuilder(this._o && this._o["footnote"]));
    this._m["footnote"] = true;
    return this;
  }
  level(build: (builder: ILevelBuilder) => ILevelBuilder): IAttributesBuilder {
    this._b["level"] = build(new LevelBuilder(this._o && this._o["level"]));
    this._m["level"] = true;
    return this;
  }
  _class(_class: string): IAttributesBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchAttributes(base: Attributes): IAttributesBuilder { return new AttributesBuilder(base); }
export function buildAttributes(): IAttributesBuilder { return new AttributesBuilder(); }

export interface ICueBuilder {
  build: () => Cue;
  patch: () => any[];
}
class CueBuilder implements ICueBuilder{
  _p: Cue = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Cue;
  constructor(toPatch?: Cue) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Cue {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Cue";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
}
export function patchCue(base: Cue): ICueBuilder { return new CueBuilder(base); }
export function buildCue(): ICueBuilder { return new CueBuilder(); }

export interface IGraceBuilder {
  build: () => Grace;
  patch: () => any[];
  makeTime: (makeTime: string) => IGraceBuilder;
  stealTimePrevious: (stealTimePrevious: string) => IGraceBuilder;
  slash: (slash: boolean) => IGraceBuilder;
  stealTimeFollowing: (stealTimeFollowing: string) => IGraceBuilder;
}
class GraceBuilder implements IGraceBuilder{
  _p: Grace = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Grace;
  constructor(toPatch?: Grace) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Grace {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Grace";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  makeTime(makeTime: string): IGraceBuilder {
    this._p.makeTime = makeTime;
    this._m["makeTime"] = true;
    return this;
  }
  stealTimePrevious(stealTimePrevious: string): IGraceBuilder {
    this._p.stealTimePrevious = stealTimePrevious;
    this._m["stealTimePrevious"] = true;
    return this;
  }
  slash(slash: boolean): IGraceBuilder {
    this._p.slash = slash;
    this._m["slash"] = true;
    return this;
  }
  stealTimeFollowing(stealTimeFollowing: string): IGraceBuilder {
    this._p.stealTimeFollowing = stealTimeFollowing;
    this._m["stealTimeFollowing"] = true;
    return this;
  }
}
export function patchGrace(base: Grace): IGraceBuilder { return new GraceBuilder(base); }
export function buildGrace(): IGraceBuilder { return new GraceBuilder(); }

export interface IChordBuilder {
  build: () => Chord;
  patch: () => any[];
}
class ChordBuilder implements IChordBuilder{
  _p: Chord = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Chord;
  constructor(toPatch?: Chord) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Chord {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Chord";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
}
export function patchChord(base: Chord): IChordBuilder { return new ChordBuilder(base); }
export function buildChord(): IChordBuilder { return new ChordBuilder(); }

export interface IUnpitchedBuilder {
  build: () => Unpitched;
  patch: () => any[];
  displayStep: (displayStep: string) => IUnpitchedBuilder;
  displayOctave: (displayOctave: string) => IUnpitchedBuilder;
}
class UnpitchedBuilder implements IUnpitchedBuilder{
  _p: Unpitched = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Unpitched;
  constructor(toPatch?: Unpitched) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Unpitched {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Unpitched";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  displayStep(displayStep: string): IUnpitchedBuilder {
    this._p.displayStep = displayStep;
    this._m["displayStep"] = true;
    return this;
  }
  displayOctave(displayOctave: string): IUnpitchedBuilder {
    this._p.displayOctave = displayOctave;
    this._m["displayOctave"] = true;
    return this;
  }
}
export function patchUnpitched(base: Unpitched): IUnpitchedBuilder { return new UnpitchedBuilder(base); }
export function buildUnpitched(): IUnpitchedBuilder { return new UnpitchedBuilder(); }

export interface IPitchBuilder {
  build: () => Pitch;
  patch: () => any[];
  alter: (alter: number) => IPitchBuilder;
  step: (step: string) => IPitchBuilder;
  octave: (octave: number) => IPitchBuilder;
}
class PitchBuilder implements IPitchBuilder{
  _p: Pitch = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Pitch;
  constructor(toPatch?: Pitch) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["octave"]) || this._b["octave"] !== undefined || this._p.octave !== undefined, "octave is a required field");
  }
  build(): Pitch {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Pitch";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  alter(alter: number): IPitchBuilder {
    this._p.alter = alter;
    this._m["alter"] = true;
    return this;
  }
  step(step: string): IPitchBuilder {
    this._p.step = step;
    this._m["step"] = true;
    return this;
  }
  octave(octave: number): IPitchBuilder {
    this._p.octave = octave;
    this._m["octave"] = true;
    return this;
  }
}
export function patchPitch(base: Pitch): IPitchBuilder { return new PitchBuilder(base); }
export function buildPitch(): IPitchBuilder { return new PitchBuilder(); }

export interface IFullNoteBuilder {
  build: () => FullNote;
  patch: () => any[];
  unpitched: (build: (builder: IUnpitchedBuilder) => IUnpitchedBuilder) => IFullNoteBuilder;
  chord: (build: (builder: IChordBuilder) => IChordBuilder) => IFullNoteBuilder;
  pitch: (build: (builder: IPitchBuilder) => IPitchBuilder) => IFullNoteBuilder;
  rest: (build: (builder: IRestBuilder) => IRestBuilder) => IFullNoteBuilder;
}
class FullNoteBuilder implements IFullNoteBuilder{
  _p: FullNote = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: FullNote;
  constructor(toPatch?: FullNote) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): FullNote {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "FullNote";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  unpitched(build: (builder: IUnpitchedBuilder) => IUnpitchedBuilder): IFullNoteBuilder {
    this._b["unpitched"] = build(new UnpitchedBuilder(this._o && this._o["unpitched"]));
    this._m["unpitched"] = true;
    return this;
  }
  chord(build: (builder: IChordBuilder) => IChordBuilder): IFullNoteBuilder {
    this._b["chord"] = build(new ChordBuilder(this._o && this._o["chord"]));
    this._m["chord"] = true;
    return this;
  }
  pitch(build: (builder: IPitchBuilder) => IPitchBuilder): IFullNoteBuilder {
    this._b["pitch"] = build(new PitchBuilder(this._o && this._o["pitch"]));
    this._m["pitch"] = true;
    return this;
  }
  rest(build: (builder: IRestBuilder) => IRestBuilder): IFullNoteBuilder {
    this._b["rest"] = build(new RestBuilder(this._o && this._o["rest"]));
    this._m["rest"] = true;
    return this;
  }
}
export function patchFullNote(base: FullNote): IFullNoteBuilder { return new FullNoteBuilder(base); }
export function buildFullNote(): IFullNoteBuilder { return new FullNoteBuilder(); }

export interface IRestBuilder {
  build: () => Rest;
  patch: () => any[];
  measure: (measure: boolean) => IRestBuilder;
  displayStep: (displayStep: string) => IRestBuilder;
  displayOctave: (displayOctave: string) => IRestBuilder;
}
class RestBuilder implements IRestBuilder{
  _p: Rest = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Rest;
  constructor(toPatch?: Rest) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Rest {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Rest";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  measure(measure: boolean): IRestBuilder {
    this._p.measure = measure;
    this._m["measure"] = true;
    return this;
  }
  displayStep(displayStep: string): IRestBuilder {
    this._p.displayStep = displayStep;
    this._m["displayStep"] = true;
    return this;
  }
  displayOctave(displayOctave: string): IRestBuilder {
    this._p.displayOctave = displayOctave;
    this._m["displayOctave"] = true;
    return this;
  }
}
export function patchRest(base: Rest): IRestBuilder { return new RestBuilder(base); }
export function buildRest(): IRestBuilder { return new RestBuilder(); }

export interface ITieBuilder {
  build: () => Tie;
  patch: () => any[];
  type: (type: StartStop) => ITieBuilder;
  timeOnly: (timeOnly: string) => ITieBuilder;
}
class TieBuilder implements ITieBuilder{
  _p: Tie = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Tie;
  constructor(toPatch?: Tie) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Tie {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Tie";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  type(type: StartStop): ITieBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  timeOnly(timeOnly: string): ITieBuilder {
    this._p.timeOnly = timeOnly;
    this._m["timeOnly"] = true;
    return this;
  }
}
export function patchTie(base: Tie): ITieBuilder { return new TieBuilder(base); }
export function buildTie(): ITieBuilder { return new TieBuilder(); }

export interface IInstrumentBuilder {
  build: () => Instrument;
  patch: () => any[];
  id: (id: string) => IInstrumentBuilder;
}
class InstrumentBuilder implements IInstrumentBuilder{
  _p: Instrument = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Instrument;
  constructor(toPatch?: Instrument) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["id"]) || this._b["id"] !== undefined || this._p.id !== undefined, "id is a required field");
  }
  build(): Instrument {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Instrument";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  id(id: string): IInstrumentBuilder {
    this._p.id = id;
    this._m["id"] = true;
    return this;
  }
}
export function patchInstrument(base: Instrument): IInstrumentBuilder { return new InstrumentBuilder(base); }
export function buildInstrument(): IInstrumentBuilder { return new InstrumentBuilder(); }

export interface INoteBuilder {
  build: () => Note;
  patch: () => any[];
  noteheadText: (build: (builder: INoteheadTextBuilder) => INoteheadTextBuilder) => INoteBuilder;
  timeModification: (build: (builder: ITimeModificationBuilder) => ITimeModificationBuilder) => INoteBuilder;
  accidental: (build: (builder: IAccidentalBuilder) => IAccidentalBuilder) => INoteBuilder;
  instrument: (build: (builder: IInstrumentBuilder) => IInstrumentBuilder) => INoteBuilder;
  attack: (attack: number) => INoteBuilder;
  endDynamics: (endDynamics: number) => INoteBuilder;
  lyrics: (lyrics: Lyric[]) => INoteBuilder;
  dots: (dots: Dot[]) => INoteBuilder;
  notations: (notations: Notations[]) => INoteBuilder;
  stem: (build: (builder: IStemBuilder) => IStemBuilder) => INoteBuilder;
  noteType: (build: (builder: ITypeBuilder) => ITypeBuilder) => INoteBuilder;
  pizzicato: (pizzicato: boolean) => INoteBuilder;
  cue: (build: (builder: ICueBuilder) => ICueBuilder) => INoteBuilder;
  duration: (duration: number) => INoteBuilder;
  ties: (ties: Tie[]) => INoteBuilder;
  dynamics: (dynamics: number) => INoteBuilder;
  play: (build: (builder: IPlayBuilder) => IPlayBuilder) => INoteBuilder;
  staff: (staff: number) => INoteBuilder;
  grace: (build: (builder: IGraceBuilder) => IGraceBuilder) => INoteBuilder;
  notehead: (build: (builder: INoteheadBuilder) => INoteheadBuilder) => INoteBuilder;
  release: (release: number) => INoteBuilder;
  beams: (beams: Beam[]) => INoteBuilder;
  voice: (voice: number) => INoteBuilder;
  footnote: (build: (builder: IFootnoteBuilder) => IFootnoteBuilder) => INoteBuilder;
  level: (build: (builder: ILevelBuilder) => ILevelBuilder) => INoteBuilder;
  _class: (_class: string) => INoteBuilder;
}
class NoteBuilder implements INoteBuilder{
  _p: Note = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Note;
  constructor(toPatch?: Note) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Note {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Note";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  noteheadText(build: (builder: INoteheadTextBuilder) => INoteheadTextBuilder): INoteBuilder {
    this._b["noteheadText"] = build(new NoteheadTextBuilder(this._o && this._o["noteheadText"]));
    this._m["noteheadText"] = true;
    return this;
  }
  timeModification(build: (builder: ITimeModificationBuilder) => ITimeModificationBuilder): INoteBuilder {
    this._b["timeModification"] = build(new TimeModificationBuilder(this._o && this._o["timeModification"]));
    this._m["timeModification"] = true;
    return this;
  }
  accidental(build: (builder: IAccidentalBuilder) => IAccidentalBuilder): INoteBuilder {
    this._b["accidental"] = build(new AccidentalBuilder(this._o && this._o["accidental"]));
    this._m["accidental"] = true;
    return this;
  }
  instrument(build: (builder: IInstrumentBuilder) => IInstrumentBuilder): INoteBuilder {
    this._b["instrument"] = build(new InstrumentBuilder(this._o && this._o["instrument"]));
    this._m["instrument"] = true;
    return this;
  }
  attack(attack: number): INoteBuilder {
    this._p.attack = attack;
    this._m["attack"] = true;
    return this;
  }
  endDynamics(endDynamics: number): INoteBuilder {
    this._p.endDynamics = endDynamics;
    this._m["endDynamics"] = true;
    return this;
  }
  lyrics(lyrics: Lyric[]): INoteBuilder {
    this._p.lyrics = lyrics;
    this._m["lyrics"] = true;
    return this;
  }
  dots(dots: Dot[]): INoteBuilder {
    this._p.dots = dots;
    this._m["dots"] = true;
    return this;
  }
  notations(notations: Notations[]): INoteBuilder {
    this._p.notations = notations;
    this._m["notations"] = true;
    return this;
  }
  stem(build: (builder: IStemBuilder) => IStemBuilder): INoteBuilder {
    this._b["stem"] = build(new StemBuilder(this._o && this._o["stem"]));
    this._m["stem"] = true;
    return this;
  }
  noteType(build: (builder: ITypeBuilder) => ITypeBuilder): INoteBuilder {
    this._b["noteType"] = build(new TypeBuilder(this._o && this._o["noteType"]));
    this._m["noteType"] = true;
    return this;
  }
  pizzicato(pizzicato: boolean): INoteBuilder {
    this._p.pizzicato = pizzicato;
    this._m["pizzicato"] = true;
    return this;
  }
  cue(build: (builder: ICueBuilder) => ICueBuilder): INoteBuilder {
    this._b["cue"] = build(new CueBuilder(this._o && this._o["cue"]));
    this._m["cue"] = true;
    return this;
  }
  duration(duration: number): INoteBuilder {
    this._p.duration = duration;
    this._m["duration"] = true;
    return this;
  }
  ties(ties: Tie[]): INoteBuilder {
    this._p.ties = ties;
    this._m["ties"] = true;
    return this;
  }
  dynamics(dynamics: number): INoteBuilder {
    this._p.dynamics = dynamics;
    this._m["dynamics"] = true;
    return this;
  }
  play(build: (builder: IPlayBuilder) => IPlayBuilder): INoteBuilder {
    this._b["play"] = build(new PlayBuilder(this._o && this._o["play"]));
    this._m["play"] = true;
    return this;
  }
  staff(staff: number): INoteBuilder {
    this._p.staff = staff;
    this._m["staff"] = true;
    return this;
  }
  grace(build: (builder: IGraceBuilder) => IGraceBuilder): INoteBuilder {
    this._b["grace"] = build(new GraceBuilder(this._o && this._o["grace"]));
    this._m["grace"] = true;
    return this;
  }
  notehead(build: (builder: INoteheadBuilder) => INoteheadBuilder): INoteBuilder {
    this._b["notehead"] = build(new NoteheadBuilder(this._o && this._o["notehead"]));
    this._m["notehead"] = true;
    return this;
  }
  release(release: number): INoteBuilder {
    this._p.release = release;
    this._m["release"] = true;
    return this;
  }
  beams(beams: Beam[]): INoteBuilder {
    this._p.beams = beams;
    this._m["beams"] = true;
    return this;
  }
  voice(voice: number): INoteBuilder {
    this._p.voice = voice;
    this._m["voice"] = true;
    return this;
  }
  footnote(build: (builder: IFootnoteBuilder) => IFootnoteBuilder): INoteBuilder {
    this._b["footnote"] = build(new FootnoteBuilder(this._o && this._o["footnote"]));
    this._m["footnote"] = true;
    return this;
  }
  level(build: (builder: ILevelBuilder) => ILevelBuilder): INoteBuilder {
    this._b["level"] = build(new LevelBuilder(this._o && this._o["level"]));
    this._m["level"] = true;
    return this;
  }
  _class(_class: string): INoteBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchNote(base: Note): INoteBuilder { return new NoteBuilder(base); }
export function buildNote(): INoteBuilder { return new NoteBuilder(); }

export interface ITypeBuilder {
  build: () => Type;
  patch: () => any[];
  duration: (duration: Count) => ITypeBuilder;
  size: (size: SymbolSize) => ITypeBuilder;
}
class TypeBuilder implements ITypeBuilder{
  _p: Type = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Type;
  constructor(toPatch?: Type) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["duration"]) || this._b["duration"] !== undefined || this._p.duration !== undefined, "duration is a required field");
  }
  build(): Type {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Type";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  duration(duration: Count): ITypeBuilder {
    this._p.duration = duration;
    this._m["duration"] = true;
    return this;
  }
  size(size: SymbolSize): ITypeBuilder {
    this._p.size = size;
    this._m["size"] = true;
    return this;
  }
}
export function patchType(base: Type): ITypeBuilder { return new TypeBuilder(base); }
export function buildType(): ITypeBuilder { return new TypeBuilder(); }

export interface IDotBuilder {
  build: () => Dot;
  patch: () => any[];
  defaultX: (defaultX: number) => IDotBuilder;
  relativeY: (relativeY: number) => IDotBuilder;
  defaultY: (defaultY: number) => IDotBuilder;
  relativeX: (relativeX: number) => IDotBuilder;
}
class DotBuilder implements IDotBuilder{
  _p: Dot = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Dot;
  constructor(toPatch?: Dot) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Dot {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Dot";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IDotBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IDotBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IDotBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IDotBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchDot(base: Dot): IDotBuilder { return new DotBuilder(base); }
export function buildDot(): IDotBuilder { return new DotBuilder(); }

export interface IAccidentalBuilder {
  build: () => Accidental;
  patch: () => any[];
  cautionary: (cautionary: boolean) => IAccidentalBuilder;
  accidental: (accidental: MxmlAccidental) => IAccidentalBuilder;
  editorial: (editorial: boolean) => IAccidentalBuilder;
  bracket: (bracket: boolean) => IAccidentalBuilder;
  size: (size: SymbolSize) => IAccidentalBuilder;
  parentheses: (parentheses: boolean) => IAccidentalBuilder;
}
class AccidentalBuilder implements IAccidentalBuilder{
  _p: Accidental = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Accidental;
  constructor(toPatch?: Accidental) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["accidental"]) || this._b["accidental"] !== undefined || this._p.accidental !== undefined, "accidental is a required field");
  }
  build(): Accidental {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Accidental";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  cautionary(cautionary: boolean): IAccidentalBuilder {
    this._p.cautionary = cautionary;
    this._m["cautionary"] = true;
    return this;
  }
  accidental(accidental: MxmlAccidental): IAccidentalBuilder {
    this._p.accidental = accidental;
    this._m["accidental"] = true;
    return this;
  }
  editorial(editorial: boolean): IAccidentalBuilder {
    this._p.editorial = editorial;
    this._m["editorial"] = true;
    return this;
  }
  bracket(bracket: boolean): IAccidentalBuilder {
    this._p.bracket = bracket;
    this._m["bracket"] = true;
    return this;
  }
  size(size: SymbolSize): IAccidentalBuilder {
    this._p.size = size;
    this._m["size"] = true;
    return this;
  }
  parentheses(parentheses: boolean): IAccidentalBuilder {
    this._p.parentheses = parentheses;
    this._m["parentheses"] = true;
    return this;
  }
}
export function patchAccidental(base: Accidental): IAccidentalBuilder { return new AccidentalBuilder(base); }
export function buildAccidental(): IAccidentalBuilder { return new AccidentalBuilder(); }

export interface ITimeModificationBuilder {
  build: () => TimeModification;
  patch: () => any[];
  actualNotes: (actualNotes: number) => ITimeModificationBuilder;
  normalType: (normalType: string) => ITimeModificationBuilder;
  normalNotes: (normalNotes: number) => ITimeModificationBuilder;
  normalDots: (normalDots: NormalDot[]) => ITimeModificationBuilder;
}
class TimeModificationBuilder implements ITimeModificationBuilder{
  _p: TimeModification = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TimeModification;
  constructor(toPatch?: TimeModification) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["actualNotes"]) || this._b["actualNotes"] !== undefined || this._p.actualNotes !== undefined, "actualNotes is a required field");
    console.assert((this._o && !this._m["normalNotes"]) || this._b["normalNotes"] !== undefined || this._p.normalNotes !== undefined, "normalNotes is a required field");
  }
  build(): TimeModification {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TimeModification";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  actualNotes(actualNotes: number): ITimeModificationBuilder {
    this._p.actualNotes = actualNotes;
    this._m["actualNotes"] = true;
    return this;
  }
  normalType(normalType: string): ITimeModificationBuilder {
    this._p.normalType = normalType;
    this._m["normalType"] = true;
    return this;
  }
  normalNotes(normalNotes: number): ITimeModificationBuilder {
    this._p.normalNotes = normalNotes;
    this._m["normalNotes"] = true;
    return this;
  }
  normalDots(normalDots: NormalDot[]): ITimeModificationBuilder {
    this._p.normalDots = normalDots;
    this._m["normalDots"] = true;
    return this;
  }
}
export function patchTimeModification(base: TimeModification): ITimeModificationBuilder { return new TimeModificationBuilder(base); }
export function buildTimeModification(): ITimeModificationBuilder { return new TimeModificationBuilder(); }

export interface IStemBuilder {
  build: () => Stem;
  patch: () => any[];
  type: (type: StemType) => IStemBuilder;
  defaultX: (defaultX: number) => IStemBuilder;
  relativeY: (relativeY: number) => IStemBuilder;
  defaultY: (defaultY: number) => IStemBuilder;
  relativeX: (relativeX: number) => IStemBuilder;
}
class StemBuilder implements IStemBuilder{
  _p: Stem = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Stem;
  constructor(toPatch?: Stem) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Stem {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Stem";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  type(type: StemType): IStemBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  defaultX(defaultX: number): IStemBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IStemBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IStemBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IStemBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchStem(base: Stem): IStemBuilder { return new StemBuilder(base); }
export function buildStem(): IStemBuilder { return new StemBuilder(); }

export interface INoteheadBuilder {
  build: () => Notehead;
  patch: () => any[];
  type: (type: NoteheadType) => INoteheadBuilder;
  filled: (filled: boolean) => INoteheadBuilder;
  parentheses: (parentheses: boolean) => INoteheadBuilder;
  fontFamily: (fontFamily: string) => INoteheadBuilder;
  fontWeight: (fontWeight: NormalBold) => INoteheadBuilder;
  fontStyle: (fontStyle: NormalItalic) => INoteheadBuilder;
  fontSize: (fontSize: string) => INoteheadBuilder;
}
class NoteheadBuilder implements INoteheadBuilder{
  _p: Notehead = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Notehead;
  constructor(toPatch?: Notehead) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Notehead {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Notehead";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  type(type: NoteheadType): INoteheadBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  filled(filled: boolean): INoteheadBuilder {
    this._p.filled = filled;
    this._m["filled"] = true;
    return this;
  }
  parentheses(parentheses: boolean): INoteheadBuilder {
    this._p.parentheses = parentheses;
    this._m["parentheses"] = true;
    return this;
  }
  fontFamily(fontFamily: string): INoteheadBuilder {
    this._p.fontFamily = fontFamily;
    this._m["fontFamily"] = true;
    return this;
  }
  fontWeight(fontWeight: NormalBold): INoteheadBuilder {
    this._p.fontWeight = fontWeight;
    this._m["fontWeight"] = true;
    return this;
  }
  fontStyle(fontStyle: NormalItalic): INoteheadBuilder {
    this._p.fontStyle = fontStyle;
    this._m["fontStyle"] = true;
    return this;
  }
  fontSize(fontSize: string): INoteheadBuilder {
    this._p.fontSize = fontSize;
    this._m["fontSize"] = true;
    return this;
  }
}
export function patchNotehead(base: Notehead): INoteheadBuilder { return new NoteheadBuilder(base); }
export function buildNotehead(): INoteheadBuilder { return new NoteheadBuilder(); }

export interface INoteheadTextBuilder {
  build: () => NoteheadText;
  patch: () => any[];
  text: (build: (builder: ITextArrayBuilder) => ITextArrayBuilder) => INoteheadTextBuilder;
}
class NoteheadTextBuilder implements INoteheadTextBuilder{
  _p: NoteheadText = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: NoteheadText;
  constructor(toPatch?: NoteheadText) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["text"]) || this._b["text"] !== undefined || this._p.text !== undefined, "text is a required field");
  }
  build(): NoteheadText {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "NoteheadText";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  text(build: (builder: ITextArrayBuilder) => ITextArrayBuilder): INoteheadTextBuilder {
    this._b["text"] = build(new TextArrayBuilder(this._o && this._o["text"]));
    this._m["text"] = true;
    return this;
  }
}
export function patchNoteheadText(base: NoteheadText): INoteheadTextBuilder { return new NoteheadTextBuilder(base); }
export function buildNoteheadText(): INoteheadTextBuilder { return new NoteheadTextBuilder(); }

export interface IBeamBuilder {
  build: () => Beam;
  patch: () => any[];
  repeater: (repeater: boolean) => IBeamBuilder;
  number: (number: number) => IBeamBuilder;
  type: (type: BeamType) => IBeamBuilder;
  fan: (fan: AccelRitNone) => IBeamBuilder;
}
class BeamBuilder implements IBeamBuilder{
  _p: Beam = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Beam;
  constructor(toPatch?: Beam) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["number"]) || this._b["number"] !== undefined || this._p.number !== undefined, "number is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Beam {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Beam";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  repeater(repeater: boolean): IBeamBuilder {
    this._p.repeater = repeater;
    this._m["repeater"] = true;
    return this;
  }
  number(number: number): IBeamBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  type(type: BeamType): IBeamBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  fan(fan: AccelRitNone): IBeamBuilder {
    this._p.fan = fan;
    this._m["fan"] = true;
    return this;
  }
}
export function patchBeam(base: Beam): IBeamBuilder { return new BeamBuilder(base); }
export function buildBeam(): IBeamBuilder { return new BeamBuilder(); }

export interface INotationsBuilder {
  build: () => Notations;
  patch: () => any[];
  slurs: (slurs: Slur[]) => INotationsBuilder;
  articulations: (articulations: Articulations[]) => INotationsBuilder;
  slides: (slides: Slide[]) => INotationsBuilder;
  technicals: (technicals: Technical[]) => INotationsBuilder;
  tieds: (tieds: Tied[]) => INotationsBuilder;
  tuplets: (tuplets: Tuplet[]) => INotationsBuilder;
  glissandos: (glissandos: Glissando[]) => INotationsBuilder;
  dynamics: (dynamics: Dynamics[]) => INotationsBuilder;
  fermatas: (fermatas: Fermata[]) => INotationsBuilder;
  accidentalMarks: (accidentalMarks: AccidentalMark[]) => INotationsBuilder;
  ornaments: (ornaments: Ornaments[]) => INotationsBuilder;
  arpeggiates: (arpeggiates: Arpeggiate[]) => INotationsBuilder;
  nonArpeggiates: (nonArpeggiates: NonArpeggiate[]) => INotationsBuilder;
  otherNotations: (otherNotations: OtherNotation[]) => INotationsBuilder;
  footnote: (build: (builder: IFootnoteBuilder) => IFootnoteBuilder) => INotationsBuilder;
  level: (build: (builder: ILevelBuilder) => ILevelBuilder) => INotationsBuilder;
  _class: (_class: string) => INotationsBuilder;
}
class NotationsBuilder implements INotationsBuilder{
  _p: Notations = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Notations;
  constructor(toPatch?: Notations) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Notations {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Notations";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  slurs(slurs: Slur[]): INotationsBuilder {
    this._p.slurs = slurs;
    this._m["slurs"] = true;
    return this;
  }
  articulations(articulations: Articulations[]): INotationsBuilder {
    this._p.articulations = articulations;
    this._m["articulations"] = true;
    return this;
  }
  slides(slides: Slide[]): INotationsBuilder {
    this._p.slides = slides;
    this._m["slides"] = true;
    return this;
  }
  technicals(technicals: Technical[]): INotationsBuilder {
    this._p.technicals = technicals;
    this._m["technicals"] = true;
    return this;
  }
  tieds(tieds: Tied[]): INotationsBuilder {
    this._p.tieds = tieds;
    this._m["tieds"] = true;
    return this;
  }
  tuplets(tuplets: Tuplet[]): INotationsBuilder {
    this._p.tuplets = tuplets;
    this._m["tuplets"] = true;
    return this;
  }
  glissandos(glissandos: Glissando[]): INotationsBuilder {
    this._p.glissandos = glissandos;
    this._m["glissandos"] = true;
    return this;
  }
  dynamics(dynamics: Dynamics[]): INotationsBuilder {
    this._p.dynamics = dynamics;
    this._m["dynamics"] = true;
    return this;
  }
  fermatas(fermatas: Fermata[]): INotationsBuilder {
    this._p.fermatas = fermatas;
    this._m["fermatas"] = true;
    return this;
  }
  accidentalMarks(accidentalMarks: AccidentalMark[]): INotationsBuilder {
    this._p.accidentalMarks = accidentalMarks;
    this._m["accidentalMarks"] = true;
    return this;
  }
  ornaments(ornaments: Ornaments[]): INotationsBuilder {
    this._p.ornaments = ornaments;
    this._m["ornaments"] = true;
    return this;
  }
  arpeggiates(arpeggiates: Arpeggiate[]): INotationsBuilder {
    this._p.arpeggiates = arpeggiates;
    this._m["arpeggiates"] = true;
    return this;
  }
  nonArpeggiates(nonArpeggiates: NonArpeggiate[]): INotationsBuilder {
    this._p.nonArpeggiates = nonArpeggiates;
    this._m["nonArpeggiates"] = true;
    return this;
  }
  otherNotations(otherNotations: OtherNotation[]): INotationsBuilder {
    this._p.otherNotations = otherNotations;
    this._m["otherNotations"] = true;
    return this;
  }
  footnote(build: (builder: IFootnoteBuilder) => IFootnoteBuilder): INotationsBuilder {
    this._b["footnote"] = build(new FootnoteBuilder(this._o && this._o["footnote"]));
    this._m["footnote"] = true;
    return this;
  }
  level(build: (builder: ILevelBuilder) => ILevelBuilder): INotationsBuilder {
    this._b["level"] = build(new LevelBuilder(this._o && this._o["level"]));
    this._m["level"] = true;
    return this;
  }
  _class(_class: string): INotationsBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchNotations(base: Notations): INotationsBuilder { return new NotationsBuilder(base); }
export function buildNotations(): INotationsBuilder { return new NotationsBuilder(); }

export interface ITiedBuilder {
  build: () => Tied;
  patch: () => any[];
  number: (number: number) => ITiedBuilder;
  type: (type: StartStopContinue) => ITiedBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => ITiedBuilder;
}
class TiedBuilder implements ITiedBuilder{
  _p: Tied = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Tied;
  constructor(toPatch?: Tied) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Tied {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Tied";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: number): ITiedBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  type(type: StartStopContinue): ITiedBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  lineType(lineType: SolidDashedDottedWavy): ITiedBuilder {
    this._p.lineType = lineType;
    this._m["lineType"] = true;
    return this;
  }
}
export function patchTied(base: Tied): ITiedBuilder { return new TiedBuilder(base); }
export function buildTied(): ITiedBuilder { return new TiedBuilder(); }

export interface ISlurBuilder {
  build: () => Slur;
  patch: () => any[];
  number: (number: number) => ISlurBuilder;
  type: (type: StartStopContinue) => ISlurBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => ISlurBuilder;
}
class SlurBuilder implements ISlurBuilder{
  _p: Slur = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Slur;
  constructor(toPatch?: Slur) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Slur {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Slur";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: number): ISlurBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  type(type: StartStopContinue): ISlurBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  lineType(lineType: SolidDashedDottedWavy): ISlurBuilder {
    this._p.lineType = lineType;
    this._m["lineType"] = true;
    return this;
  }
}
export function patchSlur(base: Slur): ISlurBuilder { return new SlurBuilder(base); }
export function buildSlur(): ISlurBuilder { return new SlurBuilder(); }

export interface ITupletBuilder {
  build: () => Tuplet;
  patch: () => any[];
  bracket: (bracket: boolean) => ITupletBuilder;
  number: (number: number) => ITupletBuilder;
  showNumber: (showNumber: ActualBothNone) => ITupletBuilder;
  tupletNormal: (build: (builder: ITupletNormalBuilder) => ITupletNormalBuilder) => ITupletBuilder;
  type: (type: StartStop) => ITupletBuilder;
  showType: (showType: ActualBothNone) => ITupletBuilder;
  tupletActual: (build: (builder: ITupletActualBuilder) => ITupletActualBuilder) => ITupletBuilder;
  lineShape: (lineShape: StraightCurved) => ITupletBuilder;
}
class TupletBuilder implements ITupletBuilder{
  _p: Tuplet = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Tuplet;
  constructor(toPatch?: Tuplet) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["number"]) || this._b["number"] !== undefined || this._p.number !== undefined, "number is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Tuplet {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Tuplet";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  bracket(bracket: boolean): ITupletBuilder {
    this._p.bracket = bracket;
    this._m["bracket"] = true;
    return this;
  }
  number(number: number): ITupletBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  showNumber(showNumber: ActualBothNone): ITupletBuilder {
    this._p.showNumber = showNumber;
    this._m["showNumber"] = true;
    return this;
  }
  tupletNormal(build: (builder: ITupletNormalBuilder) => ITupletNormalBuilder): ITupletBuilder {
    this._b["tupletNormal"] = build(new TupletNormalBuilder(this._o && this._o["tupletNormal"]));
    this._m["tupletNormal"] = true;
    return this;
  }
  type(type: StartStop): ITupletBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  showType(showType: ActualBothNone): ITupletBuilder {
    this._p.showType = showType;
    this._m["showType"] = true;
    return this;
  }
  tupletActual(build: (builder: ITupletActualBuilder) => ITupletActualBuilder): ITupletBuilder {
    this._b["tupletActual"] = build(new TupletActualBuilder(this._o && this._o["tupletActual"]));
    this._m["tupletActual"] = true;
    return this;
  }
  lineShape(lineShape: StraightCurved): ITupletBuilder {
    this._p.lineShape = lineShape;
    this._m["lineShape"] = true;
    return this;
  }
}
export function patchTuplet(base: Tuplet): ITupletBuilder { return new TupletBuilder(base); }
export function buildTuplet(): ITupletBuilder { return new TupletBuilder(); }

export interface ITupletActualBuilder {
  build: () => TupletActual;
  patch: () => any[];
  tupletNumber: (build: (builder: ITupletNumberBuilder) => ITupletNumberBuilder) => ITupletActualBuilder;
  tupletDots: (tupletDots: TupletDot[]) => ITupletActualBuilder;
  tupletType: (build: (builder: ITupletTypeBuilder) => ITupletTypeBuilder) => ITupletActualBuilder;
}
class TupletActualBuilder implements ITupletActualBuilder{
  _p: TupletActual = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TupletActual;
  constructor(toPatch?: TupletActual) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): TupletActual {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TupletActual";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  tupletNumber(build: (builder: ITupletNumberBuilder) => ITupletNumberBuilder): ITupletActualBuilder {
    this._b["tupletNumber"] = build(new TupletNumberBuilder(this._o && this._o["tupletNumber"]));
    this._m["tupletNumber"] = true;
    return this;
  }
  tupletDots(tupletDots: TupletDot[]): ITupletActualBuilder {
    this._p.tupletDots = tupletDots;
    this._m["tupletDots"] = true;
    return this;
  }
  tupletType(build: (builder: ITupletTypeBuilder) => ITupletTypeBuilder): ITupletActualBuilder {
    this._b["tupletType"] = build(new TupletTypeBuilder(this._o && this._o["tupletType"]));
    this._m["tupletType"] = true;
    return this;
  }
}
export function patchTupletActual(base: TupletActual): ITupletActualBuilder { return new TupletActualBuilder(base); }
export function buildTupletActual(): ITupletActualBuilder { return new TupletActualBuilder(); }

export interface ITupletNormalBuilder {
  build: () => TupletNormal;
  patch: () => any[];
  tupletNumber: (build: (builder: ITupletNumberBuilder) => ITupletNumberBuilder) => ITupletNormalBuilder;
  tupletDots: (tupletDots: TupletDot[]) => ITupletNormalBuilder;
  tupletType: (build: (builder: ITupletTypeBuilder) => ITupletTypeBuilder) => ITupletNormalBuilder;
}
class TupletNormalBuilder implements ITupletNormalBuilder{
  _p: TupletNormal = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TupletNormal;
  constructor(toPatch?: TupletNormal) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): TupletNormal {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TupletNormal";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  tupletNumber(build: (builder: ITupletNumberBuilder) => ITupletNumberBuilder): ITupletNormalBuilder {
    this._b["tupletNumber"] = build(new TupletNumberBuilder(this._o && this._o["tupletNumber"]));
    this._m["tupletNumber"] = true;
    return this;
  }
  tupletDots(tupletDots: TupletDot[]): ITupletNormalBuilder {
    this._p.tupletDots = tupletDots;
    this._m["tupletDots"] = true;
    return this;
  }
  tupletType(build: (builder: ITupletTypeBuilder) => ITupletTypeBuilder): ITupletNormalBuilder {
    this._b["tupletType"] = build(new TupletTypeBuilder(this._o && this._o["tupletType"]));
    this._m["tupletType"] = true;
    return this;
  }
}
export function patchTupletNormal(base: TupletNormal): ITupletNormalBuilder { return new TupletNormalBuilder(base); }
export function buildTupletNormal(): ITupletNormalBuilder { return new TupletNormalBuilder(); }

export interface ITupletNumberBuilder {
  build: () => TupletNumber;
  patch: () => any[];
  text: (text: string) => ITupletNumberBuilder;
  fontFamily: (fontFamily: string) => ITupletNumberBuilder;
  fontWeight: (fontWeight: NormalBold) => ITupletNumberBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITupletNumberBuilder;
  fontSize: (fontSize: string) => ITupletNumberBuilder;
}
class TupletNumberBuilder implements ITupletNumberBuilder{
  _p: TupletNumber = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TupletNumber;
  constructor(toPatch?: TupletNumber) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["text"]) || this._b["text"] !== undefined || this._p.text !== undefined, "text is a required field");
  }
  build(): TupletNumber {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TupletNumber";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  text(text: string): ITupletNumberBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  fontFamily(fontFamily: string): ITupletNumberBuilder {
    this._p.fontFamily = fontFamily;
    this._m["fontFamily"] = true;
    return this;
  }
  fontWeight(fontWeight: NormalBold): ITupletNumberBuilder {
    this._p.fontWeight = fontWeight;
    this._m["fontWeight"] = true;
    return this;
  }
  fontStyle(fontStyle: NormalItalic): ITupletNumberBuilder {
    this._p.fontStyle = fontStyle;
    this._m["fontStyle"] = true;
    return this;
  }
  fontSize(fontSize: string): ITupletNumberBuilder {
    this._p.fontSize = fontSize;
    this._m["fontSize"] = true;
    return this;
  }
}
export function patchTupletNumber(base: TupletNumber): ITupletNumberBuilder { return new TupletNumberBuilder(base); }
export function buildTupletNumber(): ITupletNumberBuilder { return new TupletNumberBuilder(); }

export interface ITupletTypeBuilder {
  build: () => TupletType;
  patch: () => any[];
  text: (text: string) => ITupletTypeBuilder;
  fontFamily: (fontFamily: string) => ITupletTypeBuilder;
  fontWeight: (fontWeight: NormalBold) => ITupletTypeBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITupletTypeBuilder;
  fontSize: (fontSize: string) => ITupletTypeBuilder;
}
class TupletTypeBuilder implements ITupletTypeBuilder{
  _p: TupletType = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TupletType;
  constructor(toPatch?: TupletType) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["text"]) || this._b["text"] !== undefined || this._p.text !== undefined, "text is a required field");
  }
  build(): TupletType {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TupletType";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  text(text: string): ITupletTypeBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  fontFamily(fontFamily: string): ITupletTypeBuilder {
    this._p.fontFamily = fontFamily;
    this._m["fontFamily"] = true;
    return this;
  }
  fontWeight(fontWeight: NormalBold): ITupletTypeBuilder {
    this._p.fontWeight = fontWeight;
    this._m["fontWeight"] = true;
    return this;
  }
  fontStyle(fontStyle: NormalItalic): ITupletTypeBuilder {
    this._p.fontStyle = fontStyle;
    this._m["fontStyle"] = true;
    return this;
  }
  fontSize(fontSize: string): ITupletTypeBuilder {
    this._p.fontSize = fontSize;
    this._m["fontSize"] = true;
    return this;
  }
}
export function patchTupletType(base: TupletType): ITupletTypeBuilder { return new TupletTypeBuilder(base); }
export function buildTupletType(): ITupletTypeBuilder { return new TupletTypeBuilder(); }

export interface ITupletDotBuilder {
  build: () => TupletDot;
  patch: () => any[];
  fontFamily: (fontFamily: string) => ITupletDotBuilder;
  fontWeight: (fontWeight: NormalBold) => ITupletDotBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITupletDotBuilder;
  fontSize: (fontSize: string) => ITupletDotBuilder;
}
class TupletDotBuilder implements ITupletDotBuilder{
  _p: TupletDot = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TupletDot;
  constructor(toPatch?: TupletDot) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): TupletDot {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TupletDot";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  fontFamily(fontFamily: string): ITupletDotBuilder {
    this._p.fontFamily = fontFamily;
    this._m["fontFamily"] = true;
    return this;
  }
  fontWeight(fontWeight: NormalBold): ITupletDotBuilder {
    this._p.fontWeight = fontWeight;
    this._m["fontWeight"] = true;
    return this;
  }
  fontStyle(fontStyle: NormalItalic): ITupletDotBuilder {
    this._p.fontStyle = fontStyle;
    this._m["fontStyle"] = true;
    return this;
  }
  fontSize(fontSize: string): ITupletDotBuilder {
    this._p.fontSize = fontSize;
    this._m["fontSize"] = true;
    return this;
  }
}
export function patchTupletDot(base: TupletDot): ITupletDotBuilder { return new TupletDotBuilder(base); }
export function buildTupletDot(): ITupletDotBuilder { return new TupletDotBuilder(); }

export interface IGlissandoBuilder {
  build: () => Glissando;
  patch: () => any[];
  text: (text: string) => IGlissandoBuilder;
  type: (type: StartStop) => IGlissandoBuilder;
  normal: (normal: number) => IGlissandoBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IGlissandoBuilder;
}
class GlissandoBuilder implements IGlissandoBuilder{
  _p: Glissando = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Glissando;
  constructor(toPatch?: Glissando) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Glissando {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Glissando";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  text(text: string): IGlissandoBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  type(type: StartStop): IGlissandoBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  normal(normal: number): IGlissandoBuilder {
    this._p.normal = normal;
    this._m["normal"] = true;
    return this;
  }
  lineType(lineType: SolidDashedDottedWavy): IGlissandoBuilder {
    this._p.lineType = lineType;
    this._m["lineType"] = true;
    return this;
  }
}
export function patchGlissando(base: Glissando): IGlissandoBuilder { return new GlissandoBuilder(base); }
export function buildGlissando(): IGlissandoBuilder { return new GlissandoBuilder(); }

export interface ISlideBuilder {
  build: () => Slide;
  patch: () => any[];
  text: (text: string) => ISlideBuilder;
  type: (type: StartStop) => ISlideBuilder;
  normal: (normal: number) => ISlideBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => ISlideBuilder;
}
class SlideBuilder implements ISlideBuilder{
  _p: Slide = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Slide;
  constructor(toPatch?: Slide) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Slide {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Slide";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  text(text: string): ISlideBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  type(type: StartStop): ISlideBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  normal(normal: number): ISlideBuilder {
    this._p.normal = normal;
    this._m["normal"] = true;
    return this;
  }
  lineType(lineType: SolidDashedDottedWavy): ISlideBuilder {
    this._p.lineType = lineType;
    this._m["lineType"] = true;
    return this;
  }
}
export function patchSlide(base: Slide): ISlideBuilder { return new SlideBuilder(base); }
export function buildSlide(): ISlideBuilder { return new SlideBuilder(); }

export interface IOtherNotationBuilder {
  build: () => OtherNotation;
  patch: () => any[];
  type: (type: StartStopSingle) => IOtherNotationBuilder;
  data: (data: string) => IOtherNotationBuilder;
  printObject: (printObject: boolean) => IOtherNotationBuilder;
}
class OtherNotationBuilder implements IOtherNotationBuilder{
  _p: OtherNotation = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: OtherNotation;
  constructor(toPatch?: OtherNotation) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): OtherNotation {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "OtherNotation";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  type(type: StartStopSingle): IOtherNotationBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  data(data: string): IOtherNotationBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  printObject(printObject: boolean): IOtherNotationBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchOtherNotation(base: OtherNotation): IOtherNotationBuilder { return new OtherNotationBuilder(base); }
export function buildOtherNotation(): IOtherNotationBuilder { return new OtherNotationBuilder(); }

export interface IOtherDirectionBuilder {
  build: () => OtherDirection;
  patch: () => any[];
  data: (data: string) => IOtherDirectionBuilder;
  printObject: (printObject: boolean) => IOtherDirectionBuilder;
}
class OtherDirectionBuilder implements IOtherDirectionBuilder{
  _p: OtherDirection = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: OtherDirection;
  constructor(toPatch?: OtherDirection) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): OtherDirection {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "OtherDirection";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IOtherDirectionBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  printObject(printObject: boolean): IOtherDirectionBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchOtherDirection(base: OtherDirection): IOtherDirectionBuilder { return new OtherDirectionBuilder(base); }
export function buildOtherDirection(): IOtherDirectionBuilder { return new OtherDirectionBuilder(); }

export interface IOrnamentsBuilder {
  build: () => Ornaments;
  patch: () => any[];
  delayedInvertedTurn: (build: (builder: IDelayedInvertedTurnBuilder) => IDelayedInvertedTurnBuilder) => IOrnamentsBuilder;
  shake: (build: (builder: IShakeBuilder) => IShakeBuilder) => IOrnamentsBuilder;
  turn: (build: (builder: ITurnBuilder) => ITurnBuilder) => IOrnamentsBuilder;
  invertedTurn: (build: (builder: IInvertedTurnBuilder) => IInvertedTurnBuilder) => IOrnamentsBuilder;
  otherOrnament: (build: (builder: IOtherOrnamentBuilder) => IOtherOrnamentBuilder) => IOrnamentsBuilder;
  delayedTurn: (build: (builder: IDelayedTurnBuilder) => IDelayedTurnBuilder) => IOrnamentsBuilder;
  verticalTurn: (build: (builder: IVerticalTurnBuilder) => IVerticalTurnBuilder) => IOrnamentsBuilder;
  wavyLine: (build: (builder: IWavyLineBuilder) => IWavyLineBuilder) => IOrnamentsBuilder;
  tremolo: (build: (builder: ITremoloBuilder) => ITremoloBuilder) => IOrnamentsBuilder;
  accidentalMarks: (accidentalMarks: AccidentalMark[]) => IOrnamentsBuilder;
  trillMark: (build: (builder: ITrillMarkBuilder) => ITrillMarkBuilder) => IOrnamentsBuilder;
  mordent: (build: (builder: IMordentBuilder) => IMordentBuilder) => IOrnamentsBuilder;
  invertedMordent: (build: (builder: IInvertedMordentBuilder) => IInvertedMordentBuilder) => IOrnamentsBuilder;
  schleifer: (build: (builder: ISchleiferBuilder) => ISchleiferBuilder) => IOrnamentsBuilder;
  defaultX: (defaultX: number) => IOrnamentsBuilder;
  relativeY: (relativeY: number) => IOrnamentsBuilder;
  defaultY: (defaultY: number) => IOrnamentsBuilder;
  relativeX: (relativeX: number) => IOrnamentsBuilder;
}
class OrnamentsBuilder implements IOrnamentsBuilder{
  _p: Ornaments = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Ornaments;
  constructor(toPatch?: Ornaments) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Ornaments {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Ornaments";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  delayedInvertedTurn(build: (builder: IDelayedInvertedTurnBuilder) => IDelayedInvertedTurnBuilder): IOrnamentsBuilder {
    this._b["delayedInvertedTurn"] = build(new DelayedInvertedTurnBuilder(this._o && this._o["delayedInvertedTurn"]));
    this._m["delayedInvertedTurn"] = true;
    return this;
  }
  shake(build: (builder: IShakeBuilder) => IShakeBuilder): IOrnamentsBuilder {
    this._b["shake"] = build(new ShakeBuilder(this._o && this._o["shake"]));
    this._m["shake"] = true;
    return this;
  }
  turn(build: (builder: ITurnBuilder) => ITurnBuilder): IOrnamentsBuilder {
    this._b["turn"] = build(new TurnBuilder(this._o && this._o["turn"]));
    this._m["turn"] = true;
    return this;
  }
  invertedTurn(build: (builder: IInvertedTurnBuilder) => IInvertedTurnBuilder): IOrnamentsBuilder {
    this._b["invertedTurn"] = build(new InvertedTurnBuilder(this._o && this._o["invertedTurn"]));
    this._m["invertedTurn"] = true;
    return this;
  }
  otherOrnament(build: (builder: IOtherOrnamentBuilder) => IOtherOrnamentBuilder): IOrnamentsBuilder {
    this._b["otherOrnament"] = build(new OtherOrnamentBuilder(this._o && this._o["otherOrnament"]));
    this._m["otherOrnament"] = true;
    return this;
  }
  delayedTurn(build: (builder: IDelayedTurnBuilder) => IDelayedTurnBuilder): IOrnamentsBuilder {
    this._b["delayedTurn"] = build(new DelayedTurnBuilder(this._o && this._o["delayedTurn"]));
    this._m["delayedTurn"] = true;
    return this;
  }
  verticalTurn(build: (builder: IVerticalTurnBuilder) => IVerticalTurnBuilder): IOrnamentsBuilder {
    this._b["verticalTurn"] = build(new VerticalTurnBuilder(this._o && this._o["verticalTurn"]));
    this._m["verticalTurn"] = true;
    return this;
  }
  wavyLine(build: (builder: IWavyLineBuilder) => IWavyLineBuilder): IOrnamentsBuilder {
    this._b["wavyLine"] = build(new WavyLineBuilder(this._o && this._o["wavyLine"]));
    this._m["wavyLine"] = true;
    return this;
  }
  tremolo(build: (builder: ITremoloBuilder) => ITremoloBuilder): IOrnamentsBuilder {
    this._b["tremolo"] = build(new TremoloBuilder(this._o && this._o["tremolo"]));
    this._m["tremolo"] = true;
    return this;
  }
  accidentalMarks(accidentalMarks: AccidentalMark[]): IOrnamentsBuilder {
    this._p.accidentalMarks = accidentalMarks;
    this._m["accidentalMarks"] = true;
    return this;
  }
  trillMark(build: (builder: ITrillMarkBuilder) => ITrillMarkBuilder): IOrnamentsBuilder {
    this._b["trillMark"] = build(new TrillMarkBuilder(this._o && this._o["trillMark"]));
    this._m["trillMark"] = true;
    return this;
  }
  mordent(build: (builder: IMordentBuilder) => IMordentBuilder): IOrnamentsBuilder {
    this._b["mordent"] = build(new MordentBuilder(this._o && this._o["mordent"]));
    this._m["mordent"] = true;
    return this;
  }
  invertedMordent(build: (builder: IInvertedMordentBuilder) => IInvertedMordentBuilder): IOrnamentsBuilder {
    this._b["invertedMordent"] = build(new InvertedMordentBuilder(this._o && this._o["invertedMordent"]));
    this._m["invertedMordent"] = true;
    return this;
  }
  schleifer(build: (builder: ISchleiferBuilder) => ISchleiferBuilder): IOrnamentsBuilder {
    this._b["schleifer"] = build(new SchleiferBuilder(this._o && this._o["schleifer"]));
    this._m["schleifer"] = true;
    return this;
  }
  defaultX(defaultX: number): IOrnamentsBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IOrnamentsBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IOrnamentsBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IOrnamentsBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchOrnaments(base: Ornaments): IOrnamentsBuilder { return new OrnamentsBuilder(base); }
export function buildOrnaments(): IOrnamentsBuilder { return new OrnamentsBuilder(); }

export interface ITrillMarkBuilder {
  build: () => TrillMark;
  patch: () => any[];
  defaultX: (defaultX: number) => ITrillMarkBuilder;
  relativeY: (relativeY: number) => ITrillMarkBuilder;
  defaultY: (defaultY: number) => ITrillMarkBuilder;
  relativeX: (relativeX: number) => ITrillMarkBuilder;
}
class TrillMarkBuilder implements ITrillMarkBuilder{
  _p: TrillMark = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TrillMark;
  constructor(toPatch?: TrillMark) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): TrillMark {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TrillMark";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): ITrillMarkBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): ITrillMarkBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): ITrillMarkBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): ITrillMarkBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchTrillMark(base: TrillMark): ITrillMarkBuilder { return new TrillMarkBuilder(base); }
export function buildTrillMark(): ITrillMarkBuilder { return new TrillMarkBuilder(); }

export interface ITurnBuilder {
  build: () => Turn;
  patch: () => any[];
  slash: (slash: boolean) => ITurnBuilder;
  defaultX: (defaultX: number) => ITurnBuilder;
  relativeY: (relativeY: number) => ITurnBuilder;
  defaultY: (defaultY: number) => ITurnBuilder;
  relativeX: (relativeX: number) => ITurnBuilder;
}
class TurnBuilder implements ITurnBuilder{
  _p: Turn = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Turn;
  constructor(toPatch?: Turn) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Turn {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Turn";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  slash(slash: boolean): ITurnBuilder {
    this._p.slash = slash;
    this._m["slash"] = true;
    return this;
  }
  defaultX(defaultX: number): ITurnBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): ITurnBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): ITurnBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): ITurnBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchTurn(base: Turn): ITurnBuilder { return new TurnBuilder(base); }
export function buildTurn(): ITurnBuilder { return new TurnBuilder(); }

export interface IDelayedTurnBuilder {
  build: () => DelayedTurn;
  patch: () => any[];
  slash: (slash: boolean) => IDelayedTurnBuilder;
  defaultX: (defaultX: number) => IDelayedTurnBuilder;
  relativeY: (relativeY: number) => IDelayedTurnBuilder;
  defaultY: (defaultY: number) => IDelayedTurnBuilder;
  relativeX: (relativeX: number) => IDelayedTurnBuilder;
}
class DelayedTurnBuilder implements IDelayedTurnBuilder{
  _p: DelayedTurn = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: DelayedTurn;
  constructor(toPatch?: DelayedTurn) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): DelayedTurn {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "DelayedTurn";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  slash(slash: boolean): IDelayedTurnBuilder {
    this._p.slash = slash;
    this._m["slash"] = true;
    return this;
  }
  defaultX(defaultX: number): IDelayedTurnBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IDelayedTurnBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IDelayedTurnBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IDelayedTurnBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchDelayedTurn(base: DelayedTurn): IDelayedTurnBuilder { return new DelayedTurnBuilder(base); }
export function buildDelayedTurn(): IDelayedTurnBuilder { return new DelayedTurnBuilder(); }

export interface IInvertedTurnBuilder {
  build: () => InvertedTurn;
  patch: () => any[];
  slash: (slash: boolean) => IInvertedTurnBuilder;
  defaultX: (defaultX: number) => IInvertedTurnBuilder;
  relativeY: (relativeY: number) => IInvertedTurnBuilder;
  defaultY: (defaultY: number) => IInvertedTurnBuilder;
  relativeX: (relativeX: number) => IInvertedTurnBuilder;
}
class InvertedTurnBuilder implements IInvertedTurnBuilder{
  _p: InvertedTurn = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: InvertedTurn;
  constructor(toPatch?: InvertedTurn) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): InvertedTurn {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "InvertedTurn";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  slash(slash: boolean): IInvertedTurnBuilder {
    this._p.slash = slash;
    this._m["slash"] = true;
    return this;
  }
  defaultX(defaultX: number): IInvertedTurnBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IInvertedTurnBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IInvertedTurnBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IInvertedTurnBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchInvertedTurn(base: InvertedTurn): IInvertedTurnBuilder { return new InvertedTurnBuilder(base); }
export function buildInvertedTurn(): IInvertedTurnBuilder { return new InvertedTurnBuilder(); }

export interface IDelayedInvertedTurnBuilder {
  build: () => DelayedInvertedTurn;
  patch: () => any[];
  slash: (slash: boolean) => IDelayedInvertedTurnBuilder;
  defaultX: (defaultX: number) => IDelayedInvertedTurnBuilder;
  relativeY: (relativeY: number) => IDelayedInvertedTurnBuilder;
  defaultY: (defaultY: number) => IDelayedInvertedTurnBuilder;
  relativeX: (relativeX: number) => IDelayedInvertedTurnBuilder;
}
class DelayedInvertedTurnBuilder implements IDelayedInvertedTurnBuilder{
  _p: DelayedInvertedTurn = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: DelayedInvertedTurn;
  constructor(toPatch?: DelayedInvertedTurn) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): DelayedInvertedTurn {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "DelayedInvertedTurn";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  slash(slash: boolean): IDelayedInvertedTurnBuilder {
    this._p.slash = slash;
    this._m["slash"] = true;
    return this;
  }
  defaultX(defaultX: number): IDelayedInvertedTurnBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IDelayedInvertedTurnBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IDelayedInvertedTurnBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IDelayedInvertedTurnBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchDelayedInvertedTurn(base: DelayedInvertedTurn): IDelayedInvertedTurnBuilder { return new DelayedInvertedTurnBuilder(base); }
export function buildDelayedInvertedTurn(): IDelayedInvertedTurnBuilder { return new DelayedInvertedTurnBuilder(); }

export interface IVerticalTurnBuilder {
  build: () => VerticalTurn;
  patch: () => any[];
  defaultX: (defaultX: number) => IVerticalTurnBuilder;
  relativeY: (relativeY: number) => IVerticalTurnBuilder;
  defaultY: (defaultY: number) => IVerticalTurnBuilder;
  relativeX: (relativeX: number) => IVerticalTurnBuilder;
}
class VerticalTurnBuilder implements IVerticalTurnBuilder{
  _p: VerticalTurn = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: VerticalTurn;
  constructor(toPatch?: VerticalTurn) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): VerticalTurn {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "VerticalTurn";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IVerticalTurnBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IVerticalTurnBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IVerticalTurnBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IVerticalTurnBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchVerticalTurn(base: VerticalTurn): IVerticalTurnBuilder { return new VerticalTurnBuilder(base); }
export function buildVerticalTurn(): IVerticalTurnBuilder { return new VerticalTurnBuilder(); }

export interface IShakeBuilder {
  build: () => Shake;
  patch: () => any[];
  defaultX: (defaultX: number) => IShakeBuilder;
  relativeY: (relativeY: number) => IShakeBuilder;
  defaultY: (defaultY: number) => IShakeBuilder;
  relativeX: (relativeX: number) => IShakeBuilder;
}
class ShakeBuilder implements IShakeBuilder{
  _p: Shake = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Shake;
  constructor(toPatch?: Shake) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Shake {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Shake";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IShakeBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IShakeBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IShakeBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IShakeBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchShake(base: Shake): IShakeBuilder { return new ShakeBuilder(base); }
export function buildShake(): IShakeBuilder { return new ShakeBuilder(); }

export interface IMordentBuilder {
  build: () => Mordent;
  patch: () => any[];
  long: (long: boolean) => IMordentBuilder;
  approach: (approach: AboveBelow) => IMordentBuilder;
  departure: (departure: AboveBelow) => IMordentBuilder;
  defaultX: (defaultX: number) => IMordentBuilder;
  relativeY: (relativeY: number) => IMordentBuilder;
  defaultY: (defaultY: number) => IMordentBuilder;
  relativeX: (relativeX: number) => IMordentBuilder;
}
class MordentBuilder implements IMordentBuilder{
  _p: Mordent = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Mordent;
  constructor(toPatch?: Mordent) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Mordent {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Mordent";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  long(long: boolean): IMordentBuilder {
    this._p.long = long;
    this._m["long"] = true;
    return this;
  }
  approach(approach: AboveBelow): IMordentBuilder {
    this._p.approach = approach;
    this._m["approach"] = true;
    return this;
  }
  departure(departure: AboveBelow): IMordentBuilder {
    this._p.departure = departure;
    this._m["departure"] = true;
    return this;
  }
  defaultX(defaultX: number): IMordentBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IMordentBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IMordentBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IMordentBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchMordent(base: Mordent): IMordentBuilder { return new MordentBuilder(base); }
export function buildMordent(): IMordentBuilder { return new MordentBuilder(); }

export interface IInvertedMordentBuilder {
  build: () => InvertedMordent;
  patch: () => any[];
  long: (long: boolean) => IInvertedMordentBuilder;
  approach: (approach: AboveBelow) => IInvertedMordentBuilder;
  departure: (departure: AboveBelow) => IInvertedMordentBuilder;
  defaultX: (defaultX: number) => IInvertedMordentBuilder;
  relativeY: (relativeY: number) => IInvertedMordentBuilder;
  defaultY: (defaultY: number) => IInvertedMordentBuilder;
  relativeX: (relativeX: number) => IInvertedMordentBuilder;
}
class InvertedMordentBuilder implements IInvertedMordentBuilder{
  _p: InvertedMordent = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: InvertedMordent;
  constructor(toPatch?: InvertedMordent) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): InvertedMordent {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "InvertedMordent";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  long(long: boolean): IInvertedMordentBuilder {
    this._p.long = long;
    this._m["long"] = true;
    return this;
  }
  approach(approach: AboveBelow): IInvertedMordentBuilder {
    this._p.approach = approach;
    this._m["approach"] = true;
    return this;
  }
  departure(departure: AboveBelow): IInvertedMordentBuilder {
    this._p.departure = departure;
    this._m["departure"] = true;
    return this;
  }
  defaultX(defaultX: number): IInvertedMordentBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IInvertedMordentBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IInvertedMordentBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IInvertedMordentBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchInvertedMordent(base: InvertedMordent): IInvertedMordentBuilder { return new InvertedMordentBuilder(base); }
export function buildInvertedMordent(): IInvertedMordentBuilder { return new InvertedMordentBuilder(); }

export interface ISchleiferBuilder {
  build: () => Schleifer;
  patch: () => any[];
  defaultX: (defaultX: number) => ISchleiferBuilder;
  relativeY: (relativeY: number) => ISchleiferBuilder;
  defaultY: (defaultY: number) => ISchleiferBuilder;
  relativeX: (relativeX: number) => ISchleiferBuilder;
}
class SchleiferBuilder implements ISchleiferBuilder{
  _p: Schleifer = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Schleifer;
  constructor(toPatch?: Schleifer) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Schleifer {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Schleifer";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): ISchleiferBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): ISchleiferBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): ISchleiferBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): ISchleiferBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchSchleifer(base: Schleifer): ISchleiferBuilder { return new SchleiferBuilder(base); }
export function buildSchleifer(): ISchleiferBuilder { return new SchleiferBuilder(); }

export interface ITremoloBuilder {
  build: () => Tremolo;
  patch: () => any[];
  data: (data: string) => ITremoloBuilder;
  type: (type: StartStopSingle) => ITremoloBuilder;
  defaultX: (defaultX: number) => ITremoloBuilder;
  relativeY: (relativeY: number) => ITremoloBuilder;
  defaultY: (defaultY: number) => ITremoloBuilder;
  relativeX: (relativeX: number) => ITremoloBuilder;
}
class TremoloBuilder implements ITremoloBuilder{
  _p: Tremolo = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Tremolo;
  constructor(toPatch?: Tremolo) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Tremolo {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Tremolo";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): ITremoloBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  type(type: StartStopSingle): ITremoloBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  defaultX(defaultX: number): ITremoloBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): ITremoloBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): ITremoloBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): ITremoloBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchTremolo(base: Tremolo): ITremoloBuilder { return new TremoloBuilder(base); }
export function buildTremolo(): ITremoloBuilder { return new TremoloBuilder(); }

export interface IOtherOrnamentBuilder {
  build: () => OtherOrnament;
  patch: () => any[];
  type: (type: StartStopSingle) => IOtherOrnamentBuilder;
  data: (data: string) => IOtherOrnamentBuilder;
  defaultX: (defaultX: number) => IOtherOrnamentBuilder;
  relativeY: (relativeY: number) => IOtherOrnamentBuilder;
  defaultY: (defaultY: number) => IOtherOrnamentBuilder;
  relativeX: (relativeX: number) => IOtherOrnamentBuilder;
}
class OtherOrnamentBuilder implements IOtherOrnamentBuilder{
  _p: OtherOrnament = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: OtherOrnament;
  constructor(toPatch?: OtherOrnament) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): OtherOrnament {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "OtherOrnament";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  type(type: StartStopSingle): IOtherOrnamentBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  data(data: string): IOtherOrnamentBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IOtherOrnamentBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IOtherOrnamentBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IOtherOrnamentBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IOtherOrnamentBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchOtherOrnament(base: OtherOrnament): IOtherOrnamentBuilder { return new OtherOrnamentBuilder(base); }
export function buildOtherOrnament(): IOtherOrnamentBuilder { return new OtherOrnamentBuilder(); }

export interface IAccidentalMarkBuilder {
  build: () => AccidentalMark;
  patch: () => any[];
  mark: (mark: string) => IAccidentalMarkBuilder;
  defaultX: (defaultX: number) => IAccidentalMarkBuilder;
  relativeY: (relativeY: number) => IAccidentalMarkBuilder;
  defaultY: (defaultY: number) => IAccidentalMarkBuilder;
  relativeX: (relativeX: number) => IAccidentalMarkBuilder;
}
class AccidentalMarkBuilder implements IAccidentalMarkBuilder{
  _p: AccidentalMark = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: AccidentalMark;
  constructor(toPatch?: AccidentalMark) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["mark"]) || this._b["mark"] !== undefined || this._p.mark !== undefined, "mark is a required field");
  }
  build(): AccidentalMark {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "AccidentalMark";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  mark(mark: string): IAccidentalMarkBuilder {
    this._p.mark = mark;
    this._m["mark"] = true;
    return this;
  }
  defaultX(defaultX: number): IAccidentalMarkBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IAccidentalMarkBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IAccidentalMarkBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IAccidentalMarkBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchAccidentalMark(base: AccidentalMark): IAccidentalMarkBuilder { return new AccidentalMarkBuilder(base); }
export function buildAccidentalMark(): IAccidentalMarkBuilder { return new AccidentalMarkBuilder(); }

export interface ITechnicalBuilder {
  build: () => Technical;
  patch: () => any[];
  tripleTongue: (build: (builder: ITripleTongueBuilder) => ITripleTongueBuilder) => ITechnicalBuilder;
  toe: (build: (builder: IToeBuilder) => IToeBuilder) => ITechnicalBuilder;
  hole: (build: (builder: IHoleBuilder) => IHoleBuilder) => ITechnicalBuilder;
  hammerOn: (build: (builder: IHammerOnBuilder) => IHammerOnBuilder) => ITechnicalBuilder;
  upBow: (build: (builder: IUpBowBuilder) => IUpBowBuilder) => ITechnicalBuilder;
  downBow: (build: (builder: IDownBowBuilder) => IDownBowBuilder) => ITechnicalBuilder;
  fret: (build: (builder: IFretBuilder) => IFretBuilder) => ITechnicalBuilder;
  tap: (build: (builder: ITapBuilder) => ITapBuilder) => ITechnicalBuilder;
  pullOff: (build: (builder: IPullOffBuilder) => IPullOffBuilder) => ITechnicalBuilder;
  handbell: (build: (builder: IHandbellBuilder) => IHandbellBuilder) => ITechnicalBuilder;
  bend: (build: (builder: IBendBuilder) => IBendBuilder) => ITechnicalBuilder;
  thumbPosition: (build: (builder: IThumbPositionBuilder) => IThumbPositionBuilder) => ITechnicalBuilder;
  stopped: (build: (builder: IStoppedBuilder) => IStoppedBuilder) => ITechnicalBuilder;
  pluck: (build: (builder: IPluckBuilder) => IPluckBuilder) => ITechnicalBuilder;
  doubleTongue: (build: (builder: IDoubleTongueBuilder) => IDoubleTongueBuilder) => ITechnicalBuilder;
  string: (build: (builder: IStringBuilder) => IStringBuilder) => ITechnicalBuilder;
  openString: (build: (builder: IOpenStringBuilder) => IOpenStringBuilder) => ITechnicalBuilder;
  fingernails: (build: (builder: IFingernailsBuilder) => IFingernailsBuilder) => ITechnicalBuilder;
  arrow: (build: (builder: IArrowBuilder) => IArrowBuilder) => ITechnicalBuilder;
  harmonic: (build: (builder: IHarmonicBuilder) => IHarmonicBuilder) => ITechnicalBuilder;
  heel: (build: (builder: IHeelBuilder) => IHeelBuilder) => ITechnicalBuilder;
  otherTechnical: (build: (builder: IOtherTechnicalBuilder) => IOtherTechnicalBuilder) => ITechnicalBuilder;
  snapPizzicato: (build: (builder: ISnapPizzicatoBuilder) => ISnapPizzicatoBuilder) => ITechnicalBuilder;
  fingering: (build: (builder: IFingeringBuilder) => IFingeringBuilder) => ITechnicalBuilder;
}
class TechnicalBuilder implements ITechnicalBuilder{
  _p: Technical = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Technical;
  constructor(toPatch?: Technical) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Technical {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Technical";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  tripleTongue(build: (builder: ITripleTongueBuilder) => ITripleTongueBuilder): ITechnicalBuilder {
    this._b["tripleTongue"] = build(new TripleTongueBuilder(this._o && this._o["tripleTongue"]));
    this._m["tripleTongue"] = true;
    return this;
  }
  toe(build: (builder: IToeBuilder) => IToeBuilder): ITechnicalBuilder {
    this._b["toe"] = build(new ToeBuilder(this._o && this._o["toe"]));
    this._m["toe"] = true;
    return this;
  }
  hole(build: (builder: IHoleBuilder) => IHoleBuilder): ITechnicalBuilder {
    this._b["hole"] = build(new HoleBuilder(this._o && this._o["hole"]));
    this._m["hole"] = true;
    return this;
  }
  hammerOn(build: (builder: IHammerOnBuilder) => IHammerOnBuilder): ITechnicalBuilder {
    this._b["hammerOn"] = build(new HammerOnBuilder(this._o && this._o["hammerOn"]));
    this._m["hammerOn"] = true;
    return this;
  }
  upBow(build: (builder: IUpBowBuilder) => IUpBowBuilder): ITechnicalBuilder {
    this._b["upBow"] = build(new UpBowBuilder(this._o && this._o["upBow"]));
    this._m["upBow"] = true;
    return this;
  }
  downBow(build: (builder: IDownBowBuilder) => IDownBowBuilder): ITechnicalBuilder {
    this._b["downBow"] = build(new DownBowBuilder(this._o && this._o["downBow"]));
    this._m["downBow"] = true;
    return this;
  }
  fret(build: (builder: IFretBuilder) => IFretBuilder): ITechnicalBuilder {
    this._b["fret"] = build(new FretBuilder(this._o && this._o["fret"]));
    this._m["fret"] = true;
    return this;
  }
  tap(build: (builder: ITapBuilder) => ITapBuilder): ITechnicalBuilder {
    this._b["tap"] = build(new TapBuilder(this._o && this._o["tap"]));
    this._m["tap"] = true;
    return this;
  }
  pullOff(build: (builder: IPullOffBuilder) => IPullOffBuilder): ITechnicalBuilder {
    this._b["pullOff"] = build(new PullOffBuilder(this._o && this._o["pullOff"]));
    this._m["pullOff"] = true;
    return this;
  }
  handbell(build: (builder: IHandbellBuilder) => IHandbellBuilder): ITechnicalBuilder {
    this._b["handbell"] = build(new HandbellBuilder(this._o && this._o["handbell"]));
    this._m["handbell"] = true;
    return this;
  }
  bend(build: (builder: IBendBuilder) => IBendBuilder): ITechnicalBuilder {
    this._b["bend"] = build(new BendBuilder(this._o && this._o["bend"]));
    this._m["bend"] = true;
    return this;
  }
  thumbPosition(build: (builder: IThumbPositionBuilder) => IThumbPositionBuilder): ITechnicalBuilder {
    this._b["thumbPosition"] = build(new ThumbPositionBuilder(this._o && this._o["thumbPosition"]));
    this._m["thumbPosition"] = true;
    return this;
  }
  stopped(build: (builder: IStoppedBuilder) => IStoppedBuilder): ITechnicalBuilder {
    this._b["stopped"] = build(new StoppedBuilder(this._o && this._o["stopped"]));
    this._m["stopped"] = true;
    return this;
  }
  pluck(build: (builder: IPluckBuilder) => IPluckBuilder): ITechnicalBuilder {
    this._b["pluck"] = build(new PluckBuilder(this._o && this._o["pluck"]));
    this._m["pluck"] = true;
    return this;
  }
  doubleTongue(build: (builder: IDoubleTongueBuilder) => IDoubleTongueBuilder): ITechnicalBuilder {
    this._b["doubleTongue"] = build(new DoubleTongueBuilder(this._o && this._o["doubleTongue"]));
    this._m["doubleTongue"] = true;
    return this;
  }
  string(build: (builder: IStringBuilder) => IStringBuilder): ITechnicalBuilder {
    this._b["string"] = build(new StringBuilder(this._o && this._o["string"]));
    this._m["string"] = true;
    return this;
  }
  openString(build: (builder: IOpenStringBuilder) => IOpenStringBuilder): ITechnicalBuilder {
    this._b["openString"] = build(new OpenStringBuilder(this._o && this._o["openString"]));
    this._m["openString"] = true;
    return this;
  }
  fingernails(build: (builder: IFingernailsBuilder) => IFingernailsBuilder): ITechnicalBuilder {
    this._b["fingernails"] = build(new FingernailsBuilder(this._o && this._o["fingernails"]));
    this._m["fingernails"] = true;
    return this;
  }
  arrow(build: (builder: IArrowBuilder) => IArrowBuilder): ITechnicalBuilder {
    this._b["arrow"] = build(new ArrowBuilder(this._o && this._o["arrow"]));
    this._m["arrow"] = true;
    return this;
  }
  harmonic(build: (builder: IHarmonicBuilder) => IHarmonicBuilder): ITechnicalBuilder {
    this._b["harmonic"] = build(new HarmonicBuilder(this._o && this._o["harmonic"]));
    this._m["harmonic"] = true;
    return this;
  }
  heel(build: (builder: IHeelBuilder) => IHeelBuilder): ITechnicalBuilder {
    this._b["heel"] = build(new HeelBuilder(this._o && this._o["heel"]));
    this._m["heel"] = true;
    return this;
  }
  otherTechnical(build: (builder: IOtherTechnicalBuilder) => IOtherTechnicalBuilder): ITechnicalBuilder {
    this._b["otherTechnical"] = build(new OtherTechnicalBuilder(this._o && this._o["otherTechnical"]));
    this._m["otherTechnical"] = true;
    return this;
  }
  snapPizzicato(build: (builder: ISnapPizzicatoBuilder) => ISnapPizzicatoBuilder): ITechnicalBuilder {
    this._b["snapPizzicato"] = build(new SnapPizzicatoBuilder(this._o && this._o["snapPizzicato"]));
    this._m["snapPizzicato"] = true;
    return this;
  }
  fingering(build: (builder: IFingeringBuilder) => IFingeringBuilder): ITechnicalBuilder {
    this._b["fingering"] = build(new FingeringBuilder(this._o && this._o["fingering"]));
    this._m["fingering"] = true;
    return this;
  }
}
export function patchTechnical(base: Technical): ITechnicalBuilder { return new TechnicalBuilder(base); }
export function buildTechnical(): ITechnicalBuilder { return new TechnicalBuilder(); }

export interface IUpBowBuilder {
  build: () => UpBow;
  patch: () => any[];
  defaultX: (defaultX: number) => IUpBowBuilder;
  relativeY: (relativeY: number) => IUpBowBuilder;
  defaultY: (defaultY: number) => IUpBowBuilder;
  relativeX: (relativeX: number) => IUpBowBuilder;
}
class UpBowBuilder implements IUpBowBuilder{
  _p: UpBow = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: UpBow;
  constructor(toPatch?: UpBow) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): UpBow {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "UpBow";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IUpBowBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IUpBowBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IUpBowBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IUpBowBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchUpBow(base: UpBow): IUpBowBuilder { return new UpBowBuilder(base); }
export function buildUpBow(): IUpBowBuilder { return new UpBowBuilder(); }

export interface IDownBowBuilder {
  build: () => DownBow;
  patch: () => any[];
  defaultX: (defaultX: number) => IDownBowBuilder;
  relativeY: (relativeY: number) => IDownBowBuilder;
  defaultY: (defaultY: number) => IDownBowBuilder;
  relativeX: (relativeX: number) => IDownBowBuilder;
}
class DownBowBuilder implements IDownBowBuilder{
  _p: DownBow = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: DownBow;
  constructor(toPatch?: DownBow) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): DownBow {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "DownBow";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IDownBowBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IDownBowBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IDownBowBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IDownBowBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchDownBow(base: DownBow): IDownBowBuilder { return new DownBowBuilder(base); }
export function buildDownBow(): IDownBowBuilder { return new DownBowBuilder(); }

export interface IHarmonicBuilder {
  build: () => Harmonic;
  patch: () => any[];
  artificial: (artificial: boolean) => IHarmonicBuilder;
  touchingPitch: (touchingPitch: boolean) => IHarmonicBuilder;
  soundingPitch: (soundingPitch: boolean) => IHarmonicBuilder;
  natural: (natural: boolean) => IHarmonicBuilder;
  basePitch: (basePitch: boolean) => IHarmonicBuilder;
  printObject: (printObject: boolean) => IHarmonicBuilder;
}
class HarmonicBuilder implements IHarmonicBuilder{
  _p: Harmonic = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Harmonic;
  constructor(toPatch?: Harmonic) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["artificial"]) || this._b["artificial"] !== undefined || this._p.artificial !== undefined, "artificial is a required field");
    console.assert((this._o && !this._m["touchingPitch"]) || this._b["touchingPitch"] !== undefined || this._p.touchingPitch !== undefined, "touchingPitch is a required field");
    console.assert((this._o && !this._m["soundingPitch"]) || this._b["soundingPitch"] !== undefined || this._p.soundingPitch !== undefined, "soundingPitch is a required field");
    console.assert((this._o && !this._m["natural"]) || this._b["natural"] !== undefined || this._p.natural !== undefined, "natural is a required field");
    console.assert((this._o && !this._m["basePitch"]) || this._b["basePitch"] !== undefined || this._p.basePitch !== undefined, "basePitch is a required field");
  }
  build(): Harmonic {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Harmonic";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  artificial(artificial: boolean): IHarmonicBuilder {
    this._p.artificial = artificial;
    this._m["artificial"] = true;
    return this;
  }
  touchingPitch(touchingPitch: boolean): IHarmonicBuilder {
    this._p.touchingPitch = touchingPitch;
    this._m["touchingPitch"] = true;
    return this;
  }
  soundingPitch(soundingPitch: boolean): IHarmonicBuilder {
    this._p.soundingPitch = soundingPitch;
    this._m["soundingPitch"] = true;
    return this;
  }
  natural(natural: boolean): IHarmonicBuilder {
    this._p.natural = natural;
    this._m["natural"] = true;
    return this;
  }
  basePitch(basePitch: boolean): IHarmonicBuilder {
    this._p.basePitch = basePitch;
    this._m["basePitch"] = true;
    return this;
  }
  printObject(printObject: boolean): IHarmonicBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchHarmonic(base: Harmonic): IHarmonicBuilder { return new HarmonicBuilder(base); }
export function buildHarmonic(): IHarmonicBuilder { return new HarmonicBuilder(); }

export interface IOpenStringBuilder {
  build: () => OpenString;
  patch: () => any[];
  defaultX: (defaultX: number) => IOpenStringBuilder;
  relativeY: (relativeY: number) => IOpenStringBuilder;
  defaultY: (defaultY: number) => IOpenStringBuilder;
  relativeX: (relativeX: number) => IOpenStringBuilder;
}
class OpenStringBuilder implements IOpenStringBuilder{
  _p: OpenString = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: OpenString;
  constructor(toPatch?: OpenString) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): OpenString {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "OpenString";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IOpenStringBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IOpenStringBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IOpenStringBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IOpenStringBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchOpenString(base: OpenString): IOpenStringBuilder { return new OpenStringBuilder(base); }
export function buildOpenString(): IOpenStringBuilder { return new OpenStringBuilder(); }

export interface IThumbPositionBuilder {
  build: () => ThumbPosition;
  patch: () => any[];
  defaultX: (defaultX: number) => IThumbPositionBuilder;
  relativeY: (relativeY: number) => IThumbPositionBuilder;
  defaultY: (defaultY: number) => IThumbPositionBuilder;
  relativeX: (relativeX: number) => IThumbPositionBuilder;
}
class ThumbPositionBuilder implements IThumbPositionBuilder{
  _p: ThumbPosition = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: ThumbPosition;
  constructor(toPatch?: ThumbPosition) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): ThumbPosition {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "ThumbPosition";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IThumbPositionBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IThumbPositionBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IThumbPositionBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IThumbPositionBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchThumbPosition(base: ThumbPosition): IThumbPositionBuilder { return new ThumbPositionBuilder(base); }
export function buildThumbPosition(): IThumbPositionBuilder { return new ThumbPositionBuilder(); }

export interface IPluckBuilder {
  build: () => Pluck;
  patch: () => any[];
  data: (data: string) => IPluckBuilder;
  defaultX: (defaultX: number) => IPluckBuilder;
  relativeY: (relativeY: number) => IPluckBuilder;
  defaultY: (defaultY: number) => IPluckBuilder;
  relativeX: (relativeX: number) => IPluckBuilder;
}
class PluckBuilder implements IPluckBuilder{
  _p: Pluck = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Pluck;
  constructor(toPatch?: Pluck) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): Pluck {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Pluck";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IPluckBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IPluckBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IPluckBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IPluckBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IPluckBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchPluck(base: Pluck): IPluckBuilder { return new PluckBuilder(base); }
export function buildPluck(): IPluckBuilder { return new PluckBuilder(); }

export interface IDoubleTongueBuilder {
  build: () => DoubleTongue;
  patch: () => any[];
  defaultX: (defaultX: number) => IDoubleTongueBuilder;
  relativeY: (relativeY: number) => IDoubleTongueBuilder;
  defaultY: (defaultY: number) => IDoubleTongueBuilder;
  relativeX: (relativeX: number) => IDoubleTongueBuilder;
}
class DoubleTongueBuilder implements IDoubleTongueBuilder{
  _p: DoubleTongue = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: DoubleTongue;
  constructor(toPatch?: DoubleTongue) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): DoubleTongue {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "DoubleTongue";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IDoubleTongueBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IDoubleTongueBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IDoubleTongueBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IDoubleTongueBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchDoubleTongue(base: DoubleTongue): IDoubleTongueBuilder { return new DoubleTongueBuilder(base); }
export function buildDoubleTongue(): IDoubleTongueBuilder { return new DoubleTongueBuilder(); }

export interface ITripleTongueBuilder {
  build: () => TripleTongue;
  patch: () => any[];
  defaultX: (defaultX: number) => ITripleTongueBuilder;
  relativeY: (relativeY: number) => ITripleTongueBuilder;
  defaultY: (defaultY: number) => ITripleTongueBuilder;
  relativeX: (relativeX: number) => ITripleTongueBuilder;
}
class TripleTongueBuilder implements ITripleTongueBuilder{
  _p: TripleTongue = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: TripleTongue;
  constructor(toPatch?: TripleTongue) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): TripleTongue {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "TripleTongue";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): ITripleTongueBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): ITripleTongueBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): ITripleTongueBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): ITripleTongueBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchTripleTongue(base: TripleTongue): ITripleTongueBuilder { return new TripleTongueBuilder(base); }
export function buildTripleTongue(): ITripleTongueBuilder { return new TripleTongueBuilder(); }

export interface IStoppedBuilder {
  build: () => Stopped;
  patch: () => any[];
  defaultX: (defaultX: number) => IStoppedBuilder;
  relativeY: (relativeY: number) => IStoppedBuilder;
  defaultY: (defaultY: number) => IStoppedBuilder;
  relativeX: (relativeX: number) => IStoppedBuilder;
}
class StoppedBuilder implements IStoppedBuilder{
  _p: Stopped = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Stopped;
  constructor(toPatch?: Stopped) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Stopped {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Stopped";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IStoppedBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IStoppedBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IStoppedBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IStoppedBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchStopped(base: Stopped): IStoppedBuilder { return new StoppedBuilder(base); }
export function buildStopped(): IStoppedBuilder { return new StoppedBuilder(); }

export interface ISnapPizzicatoBuilder {
  build: () => SnapPizzicato;
  patch: () => any[];
  defaultX: (defaultX: number) => ISnapPizzicatoBuilder;
  relativeY: (relativeY: number) => ISnapPizzicatoBuilder;
  defaultY: (defaultY: number) => ISnapPizzicatoBuilder;
  relativeX: (relativeX: number) => ISnapPizzicatoBuilder;
}
class SnapPizzicatoBuilder implements ISnapPizzicatoBuilder{
  _p: SnapPizzicato = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: SnapPizzicato;
  constructor(toPatch?: SnapPizzicato) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): SnapPizzicato {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "SnapPizzicato";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): ISnapPizzicatoBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): ISnapPizzicatoBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): ISnapPizzicatoBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): ISnapPizzicatoBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchSnapPizzicato(base: SnapPizzicato): ISnapPizzicatoBuilder { return new SnapPizzicatoBuilder(base); }
export function buildSnapPizzicato(): ISnapPizzicatoBuilder { return new SnapPizzicatoBuilder(); }

export interface IHammerOnBuilder {
  build: () => HammerOn;
  patch: () => any[];
  number: (number: number) => IHammerOnBuilder;
  type: (type: StartStop) => IHammerOnBuilder;
  data: (data: string) => IHammerOnBuilder;
  defaultX: (defaultX: number) => IHammerOnBuilder;
  relativeY: (relativeY: number) => IHammerOnBuilder;
  defaultY: (defaultY: number) => IHammerOnBuilder;
  relativeX: (relativeX: number) => IHammerOnBuilder;
}
class HammerOnBuilder implements IHammerOnBuilder{
  _p: HammerOn = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: HammerOn;
  constructor(toPatch?: HammerOn) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): HammerOn {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "HammerOn";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: number): IHammerOnBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  type(type: StartStop): IHammerOnBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  data(data: string): IHammerOnBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IHammerOnBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IHammerOnBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IHammerOnBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IHammerOnBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchHammerOn(base: HammerOn): IHammerOnBuilder { return new HammerOnBuilder(base); }
export function buildHammerOn(): IHammerOnBuilder { return new HammerOnBuilder(); }

export interface IPullOffBuilder {
  build: () => PullOff;
  patch: () => any[];
  number: (number: number) => IPullOffBuilder;
  type: (type: StartStop) => IPullOffBuilder;
  data: (data: string) => IPullOffBuilder;
  defaultX: (defaultX: number) => IPullOffBuilder;
  relativeY: (relativeY: number) => IPullOffBuilder;
  defaultY: (defaultY: number) => IPullOffBuilder;
  relativeX: (relativeX: number) => IPullOffBuilder;
}
class PullOffBuilder implements IPullOffBuilder{
  _p: PullOff = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PullOff;
  constructor(toPatch?: PullOff) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): PullOff {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PullOff";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: number): IPullOffBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  type(type: StartStop): IPullOffBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  data(data: string): IPullOffBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IPullOffBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IPullOffBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IPullOffBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IPullOffBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchPullOff(base: PullOff): IPullOffBuilder { return new PullOffBuilder(base); }
export function buildPullOff(): IPullOffBuilder { return new PullOffBuilder(); }

export interface IBendBuilder {
  build: () => Bend;
  patch: () => any[];
  bendAlter: (bendAlter: string) => IBendBuilder;
  withBar: (build: (builder: IWithBarBuilder) => IWithBarBuilder) => IBendBuilder;
  preBend: (preBend: boolean) => IBendBuilder;
  release: (release: boolean) => IBendBuilder;
  defaultX: (defaultX: number) => IBendBuilder;
  relativeY: (relativeY: number) => IBendBuilder;
  defaultY: (defaultY: number) => IBendBuilder;
  relativeX: (relativeX: number) => IBendBuilder;
}
class BendBuilder implements IBendBuilder{
  _p: Bend = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Bend;
  constructor(toPatch?: Bend) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["bendAlter"]) || this._b["bendAlter"] !== undefined || this._p.bendAlter !== undefined, "bendAlter is a required field");
    console.assert((this._o && !this._m["preBend"]) || this._b["preBend"] !== undefined || this._p.preBend !== undefined, "preBend is a required field");
    console.assert((this._o && !this._m["release"]) || this._b["release"] !== undefined || this._p.release !== undefined, "release is a required field");
  }
  build(): Bend {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Bend";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  bendAlter(bendAlter: string): IBendBuilder {
    this._p.bendAlter = bendAlter;
    this._m["bendAlter"] = true;
    return this;
  }
  withBar(build: (builder: IWithBarBuilder) => IWithBarBuilder): IBendBuilder {
    this._b["withBar"] = build(new WithBarBuilder(this._o && this._o["withBar"]));
    this._m["withBar"] = true;
    return this;
  }
  preBend(preBend: boolean): IBendBuilder {
    this._p.preBend = preBend;
    this._m["preBend"] = true;
    return this;
  }
  release(release: boolean): IBendBuilder {
    this._p.release = release;
    this._m["release"] = true;
    return this;
  }
  defaultX(defaultX: number): IBendBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IBendBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IBendBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IBendBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchBend(base: Bend): IBendBuilder { return new BendBuilder(base); }
export function buildBend(): IBendBuilder { return new BendBuilder(); }

export interface IWithBarBuilder {
  build: () => WithBar;
  patch: () => any[];
  data: (data: string) => IWithBarBuilder;
  defaultX: (defaultX: number) => IWithBarBuilder;
  relativeY: (relativeY: number) => IWithBarBuilder;
  defaultY: (defaultY: number) => IWithBarBuilder;
  relativeX: (relativeX: number) => IWithBarBuilder;
}
class WithBarBuilder implements IWithBarBuilder{
  _p: WithBar = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: WithBar;
  constructor(toPatch?: WithBar) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): WithBar {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "WithBar";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IWithBarBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IWithBarBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IWithBarBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IWithBarBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IWithBarBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchWithBar(base: WithBar): IWithBarBuilder { return new WithBarBuilder(base); }
export function buildWithBar(): IWithBarBuilder { return new WithBarBuilder(); }

export interface ITapBuilder {
  build: () => Tap;
  patch: () => any[];
  data: (data: string) => ITapBuilder;
  defaultX: (defaultX: number) => ITapBuilder;
  relativeY: (relativeY: number) => ITapBuilder;
  defaultY: (defaultY: number) => ITapBuilder;
  relativeX: (relativeX: number) => ITapBuilder;
}
class TapBuilder implements ITapBuilder{
  _p: Tap = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Tap;
  constructor(toPatch?: Tap) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): Tap {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Tap";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): ITapBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): ITapBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): ITapBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): ITapBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): ITapBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchTap(base: Tap): ITapBuilder { return new TapBuilder(base); }
export function buildTap(): ITapBuilder { return new TapBuilder(); }

export interface IHeelBuilder {
  build: () => Heel;
  patch: () => any[];
  substitution: (substitution: boolean) => IHeelBuilder;
  defaultX: (defaultX: number) => IHeelBuilder;
  relativeY: (relativeY: number) => IHeelBuilder;
  defaultY: (defaultY: number) => IHeelBuilder;
  relativeX: (relativeX: number) => IHeelBuilder;
}
class HeelBuilder implements IHeelBuilder{
  _p: Heel = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Heel;
  constructor(toPatch?: Heel) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Heel {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Heel";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  substitution(substitution: boolean): IHeelBuilder {
    this._p.substitution = substitution;
    this._m["substitution"] = true;
    return this;
  }
  defaultX(defaultX: number): IHeelBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IHeelBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IHeelBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IHeelBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchHeel(base: Heel): IHeelBuilder { return new HeelBuilder(base); }
export function buildHeel(): IHeelBuilder { return new HeelBuilder(); }

export interface IToeBuilder {
  build: () => Toe;
  patch: () => any[];
  substitution: (substitution: boolean) => IToeBuilder;
  defaultX: (defaultX: number) => IToeBuilder;
  relativeY: (relativeY: number) => IToeBuilder;
  defaultY: (defaultY: number) => IToeBuilder;
  relativeX: (relativeX: number) => IToeBuilder;
}
class ToeBuilder implements IToeBuilder{
  _p: Toe = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Toe;
  constructor(toPatch?: Toe) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Toe {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Toe";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  substitution(substitution: boolean): IToeBuilder {
    this._p.substitution = substitution;
    this._m["substitution"] = true;
    return this;
  }
  defaultX(defaultX: number): IToeBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IToeBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IToeBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IToeBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchToe(base: Toe): IToeBuilder { return new ToeBuilder(base); }
export function buildToe(): IToeBuilder { return new ToeBuilder(); }

export interface IFingernailsBuilder {
  build: () => Fingernails;
  patch: () => any[];
  defaultX: (defaultX: number) => IFingernailsBuilder;
  relativeY: (relativeY: number) => IFingernailsBuilder;
  defaultY: (defaultY: number) => IFingernailsBuilder;
  relativeX: (relativeX: number) => IFingernailsBuilder;
}
class FingernailsBuilder implements IFingernailsBuilder{
  _p: Fingernails = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Fingernails;
  constructor(toPatch?: Fingernails) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Fingernails {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Fingernails";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IFingernailsBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IFingernailsBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IFingernailsBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IFingernailsBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchFingernails(base: Fingernails): IFingernailsBuilder { return new FingernailsBuilder(base); }
export function buildFingernails(): IFingernailsBuilder { return new FingernailsBuilder(); }

export interface IHoleBuilder {
  build: () => Hole;
  patch: () => any[];
  holeClosed: (build: (builder: IHoleClosedBuilder) => IHoleClosedBuilder) => IHoleBuilder;
  holeShape: (holeShape: string) => IHoleBuilder;
  holeType: (holeType: string) => IHoleBuilder;
  defaultX: (defaultX: number) => IHoleBuilder;
  relativeY: (relativeY: number) => IHoleBuilder;
  defaultY: (defaultY: number) => IHoleBuilder;
  relativeX: (relativeX: number) => IHoleBuilder;
}
class HoleBuilder implements IHoleBuilder{
  _p: Hole = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Hole;
  constructor(toPatch?: Hole) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["holeClosed"]) || this._b["holeClosed"] !== undefined || this._p.holeClosed !== undefined, "holeClosed is a required field");
    console.assert((this._o && !this._m["holeShape"]) || this._b["holeShape"] !== undefined || this._p.holeShape !== undefined, "holeShape is a required field");
  }
  build(): Hole {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Hole";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  holeClosed(build: (builder: IHoleClosedBuilder) => IHoleClosedBuilder): IHoleBuilder {
    this._b["holeClosed"] = build(new HoleClosedBuilder(this._o && this._o["holeClosed"]));
    this._m["holeClosed"] = true;
    return this;
  }
  holeShape(holeShape: string): IHoleBuilder {
    this._p.holeShape = holeShape;
    this._m["holeShape"] = true;
    return this;
  }
  holeType(holeType: string): IHoleBuilder {
    this._p.holeType = holeType;
    this._m["holeType"] = true;
    return this;
  }
  defaultX(defaultX: number): IHoleBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IHoleBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IHoleBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IHoleBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchHole(base: Hole): IHoleBuilder { return new HoleBuilder(base); }
export function buildHole(): IHoleBuilder { return new HoleBuilder(); }

export interface IHoleClosedBuilder {
  build: () => HoleClosed;
  patch: () => any[];
  location: (location: HoleLocation) => IHoleClosedBuilder;
  data: (data: HoleClosedType) => IHoleClosedBuilder;
}
class HoleClosedBuilder implements IHoleClosedBuilder{
  _p: HoleClosed = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: HoleClosed;
  constructor(toPatch?: HoleClosed) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): HoleClosed {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "HoleClosed";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  location(location: HoleLocation): IHoleClosedBuilder {
    this._p.location = location;
    this._m["location"] = true;
    return this;
  }
  data(data: HoleClosedType): IHoleClosedBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
}
export function patchHoleClosed(base: HoleClosed): IHoleClosedBuilder { return new HoleClosedBuilder(base); }
export function buildHoleClosed(): IHoleClosedBuilder { return new HoleClosedBuilder(); }

export interface IArrowBuilder {
  build: () => Arrow;
  patch: () => any[];
  arrowStyle: (arrowStyle: string) => IArrowBuilder;
  arrowDirection: (arrowDirection: string) => IArrowBuilder;
  circularArrow: (circularArrow: string) => IArrowBuilder;
  defaultX: (defaultX: number) => IArrowBuilder;
  relativeY: (relativeY: number) => IArrowBuilder;
  defaultY: (defaultY: number) => IArrowBuilder;
  relativeX: (relativeX: number) => IArrowBuilder;
}
class ArrowBuilder implements IArrowBuilder{
  _p: Arrow = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Arrow;
  constructor(toPatch?: Arrow) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Arrow {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Arrow";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  arrowStyle(arrowStyle: string): IArrowBuilder {
    this._p.arrowStyle = arrowStyle;
    this._m["arrowStyle"] = true;
    return this;
  }
  arrowDirection(arrowDirection: string): IArrowBuilder {
    this._p.arrowDirection = arrowDirection;
    this._m["arrowDirection"] = true;
    return this;
  }
  circularArrow(circularArrow: string): IArrowBuilder {
    this._p.circularArrow = circularArrow;
    this._m["circularArrow"] = true;
    return this;
  }
  defaultX(defaultX: number): IArrowBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IArrowBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IArrowBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IArrowBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchArrow(base: Arrow): IArrowBuilder { return new ArrowBuilder(base); }
export function buildArrow(): IArrowBuilder { return new ArrowBuilder(); }

export interface IHandbellBuilder {
  build: () => Handbell;
  patch: () => any[];
  data: (data: string) => IHandbellBuilder;
  defaultX: (defaultX: number) => IHandbellBuilder;
  relativeY: (relativeY: number) => IHandbellBuilder;
  defaultY: (defaultY: number) => IHandbellBuilder;
  relativeX: (relativeX: number) => IHandbellBuilder;
}
class HandbellBuilder implements IHandbellBuilder{
  _p: Handbell = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Handbell;
  constructor(toPatch?: Handbell) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): Handbell {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Handbell";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IHandbellBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IHandbellBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IHandbellBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IHandbellBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IHandbellBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchHandbell(base: Handbell): IHandbellBuilder { return new HandbellBuilder(base); }
export function buildHandbell(): IHandbellBuilder { return new HandbellBuilder(); }

export interface IOtherTechnicalBuilder {
  build: () => OtherTechnical;
  patch: () => any[];
  data: (data: string) => IOtherTechnicalBuilder;
  defaultX: (defaultX: number) => IOtherTechnicalBuilder;
  relativeY: (relativeY: number) => IOtherTechnicalBuilder;
  defaultY: (defaultY: number) => IOtherTechnicalBuilder;
  relativeX: (relativeX: number) => IOtherTechnicalBuilder;
}
class OtherTechnicalBuilder implements IOtherTechnicalBuilder{
  _p: OtherTechnical = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: OtherTechnical;
  constructor(toPatch?: OtherTechnical) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): OtherTechnical {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "OtherTechnical";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IOtherTechnicalBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IOtherTechnicalBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IOtherTechnicalBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IOtherTechnicalBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IOtherTechnicalBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchOtherTechnical(base: OtherTechnical): IOtherTechnicalBuilder { return new OtherTechnicalBuilder(base); }
export function buildOtherTechnical(): IOtherTechnicalBuilder { return new OtherTechnicalBuilder(); }

export interface IArticulationsBuilder {
  build: () => Articulations;
  patch: () => any[];
  accent: (build: (builder: IAccentBuilder) => IAccentBuilder) => IArticulationsBuilder;
  doit: (build: (builder: IDoitBuilder) => IDoitBuilder) => IArticulationsBuilder;
  breathMark: (build: (builder: IBreathMarkBuilder) => IBreathMarkBuilder) => IArticulationsBuilder;
  otherArticulations: (otherArticulations: OtherArticulation[]) => IArticulationsBuilder;
  detachedLegato: (build: (builder: IDetachedLegatoBuilder) => IDetachedLegatoBuilder) => IArticulationsBuilder;
  staccatissimo: (build: (builder: IStaccatissimoBuilder) => IStaccatissimoBuilder) => IArticulationsBuilder;
  plop: (build: (builder: IPlopBuilder) => IPlopBuilder) => IArticulationsBuilder;
  unstress: (build: (builder: IUnstressBuilder) => IUnstressBuilder) => IArticulationsBuilder;
  strongAccent: (build: (builder: IStrongAccentBuilder) => IStrongAccentBuilder) => IArticulationsBuilder;
  staccato: (build: (builder: IStaccatoBuilder) => IStaccatoBuilder) => IArticulationsBuilder;
  spiccato: (build: (builder: ISpiccatoBuilder) => ISpiccatoBuilder) => IArticulationsBuilder;
  scoop: (build: (builder: IScoopBuilder) => IScoopBuilder) => IArticulationsBuilder;
  falloff: (build: (builder: IFalloffBuilder) => IFalloffBuilder) => IArticulationsBuilder;
  caesura: (build: (builder: ICaesuraBuilder) => ICaesuraBuilder) => IArticulationsBuilder;
  stress: (build: (builder: IStressBuilder) => IStressBuilder) => IArticulationsBuilder;
  tenuto: (build: (builder: ITenutoBuilder) => ITenutoBuilder) => IArticulationsBuilder;
}
class ArticulationsBuilder implements IArticulationsBuilder{
  _p: Articulations = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Articulations;
  constructor(toPatch?: Articulations) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Articulations {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Articulations";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  accent(build: (builder: IAccentBuilder) => IAccentBuilder): IArticulationsBuilder {
    this._b["accent"] = build(new AccentBuilder(this._o && this._o["accent"]));
    this._m["accent"] = true;
    return this;
  }
  doit(build: (builder: IDoitBuilder) => IDoitBuilder): IArticulationsBuilder {
    this._b["doit"] = build(new DoitBuilder(this._o && this._o["doit"]));
    this._m["doit"] = true;
    return this;
  }
  breathMark(build: (builder: IBreathMarkBuilder) => IBreathMarkBuilder): IArticulationsBuilder {
    this._b["breathMark"] = build(new BreathMarkBuilder(this._o && this._o["breathMark"]));
    this._m["breathMark"] = true;
    return this;
  }
  otherArticulations(otherArticulations: OtherArticulation[]): IArticulationsBuilder {
    this._p.otherArticulations = otherArticulations;
    this._m["otherArticulations"] = true;
    return this;
  }
  detachedLegato(build: (builder: IDetachedLegatoBuilder) => IDetachedLegatoBuilder): IArticulationsBuilder {
    this._b["detachedLegato"] = build(new DetachedLegatoBuilder(this._o && this._o["detachedLegato"]));
    this._m["detachedLegato"] = true;
    return this;
  }
  staccatissimo(build: (builder: IStaccatissimoBuilder) => IStaccatissimoBuilder): IArticulationsBuilder {
    this._b["staccatissimo"] = build(new StaccatissimoBuilder(this._o && this._o["staccatissimo"]));
    this._m["staccatissimo"] = true;
    return this;
  }
  plop(build: (builder: IPlopBuilder) => IPlopBuilder): IArticulationsBuilder {
    this._b["plop"] = build(new PlopBuilder(this._o && this._o["plop"]));
    this._m["plop"] = true;
    return this;
  }
  unstress(build: (builder: IUnstressBuilder) => IUnstressBuilder): IArticulationsBuilder {
    this._b["unstress"] = build(new UnstressBuilder(this._o && this._o["unstress"]));
    this._m["unstress"] = true;
    return this;
  }
  strongAccent(build: (builder: IStrongAccentBuilder) => IStrongAccentBuilder): IArticulationsBuilder {
    this._b["strongAccent"] = build(new StrongAccentBuilder(this._o && this._o["strongAccent"]));
    this._m["strongAccent"] = true;
    return this;
  }
  staccato(build: (builder: IStaccatoBuilder) => IStaccatoBuilder): IArticulationsBuilder {
    this._b["staccato"] = build(new StaccatoBuilder(this._o && this._o["staccato"]));
    this._m["staccato"] = true;
    return this;
  }
  spiccato(build: (builder: ISpiccatoBuilder) => ISpiccatoBuilder): IArticulationsBuilder {
    this._b["spiccato"] = build(new SpiccatoBuilder(this._o && this._o["spiccato"]));
    this._m["spiccato"] = true;
    return this;
  }
  scoop(build: (builder: IScoopBuilder) => IScoopBuilder): IArticulationsBuilder {
    this._b["scoop"] = build(new ScoopBuilder(this._o && this._o["scoop"]));
    this._m["scoop"] = true;
    return this;
  }
  falloff(build: (builder: IFalloffBuilder) => IFalloffBuilder): IArticulationsBuilder {
    this._b["falloff"] = build(new FalloffBuilder(this._o && this._o["falloff"]));
    this._m["falloff"] = true;
    return this;
  }
  caesura(build: (builder: ICaesuraBuilder) => ICaesuraBuilder): IArticulationsBuilder {
    this._b["caesura"] = build(new CaesuraBuilder(this._o && this._o["caesura"]));
    this._m["caesura"] = true;
    return this;
  }
  stress(build: (builder: IStressBuilder) => IStressBuilder): IArticulationsBuilder {
    this._b["stress"] = build(new StressBuilder(this._o && this._o["stress"]));
    this._m["stress"] = true;
    return this;
  }
  tenuto(build: (builder: ITenutoBuilder) => ITenutoBuilder): IArticulationsBuilder {
    this._b["tenuto"] = build(new TenutoBuilder(this._o && this._o["tenuto"]));
    this._m["tenuto"] = true;
    return this;
  }
}
export function patchArticulations(base: Articulations): IArticulationsBuilder { return new ArticulationsBuilder(base); }
export function buildArticulations(): IArticulationsBuilder { return new ArticulationsBuilder(); }

export interface IAccentBuilder {
  build: () => Accent;
  patch: () => any[];
  defaultX: (defaultX: number) => IAccentBuilder;
  relativeY: (relativeY: number) => IAccentBuilder;
  defaultY: (defaultY: number) => IAccentBuilder;
  relativeX: (relativeX: number) => IAccentBuilder;
}
class AccentBuilder implements IAccentBuilder{
  _p: Accent = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Accent;
  constructor(toPatch?: Accent) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Accent {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Accent";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IAccentBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IAccentBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IAccentBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IAccentBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchAccent(base: Accent): IAccentBuilder { return new AccentBuilder(base); }
export function buildAccent(): IAccentBuilder { return new AccentBuilder(); }

export interface IStrongAccentBuilder {
  build: () => StrongAccent;
  patch: () => any[];
  type: (type: UpDown) => IStrongAccentBuilder;
  defaultX: (defaultX: number) => IStrongAccentBuilder;
  relativeY: (relativeY: number) => IStrongAccentBuilder;
  defaultY: (defaultY: number) => IStrongAccentBuilder;
  relativeX: (relativeX: number) => IStrongAccentBuilder;
}
class StrongAccentBuilder implements IStrongAccentBuilder{
  _p: StrongAccent = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: StrongAccent;
  constructor(toPatch?: StrongAccent) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): StrongAccent {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "StrongAccent";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  type(type: UpDown): IStrongAccentBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  defaultX(defaultX: number): IStrongAccentBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IStrongAccentBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IStrongAccentBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IStrongAccentBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchStrongAccent(base: StrongAccent): IStrongAccentBuilder { return new StrongAccentBuilder(base); }
export function buildStrongAccent(): IStrongAccentBuilder { return new StrongAccentBuilder(); }

export interface IStaccatoBuilder {
  build: () => Staccato;
  patch: () => any[];
  defaultX: (defaultX: number) => IStaccatoBuilder;
  relativeY: (relativeY: number) => IStaccatoBuilder;
  defaultY: (defaultY: number) => IStaccatoBuilder;
  relativeX: (relativeX: number) => IStaccatoBuilder;
}
class StaccatoBuilder implements IStaccatoBuilder{
  _p: Staccato = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Staccato;
  constructor(toPatch?: Staccato) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Staccato {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Staccato";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IStaccatoBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IStaccatoBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IStaccatoBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IStaccatoBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchStaccato(base: Staccato): IStaccatoBuilder { return new StaccatoBuilder(base); }
export function buildStaccato(): IStaccatoBuilder { return new StaccatoBuilder(); }

export interface ITenutoBuilder {
  build: () => Tenuto;
  patch: () => any[];
  defaultX: (defaultX: number) => ITenutoBuilder;
  relativeY: (relativeY: number) => ITenutoBuilder;
  defaultY: (defaultY: number) => ITenutoBuilder;
  relativeX: (relativeX: number) => ITenutoBuilder;
}
class TenutoBuilder implements ITenutoBuilder{
  _p: Tenuto = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Tenuto;
  constructor(toPatch?: Tenuto) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Tenuto {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Tenuto";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): ITenutoBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): ITenutoBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): ITenutoBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): ITenutoBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchTenuto(base: Tenuto): ITenutoBuilder { return new TenutoBuilder(base); }
export function buildTenuto(): ITenutoBuilder { return new TenutoBuilder(); }

export interface IDetachedLegatoBuilder {
  build: () => DetachedLegato;
  patch: () => any[];
  defaultX: (defaultX: number) => IDetachedLegatoBuilder;
  relativeY: (relativeY: number) => IDetachedLegatoBuilder;
  defaultY: (defaultY: number) => IDetachedLegatoBuilder;
  relativeX: (relativeX: number) => IDetachedLegatoBuilder;
}
class DetachedLegatoBuilder implements IDetachedLegatoBuilder{
  _p: DetachedLegato = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: DetachedLegato;
  constructor(toPatch?: DetachedLegato) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): DetachedLegato {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "DetachedLegato";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IDetachedLegatoBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IDetachedLegatoBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IDetachedLegatoBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IDetachedLegatoBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchDetachedLegato(base: DetachedLegato): IDetachedLegatoBuilder { return new DetachedLegatoBuilder(base); }
export function buildDetachedLegato(): IDetachedLegatoBuilder { return new DetachedLegatoBuilder(); }

export interface IStaccatissimoBuilder {
  build: () => Staccatissimo;
  patch: () => any[];
  defaultX: (defaultX: number) => IStaccatissimoBuilder;
  relativeY: (relativeY: number) => IStaccatissimoBuilder;
  defaultY: (defaultY: number) => IStaccatissimoBuilder;
  relativeX: (relativeX: number) => IStaccatissimoBuilder;
}
class StaccatissimoBuilder implements IStaccatissimoBuilder{
  _p: Staccatissimo = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Staccatissimo;
  constructor(toPatch?: Staccatissimo) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Staccatissimo {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Staccatissimo";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IStaccatissimoBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IStaccatissimoBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IStaccatissimoBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IStaccatissimoBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchStaccatissimo(base: Staccatissimo): IStaccatissimoBuilder { return new StaccatissimoBuilder(base); }
export function buildStaccatissimo(): IStaccatissimoBuilder { return new StaccatissimoBuilder(); }

export interface ISpiccatoBuilder {
  build: () => Spiccato;
  patch: () => any[];
  defaultX: (defaultX: number) => ISpiccatoBuilder;
  relativeY: (relativeY: number) => ISpiccatoBuilder;
  defaultY: (defaultY: number) => ISpiccatoBuilder;
  relativeX: (relativeX: number) => ISpiccatoBuilder;
}
class SpiccatoBuilder implements ISpiccatoBuilder{
  _p: Spiccato = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Spiccato;
  constructor(toPatch?: Spiccato) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Spiccato {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Spiccato";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): ISpiccatoBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): ISpiccatoBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): ISpiccatoBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): ISpiccatoBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchSpiccato(base: Spiccato): ISpiccatoBuilder { return new SpiccatoBuilder(base); }
export function buildSpiccato(): ISpiccatoBuilder { return new SpiccatoBuilder(); }

export interface IScoopBuilder {
  build: () => Scoop;
  patch: () => any[];
  lineShape: (lineShape: StraightCurved) => IScoopBuilder;
}
class ScoopBuilder implements IScoopBuilder{
  _p: Scoop = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Scoop;
  constructor(toPatch?: Scoop) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Scoop {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Scoop";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  lineShape(lineShape: StraightCurved): IScoopBuilder {
    this._p.lineShape = lineShape;
    this._m["lineShape"] = true;
    return this;
  }
}
export function patchScoop(base: Scoop): IScoopBuilder { return new ScoopBuilder(base); }
export function buildScoop(): IScoopBuilder { return new ScoopBuilder(); }

export interface IPlopBuilder {
  build: () => Plop;
  patch: () => any[];
  lineShape: (lineShape: StraightCurved) => IPlopBuilder;
}
class PlopBuilder implements IPlopBuilder{
  _p: Plop = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Plop;
  constructor(toPatch?: Plop) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Plop {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Plop";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  lineShape(lineShape: StraightCurved): IPlopBuilder {
    this._p.lineShape = lineShape;
    this._m["lineShape"] = true;
    return this;
  }
}
export function patchPlop(base: Plop): IPlopBuilder { return new PlopBuilder(base); }
export function buildPlop(): IPlopBuilder { return new PlopBuilder(); }

export interface IDoitBuilder {
  build: () => Doit;
  patch: () => any[];
  lineShape: (lineShape: StraightCurved) => IDoitBuilder;
}
class DoitBuilder implements IDoitBuilder{
  _p: Doit = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Doit;
  constructor(toPatch?: Doit) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Doit {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Doit";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  lineShape(lineShape: StraightCurved): IDoitBuilder {
    this._p.lineShape = lineShape;
    this._m["lineShape"] = true;
    return this;
  }
}
export function patchDoit(base: Doit): IDoitBuilder { return new DoitBuilder(base); }
export function buildDoit(): IDoitBuilder { return new DoitBuilder(); }

export interface IFalloffBuilder {
  build: () => Falloff;
  patch: () => any[];
  lineShape: (lineShape: StraightCurved) => IFalloffBuilder;
}
class FalloffBuilder implements IFalloffBuilder{
  _p: Falloff = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Falloff;
  constructor(toPatch?: Falloff) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Falloff {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Falloff";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  lineShape(lineShape: StraightCurved): IFalloffBuilder {
    this._p.lineShape = lineShape;
    this._m["lineShape"] = true;
    return this;
  }
}
export function patchFalloff(base: Falloff): IFalloffBuilder { return new FalloffBuilder(base); }
export function buildFalloff(): IFalloffBuilder { return new FalloffBuilder(); }

export interface IBreathMarkBuilder {
  build: () => BreathMark;
  patch: () => any[];
  type: (type: BreathMarkType) => IBreathMarkBuilder;
  lineShape: (lineShape: StraightCurved) => IBreathMarkBuilder;
}
class BreathMarkBuilder implements IBreathMarkBuilder{
  _p: BreathMark = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: BreathMark;
  constructor(toPatch?: BreathMark) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): BreathMark {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "BreathMark";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  type(type: BreathMarkType): IBreathMarkBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  lineShape(lineShape: StraightCurved): IBreathMarkBuilder {
    this._p.lineShape = lineShape;
    this._m["lineShape"] = true;
    return this;
  }
}
export function patchBreathMark(base: BreathMark): IBreathMarkBuilder { return new BreathMarkBuilder(base); }
export function buildBreathMark(): IBreathMarkBuilder { return new BreathMarkBuilder(); }

export interface ICaesuraBuilder {
  build: () => Caesura;
  patch: () => any[];
  defaultX: (defaultX: number) => ICaesuraBuilder;
  relativeY: (relativeY: number) => ICaesuraBuilder;
  defaultY: (defaultY: number) => ICaesuraBuilder;
  relativeX: (relativeX: number) => ICaesuraBuilder;
}
class CaesuraBuilder implements ICaesuraBuilder{
  _p: Caesura = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Caesura;
  constructor(toPatch?: Caesura) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Caesura {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Caesura";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): ICaesuraBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): ICaesuraBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): ICaesuraBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): ICaesuraBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchCaesura(base: Caesura): ICaesuraBuilder { return new CaesuraBuilder(base); }
export function buildCaesura(): ICaesuraBuilder { return new CaesuraBuilder(); }

export interface IStressBuilder {
  build: () => Stress;
  patch: () => any[];
  defaultX: (defaultX: number) => IStressBuilder;
  relativeY: (relativeY: number) => IStressBuilder;
  defaultY: (defaultY: number) => IStressBuilder;
  relativeX: (relativeX: number) => IStressBuilder;
}
class StressBuilder implements IStressBuilder{
  _p: Stress = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Stress;
  constructor(toPatch?: Stress) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Stress {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Stress";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IStressBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IStressBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IStressBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IStressBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchStress(base: Stress): IStressBuilder { return new StressBuilder(base); }
export function buildStress(): IStressBuilder { return new StressBuilder(); }

export interface IUnstressBuilder {
  build: () => Unstress;
  patch: () => any[];
  defaultX: (defaultX: number) => IUnstressBuilder;
  relativeY: (relativeY: number) => IUnstressBuilder;
  defaultY: (defaultY: number) => IUnstressBuilder;
  relativeX: (relativeX: number) => IUnstressBuilder;
}
class UnstressBuilder implements IUnstressBuilder{
  _p: Unstress = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Unstress;
  constructor(toPatch?: Unstress) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Unstress {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Unstress";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IUnstressBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IUnstressBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IUnstressBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IUnstressBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchUnstress(base: Unstress): IUnstressBuilder { return new UnstressBuilder(base); }
export function buildUnstress(): IUnstressBuilder { return new UnstressBuilder(); }

export interface IOtherArticulationBuilder {
  build: () => OtherArticulation;
  patch: () => any[];
  data: (data: string) => IOtherArticulationBuilder;
  defaultX: (defaultX: number) => IOtherArticulationBuilder;
  relativeY: (relativeY: number) => IOtherArticulationBuilder;
  defaultY: (defaultY: number) => IOtherArticulationBuilder;
  relativeX: (relativeX: number) => IOtherArticulationBuilder;
}
class OtherArticulationBuilder implements IOtherArticulationBuilder{
  _p: OtherArticulation = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: OtherArticulation;
  constructor(toPatch?: OtherArticulation) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): OtherArticulation {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "OtherArticulation";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IOtherArticulationBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IOtherArticulationBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IOtherArticulationBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IOtherArticulationBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IOtherArticulationBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchOtherArticulation(base: OtherArticulation): IOtherArticulationBuilder { return new OtherArticulationBuilder(base); }
export function buildOtherArticulation(): IOtherArticulationBuilder { return new OtherArticulationBuilder(); }

export interface IArpeggiateBuilder {
  build: () => Arpeggiate;
  patch: () => any[];
  number: (number: number) => IArpeggiateBuilder;
  direction: (direction: UpDown) => IArpeggiateBuilder;
  defaultX: (defaultX: number) => IArpeggiateBuilder;
  relativeY: (relativeY: number) => IArpeggiateBuilder;
  defaultY: (defaultY: number) => IArpeggiateBuilder;
  relativeX: (relativeX: number) => IArpeggiateBuilder;
}
class ArpeggiateBuilder implements IArpeggiateBuilder{
  _p: Arpeggiate = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Arpeggiate;
  constructor(toPatch?: Arpeggiate) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Arpeggiate {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Arpeggiate";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: number): IArpeggiateBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  direction(direction: UpDown): IArpeggiateBuilder {
    this._p.direction = direction;
    this._m["direction"] = true;
    return this;
  }
  defaultX(defaultX: number): IArpeggiateBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IArpeggiateBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IArpeggiateBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IArpeggiateBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchArpeggiate(base: Arpeggiate): IArpeggiateBuilder { return new ArpeggiateBuilder(base); }
export function buildArpeggiate(): IArpeggiateBuilder { return new ArpeggiateBuilder(); }

export interface INonArpeggiateBuilder {
  build: () => NonArpeggiate;
  patch: () => any[];
  number: (number: number) => INonArpeggiateBuilder;
  type: (type: TopBottom) => INonArpeggiateBuilder;
  defaultX: (defaultX: number) => INonArpeggiateBuilder;
  relativeY: (relativeY: number) => INonArpeggiateBuilder;
  defaultY: (defaultY: number) => INonArpeggiateBuilder;
  relativeX: (relativeX: number) => INonArpeggiateBuilder;
}
class NonArpeggiateBuilder implements INonArpeggiateBuilder{
  _p: NonArpeggiate = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: NonArpeggiate;
  constructor(toPatch?: NonArpeggiate) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): NonArpeggiate {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "NonArpeggiate";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: number): INonArpeggiateBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  type(type: TopBottom): INonArpeggiateBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  defaultX(defaultX: number): INonArpeggiateBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): INonArpeggiateBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): INonArpeggiateBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): INonArpeggiateBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchNonArpeggiate(base: NonArpeggiate): INonArpeggiateBuilder { return new NonArpeggiateBuilder(base); }
export function buildNonArpeggiate(): INonArpeggiateBuilder { return new NonArpeggiateBuilder(); }

export interface ILaughingBuilder {
  build: () => Laughing;
  patch: () => any[];
  _class: (_class: string) => ILaughingBuilder;
}
class LaughingBuilder implements ILaughingBuilder{
  _p: Laughing = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Laughing;
  constructor(toPatch?: Laughing) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Laughing {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Laughing";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  _class(_class: string): ILaughingBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchLaughing(base: Laughing): ILaughingBuilder { return new LaughingBuilder(base); }
export function buildLaughing(): ILaughingBuilder { return new LaughingBuilder(); }

export interface IHummingBuilder {
  build: () => Humming;
  patch: () => any[];
  _class: (_class: string) => IHummingBuilder;
}
class HummingBuilder implements IHummingBuilder{
  _p: Humming = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Humming;
  constructor(toPatch?: Humming) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Humming {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Humming";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  _class(_class: string): IHummingBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchHumming(base: Humming): IHummingBuilder { return new HummingBuilder(base); }
export function buildHumming(): IHummingBuilder { return new HummingBuilder(); }

export interface IEndLineBuilder {
  build: () => EndLine;
  patch: () => any[];
  _class: (_class: string) => IEndLineBuilder;
}
class EndLineBuilder implements IEndLineBuilder{
  _p: EndLine = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: EndLine;
  constructor(toPatch?: EndLine) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): EndLine {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "EndLine";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  _class(_class: string): IEndLineBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchEndLine(base: EndLine): IEndLineBuilder { return new EndLineBuilder(base); }
export function buildEndLine(): IEndLineBuilder { return new EndLineBuilder(); }

export interface IEndParagraphBuilder {
  build: () => EndParagraph;
  patch: () => any[];
  _class: (_class: string) => IEndParagraphBuilder;
}
class EndParagraphBuilder implements IEndParagraphBuilder{
  _p: EndParagraph = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: EndParagraph;
  constructor(toPatch?: EndParagraph) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): EndParagraph {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "EndParagraph";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  _class(_class: string): IEndParagraphBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchEndParagraph(base: EndParagraph): IEndParagraphBuilder { return new EndParagraphBuilder(base); }
export function buildEndParagraph(): IEndParagraphBuilder { return new EndParagraphBuilder(); }

export interface ILyricPartsBuilder {
  build: () => LyricParts;
  patch: () => any[];
}
class LyricPartsBuilder implements ILyricPartsBuilder{
  _p: LyricParts = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: LyricParts;
  constructor(toPatch?: LyricParts) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): LyricParts {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "LyricParts";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
}
export function patchLyricParts(base: LyricParts): ILyricPartsBuilder { return new LyricPartsBuilder(base); }
export function buildLyricParts(): ILyricPartsBuilder { return new LyricPartsBuilder(); }

export interface ILyricBuilder {
  build: () => Lyric;
  patch: () => any[];
  lyricParts: (lyricParts: boolean[]) => ILyricBuilder;
  number: (number: number) => ILyricBuilder;
  name: (name: string) => ILyricBuilder;
  justify: (justify: LeftCenterRight) => ILyricBuilder;
}
class LyricBuilder implements ILyricBuilder{
  _p: Lyric = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Lyric;
  constructor(toPatch?: Lyric) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["lyricParts"]) || this._b["lyricParts"] !== undefined || this._p.lyricParts !== undefined, "lyricParts is a required field");
  }
  build(): Lyric {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Lyric";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  lyricParts(lyricParts: boolean[]): ILyricBuilder {
    this._p.lyricParts = lyricParts;
    this._m["lyricParts"] = true;
    return this;
  }
  number(number: number): ILyricBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  name(name: string): ILyricBuilder {
    this._p.name = name;
    this._m["name"] = true;
    return this;
  }
  justify(justify: LeftCenterRight): ILyricBuilder {
    this._p.justify = justify;
    this._m["justify"] = true;
    return this;
  }
}
export function patchLyric(base: Lyric): ILyricBuilder { return new LyricBuilder(base); }
export function buildLyric(): ILyricBuilder { return new LyricBuilder(); }

export interface ITextBuilder {
  build: () => Text;
  patch: () => any[];
  data: (data: string) => ITextBuilder;
  _class: (_class: string) => ITextBuilder;
  fontFamily: (fontFamily: string) => ITextBuilder;
  fontWeight: (fontWeight: NormalBold) => ITextBuilder;
  fontStyle: (fontStyle: NormalItalic) => ITextBuilder;
  fontSize: (fontSize: string) => ITextBuilder;
}
class TextBuilder implements ITextBuilder{
  _p: Text = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Text;
  constructor(toPatch?: Text) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): Text {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Text";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): ITextBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  _class(_class: string): ITextBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
  fontFamily(fontFamily: string): ITextBuilder {
    this._p.fontFamily = fontFamily;
    this._m["fontFamily"] = true;
    return this;
  }
  fontWeight(fontWeight: NormalBold): ITextBuilder {
    this._p.fontWeight = fontWeight;
    this._m["fontWeight"] = true;
    return this;
  }
  fontStyle(fontStyle: NormalItalic): ITextBuilder {
    this._p.fontStyle = fontStyle;
    this._m["fontStyle"] = true;
    return this;
  }
  fontSize(fontSize: string): ITextBuilder {
    this._p.fontSize = fontSize;
    this._m["fontSize"] = true;
    return this;
  }
}
export function patchText(base: Text): ITextBuilder { return new TextBuilder(base); }
export function buildText(): ITextBuilder { return new TextBuilder(); }

export interface ISyllabicBuilder {
  build: () => Syllabic;
  patch: () => any[];
  data: (data: SyllabicType) => ISyllabicBuilder;
  _class: (_class: string) => ISyllabicBuilder;
  fontFamily: (fontFamily: string) => ISyllabicBuilder;
  fontWeight: (fontWeight: NormalBold) => ISyllabicBuilder;
  fontStyle: (fontStyle: NormalItalic) => ISyllabicBuilder;
  fontSize: (fontSize: string) => ISyllabicBuilder;
}
class SyllabicBuilder implements ISyllabicBuilder{
  _p: Syllabic = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Syllabic;
  constructor(toPatch?: Syllabic) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): Syllabic {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Syllabic";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: SyllabicType): ISyllabicBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  _class(_class: string): ISyllabicBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
  fontFamily(fontFamily: string): ISyllabicBuilder {
    this._p.fontFamily = fontFamily;
    this._m["fontFamily"] = true;
    return this;
  }
  fontWeight(fontWeight: NormalBold): ISyllabicBuilder {
    this._p.fontWeight = fontWeight;
    this._m["fontWeight"] = true;
    return this;
  }
  fontStyle(fontStyle: NormalItalic): ISyllabicBuilder {
    this._p.fontStyle = fontStyle;
    this._m["fontStyle"] = true;
    return this;
  }
  fontSize(fontSize: string): ISyllabicBuilder {
    this._p.fontSize = fontSize;
    this._m["fontSize"] = true;
    return this;
  }
}
export function patchSyllabic(base: Syllabic): ISyllabicBuilder { return new SyllabicBuilder(base); }
export function buildSyllabic(): ISyllabicBuilder { return new SyllabicBuilder(); }

export interface IElisionBuilder {
  build: () => Elision;
  patch: () => any[];
  data: (data: string) => IElisionBuilder;
  _class: (_class: string) => IElisionBuilder;
  fontFamily: (fontFamily: string) => IElisionBuilder;
  fontWeight: (fontWeight: NormalBold) => IElisionBuilder;
  fontStyle: (fontStyle: NormalItalic) => IElisionBuilder;
  fontSize: (fontSize: string) => IElisionBuilder;
}
class ElisionBuilder implements IElisionBuilder{
  _p: Elision = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Elision;
  constructor(toPatch?: Elision) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): Elision {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Elision";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IElisionBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  _class(_class: string): IElisionBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
  fontFamily(fontFamily: string): IElisionBuilder {
    this._p.fontFamily = fontFamily;
    this._m["fontFamily"] = true;
    return this;
  }
  fontWeight(fontWeight: NormalBold): IElisionBuilder {
    this._p.fontWeight = fontWeight;
    this._m["fontWeight"] = true;
    return this;
  }
  fontStyle(fontStyle: NormalItalic): IElisionBuilder {
    this._p.fontStyle = fontStyle;
    this._m["fontStyle"] = true;
    return this;
  }
  fontSize(fontSize: string): IElisionBuilder {
    this._p.fontSize = fontSize;
    this._m["fontSize"] = true;
    return this;
  }
}
export function patchElision(base: Elision): IElisionBuilder { return new ElisionBuilder(base); }
export function buildElision(): IElisionBuilder { return new ElisionBuilder(); }

export interface IExtendBuilder {
  build: () => Extend;
  patch: () => any[];
  type: (type: StartStopContinue) => IExtendBuilder;
  _class: (_class: string) => IExtendBuilder;
  defaultX: (defaultX: number) => IExtendBuilder;
  relativeY: (relativeY: number) => IExtendBuilder;
  defaultY: (defaultY: number) => IExtendBuilder;
  relativeX: (relativeX: number) => IExtendBuilder;
}
class ExtendBuilder implements IExtendBuilder{
  _p: Extend = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Extend;
  constructor(toPatch?: Extend) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Extend {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Extend";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  type(type: StartStopContinue): IExtendBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  _class(_class: string): IExtendBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
  defaultX(defaultX: number): IExtendBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IExtendBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IExtendBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IExtendBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchExtend(base: Extend): IExtendBuilder { return new ExtendBuilder(base); }
export function buildExtend(): IExtendBuilder { return new ExtendBuilder(); }

export interface IFiguredBassBuilder {
  build: () => FiguredBass;
  patch: () => any[];
  figures: (figures: Figure[]) => IFiguredBassBuilder;
  duration: (duration: number) => IFiguredBassBuilder;
  parentheses: (parentheses: boolean) => IFiguredBassBuilder;
  footnote: (build: (builder: IFootnoteBuilder) => IFootnoteBuilder) => IFiguredBassBuilder;
  level: (build: (builder: ILevelBuilder) => ILevelBuilder) => IFiguredBassBuilder;
  _class: (_class: string) => IFiguredBassBuilder;
}
class FiguredBassBuilder implements IFiguredBassBuilder{
  _p: FiguredBass = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: FiguredBass;
  constructor(toPatch?: FiguredBass) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["figures"]) || this._b["figures"] !== undefined || this._p.figures !== undefined, "figures is a required field");
  }
  build(): FiguredBass {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "FiguredBass";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  figures(figures: Figure[]): IFiguredBassBuilder {
    this._p.figures = figures;
    this._m["figures"] = true;
    return this;
  }
  duration(duration: number): IFiguredBassBuilder {
    this._p.duration = duration;
    this._m["duration"] = true;
    return this;
  }
  parentheses(parentheses: boolean): IFiguredBassBuilder {
    this._p.parentheses = parentheses;
    this._m["parentheses"] = true;
    return this;
  }
  footnote(build: (builder: IFootnoteBuilder) => IFootnoteBuilder): IFiguredBassBuilder {
    this._b["footnote"] = build(new FootnoteBuilder(this._o && this._o["footnote"]));
    this._m["footnote"] = true;
    return this;
  }
  level(build: (builder: ILevelBuilder) => ILevelBuilder): IFiguredBassBuilder {
    this._b["level"] = build(new LevelBuilder(this._o && this._o["level"]));
    this._m["level"] = true;
    return this;
  }
  _class(_class: string): IFiguredBassBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchFiguredBass(base: FiguredBass): IFiguredBassBuilder { return new FiguredBassBuilder(base); }
export function buildFiguredBass(): IFiguredBassBuilder { return new FiguredBassBuilder(); }

export interface IFigureBuilder {
  build: () => Figure;
  patch: () => any[];
  prefix: (build: (builder: IPrefixBuilder) => IPrefixBuilder) => IFigureBuilder;
  figureNumber: (build: (builder: IFigureNumberBuilder) => IFigureNumberBuilder) => IFigureBuilder;
  extend: (build: (builder: IExtendBuilder) => IExtendBuilder) => IFigureBuilder;
  suffix: (build: (builder: ISuffixBuilder) => ISuffixBuilder) => IFigureBuilder;
  defaultX: (defaultX: number) => IFigureBuilder;
  relativeY: (relativeY: number) => IFigureBuilder;
  defaultY: (defaultY: number) => IFigureBuilder;
  relativeX: (relativeX: number) => IFigureBuilder;
}
class FigureBuilder implements IFigureBuilder{
  _p: Figure = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Figure;
  constructor(toPatch?: Figure) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Figure {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Figure";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  prefix(build: (builder: IPrefixBuilder) => IPrefixBuilder): IFigureBuilder {
    this._b["prefix"] = build(new PrefixBuilder(this._o && this._o["prefix"]));
    this._m["prefix"] = true;
    return this;
  }
  figureNumber(build: (builder: IFigureNumberBuilder) => IFigureNumberBuilder): IFigureBuilder {
    this._b["figureNumber"] = build(new FigureNumberBuilder(this._o && this._o["figureNumber"]));
    this._m["figureNumber"] = true;
    return this;
  }
  extend(build: (builder: IExtendBuilder) => IExtendBuilder): IFigureBuilder {
    this._b["extend"] = build(new ExtendBuilder(this._o && this._o["extend"]));
    this._m["extend"] = true;
    return this;
  }
  suffix(build: (builder: ISuffixBuilder) => ISuffixBuilder): IFigureBuilder {
    this._b["suffix"] = build(new SuffixBuilder(this._o && this._o["suffix"]));
    this._m["suffix"] = true;
    return this;
  }
  defaultX(defaultX: number): IFigureBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IFigureBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IFigureBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IFigureBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchFigure(base: Figure): IFigureBuilder { return new FigureBuilder(base); }
export function buildFigure(): IFigureBuilder { return new FigureBuilder(); }

export interface IPrefixBuilder {
  build: () => Prefix;
  patch: () => any[];
  data: (data: string) => IPrefixBuilder;
  defaultX: (defaultX: number) => IPrefixBuilder;
  relativeY: (relativeY: number) => IPrefixBuilder;
  defaultY: (defaultY: number) => IPrefixBuilder;
  relativeX: (relativeX: number) => IPrefixBuilder;
}
class PrefixBuilder implements IPrefixBuilder{
  _p: Prefix = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Prefix;
  constructor(toPatch?: Prefix) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): Prefix {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Prefix";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IPrefixBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IPrefixBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IPrefixBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IPrefixBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IPrefixBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchPrefix(base: Prefix): IPrefixBuilder { return new PrefixBuilder(base); }
export function buildPrefix(): IPrefixBuilder { return new PrefixBuilder(); }

export interface IFigureNumberBuilder {
  build: () => FigureNumber;
  patch: () => any[];
  data: (data: string) => IFigureNumberBuilder;
  defaultX: (defaultX: number) => IFigureNumberBuilder;
  relativeY: (relativeY: number) => IFigureNumberBuilder;
  defaultY: (defaultY: number) => IFigureNumberBuilder;
  relativeX: (relativeX: number) => IFigureNumberBuilder;
}
class FigureNumberBuilder implements IFigureNumberBuilder{
  _p: FigureNumber = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: FigureNumber;
  constructor(toPatch?: FigureNumber) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): FigureNumber {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "FigureNumber";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IFigureNumberBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IFigureNumberBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IFigureNumberBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IFigureNumberBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IFigureNumberBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchFigureNumber(base: FigureNumber): IFigureNumberBuilder { return new FigureNumberBuilder(base); }
export function buildFigureNumber(): IFigureNumberBuilder { return new FigureNumberBuilder(); }

export interface ISuffixBuilder {
  build: () => Suffix;
  patch: () => any[];
  data: (data: string) => ISuffixBuilder;
  defaultX: (defaultX: number) => ISuffixBuilder;
  relativeY: (relativeY: number) => ISuffixBuilder;
  defaultY: (defaultY: number) => ISuffixBuilder;
  relativeX: (relativeX: number) => ISuffixBuilder;
}
class SuffixBuilder implements ISuffixBuilder{
  _p: Suffix = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Suffix;
  constructor(toPatch?: Suffix) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): Suffix {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Suffix";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): ISuffixBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): ISuffixBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): ISuffixBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): ISuffixBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): ISuffixBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchSuffix(base: Suffix): ISuffixBuilder { return new SuffixBuilder(base); }
export function buildSuffix(): ISuffixBuilder { return new SuffixBuilder(); }

export interface IBackupBuilder {
  build: () => Backup;
  patch: () => any[];
  duration: (duration: number) => IBackupBuilder;
  footnote: (build: (builder: IFootnoteBuilder) => IFootnoteBuilder) => IBackupBuilder;
  level: (build: (builder: ILevelBuilder) => ILevelBuilder) => IBackupBuilder;
  _class: (_class: string) => IBackupBuilder;
}
class BackupBuilder implements IBackupBuilder{
  _p: Backup = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Backup;
  constructor(toPatch?: Backup) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["duration"]) || this._b["duration"] !== undefined || this._p.duration !== undefined, "duration is a required field");
  }
  build(): Backup {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Backup";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  duration(duration: number): IBackupBuilder {
    this._p.duration = duration;
    this._m["duration"] = true;
    return this;
  }
  footnote(build: (builder: IFootnoteBuilder) => IFootnoteBuilder): IBackupBuilder {
    this._b["footnote"] = build(new FootnoteBuilder(this._o && this._o["footnote"]));
    this._m["footnote"] = true;
    return this;
  }
  level(build: (builder: ILevelBuilder) => ILevelBuilder): IBackupBuilder {
    this._b["level"] = build(new LevelBuilder(this._o && this._o["level"]));
    this._m["level"] = true;
    return this;
  }
  _class(_class: string): IBackupBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchBackup(base: Backup): IBackupBuilder { return new BackupBuilder(base); }
export function buildBackup(): IBackupBuilder { return new BackupBuilder(); }

export interface IForwardBuilder {
  build: () => Forward;
  patch: () => any[];
  duration: (duration: number) => IForwardBuilder;
  staff: (staff: number) => IForwardBuilder;
  voice: (voice: number) => IForwardBuilder;
  footnote: (build: (builder: IFootnoteBuilder) => IFootnoteBuilder) => IForwardBuilder;
  level: (build: (builder: ILevelBuilder) => ILevelBuilder) => IForwardBuilder;
  _class: (_class: string) => IForwardBuilder;
}
class ForwardBuilder implements IForwardBuilder{
  _p: Forward = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Forward;
  constructor(toPatch?: Forward) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["duration"]) || this._b["duration"] !== undefined || this._p.duration !== undefined, "duration is a required field");
  }
  build(): Forward {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Forward";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  duration(duration: number): IForwardBuilder {
    this._p.duration = duration;
    this._m["duration"] = true;
    return this;
  }
  staff(staff: number): IForwardBuilder {
    this._p.staff = staff;
    this._m["staff"] = true;
    return this;
  }
  voice(voice: number): IForwardBuilder {
    this._p.voice = voice;
    this._m["voice"] = true;
    return this;
  }
  footnote(build: (builder: IFootnoteBuilder) => IFootnoteBuilder): IForwardBuilder {
    this._b["footnote"] = build(new FootnoteBuilder(this._o && this._o["footnote"]));
    this._m["footnote"] = true;
    return this;
  }
  level(build: (builder: ILevelBuilder) => ILevelBuilder): IForwardBuilder {
    this._b["level"] = build(new LevelBuilder(this._o && this._o["level"]));
    this._m["level"] = true;
    return this;
  }
  _class(_class: string): IForwardBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchForward(base: Forward): IForwardBuilder { return new ForwardBuilder(base); }
export function buildForward(): IForwardBuilder { return new ForwardBuilder(); }

export interface IBarlineBuilder {
  build: () => Barline;
  patch: () => any[];
  segno: (build: (builder: ISegnoBuilder) => ISegnoBuilder) => IBarlineBuilder;
  coda: (build: (builder: ICodaBuilder) => ICodaBuilder) => IBarlineBuilder;
  location: (location: BarlineLocation) => IBarlineBuilder;
  codaAttrib: (codaAttrib: string) => IBarlineBuilder;
  wavyLine: (build: (builder: IWavyLineBuilder) => IWavyLineBuilder) => IBarlineBuilder;
  fermatas: (fermatas: Fermata[]) => IBarlineBuilder;
  segnoAttrib: (segnoAttrib: string) => IBarlineBuilder;
  divisions: (divisions: number) => IBarlineBuilder;
  barStyle: (build: (builder: IBarStyleBuilder) => IBarStyleBuilder) => IBarlineBuilder;
  ending: (build: (builder: IEndingBuilder) => IEndingBuilder) => IBarlineBuilder;
  repeat: (build: (builder: IRepeatBuilder) => IRepeatBuilder) => IBarlineBuilder;
  footnote: (build: (builder: IFootnoteBuilder) => IFootnoteBuilder) => IBarlineBuilder;
  level: (build: (builder: ILevelBuilder) => ILevelBuilder) => IBarlineBuilder;
  _class: (_class: string) => IBarlineBuilder;
}
class BarlineBuilder implements IBarlineBuilder{
  _p: Barline = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Barline;
  constructor(toPatch?: Barline) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["codaAttrib"]) || this._b["codaAttrib"] !== undefined || this._p.codaAttrib !== undefined, "codaAttrib is a required field");
    console.assert((this._o && !this._m["segnoAttrib"]) || this._b["segnoAttrib"] !== undefined || this._p.segnoAttrib !== undefined, "segnoAttrib is a required field");
    console.assert((this._o && !this._m["divisions"]) || this._b["divisions"] !== undefined || this._p.divisions !== undefined, "divisions is a required field");
  }
  build(): Barline {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Barline";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  segno(build: (builder: ISegnoBuilder) => ISegnoBuilder): IBarlineBuilder {
    this._b["segno"] = build(new SegnoBuilder(this._o && this._o["segno"]));
    this._m["segno"] = true;
    return this;
  }
  coda(build: (builder: ICodaBuilder) => ICodaBuilder): IBarlineBuilder {
    this._b["coda"] = build(new CodaBuilder(this._o && this._o["coda"]));
    this._m["coda"] = true;
    return this;
  }
  location(location: BarlineLocation): IBarlineBuilder {
    this._p.location = location;
    this._m["location"] = true;
    return this;
  }
  codaAttrib(codaAttrib: string): IBarlineBuilder {
    this._p.codaAttrib = codaAttrib;
    this._m["codaAttrib"] = true;
    return this;
  }
  wavyLine(build: (builder: IWavyLineBuilder) => IWavyLineBuilder): IBarlineBuilder {
    this._b["wavyLine"] = build(new WavyLineBuilder(this._o && this._o["wavyLine"]));
    this._m["wavyLine"] = true;
    return this;
  }
  fermatas(fermatas: Fermata[]): IBarlineBuilder {
    this._p.fermatas = fermatas;
    this._m["fermatas"] = true;
    return this;
  }
  segnoAttrib(segnoAttrib: string): IBarlineBuilder {
    this._p.segnoAttrib = segnoAttrib;
    this._m["segnoAttrib"] = true;
    return this;
  }
  divisions(divisions: number): IBarlineBuilder {
    this._p.divisions = divisions;
    this._m["divisions"] = true;
    return this;
  }
  barStyle(build: (builder: IBarStyleBuilder) => IBarStyleBuilder): IBarlineBuilder {
    this._b["barStyle"] = build(new BarStyleBuilder(this._o && this._o["barStyle"]));
    this._m["barStyle"] = true;
    return this;
  }
  ending(build: (builder: IEndingBuilder) => IEndingBuilder): IBarlineBuilder {
    this._b["ending"] = build(new EndingBuilder(this._o && this._o["ending"]));
    this._m["ending"] = true;
    return this;
  }
  repeat(build: (builder: IRepeatBuilder) => IRepeatBuilder): IBarlineBuilder {
    this._b["repeat"] = build(new RepeatBuilder(this._o && this._o["repeat"]));
    this._m["repeat"] = true;
    return this;
  }
  footnote(build: (builder: IFootnoteBuilder) => IFootnoteBuilder): IBarlineBuilder {
    this._b["footnote"] = build(new FootnoteBuilder(this._o && this._o["footnote"]));
    this._m["footnote"] = true;
    return this;
  }
  level(build: (builder: ILevelBuilder) => ILevelBuilder): IBarlineBuilder {
    this._b["level"] = build(new LevelBuilder(this._o && this._o["level"]));
    this._m["level"] = true;
    return this;
  }
  _class(_class: string): IBarlineBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchBarline(base: Barline): IBarlineBuilder { return new BarlineBuilder(base); }
export function buildBarline(): IBarlineBuilder { return new BarlineBuilder(); }

export interface IBarStyleBuilder {
  build: () => BarStyle;
  patch: () => any[];
  data: (data: BarStyleType) => IBarStyleBuilder;
  color: (color: string) => IBarStyleBuilder;
}
class BarStyleBuilder implements IBarStyleBuilder{
  _p: BarStyle = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: BarStyle;
  constructor(toPatch?: BarStyle) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): BarStyle {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "BarStyle";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: BarStyleType): IBarStyleBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  color(color: string): IBarStyleBuilder {
    this._p.color = color;
    this._m["color"] = true;
    return this;
  }
}
export function patchBarStyle(base: BarStyle): IBarStyleBuilder { return new BarStyleBuilder(base); }
export function buildBarStyle(): IBarStyleBuilder { return new BarStyleBuilder(); }

export interface IEndingBuilder {
  build: () => Ending;
  patch: () => any[];
  endLength: (endLength: number) => IEndingBuilder;
  textX: (textX: number) => IEndingBuilder;
  number: (number: number) => IEndingBuilder;
  textY: (textY: number) => IEndingBuilder;
  type: (type: StartStopDiscontinue) => IEndingBuilder;
  ending: (ending: string) => IEndingBuilder;
  printObject: (printObject: boolean) => IEndingBuilder;
}
class EndingBuilder implements IEndingBuilder{
  _p: Ending = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Ending;
  constructor(toPatch?: Ending) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["endLength"]) || this._b["endLength"] !== undefined || this._p.endLength !== undefined, "endLength is a required field");
    console.assert((this._o && !this._m["textX"]) || this._b["textX"] !== undefined || this._p.textX !== undefined, "textX is a required field");
    console.assert((this._o && !this._m["number"]) || this._b["number"] !== undefined || this._p.number !== undefined, "number is a required field");
    console.assert((this._o && !this._m["textY"]) || this._b["textY"] !== undefined || this._p.textY !== undefined, "textY is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Ending {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Ending";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  endLength(endLength: number): IEndingBuilder {
    this._p.endLength = endLength;
    this._m["endLength"] = true;
    return this;
  }
  textX(textX: number): IEndingBuilder {
    this._p.textX = textX;
    this._m["textX"] = true;
    return this;
  }
  number(number: number): IEndingBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  textY(textY: number): IEndingBuilder {
    this._p.textY = textY;
    this._m["textY"] = true;
    return this;
  }
  type(type: StartStopDiscontinue): IEndingBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  ending(ending: string): IEndingBuilder {
    this._p.ending = ending;
    this._m["ending"] = true;
    return this;
  }
  printObject(printObject: boolean): IEndingBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchEnding(base: Ending): IEndingBuilder { return new EndingBuilder(base); }
export function buildEnding(): IEndingBuilder { return new EndingBuilder(); }

export interface IRepeatBuilder {
  build: () => Repeat;
  patch: () => any[];
  times: (times: string) => IRepeatBuilder;
  winged: (winged: WingedType) => IRepeatBuilder;
  direction: (direction: DirectionTypeBg) => IRepeatBuilder;
}
class RepeatBuilder implements IRepeatBuilder{
  _p: Repeat = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Repeat;
  constructor(toPatch?: Repeat) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["times"]) || this._b["times"] !== undefined || this._p.times !== undefined, "times is a required field");
    console.assert((this._o && !this._m["winged"]) || this._b["winged"] !== undefined || this._p.winged !== undefined, "winged is a required field");
    console.assert((this._o && !this._m["direction"]) || this._b["direction"] !== undefined || this._p.direction !== undefined, "direction is a required field");
  }
  build(): Repeat {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Repeat";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  times(times: string): IRepeatBuilder {
    this._p.times = times;
    this._m["times"] = true;
    return this;
  }
  winged(winged: WingedType): IRepeatBuilder {
    this._p.winged = winged;
    this._m["winged"] = true;
    return this;
  }
  direction(direction: DirectionTypeBg): IRepeatBuilder {
    this._p.direction = direction;
    this._m["direction"] = true;
    return this;
  }
}
export function patchRepeat(base: Repeat): IRepeatBuilder { return new RepeatBuilder(base); }
export function buildRepeat(): IRepeatBuilder { return new RepeatBuilder(); }

export interface IDirectionBuilder {
  build: () => Direction;
  patch: () => any[];
  directionTypes: (directionTypes: DirectionType[]) => IDirectionBuilder;
  staff: (staff: number) => IDirectionBuilder;
  offset: (build: (builder: IOffsetBuilder) => IOffsetBuilder) => IDirectionBuilder;
  sound: (build: (builder: ISoundBuilder) => ISoundBuilder) => IDirectionBuilder;
  voice: (voice: number) => IDirectionBuilder;
  footnote: (build: (builder: IFootnoteBuilder) => IFootnoteBuilder) => IDirectionBuilder;
  level: (build: (builder: ILevelBuilder) => ILevelBuilder) => IDirectionBuilder;
  _class: (_class: string) => IDirectionBuilder;
}
class DirectionBuilder implements IDirectionBuilder{
  _p: Direction = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Direction;
  constructor(toPatch?: Direction) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["directionTypes"]) || this._b["directionTypes"] !== undefined || this._p.directionTypes !== undefined, "directionTypes is a required field");
  }
  build(): Direction {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Direction";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  directionTypes(directionTypes: DirectionType[]): IDirectionBuilder {
    this._p.directionTypes = directionTypes;
    this._m["directionTypes"] = true;
    return this;
  }
  staff(staff: number): IDirectionBuilder {
    this._p.staff = staff;
    this._m["staff"] = true;
    return this;
  }
  offset(build: (builder: IOffsetBuilder) => IOffsetBuilder): IDirectionBuilder {
    this._b["offset"] = build(new OffsetBuilder(this._o && this._o["offset"]));
    this._m["offset"] = true;
    return this;
  }
  sound(build: (builder: ISoundBuilder) => ISoundBuilder): IDirectionBuilder {
    this._b["sound"] = build(new SoundBuilder(this._o && this._o["sound"]));
    this._m["sound"] = true;
    return this;
  }
  voice(voice: number): IDirectionBuilder {
    this._p.voice = voice;
    this._m["voice"] = true;
    return this;
  }
  footnote(build: (builder: IFootnoteBuilder) => IFootnoteBuilder): IDirectionBuilder {
    this._b["footnote"] = build(new FootnoteBuilder(this._o && this._o["footnote"]));
    this._m["footnote"] = true;
    return this;
  }
  level(build: (builder: ILevelBuilder) => ILevelBuilder): IDirectionBuilder {
    this._b["level"] = build(new LevelBuilder(this._o && this._o["level"]));
    this._m["level"] = true;
    return this;
  }
  _class(_class: string): IDirectionBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchDirection(base: Direction): IDirectionBuilder { return new DirectionBuilder(base); }
export function buildDirection(): IDirectionBuilder { return new DirectionBuilder(); }

export interface IDirectionTypeBuilder {
  build: () => DirectionType;
  patch: () => any[];
  percussions: (percussions: Percussion[]) => IDirectionTypeBuilder;
  rehearsals: (rehearsals: Rehearsal[]) => IDirectionTypeBuilder;
  pedal: (build: (builder: IPedalBuilder) => IPedalBuilder) => IDirectionTypeBuilder;
  principalVoice: (build: (builder: IPrincipalVoiceBuilder) => IPrincipalVoiceBuilder) => IDirectionTypeBuilder;
  accordionRegistration: (build: (builder: IAccordionRegistrationBuilder) => IAccordionRegistrationBuilder) => IDirectionTypeBuilder;
  eyeglasses: (build: (builder: IEyeglassesBuilder) => IEyeglassesBuilder) => IDirectionTypeBuilder;
  image: (build: (builder: IImageBuilder) => IImageBuilder) => IDirectionTypeBuilder;
  harpPedals: (build: (builder: IHarpPedalsBuilder) => IHarpPedalsBuilder) => IDirectionTypeBuilder;
  metronome: (build: (builder: IMetronomeBuilder) => IMetronomeBuilder) => IDirectionTypeBuilder;
  otherDirection: (build: (builder: IOtherDirectionBuilder) => IOtherDirectionBuilder) => IDirectionTypeBuilder;
  segnos: (segnos: Segno[]) => IDirectionTypeBuilder;
  scordatura: (build: (builder: IScordaturaBuilder) => IScordaturaBuilder) => IDirectionTypeBuilder;
  stringMute: (build: (builder: IStringMuteBuilder) => IStringMuteBuilder) => IDirectionTypeBuilder;
  wedge: (build: (builder: IWedgeBuilder) => IWedgeBuilder) => IDirectionTypeBuilder;
  dashes: (build: (builder: IDashesBuilder) => IDashesBuilder) => IDirectionTypeBuilder;
  damp: (build: (builder: IDampBuilder) => IDampBuilder) => IDirectionTypeBuilder;
  bracket: (build: (builder: IBracketBuilder) => IBracketBuilder) => IDirectionTypeBuilder;
  dynamics: (build: (builder: IDynamicsBuilder) => IDynamicsBuilder) => IDirectionTypeBuilder;
  octaveShift: (build: (builder: IOctaveShiftBuilder) => IOctaveShiftBuilder) => IDirectionTypeBuilder;
  words: (words: Words[]) => IDirectionTypeBuilder;
  dampAll: (build: (builder: IDampAllBuilder) => IDampAllBuilder) => IDirectionTypeBuilder;
  codas: (codas: Coda[]) => IDirectionTypeBuilder;
}
class DirectionTypeBuilder implements IDirectionTypeBuilder{
  _p: DirectionType = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: DirectionType;
  constructor(toPatch?: DirectionType) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["percussions"]) || this._b["percussions"] !== undefined || this._p.percussions !== undefined, "percussions is a required field");
    console.assert((this._o && !this._m["rehearsals"]) || this._b["rehearsals"] !== undefined || this._p.rehearsals !== undefined, "rehearsals is a required field");
    console.assert((this._o && !this._m["pedal"]) || this._b["pedal"] !== undefined || this._p.pedal !== undefined, "pedal is a required field");
    console.assert((this._o && !this._m["principalVoice"]) || this._b["principalVoice"] !== undefined || this._p.principalVoice !== undefined, "principalVoice is a required field");
    console.assert((this._o && !this._m["accordionRegistration"]) || this._b["accordionRegistration"] !== undefined || this._p.accordionRegistration !== undefined, "accordionRegistration is a required field");
    console.assert((this._o && !this._m["eyeglasses"]) || this._b["eyeglasses"] !== undefined || this._p.eyeglasses !== undefined, "eyeglasses is a required field");
    console.assert((this._o && !this._m["image"]) || this._b["image"] !== undefined || this._p.image !== undefined, "image is a required field");
    console.assert((this._o && !this._m["harpPedals"]) || this._b["harpPedals"] !== undefined || this._p.harpPedals !== undefined, "harpPedals is a required field");
    console.assert((this._o && !this._m["metronome"]) || this._b["metronome"] !== undefined || this._p.metronome !== undefined, "metronome is a required field");
    console.assert((this._o && !this._m["otherDirection"]) || this._b["otherDirection"] !== undefined || this._p.otherDirection !== undefined, "otherDirection is a required field");
    console.assert((this._o && !this._m["segnos"]) || this._b["segnos"] !== undefined || this._p.segnos !== undefined, "segnos is a required field");
    console.assert((this._o && !this._m["scordatura"]) || this._b["scordatura"] !== undefined || this._p.scordatura !== undefined, "scordatura is a required field");
    console.assert((this._o && !this._m["stringMute"]) || this._b["stringMute"] !== undefined || this._p.stringMute !== undefined, "stringMute is a required field");
    console.assert((this._o && !this._m["damp"]) || this._b["damp"] !== undefined || this._p.damp !== undefined, "damp is a required field");
    console.assert((this._o && !this._m["bracket"]) || this._b["bracket"] !== undefined || this._p.bracket !== undefined, "bracket is a required field");
    console.assert((this._o && !this._m["octaveShift"]) || this._b["octaveShift"] !== undefined || this._p.octaveShift !== undefined, "octaveShift is a required field");
    console.assert((this._o && !this._m["words"]) || this._b["words"] !== undefined || this._p.words !== undefined, "words is a required field");
    console.assert((this._o && !this._m["dampAll"]) || this._b["dampAll"] !== undefined || this._p.dampAll !== undefined, "dampAll is a required field");
    console.assert((this._o && !this._m["codas"]) || this._b["codas"] !== undefined || this._p.codas !== undefined, "codas is a required field");
  }
  build(): DirectionType {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "DirectionType";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  percussions(percussions: Percussion[]): IDirectionTypeBuilder {
    this._p.percussions = percussions;
    this._m["percussions"] = true;
    return this;
  }
  rehearsals(rehearsals: Rehearsal[]): IDirectionTypeBuilder {
    this._p.rehearsals = rehearsals;
    this._m["rehearsals"] = true;
    return this;
  }
  pedal(build: (builder: IPedalBuilder) => IPedalBuilder): IDirectionTypeBuilder {
    this._b["pedal"] = build(new PedalBuilder(this._o && this._o["pedal"]));
    this._m["pedal"] = true;
    return this;
  }
  principalVoice(build: (builder: IPrincipalVoiceBuilder) => IPrincipalVoiceBuilder): IDirectionTypeBuilder {
    this._b["principalVoice"] = build(new PrincipalVoiceBuilder(this._o && this._o["principalVoice"]));
    this._m["principalVoice"] = true;
    return this;
  }
  accordionRegistration(build: (builder: IAccordionRegistrationBuilder) => IAccordionRegistrationBuilder): IDirectionTypeBuilder {
    this._b["accordionRegistration"] = build(new AccordionRegistrationBuilder(this._o && this._o["accordionRegistration"]));
    this._m["accordionRegistration"] = true;
    return this;
  }
  eyeglasses(build: (builder: IEyeglassesBuilder) => IEyeglassesBuilder): IDirectionTypeBuilder {
    this._b["eyeglasses"] = build(new EyeglassesBuilder(this._o && this._o["eyeglasses"]));
    this._m["eyeglasses"] = true;
    return this;
  }
  image(build: (builder: IImageBuilder) => IImageBuilder): IDirectionTypeBuilder {
    this._b["image"] = build(new ImageBuilder(this._o && this._o["image"]));
    this._m["image"] = true;
    return this;
  }
  harpPedals(build: (builder: IHarpPedalsBuilder) => IHarpPedalsBuilder): IDirectionTypeBuilder {
    this._b["harpPedals"] = build(new HarpPedalsBuilder(this._o && this._o["harpPedals"]));
    this._m["harpPedals"] = true;
    return this;
  }
  metronome(build: (builder: IMetronomeBuilder) => IMetronomeBuilder): IDirectionTypeBuilder {
    this._b["metronome"] = build(new MetronomeBuilder(this._o && this._o["metronome"]));
    this._m["metronome"] = true;
    return this;
  }
  otherDirection(build: (builder: IOtherDirectionBuilder) => IOtherDirectionBuilder): IDirectionTypeBuilder {
    this._b["otherDirection"] = build(new OtherDirectionBuilder(this._o && this._o["otherDirection"]));
    this._m["otherDirection"] = true;
    return this;
  }
  segnos(segnos: Segno[]): IDirectionTypeBuilder {
    this._p.segnos = segnos;
    this._m["segnos"] = true;
    return this;
  }
  scordatura(build: (builder: IScordaturaBuilder) => IScordaturaBuilder): IDirectionTypeBuilder {
    this._b["scordatura"] = build(new ScordaturaBuilder(this._o && this._o["scordatura"]));
    this._m["scordatura"] = true;
    return this;
  }
  stringMute(build: (builder: IStringMuteBuilder) => IStringMuteBuilder): IDirectionTypeBuilder {
    this._b["stringMute"] = build(new StringMuteBuilder(this._o && this._o["stringMute"]));
    this._m["stringMute"] = true;
    return this;
  }
  wedge(build: (builder: IWedgeBuilder) => IWedgeBuilder): IDirectionTypeBuilder {
    this._b["wedge"] = build(new WedgeBuilder(this._o && this._o["wedge"]));
    this._m["wedge"] = true;
    return this;
  }
  dashes(build: (builder: IDashesBuilder) => IDashesBuilder): IDirectionTypeBuilder {
    this._b["dashes"] = build(new DashesBuilder(this._o && this._o["dashes"]));
    this._m["dashes"] = true;
    return this;
  }
  damp(build: (builder: IDampBuilder) => IDampBuilder): IDirectionTypeBuilder {
    this._b["damp"] = build(new DampBuilder(this._o && this._o["damp"]));
    this._m["damp"] = true;
    return this;
  }
  bracket(build: (builder: IBracketBuilder) => IBracketBuilder): IDirectionTypeBuilder {
    this._b["bracket"] = build(new BracketBuilder(this._o && this._o["bracket"]));
    this._m["bracket"] = true;
    return this;
  }
  dynamics(build: (builder: IDynamicsBuilder) => IDynamicsBuilder): IDirectionTypeBuilder {
    this._b["dynamics"] = build(new DynamicsBuilder(this._o && this._o["dynamics"]));
    this._m["dynamics"] = true;
    return this;
  }
  octaveShift(build: (builder: IOctaveShiftBuilder) => IOctaveShiftBuilder): IDirectionTypeBuilder {
    this._b["octaveShift"] = build(new OctaveShiftBuilder(this._o && this._o["octaveShift"]));
    this._m["octaveShift"] = true;
    return this;
  }
  words(words: Words[]): IDirectionTypeBuilder {
    this._p.words = words;
    this._m["words"] = true;
    return this;
  }
  dampAll(build: (builder: IDampAllBuilder) => IDampAllBuilder): IDirectionTypeBuilder {
    this._b["dampAll"] = build(new DampAllBuilder(this._o && this._o["dampAll"]));
    this._m["dampAll"] = true;
    return this;
  }
  codas(codas: Coda[]): IDirectionTypeBuilder {
    this._p.codas = codas;
    this._m["codas"] = true;
    return this;
  }
}
export function patchDirectionType(base: DirectionType): IDirectionTypeBuilder { return new DirectionTypeBuilder(base); }
export function buildDirectionType(): IDirectionTypeBuilder { return new DirectionTypeBuilder(); }

export interface IRehearsalBuilder {
  build: () => Rehearsal;
  patch: () => any[];
  data: (data: string) => IRehearsalBuilder;
  justify: (justify: LeftCenterRight) => IRehearsalBuilder;
}
class RehearsalBuilder implements IRehearsalBuilder{
  _p: Rehearsal = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Rehearsal;
  constructor(toPatch?: Rehearsal) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): Rehearsal {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Rehearsal";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IRehearsalBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  justify(justify: LeftCenterRight): IRehearsalBuilder {
    this._p.justify = justify;
    this._m["justify"] = true;
    return this;
  }
}
export function patchRehearsal(base: Rehearsal): IRehearsalBuilder { return new RehearsalBuilder(base); }
export function buildRehearsal(): IRehearsalBuilder { return new RehearsalBuilder(); }

export interface IWordsBuilder {
  build: () => Words;
  patch: () => any[];
  data: (data: string) => IWordsBuilder;
  justify: (justify: LeftCenterRight) => IWordsBuilder;
}
class WordsBuilder implements IWordsBuilder{
  _p: Words = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Words;
  constructor(toPatch?: Words) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): Words {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Words";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IWordsBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  justify(justify: LeftCenterRight): IWordsBuilder {
    this._p.justify = justify;
    this._m["justify"] = true;
    return this;
  }
}
export function patchWords(base: Words): IWordsBuilder { return new WordsBuilder(base); }
export function buildWords(): IWordsBuilder { return new WordsBuilder(); }

export interface IWedgeBuilder {
  build: () => Wedge;
  patch: () => any[];
  number: (number: number) => IWedgeBuilder;
  niente: (niente: boolean) => IWedgeBuilder;
  type: (type: WedgeType) => IWedgeBuilder;
  spread: (spread: number) => IWedgeBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IWedgeBuilder;
}
class WedgeBuilder implements IWedgeBuilder{
  _p: Wedge = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Wedge;
  constructor(toPatch?: Wedge) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["number"]) || this._b["number"] !== undefined || this._p.number !== undefined, "number is a required field");
    console.assert((this._o && !this._m["niente"]) || this._b["niente"] !== undefined || this._p.niente !== undefined, "niente is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
    console.assert((this._o && !this._m["spread"]) || this._b["spread"] !== undefined || this._p.spread !== undefined, "spread is a required field");
  }
  build(): Wedge {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Wedge";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: number): IWedgeBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  niente(niente: boolean): IWedgeBuilder {
    this._p.niente = niente;
    this._m["niente"] = true;
    return this;
  }
  type(type: WedgeType): IWedgeBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  spread(spread: number): IWedgeBuilder {
    this._p.spread = spread;
    this._m["spread"] = true;
    return this;
  }
  lineType(lineType: SolidDashedDottedWavy): IWedgeBuilder {
    this._p.lineType = lineType;
    this._m["lineType"] = true;
    return this;
  }
}
export function patchWedge(base: Wedge): IWedgeBuilder { return new WedgeBuilder(base); }
export function buildWedge(): IWedgeBuilder { return new WedgeBuilder(); }

export interface IDashesBuilder {
  build: () => Dashes;
  patch: () => any[];
  number: (number: number) => IDashesBuilder;
  type: (type: StartStopContinue) => IDashesBuilder;
  dashLength: (dashLength: number) => IDashesBuilder;
  spaceLength: (spaceLength: number) => IDashesBuilder;
}
class DashesBuilder implements IDashesBuilder{
  _p: Dashes = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Dashes;
  constructor(toPatch?: Dashes) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["number"]) || this._b["number"] !== undefined || this._p.number !== undefined, "number is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Dashes {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Dashes";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: number): IDashesBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  type(type: StartStopContinue): IDashesBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  dashLength(dashLength: number): IDashesBuilder {
    this._p.dashLength = dashLength;
    this._m["dashLength"] = true;
    return this;
  }
  spaceLength(spaceLength: number): IDashesBuilder {
    this._p.spaceLength = spaceLength;
    this._m["spaceLength"] = true;
    return this;
  }
}
export function patchDashes(base: Dashes): IDashesBuilder { return new DashesBuilder(base); }
export function buildDashes(): IDashesBuilder { return new DashesBuilder(); }

export interface IBracketBuilder {
  build: () => Bracket;
  patch: () => any[];
  endLength: (endLength: number) => IBracketBuilder;
  number: (number: number) => IBracketBuilder;
  type: (type: StartStopContinue) => IBracketBuilder;
  lineEnd: (lineEnd: LineEndType) => IBracketBuilder;
  lineType: (lineType: SolidDashedDottedWavy) => IBracketBuilder;
}
class BracketBuilder implements IBracketBuilder{
  _p: Bracket = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Bracket;
  constructor(toPatch?: Bracket) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["endLength"]) || this._b["endLength"] !== undefined || this._p.endLength !== undefined, "endLength is a required field");
    console.assert((this._o && !this._m["number"]) || this._b["number"] !== undefined || this._p.number !== undefined, "number is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
    console.assert((this._o && !this._m["lineEnd"]) || this._b["lineEnd"] !== undefined || this._p.lineEnd !== undefined, "lineEnd is a required field");
  }
  build(): Bracket {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Bracket";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  endLength(endLength: number): IBracketBuilder {
    this._p.endLength = endLength;
    this._m["endLength"] = true;
    return this;
  }
  number(number: number): IBracketBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  type(type: StartStopContinue): IBracketBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  lineEnd(lineEnd: LineEndType): IBracketBuilder {
    this._p.lineEnd = lineEnd;
    this._m["lineEnd"] = true;
    return this;
  }
  lineType(lineType: SolidDashedDottedWavy): IBracketBuilder {
    this._p.lineType = lineType;
    this._m["lineType"] = true;
    return this;
  }
}
export function patchBracket(base: Bracket): IBracketBuilder { return new BracketBuilder(base); }
export function buildBracket(): IBracketBuilder { return new BracketBuilder(); }

export interface IPedalBuilder {
  build: () => Pedal;
  patch: () => any[];
  line: (line: boolean) => IPedalBuilder;
  sign: (sign: boolean) => IPedalBuilder;
  type: (type: PedalType) => IPedalBuilder;
  defaultX: (defaultX: number) => IPedalBuilder;
  relativeY: (relativeY: number) => IPedalBuilder;
  defaultY: (defaultY: number) => IPedalBuilder;
  relativeX: (relativeX: number) => IPedalBuilder;
}
class PedalBuilder implements IPedalBuilder{
  _p: Pedal = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Pedal;
  constructor(toPatch?: Pedal) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["line"]) || this._b["line"] !== undefined || this._p.line !== undefined, "line is a required field");
    console.assert((this._o && !this._m["sign"]) || this._b["sign"] !== undefined || this._p.sign !== undefined, "sign is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Pedal {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Pedal";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  line(line: boolean): IPedalBuilder {
    this._p.line = line;
    this._m["line"] = true;
    return this;
  }
  sign(sign: boolean): IPedalBuilder {
    this._p.sign = sign;
    this._m["sign"] = true;
    return this;
  }
  type(type: PedalType): IPedalBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  defaultX(defaultX: number): IPedalBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IPedalBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IPedalBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IPedalBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchPedal(base: Pedal): IPedalBuilder { return new PedalBuilder(base); }
export function buildPedal(): IPedalBuilder { return new PedalBuilder(); }

export interface IMetronomeBuilder {
  build: () => Metronome;
  patch: () => any[];
  metronomeNotes: (metronomeNotes: MetronomeNote[]) => IMetronomeBuilder;
  perMinute: (build: (builder: IPerMinuteBuilder) => IPerMinuteBuilder) => IMetronomeBuilder;
  parentheses: (parentheses: boolean) => IMetronomeBuilder;
  beatUnit: (beatUnit: string) => IMetronomeBuilder;
  beatUnitDots: (beatUnitDots: BeatUnitDot[]) => IMetronomeBuilder;
  beatUnitChange: (beatUnitChange: string) => IMetronomeBuilder;
  beatUnitDotsChange: (beatUnitDotsChange: BeatUnitDot[]) => IMetronomeBuilder;
  metronomeRelation: (metronomeRelation: string) => IMetronomeBuilder;
  defaultX: (defaultX: number) => IMetronomeBuilder;
  relativeY: (relativeY: number) => IMetronomeBuilder;
  defaultY: (defaultY: number) => IMetronomeBuilder;
  relativeX: (relativeX: number) => IMetronomeBuilder;
}
class MetronomeBuilder implements IMetronomeBuilder{
  _p: Metronome = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Metronome;
  constructor(toPatch?: Metronome) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["metronomeNotes"]) || this._b["metronomeNotes"] !== undefined || this._p.metronomeNotes !== undefined, "metronomeNotes is a required field");
    console.assert((this._o && !this._m["perMinute"]) || this._b["perMinute"] !== undefined || this._p.perMinute !== undefined, "perMinute is a required field");
    console.assert((this._o && !this._m["parentheses"]) || this._b["parentheses"] !== undefined || this._p.parentheses !== undefined, "parentheses is a required field");
    console.assert((this._o && !this._m["beatUnit"]) || this._b["beatUnit"] !== undefined || this._p.beatUnit !== undefined, "beatUnit is a required field");
    console.assert((this._o && !this._m["beatUnitDots"]) || this._b["beatUnitDots"] !== undefined || this._p.beatUnitDots !== undefined, "beatUnitDots is a required field");
    console.assert((this._o && !this._m["beatUnitChange"]) || this._b["beatUnitChange"] !== undefined || this._p.beatUnitChange !== undefined, "beatUnitChange is a required field");
    console.assert((this._o && !this._m["beatUnitDotsChange"]) || this._b["beatUnitDotsChange"] !== undefined || this._p.beatUnitDotsChange !== undefined, "beatUnitDotsChange is a required field");
    console.assert((this._o && !this._m["metronomeRelation"]) || this._b["metronomeRelation"] !== undefined || this._p.metronomeRelation !== undefined, "metronomeRelation is a required field");
  }
  build(): Metronome {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Metronome";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  metronomeNotes(metronomeNotes: MetronomeNote[]): IMetronomeBuilder {
    this._p.metronomeNotes = metronomeNotes;
    this._m["metronomeNotes"] = true;
    return this;
  }
  perMinute(build: (builder: IPerMinuteBuilder) => IPerMinuteBuilder): IMetronomeBuilder {
    this._b["perMinute"] = build(new PerMinuteBuilder(this._o && this._o["perMinute"]));
    this._m["perMinute"] = true;
    return this;
  }
  parentheses(parentheses: boolean): IMetronomeBuilder {
    this._p.parentheses = parentheses;
    this._m["parentheses"] = true;
    return this;
  }
  beatUnit(beatUnit: string): IMetronomeBuilder {
    this._p.beatUnit = beatUnit;
    this._m["beatUnit"] = true;
    return this;
  }
  beatUnitDots(beatUnitDots: BeatUnitDot[]): IMetronomeBuilder {
    this._p.beatUnitDots = beatUnitDots;
    this._m["beatUnitDots"] = true;
    return this;
  }
  beatUnitChange(beatUnitChange: string): IMetronomeBuilder {
    this._p.beatUnitChange = beatUnitChange;
    this._m["beatUnitChange"] = true;
    return this;
  }
  beatUnitDotsChange(beatUnitDotsChange: BeatUnitDot[]): IMetronomeBuilder {
    this._p.beatUnitDotsChange = beatUnitDotsChange;
    this._m["beatUnitDotsChange"] = true;
    return this;
  }
  metronomeRelation(metronomeRelation: string): IMetronomeBuilder {
    this._p.metronomeRelation = metronomeRelation;
    this._m["metronomeRelation"] = true;
    return this;
  }
  defaultX(defaultX: number): IMetronomeBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IMetronomeBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IMetronomeBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IMetronomeBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchMetronome(base: Metronome): IMetronomeBuilder { return new MetronomeBuilder(base); }
export function buildMetronome(): IMetronomeBuilder { return new MetronomeBuilder(); }

export interface IBeatUnitDotBuilder {
  build: () => BeatUnitDot;
  patch: () => any[];
}
class BeatUnitDotBuilder implements IBeatUnitDotBuilder{
  _p: BeatUnitDot = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: BeatUnitDot;
  constructor(toPatch?: BeatUnitDot) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): BeatUnitDot {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "BeatUnitDot";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
}
export function patchBeatUnitDot(base: BeatUnitDot): IBeatUnitDotBuilder { return new BeatUnitDotBuilder(base); }
export function buildBeatUnitDot(): IBeatUnitDotBuilder { return new BeatUnitDotBuilder(); }

export interface IPerMinuteBuilder {
  build: () => PerMinute;
  patch: () => any[];
  data: (data: string) => IPerMinuteBuilder;
  fontFamily: (fontFamily: string) => IPerMinuteBuilder;
  fontWeight: (fontWeight: NormalBold) => IPerMinuteBuilder;
  fontStyle: (fontStyle: NormalItalic) => IPerMinuteBuilder;
  fontSize: (fontSize: string) => IPerMinuteBuilder;
}
class PerMinuteBuilder implements IPerMinuteBuilder{
  _p: PerMinute = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PerMinute;
  constructor(toPatch?: PerMinute) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): PerMinute {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PerMinute";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IPerMinuteBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  fontFamily(fontFamily: string): IPerMinuteBuilder {
    this._p.fontFamily = fontFamily;
    this._m["fontFamily"] = true;
    return this;
  }
  fontWeight(fontWeight: NormalBold): IPerMinuteBuilder {
    this._p.fontWeight = fontWeight;
    this._m["fontWeight"] = true;
    return this;
  }
  fontStyle(fontStyle: NormalItalic): IPerMinuteBuilder {
    this._p.fontStyle = fontStyle;
    this._m["fontStyle"] = true;
    return this;
  }
  fontSize(fontSize: string): IPerMinuteBuilder {
    this._p.fontSize = fontSize;
    this._m["fontSize"] = true;
    return this;
  }
}
export function patchPerMinute(base: PerMinute): IPerMinuteBuilder { return new PerMinuteBuilder(base); }
export function buildPerMinute(): IPerMinuteBuilder { return new PerMinuteBuilder(); }

export interface IMetronomeNoteBuilder {
  build: () => MetronomeNote;
  patch: () => any[];
  metronomeDots: (metronomeDots: MetronomeDot[]) => IMetronomeNoteBuilder;
  metronomeBeams: (metronomeBeams: MetronomeBeam[]) => IMetronomeNoteBuilder;
  metronomeType: (metronomeType: string) => IMetronomeNoteBuilder;
  metronomeTuplet: (build: (builder: IMetronomeTupletBuilder) => IMetronomeTupletBuilder) => IMetronomeNoteBuilder;
}
class MetronomeNoteBuilder implements IMetronomeNoteBuilder{
  _p: MetronomeNote = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: MetronomeNote;
  constructor(toPatch?: MetronomeNote) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["metronomeDots"]) || this._b["metronomeDots"] !== undefined || this._p.metronomeDots !== undefined, "metronomeDots is a required field");
    console.assert((this._o && !this._m["metronomeBeams"]) || this._b["metronomeBeams"] !== undefined || this._p.metronomeBeams !== undefined, "metronomeBeams is a required field");
    console.assert((this._o && !this._m["metronomeType"]) || this._b["metronomeType"] !== undefined || this._p.metronomeType !== undefined, "metronomeType is a required field");
    console.assert((this._o && !this._m["metronomeTuplet"]) || this._b["metronomeTuplet"] !== undefined || this._p.metronomeTuplet !== undefined, "metronomeTuplet is a required field");
  }
  build(): MetronomeNote {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "MetronomeNote";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  metronomeDots(metronomeDots: MetronomeDot[]): IMetronomeNoteBuilder {
    this._p.metronomeDots = metronomeDots;
    this._m["metronomeDots"] = true;
    return this;
  }
  metronomeBeams(metronomeBeams: MetronomeBeam[]): IMetronomeNoteBuilder {
    this._p.metronomeBeams = metronomeBeams;
    this._m["metronomeBeams"] = true;
    return this;
  }
  metronomeType(metronomeType: string): IMetronomeNoteBuilder {
    this._p.metronomeType = metronomeType;
    this._m["metronomeType"] = true;
    return this;
  }
  metronomeTuplet(build: (builder: IMetronomeTupletBuilder) => IMetronomeTupletBuilder): IMetronomeNoteBuilder {
    this._b["metronomeTuplet"] = build(new MetronomeTupletBuilder(this._o && this._o["metronomeTuplet"]));
    this._m["metronomeTuplet"] = true;
    return this;
  }
}
export function patchMetronomeNote(base: MetronomeNote): IMetronomeNoteBuilder { return new MetronomeNoteBuilder(base); }
export function buildMetronomeNote(): IMetronomeNoteBuilder { return new MetronomeNoteBuilder(); }

export interface IMetronomeDotBuilder {
  build: () => MetronomeDot;
  patch: () => any[];
}
class MetronomeDotBuilder implements IMetronomeDotBuilder{
  _p: MetronomeDot = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: MetronomeDot;
  constructor(toPatch?: MetronomeDot) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): MetronomeDot {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "MetronomeDot";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
}
export function patchMetronomeDot(base: MetronomeDot): IMetronomeDotBuilder { return new MetronomeDotBuilder(base); }
export function buildMetronomeDot(): IMetronomeDotBuilder { return new MetronomeDotBuilder(); }

export interface IMetronomeBeamBuilder {
  build: () => MetronomeBeam;
  patch: () => any[];
  number: (number: number) => IMetronomeBeamBuilder;
  data: (data: string) => IMetronomeBeamBuilder;
}
class MetronomeBeamBuilder implements IMetronomeBeamBuilder{
  _p: MetronomeBeam = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: MetronomeBeam;
  constructor(toPatch?: MetronomeBeam) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["number"]) || this._b["number"] !== undefined || this._p.number !== undefined, "number is a required field");
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): MetronomeBeam {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "MetronomeBeam";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: number): IMetronomeBeamBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  data(data: string): IMetronomeBeamBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
}
export function patchMetronomeBeam(base: MetronomeBeam): IMetronomeBeamBuilder { return new MetronomeBeamBuilder(base); }
export function buildMetronomeBeam(): IMetronomeBeamBuilder { return new MetronomeBeamBuilder(); }

export interface IMetronomeTupletBuilder {
  build: () => MetronomeTuplet;
  patch: () => any[];
  actualNotes: (actualNotes: number) => IMetronomeTupletBuilder;
  bracket: (bracket: boolean) => IMetronomeTupletBuilder;
  showNumber: (showNumber: ActualBothNone) => IMetronomeTupletBuilder;
  normalType: (normalType: string) => IMetronomeTupletBuilder;
  type: (type: StartStop) => IMetronomeTupletBuilder;
  normalNotes: (normalNotes: number) => IMetronomeTupletBuilder;
  normalDots: (normalDots: NormalDot[]) => IMetronomeTupletBuilder;
}
class MetronomeTupletBuilder implements IMetronomeTupletBuilder{
  _p: MetronomeTuplet = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: MetronomeTuplet;
  constructor(toPatch?: MetronomeTuplet) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["actualNotes"]) || this._b["actualNotes"] !== undefined || this._p.actualNotes !== undefined, "actualNotes is a required field");
    console.assert((this._o && !this._m["bracket"]) || this._b["bracket"] !== undefined || this._p.bracket !== undefined, "bracket is a required field");
    console.assert((this._o && !this._m["showNumber"]) || this._b["showNumber"] !== undefined || this._p.showNumber !== undefined, "showNumber is a required field");
    console.assert((this._o && !this._m["normalType"]) || this._b["normalType"] !== undefined || this._p.normalType !== undefined, "normalType is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
    console.assert((this._o && !this._m["normalNotes"]) || this._b["normalNotes"] !== undefined || this._p.normalNotes !== undefined, "normalNotes is a required field");
    console.assert((this._o && !this._m["normalDots"]) || this._b["normalDots"] !== undefined || this._p.normalDots !== undefined, "normalDots is a required field");
  }
  build(): MetronomeTuplet {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "MetronomeTuplet";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  actualNotes(actualNotes: number): IMetronomeTupletBuilder {
    this._p.actualNotes = actualNotes;
    this._m["actualNotes"] = true;
    return this;
  }
  bracket(bracket: boolean): IMetronomeTupletBuilder {
    this._p.bracket = bracket;
    this._m["bracket"] = true;
    return this;
  }
  showNumber(showNumber: ActualBothNone): IMetronomeTupletBuilder {
    this._p.showNumber = showNumber;
    this._m["showNumber"] = true;
    return this;
  }
  normalType(normalType: string): IMetronomeTupletBuilder {
    this._p.normalType = normalType;
    this._m["normalType"] = true;
    return this;
  }
  type(type: StartStop): IMetronomeTupletBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  normalNotes(normalNotes: number): IMetronomeTupletBuilder {
    this._p.normalNotes = normalNotes;
    this._m["normalNotes"] = true;
    return this;
  }
  normalDots(normalDots: NormalDot[]): IMetronomeTupletBuilder {
    this._p.normalDots = normalDots;
    this._m["normalDots"] = true;
    return this;
  }
}
export function patchMetronomeTuplet(base: MetronomeTuplet): IMetronomeTupletBuilder { return new MetronomeTupletBuilder(base); }
export function buildMetronomeTuplet(): IMetronomeTupletBuilder { return new MetronomeTupletBuilder(); }

export interface IOctaveShiftBuilder {
  build: () => OctaveShift;
  patch: () => any[];
  number: (number: number) => IOctaveShiftBuilder;
  size: (size: number) => IOctaveShiftBuilder;
  type: (type: OctaveShiftType) => IOctaveShiftBuilder;
  dashLength: (dashLength: number) => IOctaveShiftBuilder;
  spaceLength: (spaceLength: number) => IOctaveShiftBuilder;
}
class OctaveShiftBuilder implements IOctaveShiftBuilder{
  _p: OctaveShift = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: OctaveShift;
  constructor(toPatch?: OctaveShift) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["number"]) || this._b["number"] !== undefined || this._p.number !== undefined, "number is a required field");
    console.assert((this._o && !this._m["size"]) || this._b["size"] !== undefined || this._p.size !== undefined, "size is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): OctaveShift {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "OctaveShift";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: number): IOctaveShiftBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  size(size: number): IOctaveShiftBuilder {
    this._p.size = size;
    this._m["size"] = true;
    return this;
  }
  type(type: OctaveShiftType): IOctaveShiftBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  dashLength(dashLength: number): IOctaveShiftBuilder {
    this._p.dashLength = dashLength;
    this._m["dashLength"] = true;
    return this;
  }
  spaceLength(spaceLength: number): IOctaveShiftBuilder {
    this._p.spaceLength = spaceLength;
    this._m["spaceLength"] = true;
    return this;
  }
}
export function patchOctaveShift(base: OctaveShift): IOctaveShiftBuilder { return new OctaveShiftBuilder(base); }
export function buildOctaveShift(): IOctaveShiftBuilder { return new OctaveShiftBuilder(); }

export interface IHarpPedalsBuilder {
  build: () => HarpPedals;
  patch: () => any[];
  pedalTunings: (pedalTunings: PedalTuning[]) => IHarpPedalsBuilder;
  defaultX: (defaultX: number) => IHarpPedalsBuilder;
  relativeY: (relativeY: number) => IHarpPedalsBuilder;
  defaultY: (defaultY: number) => IHarpPedalsBuilder;
  relativeX: (relativeX: number) => IHarpPedalsBuilder;
}
class HarpPedalsBuilder implements IHarpPedalsBuilder{
  _p: HarpPedals = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: HarpPedals;
  constructor(toPatch?: HarpPedals) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["pedalTunings"]) || this._b["pedalTunings"] !== undefined || this._p.pedalTunings !== undefined, "pedalTunings is a required field");
  }
  build(): HarpPedals {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "HarpPedals";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  pedalTunings(pedalTunings: PedalTuning[]): IHarpPedalsBuilder {
    this._p.pedalTunings = pedalTunings;
    this._m["pedalTunings"] = true;
    return this;
  }
  defaultX(defaultX: number): IHarpPedalsBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IHarpPedalsBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IHarpPedalsBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IHarpPedalsBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchHarpPedals(base: HarpPedals): IHarpPedalsBuilder { return new HarpPedalsBuilder(base); }
export function buildHarpPedals(): IHarpPedalsBuilder { return new HarpPedalsBuilder(); }

export interface IPedalTuningBuilder {
  build: () => PedalTuning;
  patch: () => any[];
  pedalStep: (pedalStep: string) => IPedalTuningBuilder;
  pedalAlter: (pedalAlter: string) => IPedalTuningBuilder;
}
class PedalTuningBuilder implements IPedalTuningBuilder{
  _p: PedalTuning = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PedalTuning;
  constructor(toPatch?: PedalTuning) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["pedalStep"]) || this._b["pedalStep"] !== undefined || this._p.pedalStep !== undefined, "pedalStep is a required field");
    console.assert((this._o && !this._m["pedalAlter"]) || this._b["pedalAlter"] !== undefined || this._p.pedalAlter !== undefined, "pedalAlter is a required field");
  }
  build(): PedalTuning {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PedalTuning";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  pedalStep(pedalStep: string): IPedalTuningBuilder {
    this._p.pedalStep = pedalStep;
    this._m["pedalStep"] = true;
    return this;
  }
  pedalAlter(pedalAlter: string): IPedalTuningBuilder {
    this._p.pedalAlter = pedalAlter;
    this._m["pedalAlter"] = true;
    return this;
  }
}
export function patchPedalTuning(base: PedalTuning): IPedalTuningBuilder { return new PedalTuningBuilder(base); }
export function buildPedalTuning(): IPedalTuningBuilder { return new PedalTuningBuilder(); }

export interface IDampBuilder {
  build: () => Damp;
  patch: () => any[];
  defaultX: (defaultX: number) => IDampBuilder;
  relativeY: (relativeY: number) => IDampBuilder;
  defaultY: (defaultY: number) => IDampBuilder;
  relativeX: (relativeX: number) => IDampBuilder;
}
class DampBuilder implements IDampBuilder{
  _p: Damp = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Damp;
  constructor(toPatch?: Damp) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Damp {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Damp";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IDampBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IDampBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IDampBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IDampBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchDamp(base: Damp): IDampBuilder { return new DampBuilder(base); }
export function buildDamp(): IDampBuilder { return new DampBuilder(); }

export interface IDampAllBuilder {
  build: () => DampAll;
  patch: () => any[];
  defaultX: (defaultX: number) => IDampAllBuilder;
  relativeY: (relativeY: number) => IDampAllBuilder;
  defaultY: (defaultY: number) => IDampAllBuilder;
  relativeX: (relativeX: number) => IDampAllBuilder;
}
class DampAllBuilder implements IDampAllBuilder{
  _p: DampAll = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: DampAll;
  constructor(toPatch?: DampAll) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): DampAll {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "DampAll";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IDampAllBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IDampAllBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IDampAllBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IDampAllBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchDampAll(base: DampAll): IDampAllBuilder { return new DampAllBuilder(base); }
export function buildDampAll(): IDampAllBuilder { return new DampAllBuilder(); }

export interface IEyeglassesBuilder {
  build: () => Eyeglasses;
  patch: () => any[];
  defaultX: (defaultX: number) => IEyeglassesBuilder;
  relativeY: (relativeY: number) => IEyeglassesBuilder;
  defaultY: (defaultY: number) => IEyeglassesBuilder;
  relativeX: (relativeX: number) => IEyeglassesBuilder;
}
class EyeglassesBuilder implements IEyeglassesBuilder{
  _p: Eyeglasses = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Eyeglasses;
  constructor(toPatch?: Eyeglasses) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Eyeglasses {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Eyeglasses";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  defaultX(defaultX: number): IEyeglassesBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IEyeglassesBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IEyeglassesBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IEyeglassesBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchEyeglasses(base: Eyeglasses): IEyeglassesBuilder { return new EyeglassesBuilder(base); }
export function buildEyeglasses(): IEyeglassesBuilder { return new EyeglassesBuilder(); }

export interface IStringMuteBuilder {
  build: () => StringMute;
  patch: () => any[];
  type: (type: string) => IStringMuteBuilder;
  defaultX: (defaultX: number) => IStringMuteBuilder;
  relativeY: (relativeY: number) => IStringMuteBuilder;
  defaultY: (defaultY: number) => IStringMuteBuilder;
  relativeX: (relativeX: number) => IStringMuteBuilder;
}
class StringMuteBuilder implements IStringMuteBuilder{
  _p: StringMute = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: StringMute;
  constructor(toPatch?: StringMute) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): StringMute {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "StringMute";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  type(type: string): IStringMuteBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  defaultX(defaultX: number): IStringMuteBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IStringMuteBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IStringMuteBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IStringMuteBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchStringMute(base: StringMute): IStringMuteBuilder { return new StringMuteBuilder(base); }
export function buildStringMute(): IStringMuteBuilder { return new StringMuteBuilder(); }

export interface IScordaturaBuilder {
  build: () => Scordatura;
  patch: () => any[];
  accords: (accords: Accord[]) => IScordaturaBuilder;
}
class ScordaturaBuilder implements IScordaturaBuilder{
  _p: Scordatura = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Scordatura;
  constructor(toPatch?: Scordatura) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["accords"]) || this._b["accords"] !== undefined || this._p.accords !== undefined, "accords is a required field");
  }
  build(): Scordatura {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Scordatura";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  accords(accords: Accord[]): IScordaturaBuilder {
    this._p.accords = accords;
    this._m["accords"] = true;
    return this;
  }
}
export function patchScordatura(base: Scordatura): IScordaturaBuilder { return new ScordaturaBuilder(base); }
export function buildScordatura(): IScordaturaBuilder { return new ScordaturaBuilder(); }

export interface IAccordBuilder {
  build: () => Accord;
  patch: () => any[];
  tuningAlter: (tuningAlter: string) => IAccordBuilder;
  string: (string: string) => IAccordBuilder;
  tuningStep: (tuningStep: string) => IAccordBuilder;
  tuningOctave: (tuningOctave: string) => IAccordBuilder;
}
class AccordBuilder implements IAccordBuilder{
  _p: Accord = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Accord;
  constructor(toPatch?: Accord) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["tuningAlter"]) || this._b["tuningAlter"] !== undefined || this._p.tuningAlter !== undefined, "tuningAlter is a required field");
    console.assert((this._o && !this._m["string"]) || this._b["string"] !== undefined || this._p.string !== undefined, "string is a required field");
    console.assert((this._o && !this._m["tuningStep"]) || this._b["tuningStep"] !== undefined || this._p.tuningStep !== undefined, "tuningStep is a required field");
    console.assert((this._o && !this._m["tuningOctave"]) || this._b["tuningOctave"] !== undefined || this._p.tuningOctave !== undefined, "tuningOctave is a required field");
  }
  build(): Accord {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Accord";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  tuningAlter(tuningAlter: string): IAccordBuilder {
    this._p.tuningAlter = tuningAlter;
    this._m["tuningAlter"] = true;
    return this;
  }
  string(string: string): IAccordBuilder {
    this._p.string = string;
    this._m["string"] = true;
    return this;
  }
  tuningStep(tuningStep: string): IAccordBuilder {
    this._p.tuningStep = tuningStep;
    this._m["tuningStep"] = true;
    return this;
  }
  tuningOctave(tuningOctave: string): IAccordBuilder {
    this._p.tuningOctave = tuningOctave;
    this._m["tuningOctave"] = true;
    return this;
  }
}
export function patchAccord(base: Accord): IAccordBuilder { return new AccordBuilder(base); }
export function buildAccord(): IAccordBuilder { return new AccordBuilder(); }

export interface IImageBuilder {
  build: () => Image;
  patch: () => any[];
  type: (type: string) => IImageBuilder;
  source: (source: string) => IImageBuilder;
  defaultX: (defaultX: number) => IImageBuilder;
  relativeY: (relativeY: number) => IImageBuilder;
  defaultY: (defaultY: number) => IImageBuilder;
  relativeX: (relativeX: number) => IImageBuilder;
}
class ImageBuilder implements IImageBuilder{
  _p: Image = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Image;
  constructor(toPatch?: Image) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
    console.assert((this._o && !this._m["source"]) || this._b["source"] !== undefined || this._p.source !== undefined, "source is a required field");
  }
  build(): Image {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Image";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  type(type: string): IImageBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  source(source: string): IImageBuilder {
    this._p.source = source;
    this._m["source"] = true;
    return this;
  }
  defaultX(defaultX: number): IImageBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IImageBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IImageBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IImageBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchImage(base: Image): IImageBuilder { return new ImageBuilder(base); }
export function buildImage(): IImageBuilder { return new ImageBuilder(); }

export interface IPrincipalVoiceBuilder {
  build: () => PrincipalVoice;
  patch: () => any[];
  symbol: (symbol: VoiceSymbol) => IPrincipalVoiceBuilder;
  data: (data: string) => IPrincipalVoiceBuilder;
  type: (type: StartStop) => IPrincipalVoiceBuilder;
  defaultX: (defaultX: number) => IPrincipalVoiceBuilder;
  relativeY: (relativeY: number) => IPrincipalVoiceBuilder;
  defaultY: (defaultY: number) => IPrincipalVoiceBuilder;
  relativeX: (relativeX: number) => IPrincipalVoiceBuilder;
}
class PrincipalVoiceBuilder implements IPrincipalVoiceBuilder{
  _p: PrincipalVoice = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PrincipalVoice;
  constructor(toPatch?: PrincipalVoice) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["symbol"]) || this._b["symbol"] !== undefined || this._p.symbol !== undefined, "symbol is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): PrincipalVoice {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PrincipalVoice";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  symbol(symbol: VoiceSymbol): IPrincipalVoiceBuilder {
    this._p.symbol = symbol;
    this._m["symbol"] = true;
    return this;
  }
  data(data: string): IPrincipalVoiceBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  type(type: StartStop): IPrincipalVoiceBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  defaultX(defaultX: number): IPrincipalVoiceBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IPrincipalVoiceBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IPrincipalVoiceBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IPrincipalVoiceBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchPrincipalVoice(base: PrincipalVoice): IPrincipalVoiceBuilder { return new PrincipalVoiceBuilder(base); }
export function buildPrincipalVoice(): IPrincipalVoiceBuilder { return new PrincipalVoiceBuilder(); }

export interface IAccordionRegistrationBuilder {
  build: () => AccordionRegistration;
  patch: () => any[];
  accordionMiddle: (accordionMiddle: string) => IAccordionRegistrationBuilder;
  accordionHigh: (accordionHigh: boolean) => IAccordionRegistrationBuilder;
  accordionLow: (accordionLow: boolean) => IAccordionRegistrationBuilder;
  defaultX: (defaultX: number) => IAccordionRegistrationBuilder;
  relativeY: (relativeY: number) => IAccordionRegistrationBuilder;
  defaultY: (defaultY: number) => IAccordionRegistrationBuilder;
  relativeX: (relativeX: number) => IAccordionRegistrationBuilder;
}
class AccordionRegistrationBuilder implements IAccordionRegistrationBuilder{
  _p: AccordionRegistration = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: AccordionRegistration;
  constructor(toPatch?: AccordionRegistration) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["accordionMiddle"]) || this._b["accordionMiddle"] !== undefined || this._p.accordionMiddle !== undefined, "accordionMiddle is a required field");
    console.assert((this._o && !this._m["accordionHigh"]) || this._b["accordionHigh"] !== undefined || this._p.accordionHigh !== undefined, "accordionHigh is a required field");
    console.assert((this._o && !this._m["accordionLow"]) || this._b["accordionLow"] !== undefined || this._p.accordionLow !== undefined, "accordionLow is a required field");
  }
  build(): AccordionRegistration {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "AccordionRegistration";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  accordionMiddle(accordionMiddle: string): IAccordionRegistrationBuilder {
    this._p.accordionMiddle = accordionMiddle;
    this._m["accordionMiddle"] = true;
    return this;
  }
  accordionHigh(accordionHigh: boolean): IAccordionRegistrationBuilder {
    this._p.accordionHigh = accordionHigh;
    this._m["accordionHigh"] = true;
    return this;
  }
  accordionLow(accordionLow: boolean): IAccordionRegistrationBuilder {
    this._p.accordionLow = accordionLow;
    this._m["accordionLow"] = true;
    return this;
  }
  defaultX(defaultX: number): IAccordionRegistrationBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IAccordionRegistrationBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IAccordionRegistrationBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IAccordionRegistrationBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchAccordionRegistration(base: AccordionRegistration): IAccordionRegistrationBuilder { return new AccordionRegistrationBuilder(base); }
export function buildAccordionRegistration(): IAccordionRegistrationBuilder { return new AccordionRegistrationBuilder(); }

export interface IPercussionBuilder {
  build: () => Percussion;
  patch: () => any[];
  stickLocation: (stickLocation: string) => IPercussionBuilder;
  otherPercussion: (otherPercussion: string) => IPercussionBuilder;
  wood: (wood: string) => IPercussionBuilder;
  effect: (effect: string) => IPercussionBuilder;
  glass: (glass: string) => IPercussionBuilder;
  timpani: (build: (builder: ITimpaniBuilder) => ITimpaniBuilder) => IPercussionBuilder;
  stick: (build: (builder: IStickBuilder) => IStickBuilder) => IPercussionBuilder;
  metal: (metal: string) => IPercussionBuilder;
  pitched: (pitched: string) => IPercussionBuilder;
  membrane: (membrane: string) => IPercussionBuilder;
  beater: (build: (builder: IBeaterBuilder) => IBeaterBuilder) => IPercussionBuilder;
  defaultX: (defaultX: number) => IPercussionBuilder;
  relativeY: (relativeY: number) => IPercussionBuilder;
  defaultY: (defaultY: number) => IPercussionBuilder;
  relativeX: (relativeX: number) => IPercussionBuilder;
}
class PercussionBuilder implements IPercussionBuilder{
  _p: Percussion = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Percussion;
  constructor(toPatch?: Percussion) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["stickLocation"]) || this._b["stickLocation"] !== undefined || this._p.stickLocation !== undefined, "stickLocation is a required field");
    console.assert((this._o && !this._m["otherPercussion"]) || this._b["otherPercussion"] !== undefined || this._p.otherPercussion !== undefined, "otherPercussion is a required field");
    console.assert((this._o && !this._m["wood"]) || this._b["wood"] !== undefined || this._p.wood !== undefined, "wood is a required field");
    console.assert((this._o && !this._m["effect"]) || this._b["effect"] !== undefined || this._p.effect !== undefined, "effect is a required field");
    console.assert((this._o && !this._m["glass"]) || this._b["glass"] !== undefined || this._p.glass !== undefined, "glass is a required field");
    console.assert((this._o && !this._m["timpani"]) || this._b["timpani"] !== undefined || this._p.timpani !== undefined, "timpani is a required field");
    console.assert((this._o && !this._m["stick"]) || this._b["stick"] !== undefined || this._p.stick !== undefined, "stick is a required field");
    console.assert((this._o && !this._m["metal"]) || this._b["metal"] !== undefined || this._p.metal !== undefined, "metal is a required field");
    console.assert((this._o && !this._m["pitched"]) || this._b["pitched"] !== undefined || this._p.pitched !== undefined, "pitched is a required field");
    console.assert((this._o && !this._m["membrane"]) || this._b["membrane"] !== undefined || this._p.membrane !== undefined, "membrane is a required field");
    console.assert((this._o && !this._m["beater"]) || this._b["beater"] !== undefined || this._p.beater !== undefined, "beater is a required field");
  }
  build(): Percussion {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Percussion";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  stickLocation(stickLocation: string): IPercussionBuilder {
    this._p.stickLocation = stickLocation;
    this._m["stickLocation"] = true;
    return this;
  }
  otherPercussion(otherPercussion: string): IPercussionBuilder {
    this._p.otherPercussion = otherPercussion;
    this._m["otherPercussion"] = true;
    return this;
  }
  wood(wood: string): IPercussionBuilder {
    this._p.wood = wood;
    this._m["wood"] = true;
    return this;
  }
  effect(effect: string): IPercussionBuilder {
    this._p.effect = effect;
    this._m["effect"] = true;
    return this;
  }
  glass(glass: string): IPercussionBuilder {
    this._p.glass = glass;
    this._m["glass"] = true;
    return this;
  }
  timpani(build: (builder: ITimpaniBuilder) => ITimpaniBuilder): IPercussionBuilder {
    this._b["timpani"] = build(new TimpaniBuilder(this._o && this._o["timpani"]));
    this._m["timpani"] = true;
    return this;
  }
  stick(build: (builder: IStickBuilder) => IStickBuilder): IPercussionBuilder {
    this._b["stick"] = build(new StickBuilder(this._o && this._o["stick"]));
    this._m["stick"] = true;
    return this;
  }
  metal(metal: string): IPercussionBuilder {
    this._p.metal = metal;
    this._m["metal"] = true;
    return this;
  }
  pitched(pitched: string): IPercussionBuilder {
    this._p.pitched = pitched;
    this._m["pitched"] = true;
    return this;
  }
  membrane(membrane: string): IPercussionBuilder {
    this._p.membrane = membrane;
    this._m["membrane"] = true;
    return this;
  }
  beater(build: (builder: IBeaterBuilder) => IBeaterBuilder): IPercussionBuilder {
    this._b["beater"] = build(new BeaterBuilder(this._o && this._o["beater"]));
    this._m["beater"] = true;
    return this;
  }
  defaultX(defaultX: number): IPercussionBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IPercussionBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IPercussionBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IPercussionBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchPercussion(base: Percussion): IPercussionBuilder { return new PercussionBuilder(base); }
export function buildPercussion(): IPercussionBuilder { return new PercussionBuilder(); }

export interface ITimpaniBuilder {
  build: () => Timpani;
  patch: () => any[];
}
class TimpaniBuilder implements ITimpaniBuilder{
  _p: Timpani = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Timpani;
  constructor(toPatch?: Timpani) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Timpani {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Timpani";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
}
export function patchTimpani(base: Timpani): ITimpaniBuilder { return new TimpaniBuilder(base); }
export function buildTimpani(): ITimpaniBuilder { return new TimpaniBuilder(); }

export interface IBeaterBuilder {
  build: () => Beater;
  patch: () => any[];
  data: (data: string) => IBeaterBuilder;
  tip: (tip: TipDirection) => IBeaterBuilder;
}
class BeaterBuilder implements IBeaterBuilder{
  _p: Beater = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Beater;
  constructor(toPatch?: Beater) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
    console.assert((this._o && !this._m["tip"]) || this._b["tip"] !== undefined || this._p.tip !== undefined, "tip is a required field");
  }
  build(): Beater {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Beater";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IBeaterBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  tip(tip: TipDirection): IBeaterBuilder {
    this._p.tip = tip;
    this._m["tip"] = true;
    return this;
  }
}
export function patchBeater(base: Beater): IBeaterBuilder { return new BeaterBuilder(base); }
export function buildBeater(): IBeaterBuilder { return new BeaterBuilder(); }

export interface IStickBuilder {
  build: () => Stick;
  patch: () => any[];
  stickMaterial: (stickMaterial: string) => IStickBuilder;
  stickType: (stickType: string) => IStickBuilder;
  tip: (tip: TipDirection) => IStickBuilder;
}
class StickBuilder implements IStickBuilder{
  _p: Stick = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Stick;
  constructor(toPatch?: Stick) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["stickMaterial"]) || this._b["stickMaterial"] !== undefined || this._p.stickMaterial !== undefined, "stickMaterial is a required field");
    console.assert((this._o && !this._m["stickType"]) || this._b["stickType"] !== undefined || this._p.stickType !== undefined, "stickType is a required field");
    console.assert((this._o && !this._m["tip"]) || this._b["tip"] !== undefined || this._p.tip !== undefined, "tip is a required field");
  }
  build(): Stick {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Stick";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  stickMaterial(stickMaterial: string): IStickBuilder {
    this._p.stickMaterial = stickMaterial;
    this._m["stickMaterial"] = true;
    return this;
  }
  stickType(stickType: string): IStickBuilder {
    this._p.stickType = stickType;
    this._m["stickType"] = true;
    return this;
  }
  tip(tip: TipDirection): IStickBuilder {
    this._p.tip = tip;
    this._m["tip"] = true;
    return this;
  }
}
export function patchStick(base: Stick): IStickBuilder { return new StickBuilder(base); }
export function buildStick(): IStickBuilder { return new StickBuilder(); }

export interface IOffsetBuilder {
  build: () => Offset;
  patch: () => any[];
  data: (data: string) => IOffsetBuilder;
  sound: (sound: boolean) => IOffsetBuilder;
}
class OffsetBuilder implements IOffsetBuilder{
  _p: Offset = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Offset;
  constructor(toPatch?: Offset) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
    console.assert((this._o && !this._m["sound"]) || this._b["sound"] !== undefined || this._p.sound !== undefined, "sound is a required field");
  }
  build(): Offset {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Offset";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IOffsetBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  sound(sound: boolean): IOffsetBuilder {
    this._p.sound = sound;
    this._m["sound"] = true;
    return this;
  }
}
export function patchOffset(base: Offset): IOffsetBuilder { return new OffsetBuilder(base); }
export function buildOffset(): IOffsetBuilder { return new OffsetBuilder(); }

export interface IHarmonyChordBuilder {
  build: () => HarmonyChord;
  patch: () => any[];
  root: (build: (builder: IRootBuilder) => IRootBuilder) => IHarmonyChordBuilder;
  function: (build: (builder: IFunctionBuilder) => IFunctionBuilder) => IHarmonyChordBuilder;
  kind: (build: (builder: IKindBuilder) => IKindBuilder) => IHarmonyChordBuilder;
  degrees: (degrees: Degree[]) => IHarmonyChordBuilder;
  inversion: (build: (builder: IInversionBuilder) => IInversionBuilder) => IHarmonyChordBuilder;
  bass: (build: (builder: IBassBuilder) => IBassBuilder) => IHarmonyChordBuilder;
}
class HarmonyChordBuilder implements IHarmonyChordBuilder{
  _p: HarmonyChord = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: HarmonyChord;
  constructor(toPatch?: HarmonyChord) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["root"]) || this._b["root"] !== undefined || this._p.root !== undefined, "root is a required field");
    console.assert((this._o && !this._m["function"]) || this._b["function"] !== undefined || this._p.function !== undefined, "function is a required field");
    console.assert((this._o && !this._m["kind"]) || this._b["kind"] !== undefined || this._p.kind !== undefined, "kind is a required field");
    console.assert((this._o && !this._m["degrees"]) || this._b["degrees"] !== undefined || this._p.degrees !== undefined, "degrees is a required field");
    console.assert((this._o && !this._m["inversion"]) || this._b["inversion"] !== undefined || this._p.inversion !== undefined, "inversion is a required field");
    console.assert((this._o && !this._m["bass"]) || this._b["bass"] !== undefined || this._p.bass !== undefined, "bass is a required field");
  }
  build(): HarmonyChord {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "HarmonyChord";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  root(build: (builder: IRootBuilder) => IRootBuilder): IHarmonyChordBuilder {
    this._b["root"] = build(new RootBuilder(this._o && this._o["root"]));
    this._m["root"] = true;
    return this;
  }
  function(build: (builder: IFunctionBuilder) => IFunctionBuilder): IHarmonyChordBuilder {
    this._b["function"] = build(new FunctionBuilder(this._o && this._o["function"]));
    this._m["function"] = true;
    return this;
  }
  kind(build: (builder: IKindBuilder) => IKindBuilder): IHarmonyChordBuilder {
    this._b["kind"] = build(new KindBuilder(this._o && this._o["kind"]));
    this._m["kind"] = true;
    return this;
  }
  degrees(degrees: Degree[]): IHarmonyChordBuilder {
    this._p.degrees = degrees;
    this._m["degrees"] = true;
    return this;
  }
  inversion(build: (builder: IInversionBuilder) => IInversionBuilder): IHarmonyChordBuilder {
    this._b["inversion"] = build(new InversionBuilder(this._o && this._o["inversion"]));
    this._m["inversion"] = true;
    return this;
  }
  bass(build: (builder: IBassBuilder) => IBassBuilder): IHarmonyChordBuilder {
    this._b["bass"] = build(new BassBuilder(this._o && this._o["bass"]));
    this._m["bass"] = true;
    return this;
  }
}
export function patchHarmonyChord(base: HarmonyChord): IHarmonyChordBuilder { return new HarmonyChordBuilder(base); }
export function buildHarmonyChord(): IHarmonyChordBuilder { return new HarmonyChordBuilder(); }

export interface IHarmonyBuilder {
  build: () => Harmony;
  patch: () => any[];
  frame: (build: (builder: IFrameBuilder) => IFrameBuilder) => IHarmonyBuilder;
  printFrame: (printFrame: boolean) => IHarmonyBuilder;
  staff: (staff: number) => IHarmonyBuilder;
  type: (type: ExplicitImpliedAlternate) => IHarmonyBuilder;
  offset: (build: (builder: IOffsetBuilder) => IOffsetBuilder) => IHarmonyBuilder;
  root: (build: (builder: IRootBuilder) => IRootBuilder) => IHarmonyBuilder;
  function: (build: (builder: IFunctionBuilder) => IFunctionBuilder) => IHarmonyBuilder;
  kind: (build: (builder: IKindBuilder) => IKindBuilder) => IHarmonyBuilder;
  degrees: (degrees: Degree[]) => IHarmonyBuilder;
  inversion: (build: (builder: IInversionBuilder) => IInversionBuilder) => IHarmonyBuilder;
  bass: (build: (builder: IBassBuilder) => IBassBuilder) => IHarmonyBuilder;
}
class HarmonyBuilder implements IHarmonyBuilder{
  _p: Harmony = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Harmony;
  constructor(toPatch?: Harmony) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["frame"]) || this._b["frame"] !== undefined || this._p.frame !== undefined, "frame is a required field");
    console.assert((this._o && !this._m["printFrame"]) || this._b["printFrame"] !== undefined || this._p.printFrame !== undefined, "printFrame is a required field");
    console.assert((this._o && !this._m["staff"]) || this._b["staff"] !== undefined || this._p.staff !== undefined, "staff is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
    console.assert((this._o && !this._m["offset"]) || this._b["offset"] !== undefined || this._p.offset !== undefined, "offset is a required field");
    console.assert((this._o && !this._m["root"]) || this._b["root"] !== undefined || this._p.root !== undefined, "root is a required field");
    console.assert((this._o && !this._m["function"]) || this._b["function"] !== undefined || this._p.function !== undefined, "function is a required field");
    console.assert((this._o && !this._m["kind"]) || this._b["kind"] !== undefined || this._p.kind !== undefined, "kind is a required field");
    console.assert((this._o && !this._m["degrees"]) || this._b["degrees"] !== undefined || this._p.degrees !== undefined, "degrees is a required field");
    console.assert((this._o && !this._m["inversion"]) || this._b["inversion"] !== undefined || this._p.inversion !== undefined, "inversion is a required field");
    console.assert((this._o && !this._m["bass"]) || this._b["bass"] !== undefined || this._p.bass !== undefined, "bass is a required field");
  }
  build(): Harmony {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Harmony";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  frame(build: (builder: IFrameBuilder) => IFrameBuilder): IHarmonyBuilder {
    this._b["frame"] = build(new FrameBuilder(this._o && this._o["frame"]));
    this._m["frame"] = true;
    return this;
  }
  printFrame(printFrame: boolean): IHarmonyBuilder {
    this._p.printFrame = printFrame;
    this._m["printFrame"] = true;
    return this;
  }
  staff(staff: number): IHarmonyBuilder {
    this._p.staff = staff;
    this._m["staff"] = true;
    return this;
  }
  type(type: ExplicitImpliedAlternate): IHarmonyBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  offset(build: (builder: IOffsetBuilder) => IOffsetBuilder): IHarmonyBuilder {
    this._b["offset"] = build(new OffsetBuilder(this._o && this._o["offset"]));
    this._m["offset"] = true;
    return this;
  }
  root(build: (builder: IRootBuilder) => IRootBuilder): IHarmonyBuilder {
    this._b["root"] = build(new RootBuilder(this._o && this._o["root"]));
    this._m["root"] = true;
    return this;
  }
  function(build: (builder: IFunctionBuilder) => IFunctionBuilder): IHarmonyBuilder {
    this._b["function"] = build(new FunctionBuilder(this._o && this._o["function"]));
    this._m["function"] = true;
    return this;
  }
  kind(build: (builder: IKindBuilder) => IKindBuilder): IHarmonyBuilder {
    this._b["kind"] = build(new KindBuilder(this._o && this._o["kind"]));
    this._m["kind"] = true;
    return this;
  }
  degrees(degrees: Degree[]): IHarmonyBuilder {
    this._p.degrees = degrees;
    this._m["degrees"] = true;
    return this;
  }
  inversion(build: (builder: IInversionBuilder) => IInversionBuilder): IHarmonyBuilder {
    this._b["inversion"] = build(new InversionBuilder(this._o && this._o["inversion"]));
    this._m["inversion"] = true;
    return this;
  }
  bass(build: (builder: IBassBuilder) => IBassBuilder): IHarmonyBuilder {
    this._b["bass"] = build(new BassBuilder(this._o && this._o["bass"]));
    this._m["bass"] = true;
    return this;
  }
}
export function patchHarmony(base: Harmony): IHarmonyBuilder { return new HarmonyBuilder(base); }
export function buildHarmony(): IHarmonyBuilder { return new HarmonyBuilder(); }

export interface IRootBuilder {
  build: () => Root;
  patch: () => any[];
  rootStep: (build: (builder: IRootStepBuilder) => IRootStepBuilder) => IRootBuilder;
  rootAlter: (build: (builder: IRootAlterBuilder) => IRootAlterBuilder) => IRootBuilder;
}
class RootBuilder implements IRootBuilder{
  _p: Root = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Root;
  constructor(toPatch?: Root) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["rootStep"]) || this._b["rootStep"] !== undefined || this._p.rootStep !== undefined, "rootStep is a required field");
    console.assert((this._o && !this._m["rootAlter"]) || this._b["rootAlter"] !== undefined || this._p.rootAlter !== undefined, "rootAlter is a required field");
  }
  build(): Root {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Root";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  rootStep(build: (builder: IRootStepBuilder) => IRootStepBuilder): IRootBuilder {
    this._b["rootStep"] = build(new RootStepBuilder(this._o && this._o["rootStep"]));
    this._m["rootStep"] = true;
    return this;
  }
  rootAlter(build: (builder: IRootAlterBuilder) => IRootAlterBuilder): IRootBuilder {
    this._b["rootAlter"] = build(new RootAlterBuilder(this._o && this._o["rootAlter"]));
    this._m["rootAlter"] = true;
    return this;
  }
}
export function patchRoot(base: Root): IRootBuilder { return new RootBuilder(base); }
export function buildRoot(): IRootBuilder { return new RootBuilder(); }

export interface IRootStepBuilder {
  build: () => RootStep;
  patch: () => any[];
  text: (text: string) => IRootStepBuilder;
  data: (data: string) => IRootStepBuilder;
  defaultX: (defaultX: number) => IRootStepBuilder;
  relativeY: (relativeY: number) => IRootStepBuilder;
  defaultY: (defaultY: number) => IRootStepBuilder;
  relativeX: (relativeX: number) => IRootStepBuilder;
}
class RootStepBuilder implements IRootStepBuilder{
  _p: RootStep = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: RootStep;
  constructor(toPatch?: RootStep) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["text"]) || this._b["text"] !== undefined || this._p.text !== undefined, "text is a required field");
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): RootStep {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "RootStep";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  text(text: string): IRootStepBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  data(data: string): IRootStepBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IRootStepBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IRootStepBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IRootStepBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IRootStepBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchRootStep(base: RootStep): IRootStepBuilder { return new RootStepBuilder(base); }
export function buildRootStep(): IRootStepBuilder { return new RootStepBuilder(); }

export interface IRootAlterBuilder {
  build: () => RootAlter;
  patch: () => any[];
  location: (location: LeftRight) => IRootAlterBuilder;
  data: (data: string) => IRootAlterBuilder;
  printObject: (printObject: boolean) => IRootAlterBuilder;
}
class RootAlterBuilder implements IRootAlterBuilder{
  _p: RootAlter = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: RootAlter;
  constructor(toPatch?: RootAlter) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["location"]) || this._b["location"] !== undefined || this._p.location !== undefined, "location is a required field");
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): RootAlter {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "RootAlter";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  location(location: LeftRight): IRootAlterBuilder {
    this._p.location = location;
    this._m["location"] = true;
    return this;
  }
  data(data: string): IRootAlterBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  printObject(printObject: boolean): IRootAlterBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchRootAlter(base: RootAlter): IRootAlterBuilder { return new RootAlterBuilder(base); }
export function buildRootAlter(): IRootAlterBuilder { return new RootAlterBuilder(); }

export interface IFunctionBuilder {
  build: () => Function;
  patch: () => any[];
  data: (data: string) => IFunctionBuilder;
  defaultX: (defaultX: number) => IFunctionBuilder;
  relativeY: (relativeY: number) => IFunctionBuilder;
  defaultY: (defaultY: number) => IFunctionBuilder;
  relativeX: (relativeX: number) => IFunctionBuilder;
}
class FunctionBuilder implements IFunctionBuilder{
  _p: Function = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Function;
  constructor(toPatch?: Function) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): Function {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Function";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IFunctionBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IFunctionBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IFunctionBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IFunctionBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IFunctionBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchFunction(base: Function): IFunctionBuilder { return new FunctionBuilder(base); }
export function buildFunction(): IFunctionBuilder { return new FunctionBuilder(); }

export interface IKindBuilder {
  build: () => Kind;
  patch: () => any[];
  parenthesesDegrees: (parenthesesDegrees: boolean) => IKindBuilder;
  useSymbols: (useSymbols: boolean) => IKindBuilder;
  text: (text: string) => IKindBuilder;
  data: (data: string) => IKindBuilder;
  stackDegrees: (stackDegrees: boolean) => IKindBuilder;
  bracketDegrees: (bracketDegrees: boolean) => IKindBuilder;
  defaultX: (defaultX: number) => IKindBuilder;
  relativeY: (relativeY: number) => IKindBuilder;
  defaultY: (defaultY: number) => IKindBuilder;
  relativeX: (relativeX: number) => IKindBuilder;
}
class KindBuilder implements IKindBuilder{
  _p: Kind = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Kind;
  constructor(toPatch?: Kind) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["parenthesesDegrees"]) || this._b["parenthesesDegrees"] !== undefined || this._p.parenthesesDegrees !== undefined, "parenthesesDegrees is a required field");
    console.assert((this._o && !this._m["useSymbols"]) || this._b["useSymbols"] !== undefined || this._p.useSymbols !== undefined, "useSymbols is a required field");
    console.assert((this._o && !this._m["text"]) || this._b["text"] !== undefined || this._p.text !== undefined, "text is a required field");
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
    console.assert((this._o && !this._m["stackDegrees"]) || this._b["stackDegrees"] !== undefined || this._p.stackDegrees !== undefined, "stackDegrees is a required field");
    console.assert((this._o && !this._m["bracketDegrees"]) || this._b["bracketDegrees"] !== undefined || this._p.bracketDegrees !== undefined, "bracketDegrees is a required field");
  }
  build(): Kind {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Kind";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  parenthesesDegrees(parenthesesDegrees: boolean): IKindBuilder {
    this._p.parenthesesDegrees = parenthesesDegrees;
    this._m["parenthesesDegrees"] = true;
    return this;
  }
  useSymbols(useSymbols: boolean): IKindBuilder {
    this._p.useSymbols = useSymbols;
    this._m["useSymbols"] = true;
    return this;
  }
  text(text: string): IKindBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  data(data: string): IKindBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  stackDegrees(stackDegrees: boolean): IKindBuilder {
    this._p.stackDegrees = stackDegrees;
    this._m["stackDegrees"] = true;
    return this;
  }
  bracketDegrees(bracketDegrees: boolean): IKindBuilder {
    this._p.bracketDegrees = bracketDegrees;
    this._m["bracketDegrees"] = true;
    return this;
  }
  defaultX(defaultX: number): IKindBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IKindBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IKindBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IKindBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchKind(base: Kind): IKindBuilder { return new KindBuilder(base); }
export function buildKind(): IKindBuilder { return new KindBuilder(); }

export interface IInversionBuilder {
  build: () => Inversion;
  patch: () => any[];
  data: (data: string) => IInversionBuilder;
  defaultX: (defaultX: number) => IInversionBuilder;
  relativeY: (relativeY: number) => IInversionBuilder;
  defaultY: (defaultY: number) => IInversionBuilder;
  relativeX: (relativeX: number) => IInversionBuilder;
}
class InversionBuilder implements IInversionBuilder{
  _p: Inversion = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Inversion;
  constructor(toPatch?: Inversion) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): Inversion {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Inversion";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IInversionBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IInversionBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IInversionBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IInversionBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IInversionBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchInversion(base: Inversion): IInversionBuilder { return new InversionBuilder(base); }
export function buildInversion(): IInversionBuilder { return new InversionBuilder(); }

export interface IBassBuilder {
  build: () => Bass;
  patch: () => any[];
  bassStep: (build: (builder: IBassStepBuilder) => IBassStepBuilder) => IBassBuilder;
  bassAlter: (build: (builder: IBassAlterBuilder) => IBassAlterBuilder) => IBassBuilder;
}
class BassBuilder implements IBassBuilder{
  _p: Bass = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Bass;
  constructor(toPatch?: Bass) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["bassStep"]) || this._b["bassStep"] !== undefined || this._p.bassStep !== undefined, "bassStep is a required field");
    console.assert((this._o && !this._m["bassAlter"]) || this._b["bassAlter"] !== undefined || this._p.bassAlter !== undefined, "bassAlter is a required field");
  }
  build(): Bass {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Bass";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  bassStep(build: (builder: IBassStepBuilder) => IBassStepBuilder): IBassBuilder {
    this._b["bassStep"] = build(new BassStepBuilder(this._o && this._o["bassStep"]));
    this._m["bassStep"] = true;
    return this;
  }
  bassAlter(build: (builder: IBassAlterBuilder) => IBassAlterBuilder): IBassBuilder {
    this._b["bassAlter"] = build(new BassAlterBuilder(this._o && this._o["bassAlter"]));
    this._m["bassAlter"] = true;
    return this;
  }
}
export function patchBass(base: Bass): IBassBuilder { return new BassBuilder(base); }
export function buildBass(): IBassBuilder { return new BassBuilder(); }

export interface IBassStepBuilder {
  build: () => BassStep;
  patch: () => any[];
  text: (text: string) => IBassStepBuilder;
  data: (data: string) => IBassStepBuilder;
  defaultX: (defaultX: number) => IBassStepBuilder;
  relativeY: (relativeY: number) => IBassStepBuilder;
  defaultY: (defaultY: number) => IBassStepBuilder;
  relativeX: (relativeX: number) => IBassStepBuilder;
}
class BassStepBuilder implements IBassStepBuilder{
  _p: BassStep = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: BassStep;
  constructor(toPatch?: BassStep) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["text"]) || this._b["text"] !== undefined || this._p.text !== undefined, "text is a required field");
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): BassStep {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "BassStep";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  text(text: string): IBassStepBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  data(data: string): IBassStepBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IBassStepBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IBassStepBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IBassStepBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IBassStepBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchBassStep(base: BassStep): IBassStepBuilder { return new BassStepBuilder(base); }
export function buildBassStep(): IBassStepBuilder { return new BassStepBuilder(); }

export interface IBassAlterBuilder {
  build: () => BassAlter;
  patch: () => any[];
  location: (location: LeftRight) => IBassAlterBuilder;
  data: (data: string) => IBassAlterBuilder;
  printObject: (printObject: boolean) => IBassAlterBuilder;
}
class BassAlterBuilder implements IBassAlterBuilder{
  _p: BassAlter = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: BassAlter;
  constructor(toPatch?: BassAlter) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["location"]) || this._b["location"] !== undefined || this._p.location !== undefined, "location is a required field");
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): BassAlter {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "BassAlter";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  location(location: LeftRight): IBassAlterBuilder {
    this._p.location = location;
    this._m["location"] = true;
    return this;
  }
  data(data: string): IBassAlterBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  printObject(printObject: boolean): IBassAlterBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchBassAlter(base: BassAlter): IBassAlterBuilder { return new BassAlterBuilder(base); }
export function buildBassAlter(): IBassAlterBuilder { return new BassAlterBuilder(); }

export interface IDegreeBuilder {
  build: () => Degree;
  patch: () => any[];
  degreeAlter: (build: (builder: IDegreeAlterBuilder) => IDegreeAlterBuilder) => IDegreeBuilder;
  degreeValue: (build: (builder: IDegreeValueBuilder) => IDegreeValueBuilder) => IDegreeBuilder;
  degreeType: (build: (builder: IDegreeTypeBuilder) => IDegreeTypeBuilder) => IDegreeBuilder;
  printObject: (printObject: boolean) => IDegreeBuilder;
}
class DegreeBuilder implements IDegreeBuilder{
  _p: Degree = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Degree;
  constructor(toPatch?: Degree) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["degreeAlter"]) || this._b["degreeAlter"] !== undefined || this._p.degreeAlter !== undefined, "degreeAlter is a required field");
    console.assert((this._o && !this._m["degreeValue"]) || this._b["degreeValue"] !== undefined || this._p.degreeValue !== undefined, "degreeValue is a required field");
    console.assert((this._o && !this._m["degreeType"]) || this._b["degreeType"] !== undefined || this._p.degreeType !== undefined, "degreeType is a required field");
  }
  build(): Degree {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Degree";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  degreeAlter(build: (builder: IDegreeAlterBuilder) => IDegreeAlterBuilder): IDegreeBuilder {
    this._b["degreeAlter"] = build(new DegreeAlterBuilder(this._o && this._o["degreeAlter"]));
    this._m["degreeAlter"] = true;
    return this;
  }
  degreeValue(build: (builder: IDegreeValueBuilder) => IDegreeValueBuilder): IDegreeBuilder {
    this._b["degreeValue"] = build(new DegreeValueBuilder(this._o && this._o["degreeValue"]));
    this._m["degreeValue"] = true;
    return this;
  }
  degreeType(build: (builder: IDegreeTypeBuilder) => IDegreeTypeBuilder): IDegreeBuilder {
    this._b["degreeType"] = build(new DegreeTypeBuilder(this._o && this._o["degreeType"]));
    this._m["degreeType"] = true;
    return this;
  }
  printObject(printObject: boolean): IDegreeBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchDegree(base: Degree): IDegreeBuilder { return new DegreeBuilder(base); }
export function buildDegree(): IDegreeBuilder { return new DegreeBuilder(); }

export interface IDegreeValueBuilder {
  build: () => DegreeValue;
  patch: () => any[];
  symbol: (symbol: ChordType) => IDegreeValueBuilder;
  text: (text: string) => IDegreeValueBuilder;
  data: (data: string) => IDegreeValueBuilder;
  defaultX: (defaultX: number) => IDegreeValueBuilder;
  relativeY: (relativeY: number) => IDegreeValueBuilder;
  defaultY: (defaultY: number) => IDegreeValueBuilder;
  relativeX: (relativeX: number) => IDegreeValueBuilder;
}
class DegreeValueBuilder implements IDegreeValueBuilder{
  _p: DegreeValue = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: DegreeValue;
  constructor(toPatch?: DegreeValue) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["symbol"]) || this._b["symbol"] !== undefined || this._p.symbol !== undefined, "symbol is a required field");
    console.assert((this._o && !this._m["text"]) || this._b["text"] !== undefined || this._p.text !== undefined, "text is a required field");
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): DegreeValue {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "DegreeValue";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  symbol(symbol: ChordType): IDegreeValueBuilder {
    this._p.symbol = symbol;
    this._m["symbol"] = true;
    return this;
  }
  text(text: string): IDegreeValueBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  data(data: string): IDegreeValueBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IDegreeValueBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IDegreeValueBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IDegreeValueBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IDegreeValueBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchDegreeValue(base: DegreeValue): IDegreeValueBuilder { return new DegreeValueBuilder(base); }
export function buildDegreeValue(): IDegreeValueBuilder { return new DegreeValueBuilder(); }

export interface IDegreeAlterBuilder {
  build: () => DegreeAlter;
  patch: () => any[];
  plusMinus: (plusMinus: boolean) => IDegreeAlterBuilder;
  data: (data: string) => IDegreeAlterBuilder;
  defaultX: (defaultX: number) => IDegreeAlterBuilder;
  relativeY: (relativeY: number) => IDegreeAlterBuilder;
  defaultY: (defaultY: number) => IDegreeAlterBuilder;
  relativeX: (relativeX: number) => IDegreeAlterBuilder;
}
class DegreeAlterBuilder implements IDegreeAlterBuilder{
  _p: DegreeAlter = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: DegreeAlter;
  constructor(toPatch?: DegreeAlter) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["plusMinus"]) || this._b["plusMinus"] !== undefined || this._p.plusMinus !== undefined, "plusMinus is a required field");
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): DegreeAlter {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "DegreeAlter";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  plusMinus(plusMinus: boolean): IDegreeAlterBuilder {
    this._p.plusMinus = plusMinus;
    this._m["plusMinus"] = true;
    return this;
  }
  data(data: string): IDegreeAlterBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IDegreeAlterBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IDegreeAlterBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IDegreeAlterBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IDegreeAlterBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchDegreeAlter(base: DegreeAlter): IDegreeAlterBuilder { return new DegreeAlterBuilder(base); }
export function buildDegreeAlter(): IDegreeAlterBuilder { return new DegreeAlterBuilder(); }

export interface IDegreeTypeBuilder {
  build: () => DegreeType;
  patch: () => any[];
  text: (text: string) => IDegreeTypeBuilder;
  data: (data: string) => IDegreeTypeBuilder;
  defaultX: (defaultX: number) => IDegreeTypeBuilder;
  relativeY: (relativeY: number) => IDegreeTypeBuilder;
  defaultY: (defaultY: number) => IDegreeTypeBuilder;
  relativeX: (relativeX: number) => IDegreeTypeBuilder;
}
class DegreeTypeBuilder implements IDegreeTypeBuilder{
  _p: DegreeType = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: DegreeType;
  constructor(toPatch?: DegreeType) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["text"]) || this._b["text"] !== undefined || this._p.text !== undefined, "text is a required field");
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): DegreeType {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "DegreeType";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  text(text: string): IDegreeTypeBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  data(data: string): IDegreeTypeBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IDegreeTypeBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IDegreeTypeBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IDegreeTypeBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IDegreeTypeBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchDegreeType(base: DegreeType): IDegreeTypeBuilder { return new DegreeTypeBuilder(base); }
export function buildDegreeType(): IDegreeTypeBuilder { return new DegreeTypeBuilder(); }

export interface IFrameBuilder {
  build: () => Frame;
  patch: () => any[];
  frameStrings: (frameStrings: string) => IFrameBuilder;
  frameNotes: (frameNotes: FrameNote[]) => IFrameBuilder;
  unplayed: (unplayed: string) => IFrameBuilder;
  frameFrets: (frameFrets: string) => IFrameBuilder;
  firstFret: (build: (builder: IFirstFretBuilder) => IFirstFretBuilder) => IFrameBuilder;
  width: (width: number) => IFrameBuilder;
  height: (height: number) => IFrameBuilder;
  defaultX: (defaultX: number) => IFrameBuilder;
  relativeY: (relativeY: number) => IFrameBuilder;
  defaultY: (defaultY: number) => IFrameBuilder;
  relativeX: (relativeX: number) => IFrameBuilder;
}
class FrameBuilder implements IFrameBuilder{
  _p: Frame = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Frame;
  constructor(toPatch?: Frame) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["frameStrings"]) || this._b["frameStrings"] !== undefined || this._p.frameStrings !== undefined, "frameStrings is a required field");
    console.assert((this._o && !this._m["frameNotes"]) || this._b["frameNotes"] !== undefined || this._p.frameNotes !== undefined, "frameNotes is a required field");
    console.assert((this._o && !this._m["unplayed"]) || this._b["unplayed"] !== undefined || this._p.unplayed !== undefined, "unplayed is a required field");
    console.assert((this._o && !this._m["frameFrets"]) || this._b["frameFrets"] !== undefined || this._p.frameFrets !== undefined, "frameFrets is a required field");
    console.assert((this._o && !this._m["firstFret"]) || this._b["firstFret"] !== undefined || this._p.firstFret !== undefined, "firstFret is a required field");
    console.assert((this._o && !this._m["width"]) || this._b["width"] !== undefined || this._p.width !== undefined, "width is a required field");
    console.assert((this._o && !this._m["height"]) || this._b["height"] !== undefined || this._p.height !== undefined, "height is a required field");
  }
  build(): Frame {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Frame";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  frameStrings(frameStrings: string): IFrameBuilder {
    this._p.frameStrings = frameStrings;
    this._m["frameStrings"] = true;
    return this;
  }
  frameNotes(frameNotes: FrameNote[]): IFrameBuilder {
    this._p.frameNotes = frameNotes;
    this._m["frameNotes"] = true;
    return this;
  }
  unplayed(unplayed: string): IFrameBuilder {
    this._p.unplayed = unplayed;
    this._m["unplayed"] = true;
    return this;
  }
  frameFrets(frameFrets: string): IFrameBuilder {
    this._p.frameFrets = frameFrets;
    this._m["frameFrets"] = true;
    return this;
  }
  firstFret(build: (builder: IFirstFretBuilder) => IFirstFretBuilder): IFrameBuilder {
    this._b["firstFret"] = build(new FirstFretBuilder(this._o && this._o["firstFret"]));
    this._m["firstFret"] = true;
    return this;
  }
  width(width: number): IFrameBuilder {
    this._p.width = width;
    this._m["width"] = true;
    return this;
  }
  height(height: number): IFrameBuilder {
    this._p.height = height;
    this._m["height"] = true;
    return this;
  }
  defaultX(defaultX: number): IFrameBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IFrameBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IFrameBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IFrameBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchFrame(base: Frame): IFrameBuilder { return new FrameBuilder(base); }
export function buildFrame(): IFrameBuilder { return new FrameBuilder(); }

export interface IFirstFretBuilder {
  build: () => FirstFret;
  patch: () => any[];
  text: (text: string) => IFirstFretBuilder;
  location: (location: LeftRight) => IFirstFretBuilder;
  data: (data: string) => IFirstFretBuilder;
}
class FirstFretBuilder implements IFirstFretBuilder{
  _p: FirstFret = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: FirstFret;
  constructor(toPatch?: FirstFret) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["text"]) || this._b["text"] !== undefined || this._p.text !== undefined, "text is a required field");
    console.assert((this._o && !this._m["location"]) || this._b["location"] !== undefined || this._p.location !== undefined, "location is a required field");
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): FirstFret {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "FirstFret";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  text(text: string): IFirstFretBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  location(location: LeftRight): IFirstFretBuilder {
    this._p.location = location;
    this._m["location"] = true;
    return this;
  }
  data(data: string): IFirstFretBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
}
export function patchFirstFret(base: FirstFret): IFirstFretBuilder { return new FirstFretBuilder(base); }
export function buildFirstFret(): IFirstFretBuilder { return new FirstFretBuilder(); }

export interface IFrameNoteBuilder {
  build: () => FrameNote;
  patch: () => any[];
  barre: (build: (builder: IBarreBuilder) => IBarreBuilder) => IFrameNoteBuilder;
  string: (build: (builder: IStringBuilder) => IStringBuilder) => IFrameNoteBuilder;
  fingering: (build: (builder: IFingeringBuilder) => IFingeringBuilder) => IFrameNoteBuilder;
  fret: (build: (builder: IFretBuilder) => IFretBuilder) => IFrameNoteBuilder;
}
class FrameNoteBuilder implements IFrameNoteBuilder{
  _p: FrameNote = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: FrameNote;
  constructor(toPatch?: FrameNote) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["barre"]) || this._b["barre"] !== undefined || this._p.barre !== undefined, "barre is a required field");
    console.assert((this._o && !this._m["string"]) || this._b["string"] !== undefined || this._p.string !== undefined, "string is a required field");
    console.assert((this._o && !this._m["fingering"]) || this._b["fingering"] !== undefined || this._p.fingering !== undefined, "fingering is a required field");
    console.assert((this._o && !this._m["fret"]) || this._b["fret"] !== undefined || this._p.fret !== undefined, "fret is a required field");
  }
  build(): FrameNote {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "FrameNote";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  barre(build: (builder: IBarreBuilder) => IBarreBuilder): IFrameNoteBuilder {
    this._b["barre"] = build(new BarreBuilder(this._o && this._o["barre"]));
    this._m["barre"] = true;
    return this;
  }
  string(build: (builder: IStringBuilder) => IStringBuilder): IFrameNoteBuilder {
    this._b["string"] = build(new StringBuilder(this._o && this._o["string"]));
    this._m["string"] = true;
    return this;
  }
  fingering(build: (builder: IFingeringBuilder) => IFingeringBuilder): IFrameNoteBuilder {
    this._b["fingering"] = build(new FingeringBuilder(this._o && this._o["fingering"]));
    this._m["fingering"] = true;
    return this;
  }
  fret(build: (builder: IFretBuilder) => IFretBuilder): IFrameNoteBuilder {
    this._b["fret"] = build(new FretBuilder(this._o && this._o["fret"]));
    this._m["fret"] = true;
    return this;
  }
}
export function patchFrameNote(base: FrameNote): IFrameNoteBuilder { return new FrameNoteBuilder(base); }
export function buildFrameNote(): IFrameNoteBuilder { return new FrameNoteBuilder(); }

export interface IBarreBuilder {
  build: () => Barre;
  patch: () => any[];
  type: (type: StartStop) => IBarreBuilder;
  color: (color: string) => IBarreBuilder;
}
class BarreBuilder implements IBarreBuilder{
  _p: Barre = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Barre;
  constructor(toPatch?: Barre) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Barre {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Barre";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  type(type: StartStop): IBarreBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  color(color: string): IBarreBuilder {
    this._p.color = color;
    this._m["color"] = true;
    return this;
  }
}
export function patchBarre(base: Barre): IBarreBuilder { return new BarreBuilder(base); }
export function buildBarre(): IBarreBuilder { return new BarreBuilder(); }

export interface IGroupingBuilder {
  build: () => Grouping;
  patch: () => any[];
  features: (features: Feature[]) => IGroupingBuilder;
  number: (number: number) => IGroupingBuilder;
  type: (type: StartStopSingle) => IGroupingBuilder;
  memberOf: (memberOf: string) => IGroupingBuilder;
  _class: (_class: string) => IGroupingBuilder;
}
class GroupingBuilder implements IGroupingBuilder{
  _p: Grouping = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Grouping;
  constructor(toPatch?: Grouping) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["features"]) || this._b["features"] !== undefined || this._p.features !== undefined, "features is a required field");
    console.assert((this._o && !this._m["number"]) || this._b["number"] !== undefined || this._p.number !== undefined, "number is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
    console.assert((this._o && !this._m["memberOf"]) || this._b["memberOf"] !== undefined || this._p.memberOf !== undefined, "memberOf is a required field");
  }
  build(): Grouping {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Grouping";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  features(features: Feature[]): IGroupingBuilder {
    this._p.features = features;
    this._m["features"] = true;
    return this;
  }
  number(number: number): IGroupingBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  type(type: StartStopSingle): IGroupingBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  memberOf(memberOf: string): IGroupingBuilder {
    this._p.memberOf = memberOf;
    this._m["memberOf"] = true;
    return this;
  }
  _class(_class: string): IGroupingBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchGrouping(base: Grouping): IGroupingBuilder { return new GroupingBuilder(base); }
export function buildGrouping(): IGroupingBuilder { return new GroupingBuilder(); }

export interface IFeatureBuilder {
  build: () => Feature;
  patch: () => any[];
  data: (data: string) => IFeatureBuilder;
  type: (type: string) => IFeatureBuilder;
}
class FeatureBuilder implements IFeatureBuilder{
  _p: Feature = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Feature;
  constructor(toPatch?: Feature) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
  }
  build(): Feature {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Feature";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IFeatureBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  type(type: string): IFeatureBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
}
export function patchFeature(base: Feature): IFeatureBuilder { return new FeatureBuilder(base); }
export function buildFeature(): IFeatureBuilder { return new FeatureBuilder(); }

export interface IPrintBuilder {
  build: () => Print;
  patch: () => any[];
  measureNumbering: (build: (builder: IMeasureNumberingBuilder) => IMeasureNumberingBuilder) => IPrintBuilder;
  partNameDisplay: (build: (builder: IPartNameDisplayBuilder) => IPartNameDisplayBuilder) => IPrintBuilder;
  newSystem: (newSystem: boolean) => IPrintBuilder;
  newPage: (newPage: boolean) => IPrintBuilder;
  blankPage: (blankPage: string) => IPrintBuilder;
  measureLayout: (build: (builder: IMeasureLayoutBuilder) => IMeasureLayoutBuilder) => IPrintBuilder;
  partAbbreviationDisplay: (build: (builder: IPartAbbreviationDisplayBuilder) => IPartAbbreviationDisplayBuilder) => IPrintBuilder;
  pageLayout: (build: (builder: IPageLayoutBuilder) => IPageLayoutBuilder) => IPrintBuilder;
  systemLayout: (build: (builder: ISystemLayoutBuilder) => ISystemLayoutBuilder) => IPrintBuilder;
  staffSpacing: (staffSpacing: number) => IPrintBuilder;
  staffLayouts: (staffLayouts: StaffLayout[]) => IPrintBuilder;
  pageNumber: (pageNumber: string) => IPrintBuilder;
  _class: (_class: string) => IPrintBuilder;
}
class PrintBuilder implements IPrintBuilder{
  _p: Print = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Print;
  constructor(toPatch?: Print) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["measureNumbering"]) || this._b["measureNumbering"] !== undefined || this._p.measureNumbering !== undefined, "measureNumbering is a required field");
    console.assert((this._o && !this._m["partNameDisplay"]) || this._b["partNameDisplay"] !== undefined || this._p.partNameDisplay !== undefined, "partNameDisplay is a required field");
    console.assert((this._o && !this._m["newSystem"]) || this._b["newSystem"] !== undefined || this._p.newSystem !== undefined, "newSystem is a required field");
    console.assert((this._o && !this._m["newPage"]) || this._b["newPage"] !== undefined || this._p.newPage !== undefined, "newPage is a required field");
    console.assert((this._o && !this._m["blankPage"]) || this._b["blankPage"] !== undefined || this._p.blankPage !== undefined, "blankPage is a required field");
    console.assert((this._o && !this._m["measureLayout"]) || this._b["measureLayout"] !== undefined || this._p.measureLayout !== undefined, "measureLayout is a required field");
    console.assert((this._o && !this._m["partAbbreviationDisplay"]) || this._b["partAbbreviationDisplay"] !== undefined || this._p.partAbbreviationDisplay !== undefined, "partAbbreviationDisplay is a required field");
    console.assert((this._o && !this._m["pageLayout"]) || this._b["pageLayout"] !== undefined || this._p.pageLayout !== undefined, "pageLayout is a required field");
    console.assert((this._o && !this._m["systemLayout"]) || this._b["systemLayout"] !== undefined || this._p.systemLayout !== undefined, "systemLayout is a required field");
    console.assert((this._o && !this._m["staffSpacing"]) || this._b["staffSpacing"] !== undefined || this._p.staffSpacing !== undefined, "staffSpacing is a required field");
    console.assert((this._o && !this._m["staffLayouts"]) || this._b["staffLayouts"] !== undefined || this._p.staffLayouts !== undefined, "staffLayouts is a required field");
    console.assert((this._o && !this._m["pageNumber"]) || this._b["pageNumber"] !== undefined || this._p.pageNumber !== undefined, "pageNumber is a required field");
  }
  build(): Print {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Print";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  measureNumbering(build: (builder: IMeasureNumberingBuilder) => IMeasureNumberingBuilder): IPrintBuilder {
    this._b["measureNumbering"] = build(new MeasureNumberingBuilder(this._o && this._o["measureNumbering"]));
    this._m["measureNumbering"] = true;
    return this;
  }
  partNameDisplay(build: (builder: IPartNameDisplayBuilder) => IPartNameDisplayBuilder): IPrintBuilder {
    this._b["partNameDisplay"] = build(new PartNameDisplayBuilder(this._o && this._o["partNameDisplay"]));
    this._m["partNameDisplay"] = true;
    return this;
  }
  newSystem(newSystem: boolean): IPrintBuilder {
    this._p.newSystem = newSystem;
    this._m["newSystem"] = true;
    return this;
  }
  newPage(newPage: boolean): IPrintBuilder {
    this._p.newPage = newPage;
    this._m["newPage"] = true;
    return this;
  }
  blankPage(blankPage: string): IPrintBuilder {
    this._p.blankPage = blankPage;
    this._m["blankPage"] = true;
    return this;
  }
  measureLayout(build: (builder: IMeasureLayoutBuilder) => IMeasureLayoutBuilder): IPrintBuilder {
    this._b["measureLayout"] = build(new MeasureLayoutBuilder(this._o && this._o["measureLayout"]));
    this._m["measureLayout"] = true;
    return this;
  }
  partAbbreviationDisplay(build: (builder: IPartAbbreviationDisplayBuilder) => IPartAbbreviationDisplayBuilder): IPrintBuilder {
    this._b["partAbbreviationDisplay"] = build(new PartAbbreviationDisplayBuilder(this._o && this._o["partAbbreviationDisplay"]));
    this._m["partAbbreviationDisplay"] = true;
    return this;
  }
  pageLayout(build: (builder: IPageLayoutBuilder) => IPageLayoutBuilder): IPrintBuilder {
    this._b["pageLayout"] = build(new PageLayoutBuilder(this._o && this._o["pageLayout"]));
    this._m["pageLayout"] = true;
    return this;
  }
  systemLayout(build: (builder: ISystemLayoutBuilder) => ISystemLayoutBuilder): IPrintBuilder {
    this._b["systemLayout"] = build(new SystemLayoutBuilder(this._o && this._o["systemLayout"]));
    this._m["systemLayout"] = true;
    return this;
  }
  staffSpacing(staffSpacing: number): IPrintBuilder {
    this._p.staffSpacing = staffSpacing;
    this._m["staffSpacing"] = true;
    return this;
  }
  staffLayouts(staffLayouts: StaffLayout[]): IPrintBuilder {
    this._p.staffLayouts = staffLayouts;
    this._m["staffLayouts"] = true;
    return this;
  }
  pageNumber(pageNumber: string): IPrintBuilder {
    this._p.pageNumber = pageNumber;
    this._m["pageNumber"] = true;
    return this;
  }
  _class(_class: string): IPrintBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchPrint(base: Print): IPrintBuilder { return new PrintBuilder(base); }
export function buildPrint(): IPrintBuilder { return new PrintBuilder(); }

export interface IMeasureNumberingBuilder {
  build: () => MeasureNumbering;
  patch: () => any[];
  data: (data: string) => IMeasureNumberingBuilder;
  defaultX: (defaultX: number) => IMeasureNumberingBuilder;
  relativeY: (relativeY: number) => IMeasureNumberingBuilder;
  defaultY: (defaultY: number) => IMeasureNumberingBuilder;
  relativeX: (relativeX: number) => IMeasureNumberingBuilder;
}
class MeasureNumberingBuilder implements IMeasureNumberingBuilder{
  _p: MeasureNumbering = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: MeasureNumbering;
  constructor(toPatch?: MeasureNumbering) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): MeasureNumbering {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "MeasureNumbering";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IMeasureNumberingBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IMeasureNumberingBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IMeasureNumberingBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IMeasureNumberingBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IMeasureNumberingBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchMeasureNumbering(base: MeasureNumbering): IMeasureNumberingBuilder { return new MeasureNumberingBuilder(base); }
export function buildMeasureNumbering(): IMeasureNumberingBuilder { return new MeasureNumberingBuilder(); }

export interface ISoundBuilder {
  build: () => Sound;
  patch: () => any[];
  softPedal: (softPedal: string) => ISoundBuilder;
  midiInstruments: (midiInstruments: MidiInstrument[]) => ISoundBuilder;
  pan: (pan: string) => ISoundBuilder;
  tocoda: (tocoda: string) => ISoundBuilder;
  decapo: (decapo: boolean) => ISoundBuilder;
  divisions: (divisions: number) => ISoundBuilder;
  pizzicato: (pizzicato: boolean) => ISoundBuilder;
  coda: (coda: string) => ISoundBuilder;
  segno: (segno: string) => ISoundBuilder;
  elevation: (elevation: string) => ISoundBuilder;
  fine: (fine: string) => ISoundBuilder;
  damperPedal: (damperPedal: string) => ISoundBuilder;
  dynamics: (dynamics: string) => ISoundBuilder;
  plays: (plays: Play[]) => ISoundBuilder;
  offset: (build: (builder: IOffsetBuilder) => IOffsetBuilder) => ISoundBuilder;
  sostenutoPedal: (sostenutoPedal: string) => ISoundBuilder;
  dalsegno: (dalsegno: string) => ISoundBuilder;
  midiDevices: (midiDevices: MidiDevice[]) => ISoundBuilder;
  tempo: (tempo: string) => ISoundBuilder;
  forwardRepeat: (forwardRepeat: boolean) => ISoundBuilder;
  _class: (_class: string) => ISoundBuilder;
  timeOnly: (timeOnly: string) => ISoundBuilder;
}
class SoundBuilder implements ISoundBuilder{
  _p: Sound = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Sound;
  constructor(toPatch?: Sound) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["softPedal"]) || this._b["softPedal"] !== undefined || this._p.softPedal !== undefined, "softPedal is a required field");
    console.assert((this._o && !this._m["midiInstruments"]) || this._b["midiInstruments"] !== undefined || this._p.midiInstruments !== undefined, "midiInstruments is a required field");
    console.assert((this._o && !this._m["pan"]) || this._b["pan"] !== undefined || this._p.pan !== undefined, "pan is a required field");
    console.assert((this._o && !this._m["tocoda"]) || this._b["tocoda"] !== undefined || this._p.tocoda !== undefined, "tocoda is a required field");
    console.assert((this._o && !this._m["decapo"]) || this._b["decapo"] !== undefined || this._p.decapo !== undefined, "decapo is a required field");
    console.assert((this._o && !this._m["divisions"]) || this._b["divisions"] !== undefined || this._p.divisions !== undefined, "divisions is a required field");
    console.assert((this._o && !this._m["pizzicato"]) || this._b["pizzicato"] !== undefined || this._p.pizzicato !== undefined, "pizzicato is a required field");
    console.assert((this._o && !this._m["coda"]) || this._b["coda"] !== undefined || this._p.coda !== undefined, "coda is a required field");
    console.assert((this._o && !this._m["segno"]) || this._b["segno"] !== undefined || this._p.segno !== undefined, "segno is a required field");
    console.assert((this._o && !this._m["elevation"]) || this._b["elevation"] !== undefined || this._p.elevation !== undefined, "elevation is a required field");
    console.assert((this._o && !this._m["fine"]) || this._b["fine"] !== undefined || this._p.fine !== undefined, "fine is a required field");
    console.assert((this._o && !this._m["damperPedal"]) || this._b["damperPedal"] !== undefined || this._p.damperPedal !== undefined, "damperPedal is a required field");
    console.assert((this._o && !this._m["dynamics"]) || this._b["dynamics"] !== undefined || this._p.dynamics !== undefined, "dynamics is a required field");
    console.assert((this._o && !this._m["plays"]) || this._b["plays"] !== undefined || this._p.plays !== undefined, "plays is a required field");
    console.assert((this._o && !this._m["offset"]) || this._b["offset"] !== undefined || this._p.offset !== undefined, "offset is a required field");
    console.assert((this._o && !this._m["sostenutoPedal"]) || this._b["sostenutoPedal"] !== undefined || this._p.sostenutoPedal !== undefined, "sostenutoPedal is a required field");
    console.assert((this._o && !this._m["dalsegno"]) || this._b["dalsegno"] !== undefined || this._p.dalsegno !== undefined, "dalsegno is a required field");
    console.assert((this._o && !this._m["midiDevices"]) || this._b["midiDevices"] !== undefined || this._p.midiDevices !== undefined, "midiDevices is a required field");
    console.assert((this._o && !this._m["tempo"]) || this._b["tempo"] !== undefined || this._p.tempo !== undefined, "tempo is a required field");
    console.assert((this._o && !this._m["forwardRepeat"]) || this._b["forwardRepeat"] !== undefined || this._p.forwardRepeat !== undefined, "forwardRepeat is a required field");
  }
  build(): Sound {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Sound";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  softPedal(softPedal: string): ISoundBuilder {
    this._p.softPedal = softPedal;
    this._m["softPedal"] = true;
    return this;
  }
  midiInstruments(midiInstruments: MidiInstrument[]): ISoundBuilder {
    this._p.midiInstruments = midiInstruments;
    this._m["midiInstruments"] = true;
    return this;
  }
  pan(pan: string): ISoundBuilder {
    this._p.pan = pan;
    this._m["pan"] = true;
    return this;
  }
  tocoda(tocoda: string): ISoundBuilder {
    this._p.tocoda = tocoda;
    this._m["tocoda"] = true;
    return this;
  }
  decapo(decapo: boolean): ISoundBuilder {
    this._p.decapo = decapo;
    this._m["decapo"] = true;
    return this;
  }
  divisions(divisions: number): ISoundBuilder {
    this._p.divisions = divisions;
    this._m["divisions"] = true;
    return this;
  }
  pizzicato(pizzicato: boolean): ISoundBuilder {
    this._p.pizzicato = pizzicato;
    this._m["pizzicato"] = true;
    return this;
  }
  coda(coda: string): ISoundBuilder {
    this._p.coda = coda;
    this._m["coda"] = true;
    return this;
  }
  segno(segno: string): ISoundBuilder {
    this._p.segno = segno;
    this._m["segno"] = true;
    return this;
  }
  elevation(elevation: string): ISoundBuilder {
    this._p.elevation = elevation;
    this._m["elevation"] = true;
    return this;
  }
  fine(fine: string): ISoundBuilder {
    this._p.fine = fine;
    this._m["fine"] = true;
    return this;
  }
  damperPedal(damperPedal: string): ISoundBuilder {
    this._p.damperPedal = damperPedal;
    this._m["damperPedal"] = true;
    return this;
  }
  dynamics(dynamics: string): ISoundBuilder {
    this._p.dynamics = dynamics;
    this._m["dynamics"] = true;
    return this;
  }
  plays(plays: Play[]): ISoundBuilder {
    this._p.plays = plays;
    this._m["plays"] = true;
    return this;
  }
  offset(build: (builder: IOffsetBuilder) => IOffsetBuilder): ISoundBuilder {
    this._b["offset"] = build(new OffsetBuilder(this._o && this._o["offset"]));
    this._m["offset"] = true;
    return this;
  }
  sostenutoPedal(sostenutoPedal: string): ISoundBuilder {
    this._p.sostenutoPedal = sostenutoPedal;
    this._m["sostenutoPedal"] = true;
    return this;
  }
  dalsegno(dalsegno: string): ISoundBuilder {
    this._p.dalsegno = dalsegno;
    this._m["dalsegno"] = true;
    return this;
  }
  midiDevices(midiDevices: MidiDevice[]): ISoundBuilder {
    this._p.midiDevices = midiDevices;
    this._m["midiDevices"] = true;
    return this;
  }
  tempo(tempo: string): ISoundBuilder {
    this._p.tempo = tempo;
    this._m["tempo"] = true;
    return this;
  }
  forwardRepeat(forwardRepeat: boolean): ISoundBuilder {
    this._p.forwardRepeat = forwardRepeat;
    this._m["forwardRepeat"] = true;
    return this;
  }
  _class(_class: string): ISoundBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
  timeOnly(timeOnly: string): ISoundBuilder {
    this._p.timeOnly = timeOnly;
    this._m["timeOnly"] = true;
    return this;
  }
}
export function patchSound(base: Sound): ISoundBuilder { return new SoundBuilder(base); }
export function buildSound(): ISoundBuilder { return new SoundBuilder(); }

export interface IWorkBuilder {
  build: () => Work;
  patch: () => any[];
  workNumber: (workNumber: string) => IWorkBuilder;
  workTitle: (workTitle: string) => IWorkBuilder;
  opus: (build: (builder: IOpusBuilder) => IOpusBuilder) => IWorkBuilder;
}
class WorkBuilder implements IWorkBuilder{
  _p: Work = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Work;
  constructor(toPatch?: Work) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["workNumber"]) || this._b["workNumber"] !== undefined || this._p.workNumber !== undefined, "workNumber is a required field");
    console.assert((this._o && !this._m["workTitle"]) || this._b["workTitle"] !== undefined || this._p.workTitle !== undefined, "workTitle is a required field");
    console.assert((this._o && !this._m["opus"]) || this._b["opus"] !== undefined || this._p.opus !== undefined, "opus is a required field");
  }
  build(): Work {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Work";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  workNumber(workNumber: string): IWorkBuilder {
    this._p.workNumber = workNumber;
    this._m["workNumber"] = true;
    return this;
  }
  workTitle(workTitle: string): IWorkBuilder {
    this._p.workTitle = workTitle;
    this._m["workTitle"] = true;
    return this;
  }
  opus(build: (builder: IOpusBuilder) => IOpusBuilder): IWorkBuilder {
    this._b["opus"] = build(new OpusBuilder(this._o && this._o["opus"]));
    this._m["opus"] = true;
    return this;
  }
}
export function patchWork(base: Work): IWorkBuilder { return new WorkBuilder(base); }
export function buildWork(): IWorkBuilder { return new WorkBuilder(); }

export interface IOpusBuilder {
  build: () => Opus;
  patch: () => any[];
}
class OpusBuilder implements IOpusBuilder{
  _p: Opus = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Opus;
  constructor(toPatch?: Opus) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Opus {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Opus";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
}
export function patchOpus(base: Opus): IOpusBuilder { return new OpusBuilder(base); }
export function buildOpus(): IOpusBuilder { return new OpusBuilder(); }

export interface IDefaultsBuilder {
  build: () => Defaults;
  patch: () => any[];
  wordFont: (build: (builder: IWordFontBuilder) => IWordFontBuilder) => IDefaultsBuilder;
  lyricLanguages: (lyricLanguages: LyricLanguage[]) => IDefaultsBuilder;
  lyricFonts: (lyricFonts: LyricFont[]) => IDefaultsBuilder;
  pageLayout: (build: (builder: IPageLayoutBuilder) => IPageLayoutBuilder) => IDefaultsBuilder;
  systemLayout: (build: (builder: ISystemLayoutBuilder) => ISystemLayoutBuilder) => IDefaultsBuilder;
  appearance: (build: (builder: IAppearanceBuilder) => IAppearanceBuilder) => IDefaultsBuilder;
  scaling: (build: (builder: IScalingBuilder) => IScalingBuilder) => IDefaultsBuilder;
  staffLayouts: (staffLayouts: StaffLayout[]) => IDefaultsBuilder;
  musicFont: (build: (builder: IMusicFontBuilder) => IMusicFontBuilder) => IDefaultsBuilder;
}
class DefaultsBuilder implements IDefaultsBuilder{
  _p: Defaults = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Defaults;
  constructor(toPatch?: Defaults) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["wordFont"]) || this._b["wordFont"] !== undefined || this._p.wordFont !== undefined, "wordFont is a required field");
    console.assert((this._o && !this._m["lyricLanguages"]) || this._b["lyricLanguages"] !== undefined || this._p.lyricLanguages !== undefined, "lyricLanguages is a required field");
    console.assert((this._o && !this._m["lyricFonts"]) || this._b["lyricFonts"] !== undefined || this._p.lyricFonts !== undefined, "lyricFonts is a required field");
    console.assert((this._o && !this._m["pageLayout"]) || this._b["pageLayout"] !== undefined || this._p.pageLayout !== undefined, "pageLayout is a required field");
    console.assert((this._o && !this._m["systemLayout"]) || this._b["systemLayout"] !== undefined || this._p.systemLayout !== undefined, "systemLayout is a required field");
    console.assert((this._o && !this._m["appearance"]) || this._b["appearance"] !== undefined || this._p.appearance !== undefined, "appearance is a required field");
    console.assert((this._o && !this._m["scaling"]) || this._b["scaling"] !== undefined || this._p.scaling !== undefined, "scaling is a required field");
    console.assert((this._o && !this._m["staffLayouts"]) || this._b["staffLayouts"] !== undefined || this._p.staffLayouts !== undefined, "staffLayouts is a required field");
    console.assert((this._o && !this._m["musicFont"]) || this._b["musicFont"] !== undefined || this._p.musicFont !== undefined, "musicFont is a required field");
  }
  build(): Defaults {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Defaults";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  wordFont(build: (builder: IWordFontBuilder) => IWordFontBuilder): IDefaultsBuilder {
    this._b["wordFont"] = build(new WordFontBuilder(this._o && this._o["wordFont"]));
    this._m["wordFont"] = true;
    return this;
  }
  lyricLanguages(lyricLanguages: LyricLanguage[]): IDefaultsBuilder {
    this._p.lyricLanguages = lyricLanguages;
    this._m["lyricLanguages"] = true;
    return this;
  }
  lyricFonts(lyricFonts: LyricFont[]): IDefaultsBuilder {
    this._p.lyricFonts = lyricFonts;
    this._m["lyricFonts"] = true;
    return this;
  }
  pageLayout(build: (builder: IPageLayoutBuilder) => IPageLayoutBuilder): IDefaultsBuilder {
    this._b["pageLayout"] = build(new PageLayoutBuilder(this._o && this._o["pageLayout"]));
    this._m["pageLayout"] = true;
    return this;
  }
  systemLayout(build: (builder: ISystemLayoutBuilder) => ISystemLayoutBuilder): IDefaultsBuilder {
    this._b["systemLayout"] = build(new SystemLayoutBuilder(this._o && this._o["systemLayout"]));
    this._m["systemLayout"] = true;
    return this;
  }
  appearance(build: (builder: IAppearanceBuilder) => IAppearanceBuilder): IDefaultsBuilder {
    this._b["appearance"] = build(new AppearanceBuilder(this._o && this._o["appearance"]));
    this._m["appearance"] = true;
    return this;
  }
  scaling(build: (builder: IScalingBuilder) => IScalingBuilder): IDefaultsBuilder {
    this._b["scaling"] = build(new ScalingBuilder(this._o && this._o["scaling"]));
    this._m["scaling"] = true;
    return this;
  }
  staffLayouts(staffLayouts: StaffLayout[]): IDefaultsBuilder {
    this._p.staffLayouts = staffLayouts;
    this._m["staffLayouts"] = true;
    return this;
  }
  musicFont(build: (builder: IMusicFontBuilder) => IMusicFontBuilder): IDefaultsBuilder {
    this._b["musicFont"] = build(new MusicFontBuilder(this._o && this._o["musicFont"]));
    this._m["musicFont"] = true;
    return this;
  }
}
export function patchDefaults(base: Defaults): IDefaultsBuilder { return new DefaultsBuilder(base); }
export function buildDefaults(): IDefaultsBuilder { return new DefaultsBuilder(); }

export interface IMusicFontBuilder {
  build: () => MusicFont;
  patch: () => any[];
  fontFamily: (fontFamily: string) => IMusicFontBuilder;
  fontWeight: (fontWeight: NormalBold) => IMusicFontBuilder;
  fontStyle: (fontStyle: NormalItalic) => IMusicFontBuilder;
  fontSize: (fontSize: string) => IMusicFontBuilder;
}
class MusicFontBuilder implements IMusicFontBuilder{
  _p: MusicFont = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: MusicFont;
  constructor(toPatch?: MusicFont) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): MusicFont {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "MusicFont";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  fontFamily(fontFamily: string): IMusicFontBuilder {
    this._p.fontFamily = fontFamily;
    this._m["fontFamily"] = true;
    return this;
  }
  fontWeight(fontWeight: NormalBold): IMusicFontBuilder {
    this._p.fontWeight = fontWeight;
    this._m["fontWeight"] = true;
    return this;
  }
  fontStyle(fontStyle: NormalItalic): IMusicFontBuilder {
    this._p.fontStyle = fontStyle;
    this._m["fontStyle"] = true;
    return this;
  }
  fontSize(fontSize: string): IMusicFontBuilder {
    this._p.fontSize = fontSize;
    this._m["fontSize"] = true;
    return this;
  }
}
export function patchMusicFont(base: MusicFont): IMusicFontBuilder { return new MusicFontBuilder(base); }
export function buildMusicFont(): IMusicFontBuilder { return new MusicFontBuilder(); }

export interface IWordFontBuilder {
  build: () => WordFont;
  patch: () => any[];
  fontFamily: (fontFamily: string) => IWordFontBuilder;
  fontWeight: (fontWeight: NormalBold) => IWordFontBuilder;
  fontStyle: (fontStyle: NormalItalic) => IWordFontBuilder;
  fontSize: (fontSize: string) => IWordFontBuilder;
}
class WordFontBuilder implements IWordFontBuilder{
  _p: WordFont = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: WordFont;
  constructor(toPatch?: WordFont) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): WordFont {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "WordFont";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  fontFamily(fontFamily: string): IWordFontBuilder {
    this._p.fontFamily = fontFamily;
    this._m["fontFamily"] = true;
    return this;
  }
  fontWeight(fontWeight: NormalBold): IWordFontBuilder {
    this._p.fontWeight = fontWeight;
    this._m["fontWeight"] = true;
    return this;
  }
  fontStyle(fontStyle: NormalItalic): IWordFontBuilder {
    this._p.fontStyle = fontStyle;
    this._m["fontStyle"] = true;
    return this;
  }
  fontSize(fontSize: string): IWordFontBuilder {
    this._p.fontSize = fontSize;
    this._m["fontSize"] = true;
    return this;
  }
}
export function patchWordFont(base: WordFont): IWordFontBuilder { return new WordFontBuilder(base); }
export function buildWordFont(): IWordFontBuilder { return new WordFontBuilder(); }

export interface ILyricFontBuilder {
  build: () => LyricFont;
  patch: () => any[];
  number: (number: number) => ILyricFontBuilder;
  name: (name: string) => ILyricFontBuilder;
  fontFamily: (fontFamily: string) => ILyricFontBuilder;
  fontWeight: (fontWeight: NormalBold) => ILyricFontBuilder;
  fontStyle: (fontStyle: NormalItalic) => ILyricFontBuilder;
  fontSize: (fontSize: string) => ILyricFontBuilder;
}
class LyricFontBuilder implements ILyricFontBuilder{
  _p: LyricFont = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: LyricFont;
  constructor(toPatch?: LyricFont) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["number"]) || this._b["number"] !== undefined || this._p.number !== undefined, "number is a required field");
    console.assert((this._o && !this._m["name"]) || this._b["name"] !== undefined || this._p.name !== undefined, "name is a required field");
  }
  build(): LyricFont {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "LyricFont";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: number): ILyricFontBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  name(name: string): ILyricFontBuilder {
    this._p.name = name;
    this._m["name"] = true;
    return this;
  }
  fontFamily(fontFamily: string): ILyricFontBuilder {
    this._p.fontFamily = fontFamily;
    this._m["fontFamily"] = true;
    return this;
  }
  fontWeight(fontWeight: NormalBold): ILyricFontBuilder {
    this._p.fontWeight = fontWeight;
    this._m["fontWeight"] = true;
    return this;
  }
  fontStyle(fontStyle: NormalItalic): ILyricFontBuilder {
    this._p.fontStyle = fontStyle;
    this._m["fontStyle"] = true;
    return this;
  }
  fontSize(fontSize: string): ILyricFontBuilder {
    this._p.fontSize = fontSize;
    this._m["fontSize"] = true;
    return this;
  }
}
export function patchLyricFont(base: LyricFont): ILyricFontBuilder { return new LyricFontBuilder(base); }
export function buildLyricFont(): ILyricFontBuilder { return new LyricFontBuilder(); }

export interface ILyricLanguageBuilder {
  build: () => LyricLanguage;
  patch: () => any[];
  number: (number: number) => ILyricLanguageBuilder;
  name: (name: string) => ILyricLanguageBuilder;
}
class LyricLanguageBuilder implements ILyricLanguageBuilder{
  _p: LyricLanguage = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: LyricLanguage;
  constructor(toPatch?: LyricLanguage) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["number"]) || this._b["number"] !== undefined || this._p.number !== undefined, "number is a required field");
    console.assert((this._o && !this._m["name"]) || this._b["name"] !== undefined || this._p.name !== undefined, "name is a required field");
  }
  build(): LyricLanguage {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "LyricLanguage";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: number): ILyricLanguageBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  name(name: string): ILyricLanguageBuilder {
    this._p.name = name;
    this._m["name"] = true;
    return this;
  }
}
export function patchLyricLanguage(base: LyricLanguage): ILyricLanguageBuilder { return new LyricLanguageBuilder(base); }
export function buildLyricLanguage(): ILyricLanguageBuilder { return new LyricLanguageBuilder(); }

export interface ICreditBuilder {
  build: () => Credit;
  patch: () => any[];
  creditTypes: (creditTypes: string[]) => ICreditBuilder;
  creditWords: (creditWords: CreditWords[]) => ICreditBuilder;
  creditImage: (build: (builder: ICreditImageBuilder) => ICreditImageBuilder) => ICreditBuilder;
  page: (page: number) => ICreditBuilder;
}
class CreditBuilder implements ICreditBuilder{
  _p: Credit = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Credit;
  constructor(toPatch?: Credit) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["creditTypes"]) || this._b["creditTypes"] !== undefined || this._p.creditTypes !== undefined, "creditTypes is a required field");
    console.assert((this._o && !this._m["creditWords"]) || this._b["creditWords"] !== undefined || this._p.creditWords !== undefined, "creditWords is a required field");
    console.assert((this._o && !this._m["creditImage"]) || this._b["creditImage"] !== undefined || this._p.creditImage !== undefined, "creditImage is a required field");
    console.assert((this._o && !this._m["page"]) || this._b["page"] !== undefined || this._p.page !== undefined, "page is a required field");
  }
  build(): Credit {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Credit";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  creditTypes(creditTypes: string[]): ICreditBuilder {
    this._p.creditTypes = creditTypes;
    this._m["creditTypes"] = true;
    return this;
  }
  creditWords(creditWords: CreditWords[]): ICreditBuilder {
    this._p.creditWords = creditWords;
    this._m["creditWords"] = true;
    return this;
  }
  creditImage(build: (builder: ICreditImageBuilder) => ICreditImageBuilder): ICreditBuilder {
    this._b["creditImage"] = build(new CreditImageBuilder(this._o && this._o["creditImage"]));
    this._m["creditImage"] = true;
    return this;
  }
  page(page: number): ICreditBuilder {
    this._p.page = page;
    this._m["page"] = true;
    return this;
  }
}
export function patchCredit(base: Credit): ICreditBuilder { return new CreditBuilder(base); }
export function buildCredit(): ICreditBuilder { return new CreditBuilder(); }

export interface ICreditWordsBuilder {
  build: () => CreditWords;
  patch: () => any[];
  words: (words: string) => ICreditWordsBuilder;
  justify: (justify: LeftCenterRight) => ICreditWordsBuilder;
}
class CreditWordsBuilder implements ICreditWordsBuilder{
  _p: CreditWords = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: CreditWords;
  constructor(toPatch?: CreditWords) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["words"]) || this._b["words"] !== undefined || this._p.words !== undefined, "words is a required field");
  }
  build(): CreditWords {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "CreditWords";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  words(words: string): ICreditWordsBuilder {
    this._p.words = words;
    this._m["words"] = true;
    return this;
  }
  justify(justify: LeftCenterRight): ICreditWordsBuilder {
    this._p.justify = justify;
    this._m["justify"] = true;
    return this;
  }
}
export function patchCreditWords(base: CreditWords): ICreditWordsBuilder { return new CreditWordsBuilder(base); }
export function buildCreditWords(): ICreditWordsBuilder { return new CreditWordsBuilder(); }

export interface ICreditImageBuilder {
  build: () => CreditImage;
  patch: () => any[];
  type: (type: string) => ICreditImageBuilder;
  source: (source: string) => ICreditImageBuilder;
  defaultX: (defaultX: number) => ICreditImageBuilder;
  relativeY: (relativeY: number) => ICreditImageBuilder;
  defaultY: (defaultY: number) => ICreditImageBuilder;
  relativeX: (relativeX: number) => ICreditImageBuilder;
}
class CreditImageBuilder implements ICreditImageBuilder{
  _p: CreditImage = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: CreditImage;
  constructor(toPatch?: CreditImage) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
    console.assert((this._o && !this._m["source"]) || this._b["source"] !== undefined || this._p.source !== undefined, "source is a required field");
  }
  build(): CreditImage {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "CreditImage";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  type(type: string): ICreditImageBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  source(source: string): ICreditImageBuilder {
    this._p.source = source;
    this._m["source"] = true;
    return this;
  }
  defaultX(defaultX: number): ICreditImageBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): ICreditImageBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): ICreditImageBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): ICreditImageBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchCreditImage(base: CreditImage): ICreditImageBuilder { return new CreditImageBuilder(base); }
export function buildCreditImage(): ICreditImageBuilder { return new CreditImageBuilder(); }

export interface IScorePartBuilder {
  build: () => ScorePart;
  patch: () => any[];
  identification: (build: (builder: IIdentificationBuilder) => IIdentificationBuilder) => IScorePartBuilder;
  partNameDisplay: (build: (builder: IPartNameDisplayBuilder) => IPartNameDisplayBuilder) => IScorePartBuilder;
  scoreInstruments: (scoreInstruments: ScoreInstrument[]) => IScorePartBuilder;
  midiDevices: (midiDevices: MidiDevice[]) => IScorePartBuilder;
  partName: (build: (builder: IPartNameBuilder) => IPartNameBuilder) => IScorePartBuilder;
  partAbbreviationDisplay: (build: (builder: IPartAbbreviationDisplayBuilder) => IPartAbbreviationDisplayBuilder) => IScorePartBuilder;
  partAbbreviation: (build: (builder: IPartAbbreviationBuilder) => IPartAbbreviationBuilder) => IScorePartBuilder;
  groups: (groups: string[]) => IScorePartBuilder;
  midiInstruments: (midiInstruments: MidiInstrument[]) => IScorePartBuilder;
  id: (id: string) => IScorePartBuilder;
  _class: (_class: string) => IScorePartBuilder;
}
class ScorePartBuilder implements IScorePartBuilder{
  _p: ScorePart = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: ScorePart;
  constructor(toPatch?: ScorePart) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["identification"]) || this._b["identification"] !== undefined || this._p.identification !== undefined, "identification is a required field");
    console.assert((this._o && !this._m["partNameDisplay"]) || this._b["partNameDisplay"] !== undefined || this._p.partNameDisplay !== undefined, "partNameDisplay is a required field");
    console.assert((this._o && !this._m["scoreInstruments"]) || this._b["scoreInstruments"] !== undefined || this._p.scoreInstruments !== undefined, "scoreInstruments is a required field");
    console.assert((this._o && !this._m["midiDevices"]) || this._b["midiDevices"] !== undefined || this._p.midiDevices !== undefined, "midiDevices is a required field");
    console.assert((this._o && !this._m["partName"]) || this._b["partName"] !== undefined || this._p.partName !== undefined, "partName is a required field");
    console.assert((this._o && !this._m["partAbbreviationDisplay"]) || this._b["partAbbreviationDisplay"] !== undefined || this._p.partAbbreviationDisplay !== undefined, "partAbbreviationDisplay is a required field");
    console.assert((this._o && !this._m["partAbbreviation"]) || this._b["partAbbreviation"] !== undefined || this._p.partAbbreviation !== undefined, "partAbbreviation is a required field");
    console.assert((this._o && !this._m["groups"]) || this._b["groups"] !== undefined || this._p.groups !== undefined, "groups is a required field");
    console.assert((this._o && !this._m["midiInstruments"]) || this._b["midiInstruments"] !== undefined || this._p.midiInstruments !== undefined, "midiInstruments is a required field");
    console.assert((this._o && !this._m["id"]) || this._b["id"] !== undefined || this._p.id !== undefined, "id is a required field");
    console.assert((this._o && !this._m["_class"]) || this._b["_class"] !== undefined || this._p._class !== undefined, "_class is a required field");
  }
  build(): ScorePart {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "ScorePart";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  identification(build: (builder: IIdentificationBuilder) => IIdentificationBuilder): IScorePartBuilder {
    this._b["identification"] = build(new IdentificationBuilder(this._o && this._o["identification"]));
    this._m["identification"] = true;
    return this;
  }
  partNameDisplay(build: (builder: IPartNameDisplayBuilder) => IPartNameDisplayBuilder): IScorePartBuilder {
    this._b["partNameDisplay"] = build(new PartNameDisplayBuilder(this._o && this._o["partNameDisplay"]));
    this._m["partNameDisplay"] = true;
    return this;
  }
  scoreInstruments(scoreInstruments: ScoreInstrument[]): IScorePartBuilder {
    this._p.scoreInstruments = scoreInstruments;
    this._m["scoreInstruments"] = true;
    return this;
  }
  midiDevices(midiDevices: MidiDevice[]): IScorePartBuilder {
    this._p.midiDevices = midiDevices;
    this._m["midiDevices"] = true;
    return this;
  }
  partName(build: (builder: IPartNameBuilder) => IPartNameBuilder): IScorePartBuilder {
    this._b["partName"] = build(new PartNameBuilder(this._o && this._o["partName"]));
    this._m["partName"] = true;
    return this;
  }
  partAbbreviationDisplay(build: (builder: IPartAbbreviationDisplayBuilder) => IPartAbbreviationDisplayBuilder): IScorePartBuilder {
    this._b["partAbbreviationDisplay"] = build(new PartAbbreviationDisplayBuilder(this._o && this._o["partAbbreviationDisplay"]));
    this._m["partAbbreviationDisplay"] = true;
    return this;
  }
  partAbbreviation(build: (builder: IPartAbbreviationBuilder) => IPartAbbreviationBuilder): IScorePartBuilder {
    this._b["partAbbreviation"] = build(new PartAbbreviationBuilder(this._o && this._o["partAbbreviation"]));
    this._m["partAbbreviation"] = true;
    return this;
  }
  groups(groups: string[]): IScorePartBuilder {
    this._p.groups = groups;
    this._m["groups"] = true;
    return this;
  }
  midiInstruments(midiInstruments: MidiInstrument[]): IScorePartBuilder {
    this._p.midiInstruments = midiInstruments;
    this._m["midiInstruments"] = true;
    return this;
  }
  id(id: string): IScorePartBuilder {
    this._p.id = id;
    this._m["id"] = true;
    return this;
  }
  _class(_class: string): IScorePartBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
}
export function patchScorePart(base: ScorePart): IScorePartBuilder { return new ScorePartBuilder(base); }
export function buildScorePart(): IScorePartBuilder { return new ScorePartBuilder(); }

export interface IPartNameBuilder {
  build: () => PartName;
  patch: () => any[];
  partName: (partName: string) => IPartNameBuilder;
  defaultX: (defaultX: number) => IPartNameBuilder;
  relativeY: (relativeY: number) => IPartNameBuilder;
  defaultY: (defaultY: number) => IPartNameBuilder;
  relativeX: (relativeX: number) => IPartNameBuilder;
}
class PartNameBuilder implements IPartNameBuilder{
  _p: PartName = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PartName;
  constructor(toPatch?: PartName) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["partName"]) || this._b["partName"] !== undefined || this._p.partName !== undefined, "partName is a required field");
  }
  build(): PartName {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PartName";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  partName(partName: string): IPartNameBuilder {
    this._p.partName = partName;
    this._m["partName"] = true;
    return this;
  }
  defaultX(defaultX: number): IPartNameBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IPartNameBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IPartNameBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IPartNameBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchPartName(base: PartName): IPartNameBuilder { return new PartNameBuilder(base); }
export function buildPartName(): IPartNameBuilder { return new PartNameBuilder(); }

export interface IPartAbbreviationBuilder {
  build: () => PartAbbreviation;
  patch: () => any[];
  abbreviation: (abbreviation: string) => IPartAbbreviationBuilder;
  defaultX: (defaultX: number) => IPartAbbreviationBuilder;
  relativeY: (relativeY: number) => IPartAbbreviationBuilder;
  defaultY: (defaultY: number) => IPartAbbreviationBuilder;
  relativeX: (relativeX: number) => IPartAbbreviationBuilder;
}
class PartAbbreviationBuilder implements IPartAbbreviationBuilder{
  _p: PartAbbreviation = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PartAbbreviation;
  constructor(toPatch?: PartAbbreviation) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["abbreviation"]) || this._b["abbreviation"] !== undefined || this._p.abbreviation !== undefined, "abbreviation is a required field");
  }
  build(): PartAbbreviation {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PartAbbreviation";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  abbreviation(abbreviation: string): IPartAbbreviationBuilder {
    this._p.abbreviation = abbreviation;
    this._m["abbreviation"] = true;
    return this;
  }
  defaultX(defaultX: number): IPartAbbreviationBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IPartAbbreviationBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IPartAbbreviationBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IPartAbbreviationBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchPartAbbreviation(base: PartAbbreviation): IPartAbbreviationBuilder { return new PartAbbreviationBuilder(base); }
export function buildPartAbbreviation(): IPartAbbreviationBuilder { return new PartAbbreviationBuilder(); }

export interface IPartGroupBuilder {
  build: () => PartGroup;
  patch: () => any[];
  groupNameDisplay: (build: (builder: IGroupNameDisplayBuilder) => IGroupNameDisplayBuilder) => IPartGroupBuilder;
  groupSymbol: (build: (builder: IGroupSymbolBuilder) => IGroupSymbolBuilder) => IPartGroupBuilder;
  groupName: (build: (builder: IGroupNameBuilder) => IGroupNameBuilder) => IPartGroupBuilder;
  groupAbbreviationDisplay: (build: (builder: IGroupAbbreviationDisplayBuilder) => IGroupAbbreviationDisplayBuilder) => IPartGroupBuilder;
  groupBarline: (build: (builder: IGroupBarlineBuilder) => IGroupBarlineBuilder) => IPartGroupBuilder;
  number: (number: number) => IPartGroupBuilder;
  groupAbbreviation: (build: (builder: IGroupAbbreviationBuilder) => IGroupAbbreviationBuilder) => IPartGroupBuilder;
  type: (type: StartStop) => IPartGroupBuilder;
  groupTime: (build: (builder: IGroupTimeBuilder) => IGroupTimeBuilder) => IPartGroupBuilder;
  _class: (_class: string) => IPartGroupBuilder;
  footnote: (build: (builder: IFootnoteBuilder) => IFootnoteBuilder) => IPartGroupBuilder;
  level: (build: (builder: ILevelBuilder) => ILevelBuilder) => IPartGroupBuilder;
}
class PartGroupBuilder implements IPartGroupBuilder{
  _p: PartGroup = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: PartGroup;
  constructor(toPatch?: PartGroup) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["groupNameDisplay"]) || this._b["groupNameDisplay"] !== undefined || this._p.groupNameDisplay !== undefined, "groupNameDisplay is a required field");
    console.assert((this._o && !this._m["groupSymbol"]) || this._b["groupSymbol"] !== undefined || this._p.groupSymbol !== undefined, "groupSymbol is a required field");
    console.assert((this._o && !this._m["groupName"]) || this._b["groupName"] !== undefined || this._p.groupName !== undefined, "groupName is a required field");
    console.assert((this._o && !this._m["groupAbbreviationDisplay"]) || this._b["groupAbbreviationDisplay"] !== undefined || this._p.groupAbbreviationDisplay !== undefined, "groupAbbreviationDisplay is a required field");
    console.assert((this._o && !this._m["groupBarline"]) || this._b["groupBarline"] !== undefined || this._p.groupBarline !== undefined, "groupBarline is a required field");
    console.assert((this._o && !this._m["number"]) || this._b["number"] !== undefined || this._p.number !== undefined, "number is a required field");
    console.assert((this._o && !this._m["groupAbbreviation"]) || this._b["groupAbbreviation"] !== undefined || this._p.groupAbbreviation !== undefined, "groupAbbreviation is a required field");
    console.assert((this._o && !this._m["type"]) || this._b["type"] !== undefined || this._p.type !== undefined, "type is a required field");
    console.assert((this._o && !this._m["groupTime"]) || this._b["groupTime"] !== undefined || this._p.groupTime !== undefined, "groupTime is a required field");
  }
  build(): PartGroup {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "PartGroup";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  groupNameDisplay(build: (builder: IGroupNameDisplayBuilder) => IGroupNameDisplayBuilder): IPartGroupBuilder {
    this._b["groupNameDisplay"] = build(new GroupNameDisplayBuilder(this._o && this._o["groupNameDisplay"]));
    this._m["groupNameDisplay"] = true;
    return this;
  }
  groupSymbol(build: (builder: IGroupSymbolBuilder) => IGroupSymbolBuilder): IPartGroupBuilder {
    this._b["groupSymbol"] = build(new GroupSymbolBuilder(this._o && this._o["groupSymbol"]));
    this._m["groupSymbol"] = true;
    return this;
  }
  groupName(build: (builder: IGroupNameBuilder) => IGroupNameBuilder): IPartGroupBuilder {
    this._b["groupName"] = build(new GroupNameBuilder(this._o && this._o["groupName"]));
    this._m["groupName"] = true;
    return this;
  }
  groupAbbreviationDisplay(build: (builder: IGroupAbbreviationDisplayBuilder) => IGroupAbbreviationDisplayBuilder): IPartGroupBuilder {
    this._b["groupAbbreviationDisplay"] = build(new GroupAbbreviationDisplayBuilder(this._o && this._o["groupAbbreviationDisplay"]));
    this._m["groupAbbreviationDisplay"] = true;
    return this;
  }
  groupBarline(build: (builder: IGroupBarlineBuilder) => IGroupBarlineBuilder): IPartGroupBuilder {
    this._b["groupBarline"] = build(new GroupBarlineBuilder(this._o && this._o["groupBarline"]));
    this._m["groupBarline"] = true;
    return this;
  }
  number(number: number): IPartGroupBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  groupAbbreviation(build: (builder: IGroupAbbreviationBuilder) => IGroupAbbreviationBuilder): IPartGroupBuilder {
    this._b["groupAbbreviation"] = build(new GroupAbbreviationBuilder(this._o && this._o["groupAbbreviation"]));
    this._m["groupAbbreviation"] = true;
    return this;
  }
  type(type: StartStop): IPartGroupBuilder {
    this._p.type = type;
    this._m["type"] = true;
    return this;
  }
  groupTime(build: (builder: IGroupTimeBuilder) => IGroupTimeBuilder): IPartGroupBuilder {
    this._b["groupTime"] = build(new GroupTimeBuilder(this._o && this._o["groupTime"]));
    this._m["groupTime"] = true;
    return this;
  }
  _class(_class: string): IPartGroupBuilder {
    this._p._class = _class;
    this._m["_class"] = true;
    return this;
  }
  footnote(build: (builder: IFootnoteBuilder) => IFootnoteBuilder): IPartGroupBuilder {
    this._b["footnote"] = build(new FootnoteBuilder(this._o && this._o["footnote"]));
    this._m["footnote"] = true;
    return this;
  }
  level(build: (builder: ILevelBuilder) => ILevelBuilder): IPartGroupBuilder {
    this._b["level"] = build(new LevelBuilder(this._o && this._o["level"]));
    this._m["level"] = true;
    return this;
  }
}
export function patchPartGroup(base: PartGroup): IPartGroupBuilder { return new PartGroupBuilder(base); }
export function buildPartGroup(): IPartGroupBuilder { return new PartGroupBuilder(); }

export interface IGroupNameBuilder {
  build: () => GroupName;
  patch: () => any[];
  name: (name: string) => IGroupNameBuilder;
  defaultX: (defaultX: number) => IGroupNameBuilder;
  relativeY: (relativeY: number) => IGroupNameBuilder;
  defaultY: (defaultY: number) => IGroupNameBuilder;
  relativeX: (relativeX: number) => IGroupNameBuilder;
}
class GroupNameBuilder implements IGroupNameBuilder{
  _p: GroupName = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: GroupName;
  constructor(toPatch?: GroupName) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["name"]) || this._b["name"] !== undefined || this._p.name !== undefined, "name is a required field");
  }
  build(): GroupName {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "GroupName";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  name(name: string): IGroupNameBuilder {
    this._p.name = name;
    this._m["name"] = true;
    return this;
  }
  defaultX(defaultX: number): IGroupNameBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IGroupNameBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IGroupNameBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IGroupNameBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchGroupName(base: GroupName): IGroupNameBuilder { return new GroupNameBuilder(base); }
export function buildGroupName(): IGroupNameBuilder { return new GroupNameBuilder(); }

export interface IGroupNameDisplayBuilder {
  build: () => GroupNameDisplay;
  patch: () => any[];
  name: (build: (builder: ITextArrayBuilder) => ITextArrayBuilder) => IGroupNameDisplayBuilder;
  printObject: (printObject: boolean) => IGroupNameDisplayBuilder;
}
class GroupNameDisplayBuilder implements IGroupNameDisplayBuilder{
  _p: GroupNameDisplay = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: GroupNameDisplay;
  constructor(toPatch?: GroupNameDisplay) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["name"]) || this._b["name"] !== undefined || this._p.name !== undefined, "name is a required field");
  }
  build(): GroupNameDisplay {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "GroupNameDisplay";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  name(build: (builder: ITextArrayBuilder) => ITextArrayBuilder): IGroupNameDisplayBuilder {
    this._b["name"] = build(new TextArrayBuilder(this._o && this._o["name"]));
    this._m["name"] = true;
    return this;
  }
  printObject(printObject: boolean): IGroupNameDisplayBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchGroupNameDisplay(base: GroupNameDisplay): IGroupNameDisplayBuilder { return new GroupNameDisplayBuilder(base); }
export function buildGroupNameDisplay(): IGroupNameDisplayBuilder { return new GroupNameDisplayBuilder(); }

export interface IGroupAbbreviationBuilder {
  build: () => GroupAbbreviation;
  patch: () => any[];
  text: (text: string) => IGroupAbbreviationBuilder;
  defaultX: (defaultX: number) => IGroupAbbreviationBuilder;
  relativeY: (relativeY: number) => IGroupAbbreviationBuilder;
  defaultY: (defaultY: number) => IGroupAbbreviationBuilder;
  relativeX: (relativeX: number) => IGroupAbbreviationBuilder;
}
class GroupAbbreviationBuilder implements IGroupAbbreviationBuilder{
  _p: GroupAbbreviation = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: GroupAbbreviation;
  constructor(toPatch?: GroupAbbreviation) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["text"]) || this._b["text"] !== undefined || this._p.text !== undefined, "text is a required field");
  }
  build(): GroupAbbreviation {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "GroupAbbreviation";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  text(text: string): IGroupAbbreviationBuilder {
    this._p.text = text;
    this._m["text"] = true;
    return this;
  }
  defaultX(defaultX: number): IGroupAbbreviationBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IGroupAbbreviationBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IGroupAbbreviationBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IGroupAbbreviationBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchGroupAbbreviation(base: GroupAbbreviation): IGroupAbbreviationBuilder { return new GroupAbbreviationBuilder(base); }
export function buildGroupAbbreviation(): IGroupAbbreviationBuilder { return new GroupAbbreviationBuilder(); }

export interface IGroupAbbreviationDisplayBuilder {
  build: () => GroupAbbreviationDisplay;
  patch: () => any[];
  name: (build: (builder: ITextArrayBuilder) => ITextArrayBuilder) => IGroupAbbreviationDisplayBuilder;
  printObject: (printObject: boolean) => IGroupAbbreviationDisplayBuilder;
}
class GroupAbbreviationDisplayBuilder implements IGroupAbbreviationDisplayBuilder{
  _p: GroupAbbreviationDisplay = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: GroupAbbreviationDisplay;
  constructor(toPatch?: GroupAbbreviationDisplay) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["name"]) || this._b["name"] !== undefined || this._p.name !== undefined, "name is a required field");
  }
  build(): GroupAbbreviationDisplay {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "GroupAbbreviationDisplay";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  name(build: (builder: ITextArrayBuilder) => ITextArrayBuilder): IGroupAbbreviationDisplayBuilder {
    this._b["name"] = build(new TextArrayBuilder(this._o && this._o["name"]));
    this._m["name"] = true;
    return this;
  }
  printObject(printObject: boolean): IGroupAbbreviationDisplayBuilder {
    this._p.printObject = printObject;
    this._m["printObject"] = true;
    return this;
  }
}
export function patchGroupAbbreviationDisplay(base: GroupAbbreviationDisplay): IGroupAbbreviationDisplayBuilder { return new GroupAbbreviationDisplayBuilder(base); }
export function buildGroupAbbreviationDisplay(): IGroupAbbreviationDisplayBuilder { return new GroupAbbreviationDisplayBuilder(); }

export interface IGroupSymbolBuilder {
  build: () => GroupSymbol;
  patch: () => any[];
  data: (data: PartSymbolType) => IGroupSymbolBuilder;
  defaultX: (defaultX: number) => IGroupSymbolBuilder;
  relativeY: (relativeY: number) => IGroupSymbolBuilder;
  defaultY: (defaultY: number) => IGroupSymbolBuilder;
  relativeX: (relativeX: number) => IGroupSymbolBuilder;
}
class GroupSymbolBuilder implements IGroupSymbolBuilder{
  _p: GroupSymbol = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: GroupSymbol;
  constructor(toPatch?: GroupSymbol) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): GroupSymbol {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "GroupSymbol";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: PartSymbolType): IGroupSymbolBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  defaultX(defaultX: number): IGroupSymbolBuilder {
    this._p.defaultX = defaultX;
    this._m["defaultX"] = true;
    return this;
  }
  relativeY(relativeY: number): IGroupSymbolBuilder {
    this._p.relativeY = relativeY;
    this._m["relativeY"] = true;
    return this;
  }
  defaultY(defaultY: number): IGroupSymbolBuilder {
    this._p.defaultY = defaultY;
    this._m["defaultY"] = true;
    return this;
  }
  relativeX(relativeX: number): IGroupSymbolBuilder {
    this._p.relativeX = relativeX;
    this._m["relativeX"] = true;
    return this;
  }
}
export function patchGroupSymbol(base: GroupSymbol): IGroupSymbolBuilder { return new GroupSymbolBuilder(base); }
export function buildGroupSymbol(): IGroupSymbolBuilder { return new GroupSymbolBuilder(); }

export interface IGroupBarlineBuilder {
  build: () => GroupBarline;
  patch: () => any[];
  data: (data: string) => IGroupBarlineBuilder;
  color: (color: string) => IGroupBarlineBuilder;
}
class GroupBarlineBuilder implements IGroupBarlineBuilder{
  _p: GroupBarline = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: GroupBarline;
  constructor(toPatch?: GroupBarline) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["data"]) || this._b["data"] !== undefined || this._p.data !== undefined, "data is a required field");
  }
  build(): GroupBarline {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "GroupBarline";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  data(data: string): IGroupBarlineBuilder {
    this._p.data = data;
    this._m["data"] = true;
    return this;
  }
  color(color: string): IGroupBarlineBuilder {
    this._p.color = color;
    this._m["color"] = true;
    return this;
  }
}
export function patchGroupBarline(base: GroupBarline): IGroupBarlineBuilder { return new GroupBarlineBuilder(base); }
export function buildGroupBarline(): IGroupBarlineBuilder { return new GroupBarlineBuilder(); }

export interface IGroupTimeBuilder {
  build: () => GroupTime;
  patch: () => any[];
}
class GroupTimeBuilder implements IGroupTimeBuilder{
  _p: GroupTime = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: GroupTime;
  constructor(toPatch?: GroupTime) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): GroupTime {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "GroupTime";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
}
export function patchGroupTime(base: GroupTime): IGroupTimeBuilder { return new GroupTimeBuilder(base); }
export function buildGroupTime(): IGroupTimeBuilder { return new GroupTimeBuilder(); }

export interface IScoreInstrumentBuilder {
  build: () => ScoreInstrument;
  patch: () => any[];
  instrumentName: (instrumentName: string) => IScoreInstrumentBuilder;
  instrumentSound: (instrumentSound: string) => IScoreInstrumentBuilder;
  ensemble: (ensemble: string) => IScoreInstrumentBuilder;
  virtualInstrument: (build: (builder: IVirtualInstrumentBuilder) => IVirtualInstrumentBuilder) => IScoreInstrumentBuilder;
  instrumentAbbreviation: (instrumentAbbreviation: string) => IScoreInstrumentBuilder;
  solo: (build: (builder: ISoloBuilder) => ISoloBuilder) => IScoreInstrumentBuilder;
  id: (id: string) => IScoreInstrumentBuilder;
}
class ScoreInstrumentBuilder implements IScoreInstrumentBuilder{
  _p: ScoreInstrument = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: ScoreInstrument;
  constructor(toPatch?: ScoreInstrument) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["instrumentName"]) || this._b["instrumentName"] !== undefined || this._p.instrumentName !== undefined, "instrumentName is a required field");
    console.assert((this._o && !this._m["instrumentSound"]) || this._b["instrumentSound"] !== undefined || this._p.instrumentSound !== undefined, "instrumentSound is a required field");
    console.assert((this._o && !this._m["ensemble"]) || this._b["ensemble"] !== undefined || this._p.ensemble !== undefined, "ensemble is a required field");
    console.assert((this._o && !this._m["virtualInstrument"]) || this._b["virtualInstrument"] !== undefined || this._p.virtualInstrument !== undefined, "virtualInstrument is a required field");
    console.assert((this._o && !this._m["instrumentAbbreviation"]) || this._b["instrumentAbbreviation"] !== undefined || this._p.instrumentAbbreviation !== undefined, "instrumentAbbreviation is a required field");
    console.assert((this._o && !this._m["solo"]) || this._b["solo"] !== undefined || this._p.solo !== undefined, "solo is a required field");
    console.assert((this._o && !this._m["id"]) || this._b["id"] !== undefined || this._p.id !== undefined, "id is a required field");
  }
  build(): ScoreInstrument {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "ScoreInstrument";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  instrumentName(instrumentName: string): IScoreInstrumentBuilder {
    this._p.instrumentName = instrumentName;
    this._m["instrumentName"] = true;
    return this;
  }
  instrumentSound(instrumentSound: string): IScoreInstrumentBuilder {
    this._p.instrumentSound = instrumentSound;
    this._m["instrumentSound"] = true;
    return this;
  }
  ensemble(ensemble: string): IScoreInstrumentBuilder {
    this._p.ensemble = ensemble;
    this._m["ensemble"] = true;
    return this;
  }
  virtualInstrument(build: (builder: IVirtualInstrumentBuilder) => IVirtualInstrumentBuilder): IScoreInstrumentBuilder {
    this._b["virtualInstrument"] = build(new VirtualInstrumentBuilder(this._o && this._o["virtualInstrument"]));
    this._m["virtualInstrument"] = true;
    return this;
  }
  instrumentAbbreviation(instrumentAbbreviation: string): IScoreInstrumentBuilder {
    this._p.instrumentAbbreviation = instrumentAbbreviation;
    this._m["instrumentAbbreviation"] = true;
    return this;
  }
  solo(build: (builder: ISoloBuilder) => ISoloBuilder): IScoreInstrumentBuilder {
    this._b["solo"] = build(new SoloBuilder(this._o && this._o["solo"]));
    this._m["solo"] = true;
    return this;
  }
  id(id: string): IScoreInstrumentBuilder {
    this._p.id = id;
    this._m["id"] = true;
    return this;
  }
}
export function patchScoreInstrument(base: ScoreInstrument): IScoreInstrumentBuilder { return new ScoreInstrumentBuilder(base); }
export function buildScoreInstrument(): IScoreInstrumentBuilder { return new ScoreInstrumentBuilder(); }

export interface ISoloBuilder {
  build: () => Solo;
  patch: () => any[];
}
class SoloBuilder implements ISoloBuilder{
  _p: Solo = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Solo;
  constructor(toPatch?: Solo) {
    this._o = toPatch;
  }
  _i() {
  }
  build(): Solo {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Solo";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
}
export function patchSolo(base: Solo): ISoloBuilder { return new SoloBuilder(base); }
export function buildSolo(): ISoloBuilder { return new SoloBuilder(); }

export interface IVirtualInstrumentBuilder {
  build: () => VirtualInstrument;
  patch: () => any[];
  virtualLibrary: (virtualLibrary: string) => IVirtualInstrumentBuilder;
  virtualName: (virtualName: string) => IVirtualInstrumentBuilder;
}
class VirtualInstrumentBuilder implements IVirtualInstrumentBuilder{
  _p: VirtualInstrument = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: VirtualInstrument;
  constructor(toPatch?: VirtualInstrument) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["virtualLibrary"]) || this._b["virtualLibrary"] !== undefined || this._p.virtualLibrary !== undefined, "virtualLibrary is a required field");
    console.assert((this._o && !this._m["virtualName"]) || this._b["virtualName"] !== undefined || this._p.virtualName !== undefined, "virtualName is a required field");
  }
  build(): VirtualInstrument {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "VirtualInstrument";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  virtualLibrary(virtualLibrary: string): IVirtualInstrumentBuilder {
    this._p.virtualLibrary = virtualLibrary;
    this._m["virtualLibrary"] = true;
    return this;
  }
  virtualName(virtualName: string): IVirtualInstrumentBuilder {
    this._p.virtualName = virtualName;
    this._m["virtualName"] = true;
    return this;
  }
}
export function patchVirtualInstrument(base: VirtualInstrument): IVirtualInstrumentBuilder { return new VirtualInstrumentBuilder(base); }
export function buildVirtualInstrument(): IVirtualInstrumentBuilder { return new VirtualInstrumentBuilder(); }

export interface IScoreHeaderBuilder {
  build: () => ScoreHeader;
  patch: () => any[];
  movementTitle: (movementTitle: string) => IScoreHeaderBuilder;
  identification: (build: (builder: IIdentificationBuilder) => IIdentificationBuilder) => IScoreHeaderBuilder;
  defaults: (build: (builder: IDefaultsBuilder) => IDefaultsBuilder) => IScoreHeaderBuilder;
  work: (build: (builder: IWorkBuilder) => IWorkBuilder) => IScoreHeaderBuilder;
  credits: (credits: Credit[]) => IScoreHeaderBuilder;
  partList: (partList: PartList) => IScoreHeaderBuilder;
  movementNumber: (movementNumber: string) => IScoreHeaderBuilder;
}
class ScoreHeaderBuilder implements IScoreHeaderBuilder{
  _p: ScoreHeader = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: ScoreHeader;
  constructor(toPatch?: ScoreHeader) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["movementTitle"]) || this._b["movementTitle"] !== undefined || this._p.movementTitle !== undefined, "movementTitle is a required field");
    console.assert((this._o && !this._m["identification"]) || this._b["identification"] !== undefined || this._p.identification !== undefined, "identification is a required field");
    console.assert((this._o && !this._m["defaults"]) || this._b["defaults"] !== undefined || this._p.defaults !== undefined, "defaults is a required field");
    console.assert((this._o && !this._m["work"]) || this._b["work"] !== undefined || this._p.work !== undefined, "work is a required field");
    console.assert((this._o && !this._m["credits"]) || this._b["credits"] !== undefined || this._p.credits !== undefined, "credits is a required field");
    console.assert((this._o && !this._m["partList"]) || this._b["partList"] !== undefined || this._p.partList !== undefined, "partList is a required field");
    console.assert((this._o && !this._m["movementNumber"]) || this._b["movementNumber"] !== undefined || this._p.movementNumber !== undefined, "movementNumber is a required field");
  }
  build(): ScoreHeader {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "ScoreHeader";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  movementTitle(movementTitle: string): IScoreHeaderBuilder {
    this._p.movementTitle = movementTitle;
    this._m["movementTitle"] = true;
    return this;
  }
  identification(build: (builder: IIdentificationBuilder) => IIdentificationBuilder): IScoreHeaderBuilder {
    this._b["identification"] = build(new IdentificationBuilder(this._o && this._o["identification"]));
    this._m["identification"] = true;
    return this;
  }
  defaults(build: (builder: IDefaultsBuilder) => IDefaultsBuilder): IScoreHeaderBuilder {
    this._b["defaults"] = build(new DefaultsBuilder(this._o && this._o["defaults"]));
    this._m["defaults"] = true;
    return this;
  }
  work(build: (builder: IWorkBuilder) => IWorkBuilder): IScoreHeaderBuilder {
    this._b["work"] = build(new WorkBuilder(this._o && this._o["work"]));
    this._m["work"] = true;
    return this;
  }
  credits(credits: Credit[]): IScoreHeaderBuilder {
    this._p.credits = credits;
    this._m["credits"] = true;
    return this;
  }
  partList(partList: PartList): IScoreHeaderBuilder {
    this._p.partList = partList;
    this._m["partList"] = true;
    return this;
  }
  movementNumber(movementNumber: string): IScoreHeaderBuilder {
    this._p.movementNumber = movementNumber;
    this._m["movementNumber"] = true;
    return this;
  }
}
export function patchScoreHeader(base: ScoreHeader): IScoreHeaderBuilder { return new ScoreHeaderBuilder(base); }
export function buildScoreHeader(): IScoreHeaderBuilder { return new ScoreHeaderBuilder(); }

export interface IScoreTimewiseBuilder {
  build: () => ScoreTimewise;
  patch: () => any[];
  measures: (measures: Measure[]) => IScoreTimewiseBuilder;
  version: (version: string) => IScoreTimewiseBuilder;
}
class ScoreTimewiseBuilder implements IScoreTimewiseBuilder{
  _p: ScoreTimewise = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: ScoreTimewise;
  constructor(toPatch?: ScoreTimewise) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["measures"]) || this._b["measures"] !== undefined || this._p.measures !== undefined, "measures is a required field");
    console.assert((this._o && !this._m["version"]) || this._b["version"] !== undefined || this._p.version !== undefined, "version is a required field");
  }
  build(): ScoreTimewise {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "ScoreTimewise";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  measures(measures: Measure[]): IScoreTimewiseBuilder {
    this._p.measures = measures;
    this._m["measures"] = true;
    return this;
  }
  version(version: string): IScoreTimewiseBuilder {
    this._p.version = version;
    this._m["version"] = true;
    return this;
  }
}
export function patchScoreTimewise(base: ScoreTimewise): IScoreTimewiseBuilder { return new ScoreTimewiseBuilder(base); }
export function buildScoreTimewise(): IScoreTimewiseBuilder { return new ScoreTimewiseBuilder(); }

export interface IMeasureBuilder {
  build: () => Measure;
  patch: () => any[];
  number: (number: string) => IMeasureBuilder;
  implicit: (implicit: boolean) => IMeasureBuilder;
  width: (width: number) => IMeasureBuilder;
  set: (key: string, val: boolean[]) => IMeasureBuilder;
  nonControlling: (nonControlling: boolean) => IMeasureBuilder;
}
class MeasureBuilder implements IMeasureBuilder{
  _p: Measure = {} as any;
  _b: {[key: string]: any} = {};
  _m: {[key: string]: boolean} = {};
  _o: Measure;
  constructor(toPatch?: Measure) {
    this._o = toPatch;
  }
  _i() {
    console.assert((this._o && !this._m["number"]) || this._b["number"] !== undefined || this._p.number !== undefined, "number is a required field");
    console.assert((this._o && !this._m["implicit"]) || this._b["implicit"] !== undefined || this._p.implicit !== undefined, "implicit is a required field");
    console.assert((this._o && !this._m["width"]) || this._b["width"] !== undefined || this._p.width !== undefined, "width is a required field");
    console.assert((this._o && !this._m["nonControlling"]) || this._b["nonControlling"] !== undefined || this._p.nonControlling !== undefined, "nonControlling is a required field");
  }
  build(): Measure {
    console.assert(!this._o, "Refusing to create in patch mode.");
    this._i();
    (this._p as any)._class = "Measure";
    return this._p;
  }
  patch(): any[] {
    console.assert(Boolean(this._o), "The builder is in build mode.");
    this._i();
    let patches: any = Object.keys(this._m).map(key => {
      if (this._b[key] !== undefined) return;
      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;
      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};
      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};
      return {p: [key], od: this._o[key], oi: this._p[key]};
    }).filter(p => Boolean(p));
    Object.keys(this._b).map(key => {
      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});
      let subpatches = this._b[key].patch().map(patch => {
        patch.p = [key].concat(patch.p);
        return patch;
      })
      patches = patches.concat(subpatches);
    });
    return patches;
  }
  number(number: string): IMeasureBuilder {
    this._p.number = number;
    this._m["number"] = true;
    return this;
  }
  implicit(implicit: boolean): IMeasureBuilder {
    this._p.implicit = implicit;
    this._m["implicit"] = true;
    return this;
  }
  width(width: number): IMeasureBuilder {
    this._p.width = width;
    this._m["width"] = true;
    return this;
  }
  set(key: string, val: boolean[]): IMeasureBuilder {
    this._p[key] = val;
    this._m[key] = true;
    return this;
  }
  nonControlling(nonControlling: boolean): IMeasureBuilder {
    this._p.nonControlling = nonControlling;
    this._m["nonControlling"] = true;
    return this;
  }
}
export function patchMeasure(base: Measure): IMeasureBuilder { return new MeasureBuilder(base); }
export function buildMeasure(): IMeasureBuilder { return new MeasureBuilder(); }

