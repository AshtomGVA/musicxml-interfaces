"use strict";

const _ = require("lodash");
const impGen = require("./spec.tmp.json");

const symbols = impGen.
    filter(
        n => n.kind === 'ModuleDeclaration' &&
            n.name === 'musicxml-interfaces/musicxml-interfaces')
    [0].
    symbols;

const decls = {
    interfaces: symbols.
        filter(n => n.kind === 'InterfaceDeclaration'),
    enums: symbols.
        filter(n => n.kind === 'EnumDeclaration')
};

const enums = decls.enums.reduce(
    (memo, spec) => {
        memo[spec.name] = spec.members.reduce(
            (memo2, spec2) => {
                memo2[spec2.name] = spec2.value;
                return memo2;
            }, {});
        return memo;
    }, {});

const exFrom = {};
const exTo = {};

const interfaces = decls.interfaces.reduce(
    (memo, spec) => {
        spec.extends.forEach(exName => {
            exFrom[exName] = exFrom[exName] || [];
            exTo[spec.name] = exTo[spec.name] || [];

            exFrom[exName].push(spec.name);
            exTo[spec.name].push(exName);
        });
        memo[spec.name] = spec.members.reduce(
            (memo2, spec2) => {
                if (typeof spec2.kind !== 'string' && spec2.kind.kind === 'typeLiteral') {
                    spec2.kind.members.forEach(member => {
                        member.in.forEach(inType => {
                            memo2[`<${inType}Literal>`] = member.out;
                        });
                    });
                } else {
                    memo2[spec2.name] = spec2.kind + (spec2.required ? '' : '?');
                }
                return memo2;
            }, {});
        return memo;
    }, {});

while (Object.keys(exFrom).length) {
    for (var zkey in exFrom) {
        if (exFrom.hasOwnProperty(zkey) && (!exTo[zkey] || !exTo[zkey].length)) {
            exFrom[zkey].forEach(tkey => {
                exTo[tkey] = exTo[tkey].filter(okey => okey !== zkey);
                _.extend(interfaces[tkey], interfaces[zkey]);
            });
            delete exFrom[zkey];
        }
    }
}

const imports = Object.keys(enums).concat(Object.keys(interfaces)).concat('PartList');

const emit = console.log.bind(console);

emit(`// Auto-generated by emitBuilders.js. Modification is unwise.`);
emit(``);
emit(`import {${imports.join(", ")}} from "./musicxml-interfaces";`);
emit(``);
_.forEach(interfaces, (spec, key) => {
    emit(`export interface I${key}Builder {`);
    emit(`  build: () => ${key};`);
    emit(`  patch: () => any[];`);

    _.forEach(spec, (fieldSpec, fieldName) => {
        if (fieldName === "<stringLiteral>") {
            emit(`  set: (key: string, val: ${fieldSpec.replace('?', '')}) => I${key}Builder;`);
            return;
        }
        
        let realFieldSpec = fieldSpec.replace('?', '');
        if (interfaces[realFieldSpec]) {
            emit(`  ${fieldName}: (build: (builder: I${realFieldSpec}Builder) => I${realFieldSpec}Builder) => I${key}Builder;`);
        } else {
            emit(`  ${fieldName}: (${fieldName}: ${realFieldSpec}) => I${key}Builder;`);
        }
    });
    emit(`}`); // export class ${key}Builder

    emit(`class ${key}Builder implements I${key}Builder{`);
    emit(`  _p: ${key} = {} as any;`);    // patch
    emit(`  _b: {[key: string]: any} = {};`);    // child builders
    emit(`  _m: {[key: string]: boolean} = {};`);  // modified keys
    emit(`  _o: ${key};`);    // original
    emit(`  constructor(toPatch?: ${key}) {`);
    emit(`    this._o = toPatch;`);
    emit(`  }`); // constructor
    emit(`  _i() {`); // invariants
    _.forEach(spec, (fieldSpec, fieldName) => {
        if (fieldName === "<stringLiteral>") {
            return;
        } else if (fieldSpec.indexOf('?') === -1) {
            emit(`    console.assert((this._o && !this._m["${fieldName}"]) || this._b["${fieldName}"] !== undefined || this._p.${fieldName} !== undefined, "${fieldName} is a required field");`);
        }
    });
    emit(`  }`); // _i

    emit(`  build(): ${key} {`); // create
    emit(`    console.assert(!this._o, "Refusing to create in patch mode.");`);
    emit(`    this._i();`);
    emit(`    (this._p as any)._class = "${key}";`);
    emit(`    return this._p;`);
    emit(`  }`); // _c

    emit(`  patch(): any[] {`); // patch
    emit(`    console.assert(Boolean(this._o), "The builder is in build mode.");`);
    emit(`    this._i();`);
    emit(`    let patches: any = Object.keys(this._m).map(key => {`);
    emit(`      if (this._b[key] !== undefined) return;`);
    emit(`      if (this._p[key] === this._o[key] || this._p[key] !== this._p[key] && this._o[key] !== this._o[key]) return;`);
    emit(`      if (this._p[key] === undefined) return {p: [key], od: this._o[key]};`);
    emit(`      if (this._o[key] === undefined) return {p: [key], oi: this._p[key]};`);
    emit(`      return {p: [key], od: this._o[key], oi: this._p[key]};`);
    emit(`    }).filter(p => Boolean(p));`);
    emit(`    Object.keys(this._b).map(key => {`);
    emit(`      if (this._o[key] === undefined) patches.push({p: [key], oi: this._b[key].build()});`);
    emit(`      let subpatches = this._b[key].patch().map(patch => {`);
    emit(`        patch.p = [key].concat(patch.p);`);
    emit(`        return patch;`);
    emit(`      })`);
    emit(`      patches = patches.concat(subpatches);`);
    emit(`    });`);
    emit(`    return patches;`);
    emit(`  }`); // _c

    _.forEach(spec, (fieldSpec, fieldName) => {
        if (fieldName === "<stringLiteral>") {
            emit(`  set(key: string, val: ${fieldSpec.replace('?', '')}): I${key}Builder {`);
            emit(`    this._p[key] = val;`);
            emit(`    this._m[key] = true;`);
            emit(`    return this;`);
            emit(`  }`); // ${fieldName}(...): I${key}Builder
            return;
        }
        
        let realFieldSpec = fieldSpec.replace('?', '');
        if (interfaces[realFieldSpec]) {
            emit(`  ${fieldName}(build: (builder: I${realFieldSpec}Builder) => I${realFieldSpec}Builder): I${key}Builder {`);
            emit(`    this._b["${fieldName}"] = build(new ${realFieldSpec}Builder(this._o && this._o["${fieldName}"]));`);
            emit(`    this._m["${fieldName}"] = true;`);
            emit(`    return this;`);
            emit(`  }`) // ${fieldName}(...): ${key}Builder
        } else {
            emit(`  ${fieldName}(${fieldName}: ${realFieldSpec}): I${key}Builder {`);
            emit(`    this._p.${fieldName} = ${fieldName};`);
            emit(`    this._m["${fieldName}"] = true;`);
            emit(`    return this;`);
            emit(`  }`); // ${fieldName}(...): ${key}Builder
        }
    });
    emit(`}`); // export class ${key}Builder
    emit(`export function patch${key}(base: ${key}): I${key}Builder { return new ${key}Builder(base); }`);
    emit(`export function build${key}(): I${key}Builder { return new ${key}Builder(); }`);
    emit(``);
});

//console.log(JSON.stringify(interfaces, null, 2));

